# Product Requirements Document: Agent Delegation Tool

**1. Introduction**

This document outlines the requirements for a new tool, the `AgentDelegationTool`, within the NeuralAMI Control system. This tool will enable an agent (the "parent") to delegate a specific task or question (provided as a prompt) to another designated agent (the "child") within the system. The final response generated by the child agent, after potentially using its own tools, will be returned as the output of the `AgentDelegationTool` to the parent agent. This facilitates hierarchical task decomposition and allows agents to leverage the specialized skills or toolsets of others.

**2. Goals**

*   Enable agents to delegate tasks to other agents based on their specific capabilities.
*   Allow for complex workflows where tasks are broken down and distributed among specialized agents.
*   Integrate seamlessly with the existing agent and tool framework (`BaseTool`).
*   Ensure the delegation process is robust, handling errors and potential complexities like nested tool use.
*   Provide adequate logging for traceability and debugging of delegated tasks.

**3. Requirements**

*   **Tool Definition:**
    *   Create a new tool class `AgentDelegationTool` inheriting from `apps.agents.tools.base_tool.BaseTool`.
    *   Define a Pydantic input schema (`AgentDelegationInput`) for the tool:
        *   `agent_id`: The database ID of the agent to delegate the task to (Required).
        *   `prompt`: The specific task, question, or instruction for the delegated agent (Required).
        *   `include_parent_history`: (Boolean, Optional, Default: `False`) Flag to determine if the parent agent's recent conversation history should be passed as context. *Initially, this will be False to limit complexity.*
*   **Delegation Execution (`_run` method):**
    *   Fetch the `Agent` model instance using the provided `agent_id`. Handle `Agent.DoesNotExist` errors gracefully.
    *   Instantiate a simplified, non-WebSocket execution environment for the child agent. This involves:
        *   Retrieving the child agent's configuration (LLM, tools, prompt settings).
        *   Using utility functions like `get_llm` to initialize the LLM.
        *   Loading the child agent's tools using a mechanism similar to `load_tool_in_task` but adapted for this context.
        *   Constructing a LangChain `AgentExecutor` (or a similar execution loop) specifically for this single delegated task. A simple `ConversationBufferMemory` might be used, potentially seeded with the `prompt`.
    *   Invoke the child agent's executor with the provided `prompt`.
    *   Capture the final `output` from the child agent's execution.
    *   Return the captured `output` string as the result of the `AgentDelegationTool`.
*   **Context Management:**
    *   The child agent must run with its own defined configuration (LLM, tools, system prompt, backstory).
    *   For the initial implementation (`include_parent_history=False`), the child agent will only receive the `prompt` as input, ensuring isolation.
*   **Error Handling:**
    *   Return informative error messages if the `agent_id` is invalid or the agent cannot be loaded.
    *   Catch exceptions during the child agent's execution (e.g., errors in its LLM calls or tool usage) and return a formatted error message as the tool's output.
    *   Prevent runaway costs or infinite loops (e.g., limit the child agent's `max_iterations`).
*   **Recursion Prevention:** Implement a basic check to prevent an agent from delegating directly back to the agent that delegated to it within the same immediate chain. A simple depth counter passed during delegation could also be considered for future enhancement.
*   **Logging:** Add detailed `logger.debug` and `logger.info` statements within the `_run` method to track:
    *   Tool invocation with input parameters.
    *   Successful loading of the child agent.
    *   Initiation of the child agent execution.
    *   Completion of the child agent execution and the result.
    *   Any errors encountered during the process.
*   **Tool Registration:** Ensure the tool is discoverable and can be added to agents through the standard application mechanisms.

**4. Design Considerations**

*   **Execution Environment:** Avoid using the full `AgentChatService` as it's designed for persistent WebSocket connections and complex callbacks. Create a dedicated, synchronous function (e.g., `_execute_delegated_agent`) within the tool's module to handle the setup and execution of the child agent. This function will encapsulate the logic for creating the temporary `AgentExecutor`.
*   **Synchronous Execution:** The `_run` method will be synchronous, aligning with the `BaseTool` standard. Asynchronous execution (`_arun`) can be added later if needed.
*   **Dependencies:** Reuse existing utilities like `get_llm`, `load_tool_in_task`, and agent/tool model definitions.
*   **Simplicity:** Start with the simplest viable delegation model (no history passing, basic recursion check) and iterate based on usage and feedback.

**5. Implementation Plan & Checklist**

- [ ] Define `AgentDelegationInput` Pydantic model in the tool file.
- [ ] Create `AgentDelegationTool` class inheriting `BaseTool` (`apps/agents/tools/agent_delegation_tool/agent_delegation_tool.py`).
- [ ] Implement `_run` method in `AgentDelegationTool`.
- [ ] Implement helper function `_execute_delegated_agent`.
  - [ ] Fetch `Agent` model.
  - [ ] Load LLM (`get_llm`).
  - [ ] Load Tools (adapt `load_tool_in_task` or create similar logic).
  - [ ] Build LangChain prompt, agent, and `AgentExecutor`.
  - [ ] Invoke `executor.invoke()` with the prompt.
  - [ ] Handle output and exceptions.
- [ ] Add Logging throughout the new code.
- [ ] Add Basic Recursion Check within `_run`.
- [ ] Write Unit Tests for the tool's logic.
- [ ] Perform Integration Testing.
- [ ] Register Tool for availability in the UI/admin.

**6. Future Considerations**

*   Implement `_arun` for asynchronous delegation.
*   Implement `include_parent_history=True` logic.
*   Add configurable `max_iterations` or timeouts for the delegated agent.
*   Develop a more robust recursion/loop detection mechanism (e.g., passing a set of visited agent IDs).
*   Explore agent discovery mechanisms instead of requiring a specific `agent_id`.
