This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-01T05:22:07.635Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
rules/
  bootstrap.mdc
  charts.mdc
  htmx-websocket-patterns.mdc
  tables-datatables.mdc
  template-extra-css-js.mdc

================================================================
Repository Files
================================================================

================
File: rules/bootstrap.mdc
================
---
description: bootstrap styling guidelines
globs: *.html,*.js
---
8. use standard softui dashboard pro bootstrap classes and styles. avoid custom css unless necessary

================
File: rules/charts.mdc
================
---
description: When carts are required
globs: *.html,*.js
---

# Charts
- for charts use chartjs like:
    <script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>

================
File: rules/htmx-websocket-patterns.mdc
================
---
description: When websockes are required,*
globs: *.html
alwaysApply: false
---
# HTMX WebSocket Patterns

This guide outlines best practices for implementing real-time updates with HTMX WebSockets in our Django application.

## Basic Setup

### 1. Include the WebSocket Extension

```html
<!-- Include HTMX WebSocket extension -->
<script src="https://unpkg.com/htmx.org/dist/ext/ws.js"></script>
```

### 2. Set Up the Container

**Simple approach (inline):**
```html
<div class="container-fluid py-4"
     hx-ext="ws"
     ws-connect="/ws/your-endpoint/{{ id }}/">
  <!-- Content that will receive updates -->
</div>
```

**Dynamic approach (JavaScript):**
```javascript
// Configure the connection programmatically
const container = document.getElementById('yourContainer');
container.setAttribute('ws-connect', `/ws/your-endpoint/${taskId}/`);
htmx.process(container);
```

## Message Handling Patterns

### 1. Out-of-Band Swaps (Simple Updates)

```html
<!-- Target element with out-of-band swap -->
<span id="status-badge" hx-swap-oob="true">{{ status }}</span>
```

### 2. Progress Tracking (Advanced)

```html
<!-- Progress bar that updates based on WebSocket messages -->
<div class="progress mb-3">
  <div class="progress-bar bg-gradient-primary" 
       role="progressbar" 
       style="width: 0%" 
       id="research-progress" 
       hx-swap-oob="true"></div>
</div>
```

### 3. JSON Message Processing (Most Flexible)

```javascript
// Listen for WebSocket messages and process JSON data
document.body.addEventListener('htmx:wsAfterMessage', function(event) {
  console.log("Raw WebSocket message:", event.detail.message);
  try {
    const data = JSON.parse(event.detail.message);
    
    // Update UI based on message type
    if (data.progress) {
      updateProgressUI(data.progress);
    } else if (data.status === 'complete') {
      handleCompletion(data);
    } else if (data.status === 'failed') {
      handleError(data);
    }
  } catch (e) {
    console.error("Error processing WebSocket message:", e);
  }
});
```

## Debugging WebSockets

```javascript
// Add these listeners to debug WebSocket connections
document.body.addEventListener('htmx:wsOpen', function(evt) {
  console.log('WebSocket opened:', evt.detail);
});

document.body.addEventListener('htmx:wsClose', function(evt) {
  console.log('WebSocket closed:', evt.detail);
});

document.body.addEventListener('htmx:wsError', function(evt) {
  console.error('WebSocket error:', evt.detail);
});
```

## UI Patterns

### 1. Loading Overlay

```html
<div id="progressOverlay" class="progress-overlay d-none" hx-ext="ws">
  <div class="progress-content">
    <h5 id="progressAction">Processing...</h5>
    <div class="progress">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
           role="progressbar" style="width: 0%"></div>
    </div>
    <p id="progressMessage" class="text-sm mt-2">Starting operation</p>
    
    <!-- Stats display -->
    <div class="progress-stats">
      <!-- Add your stats here -->
    </div>
  </div>
</div>
```

### 2. Timeline Updates

```html
<div class="timeline timeline-one-side">
  <!-- Existing steps rendered server-side -->
  {% for step in steps %}
    {% include "partials/_step.html" with step=step %}
  {% endfor %}
  
  <!-- Processing indicator -->
  <div id="processing-indicator" class="{% if not in_progress %}d-none{% endif %}">
    <span class="timeline-step bg-info">
      <i class="fas fa-circle-notch fa-spin"></i>
    </span>
    <div class="timeline-content">
      <h6>Processing Next Step</h6>
    </div>
  </div>
</div>
```

## Best Practices

1. **Event Delegation**: Listen at the document level for `htmx:wsAfterMessage` to capture all messages

2. **Proper Error Handling**:
   - Parse JSON safely with try/catch
   - Provide user feedback for connection issues
   - Log connection events for debugging

3. **Initialization**:
   - Set up listeners after the DOM is loaded
   - Verify WebSocket support before attempting connection
   - Include fallback for failed connections

4. **UI Updates**:
   - Update UI elements incrementally as data arrives
   - Provide visual feedback during long-running operations
   - Use CSS transitions for smooth progress updates

5. **Connection Management**:
   - Connect only when needed
   - Disconnect when appropriate (page navigation, task completion)
   - Handle reconnection attempts gracefully

## Django Consumer Implementation

For reference, your Django consumer should follow this pattern:

```python
class YourConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.task_id = self.scope['url_route']['kwargs']['task_id']
        self.group_name = f"task_{self.task_id}"
        
        # Join the group
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        await self.accept()
        
        # Start background task to check status
        asyncio.create_task(self.check_status_periodically())
        
    async def disconnect(self, close_code):
        # Leave the group
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
        
    # Handle messages from WebSocket
    async def receive(self, text_data):
        # Process incoming messages if needed
        
    # Send progress updates to WebSocket
    async def progress_update(self, event):
        # Send the progress data to the WebSocket
        await self.send(text_data=json.dumps({
            'progress': event['progress']
        }))
        
    # Send status updates to WebSocket
    async def status_update(self, event):
        # Send the status update to the WebSocket
        await self.send(text_data=json.dumps({
            'status': event['status'],
            'result': event.get('result'),
            'message': event.get('message')
        }))
```

================
File: rules/tables-datatables.mdc
================
---
description: When tables are requested use datatables
globs: *.html,*.js
---

# Tables

for tables and alerts use datatable and sweetalert javascript like:
    <script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
    <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
    <script>
        const dataTableSearch = new simpleDatatables.DataTable("#agents-table", {
        searchable: true,
        fixedHeight: true,
        perPage: 25,
        pageLength: [25, 50, 100, 200]
        });
    </script>

================
File: rules/template-extra-css-js.mdc
================
---
description: In django templates use these block titles for extra css and javascript
globs: *.html
---

for extra styles and scripts use {% block extrastyle %} {% endblock extrastyle %} and {% block extra_js %} {% endblock extra_js %}
