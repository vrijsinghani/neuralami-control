This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-22T17:36:52.037Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
static/
  agents/
    js/
      chat/
        app.js
      components/
        tool_outputs/
          base.js
      services/
        message_handler.js
      crew_kanban.js
websockets/
  chat_consumer.py
kanban_consumers.py
models.py

================================================================
Repository Files
================================================================

================
File: static/agents/js/chat/app.js
================
// Get current timestamp for cache busting
const version = new Date().getTime();

// Create URLs with cache busting
const messageListUrl = new URL('/static/agents/js/components/message_list.js', window.location.href);
const webSocketUrl = new URL('/static/agents/js/services/websocket.js', window.location.href);
const messageHandlerUrl = new URL('/static/agents/js/services/message_handler.js', window.location.href);
const toolOutputUrl = new URL('/static/agents/js/components/tool_outputs/base.js', window.location.href);

// Add version parameter to each URL
messageListUrl.searchParams.set('v', version);
webSocketUrl.searchParams.set('v', version);
messageHandlerUrl.searchParams.set('v', version);
toolOutputUrl.searchParams.set('v', version);

// Initialize components asynchronously
async function initializeComponents() {
    // Import modules dynamically
    const [
        { MessageList },
        { ChatWebSocket },
        { MessageHandler },
        { ToolOutputManager }
    ] = await Promise.all([
        import(messageListUrl.toString()),
        import(webSocketUrl.toString()),
        import(messageHandlerUrl.toString()),
        import(toolOutputUrl.toString())
    ]);

    return { MessageList, ChatWebSocket, MessageHandler, ToolOutputManager };
}

class ChatApp {
    constructor(config) {
        this.config = config;
        this.participantType = 'unset'; // Track participant type
        this.crewInitialized = false; // Track if crew has been initialized
        
        // Initialize highlight.js
        hljs.configure({
            ignoreUnescapedHTML: true,
            languages: ['javascript', 'python', 'bash', 'json', 'html', 'css']
        });
        
        this.elements = {
            messages: document.getElementById('chat-messages'),
            input: document.getElementById('message-input'),
            sendButton: document.getElementById('send-message'),
            agentSelect: document.getElementById('agent-select'),
            modelSelect: document.getElementById('model-select'),
            clientSelect: document.getElementById('client-select'),
            crewSelect: document.getElementById('crew-select'),
            newChatBtn: document.getElementById('new-chat-btn'),
            shareBtn: document.getElementById('share-conversation')
        };
    }

    async initialize() {
        // Import and initialize components
        const { MessageList, ChatWebSocket, MessageHandler, ToolOutputManager } = await initializeComponents();
        
        // Initialize components
        this.messageList = new MessageList(this.elements.messages);
        this.toolOutputManager = new ToolOutputManager();
        
        // Create message handler first without websocket
        this.messageHandler = new MessageHandler(this.messageList, this.toolOutputManager);
        
        // Create websocket with message handler
        this.websocket = new ChatWebSocket(this.config, this.messageHandler);
        
        // Update message handler with websocket
        this.messageHandler.websocket = this.websocket;
        
        // Set message handler callback for system messages
        this.messageHandler.onSystemMessage = this.handleSystemMessage.bind(this);
        
        // Bind event handlers
        this._bindEvents();

        // Listen for edit-message custom event
        document.addEventListener('edit-message', (event) => {
            const messageContainer = document.getElementById(`${event.detail.domId}-container`);
            if (messageContainer) {
                this.editMessage(messageContainer.querySelector('.edit-message'));
            }
        });

        // Connect WebSocket
        this.websocket.connect();
        
        // Initialize autosize for textarea
        if (this.elements.input) {
            autosize(this.elements.input);
        }
        
        // Set initial agent avatar and initialize chatConfig
        if (!window.chatConfig.currentAgent) {
            const selectedOption = this.elements.agentSelect?.selectedOptions[0];

            window.chatConfig.currentAgent = {
                avatar: selectedOption ? selectedOption.dataset.avatar : '/static/assets/img/team-3.jpg',
                name: selectedOption ? selectedOption.dataset.name : 'AI Assistant'
            };
        }
        this._updateAgentAvatar();
        
        // Update MessageList with current agent
        this.messageList.updateCurrentAgent(window.chatConfig.currentAgent);

        // Expose functions globally
        window.editMessage = this.editMessage.bind(this);
        window.copyMessage = this.copyMessage.bind(this);
        window.deleteConversation = this.deleteConversation.bind(this);
    }

    handleSystemMessage(message) {
        console.log('Handling system message:', message);
        // Update participant type from system message
        if (message.participant_type) {
            this.participantType = message.participant_type;
            this._updateUIForParticipantType();
        }
    }

    _updateUIForParticipantType() {
        console.log('Updating UI for participant type:', this.participantType);
        const selectedOption = this.elements.agentSelect?.selectedOptions[0];
        const selectedType = selectedOption?.dataset.type;

        // Update UI based on participant type
        if (this.participantType === 'crew' || selectedType === 'crew') {
            if (this.elements.agentSelect) {
                this.elements.agentSelect.disabled = true;
                this.elements.modelSelect.disabled = true;
            }
            // Update agent name to show crew if available
            const crewOption = this.elements.crewSelect?.selectedOptions[0];
            if (crewOption && document.getElementById('agent-name')) {
                document.getElementById('agent-name').textContent = `Crew: ${crewOption.textContent}`;
            }
        } else if (this.participantType === 'agent' || selectedType === 'agent') {
            if (this.elements.crewSelect) {
                this.elements.crewSelect.disabled = true;
            }
        }
    }

    _handleAgentOrCrewSelection() {
        const selectedOption = this.elements.agentSelect?.selectedOptions[0];
        if (!selectedOption) return;

        const selectedType = selectedOption.dataset.type;
        const selectedId = selectedOption.value;

        if (selectedType === 'crew') {
            // Just update the UI and participant type, don't start crew yet
            this.participantType = 'crew';
            this.crewInitialized = false; // Reset initialization flag
        } else {
            // Update participant type for agent
            this.participantType = 'agent';
        }

        this._updateUIForParticipantType();
        this._updateAgentAvatar();
    }

    _sendMessage() {
        const message = this.elements.input.value.trim();
        if (!message) return;

        const selectedOption = this.elements.agentSelect?.selectedOptions[0];
        const selectedType = selectedOption?.dataset.type;

        // Send message based on participant type
        if (this.participantType === 'crew' || selectedType === 'crew') {
            // If this is the first message to the crew, initialize it
            if (!this.crewInitialized) {
                this.websocket.send({
                    type: 'start_crew',
                    crew_id: selectedOption.value,
                    client_id: this.elements.clientSelect.value
                });
                this.crewInitialized = true;
            }
            
            // Send the crew message
            this.websocket.send({
                message: message,
                type: 'crew_message',
                crew_id: selectedOption.value,
                client_id: this.elements.clientSelect.value
            });
        } else {
            // Regular agent message
            this.websocket.send({
                message: message,
                agent_id: selectedOption.value,
                model: this.elements.modelSelect.value,
                client_id: this.elements.clientSelect.value
            });
        }

        // Clear input
        this.elements.input.value = '';
        autosize.update(this.elements.input);
    }

    editMessage(button) {
        const messageContainer = button.closest('.d-flex');
        if (!messageContainer) {
            console.warn('Could not find message container');
            return;
        }

        const messageText = messageContainer.querySelector('.message-text')?.textContent.trim();
        if (!messageText) {
            console.warn('Could not find message text');
            return;
        }
        
        // Get the message ID
        const domId = messageContainer.id.replace('-container', '');
        const backendId = this.messageList.getMessageId(domId);
        
        if (!backendId) {
            console.warn('No backend message ID found for container:', domId);
            return;
        }
        
        try {
            console.log('Editing message:', { domId, backendId, messageText });
            
            // Set input value to message content
            this.elements.input.value = messageText;
            this.elements.input.focus();
            autosize.update(this.elements.input);
            
            // Delete messages from the message list
            this.messageList.deleteMessagesFromIndex(domId);
            
            // Notify backend to handle edit
            this.websocket.send({
                type: 'edit',
                message: messageText,
                message_id: backendId,
                session_id: this.config.sessionId
            });
            
        } catch (error) {
            console.error('Error editing message:', error);
            alert('Failed to edit message. Please try again.');
        }
    }

    copyMessage(button) {
        const messageText = button.closest('.message-content')?.querySelector('.message-text')?.textContent.trim();
        if (!messageText) {
            console.warn('Could not find message text');
            return;
        }
        
        navigator.clipboard.writeText(messageText).then(() => {
            // Show temporary success indicator
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            setTimeout(() => {
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1000);
        }).catch(err => {
            console.error('Failed to copy text:', err);
        });
    }

    _bindEvents() {
        // Message sending
        if (this.elements.input && this.elements.sendButton) {
            this.elements.input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this._sendMessage();
                }
            });
            
            this.elements.sendButton.addEventListener('click', () => {
                this._sendMessage();
            });
        }

        // Agent/Crew selection
        if (this.elements.agentSelect) {
            this.elements.agentSelect.addEventListener('change', () => {
                this._handleAgentOrCrewSelection();
            });
        }

        // New chat button
        if (this.elements.newChatBtn) {
            this.elements.newChatBtn.addEventListener('click', () => {
                window.location.href = this.elements.newChatBtn.dataset.url;
            });
        }

        // Share button
        if (this.elements.shareBtn) {
            this.elements.shareBtn.addEventListener('click', () => {
                this.exportToMarkdown();
            });
        }
    }

    _updateAgentAvatar() {
        const selectedOption = this.elements.agentSelect.selectedOptions[0];
        if (selectedOption) {
            const avatarPath = selectedOption.dataset.avatar || '/static/assets/img/team-3.jpg';
            const avatarUrl = avatarPath.startsWith('/') ? avatarPath : `/static/assets/img/${avatarPath}`;
            const name = selectedOption.dataset.name;
            
            const avatarImg = document.getElementById('agent-avatar').querySelector('img');
            if (avatarImg) {
                avatarImg.src = avatarUrl;
                avatarImg.alt = name;
            }
            
            const nameElement = document.getElementById('agent-name');
            if (nameElement) {
                nameElement.textContent = name;
            }
            
            // Update global config for Message component
            window.chatConfig.currentAgent = {
                avatar: avatarUrl,
                name: name
            };
            
            // Update MessageList with new agent info
            this.messageList.updateCurrentAgent(window.chatConfig.currentAgent);
        }
    }

    async deleteConversation(sessionId, event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }

        if (!confirm('Are you sure you want to delete this conversation?')) {
            return;
        }

        try {
            const url = this.config.urls.deleteConversation.replace('{sessionId}', sessionId);
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.config.csrfToken,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('Failed to delete conversation');
            }

            // Redirect to new chat if we're deleting the current conversation
            if (sessionId === this.config.sessionId) {
                window.location.href = this.config.urls.newChat;
            } else {
                // Otherwise just remove the conversation from the list
                const conversationElement = event.target.closest('.position-relative');
                if (conversationElement) {
                    conversationElement.remove();
                }
            }
        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Failed to delete conversation. Please try again.');
        }
    }

    scrollToBottom() {
        if (this.elements.messages) {
            const scrollHeight = this.elements.messages.scrollHeight;
            this.elements.messages.scrollTo({
                top: scrollHeight,
                behavior: 'smooth'
            });
        }
    }

    appendMessage(content, isAgent = false, withActions = true, messageId = null) {
        // Use MessageList's addMessage method
        const domId = this.messageList.addMessage(content, isAgent, 
            isAgent ? window.chatConfig.currentAgent?.avatar : null, 
            messageId
        );
        
        // Add event listeners for actions
        if (withActions) {
            this.addMessageEventListeners(domId);
        }
    }

    async deleteMessagesFromIndex(messageContainer) {
        // Get the actual message container if we're passed a child element
        const container = messageContainer.closest('.d-flex');
        if (!container) {
            console.warn('Could not find message container');
            return;
        }

        // Get the message ID from the container ID
        const domId = container.id.replace('-container', '');
        const backendId = this.messageList.getMessageId(domId);
        
        if (!backendId) {
            console.warn('No backend message ID found for container:', domId);
            return;
        }
        
        try {
            // Delete messages from the message list
            this.messageList.deleteMessagesFromIndex(domId);
            
            // Notify backend to handle edit
            const editData = {
                type: 'edit',
                message: this.elements.input.value.trim(),
                message_id: backendId,
                session_id: this.config.sessionId
            };
            this.websocket.send(editData);
            
        } catch (error) {
            console.error('Error editing messages:', error);
            alert('Failed to edit messages. Please try again.');
        }
    }

    addMessageEventListeners(domId) {
        const container = document.getElementById(`${domId}-container`);
        if (!container) return;

        const messageContent = container.querySelector('.message-content');
        const messageActions = container.querySelector('.message-actions');
        const copyButton = container.querySelector('.copy-message');
        const editButton = container.querySelector('.edit-message');

        // Show/hide actions on hover
        if (messageContent && messageActions) {
            messageContent.addEventListener('mouseenter', () => {
                messageActions.classList.remove('opacity-0');
            });
            messageContent.addEventListener('mouseleave', () => {
                messageActions.classList.add('opacity-0');
            });
        }

        // Copy button functionality
        if (copyButton) {
            copyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const messageText = container.querySelector('.message-text').textContent.trim();
                navigator.clipboard.writeText(messageText).then(() => {
                    // Show success feedback
                    const icon = copyButton.querySelector('i');
                    icon.classList.remove('fa-copy');
                    icon.classList.add('fa-check');
                    setTimeout(() => {
                        icon.classList.remove('fa-check');
                        icon.classList.add('fa-copy');
                    }, 1000);
                });
            });
        }

        // Edit button functionality
        if (editButton) {
            editButton.addEventListener('click', async (e) => {
                e.stopPropagation();
                const messageText = container.querySelector('.message-text').textContent.trim();
                
                // 1. Put the message text in the input field
                this.elements.input.value = messageText;
                this.elements.input.focus();
                autosize.update(this.elements.input);

                // 2. Delete this message and all subsequent messages
                await this.deleteMessagesFromIndex(container);
            });
        }
    }

    exportToMarkdown() {
        let markdown = '# Chat Conversation\n\n';
        const messages = this.elements.messages.querySelectorAll('.message');
        
        messages.forEach(message => {
            const isAgent = message.classList.contains('agent');
            const messageText = message.querySelector('.message-text').textContent.trim();
            const role = isAgent ? 'Assistant' : 'User';
            
            markdown += `**${role}**: ${messageText}\n\n`;
        });

        // Create a blob and trigger download
        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chat-export-${new Date().toISOString().slice(0,10)}.md`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }
}

export { ChatApp };

================
File: static/agents/js/components/tool_outputs/base.js
================
class ToolOutputManager {
    constructor() {
        this.activeContainer = null;
        this.messagesContainer = document.getElementById('chat-messages');
        this.charts = new Map(); // Store chart instances
        
        // The date-fns adapter is automatically registered via the bundle
    }

    handleToolStart(data) {
        try {
            // Try to parse if string, otherwise use as is
            const toolData = typeof data === 'string' ? JSON.parse(data) : data;
            
            // Create a new container for this tool output
            const container = document.createElement('div');
            container.className = 'd-flex justify-content-start mb-4';
            const containerId = `tool-${Date.now()}`;
            container.innerHTML = `
                <div class="avatar me-2">
                    <img src="${window.chatConfig.currentAgent.avatar}" 
                         alt="${window.chatConfig.currentAgent.name}" 
                         class="border-radius-lg shadow">
                </div>
                <div class="message agent" style="max-width: 75%;">
                    <div class="tool-output">
                        <div class="tool-header d-flex align-items-center justify-content-between">
                            <div class="d-flex align-items-center cursor-pointer collapsed" data-bs-toggle="collapse" data-bs-target="#${containerId}-content">
                                <i class="fas fa-chevron-down me-2 toggle-icon"></i>
                                <i class="fas fa-tools me-2"></i>
                                <span class="tool-name small">${toolData.tool || 'Tool'}</span>
                            </div>
                        </div>
                        <div class="tool-content mt-2 collapse" id="${containerId}-content">
                            ${toolData.input ? `
                            <div class="tool-input text-muted mb-2">
                                <small>Input: ${toolData.input}</small>
                            </div>` : ''}
                            <div class="tool-result"></div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to messages container
            if (this.messagesContainer) {
                this.messagesContainer.appendChild(container);
                this.activeContainer = container;
                
                // Scroll to the new container
                container.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
        } catch (error) {
            console.error('Error handling tool start:', error);
            // Create a minimal container for error case
            const container = document.createElement('div');
            container.className = 'd-flex justify-content-start mb-4';
            container.innerHTML = `
                <div class="avatar me-2">
                    <img src="${window.chatConfig.currentAgent.avatar}" 
                         alt="${window.chatConfig.currentAgent.name}" 
                         class="border-radius-lg shadow">
                </div>
                <div class="message agent" style="max-width: 75%;">
                    <div class="tool-output">
                        <div class="tool-header d-flex align-items-center">
                            <i class="fas fa-tools me-2"></i>
                            <span class="tool-name small">Tool Execution</span>
                        </div>
                    </div>
                </div>
            `;
            
            if (this.messagesContainer) {
                this.messagesContainer.appendChild(container);
                this.activeContainer = container;
            }
        }
    }

    handleToolResult(result) {
        try {
            let container = this.activeContainer;
            
            if (!container) {
                console.warn('No active tool container found for result');
                return;
            }

            const resultContainer = container.querySelector('.tool-result');
            if (!resultContainer) return;

            if (result.type === 'error') {
                resultContainer.innerHTML = `
                    <div class="tool-error mt-2">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <span class="text-danger small">${result.data}</span>
                    </div>
                `;
            } else if (result.type === 'text') {
                // Handle text-based results with markdown formatting
                resultContainer.innerHTML = `
                    <div class="tool-text mt-2">
                        <small>${marked.parse(result.data)}</small>
                    </div>
                `;
            } else if (result.type === 'json' || (result.type === 'table' && Array.isArray(result.data))) {
                const data = result.data;
                const timeSeriesData = this._findTimeSeriesData(data);
                
                if (timeSeriesData) {
                    // Add visualization toggle buttons
                    const toggleContainer = document.createElement('div');
                    toggleContainer.className = 'mb-2 btn-group';
                    toggleContainer.innerHTML = `
                        <button class="btn btn-primary btn-sm active" data-view="chart">
                            <i class="fas fa-chart-line me-1"></i>Chart
                        </button>
                        <button class="btn btn-primary btn-sm" data-view="table">
                            <i class="fas fa-table me-1"></i>Table
                        </button>
                    `;
                    
                    // Add visualization container
                    const vizContainer = document.createElement('div');
                    vizContainer.className = 'visualization-container';
                    
                    resultContainer.appendChild(toggleContainer);
                    resultContainer.appendChild(vizContainer);
                    
                    // Add event listeners for toggle buttons
                    toggleContainer.querySelectorAll('button').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const view = e.currentTarget.dataset.view;
                            this._updateVisualization(vizContainer, view, timeSeriesData, data);
                            
                            // Update active button state
                            toggleContainer.querySelectorAll('button').forEach(btn => 
                                btn.classList.toggle('active', btn === e.currentTarget)
                            );
                        });
                    });
                    
                    // Show initial visualization
                    this._updateVisualization(vizContainer, 'chart', timeSeriesData, data);
                    
                    // Add CSV download button for full data
                    this._addCsvDownloadButton(container, data);
                } else {
                    const tableData = this._findTableData(data);
                    if (tableData) {
                        resultContainer.innerHTML = this._createTable(tableData);
                        this._addCsvDownloadButton(container, tableData);
                    } else {
                        resultContainer.innerHTML = `
                            <pre class="json-output small">${JSON.stringify(data, null, 2)}</pre>
                        `;
                    }
                }
            } else {
                resultContainer.innerHTML = `
                    <div class="tool-text mt-2">
                        <small>${typeof result === 'string' ? result : JSON.stringify(result)}</small>
                    </div>
                `;
            }

            // Show the tool content after adding result
            const toolContent = container.querySelector('.tool-content');
            if (toolContent) {
                toolContent.classList.add('show');
            }
        } catch (error) {
            console.error('Error handling tool result:', error);
        }
    }

    _updateVisualization(container, view, timeSeriesData, originalData) {
        // Clear previous visualization
        container.innerHTML = '';
        
        if (view === 'chart' && timeSeriesData) {
            // Create chart with filtered data
            this._createChart(container, timeSeriesData);
        } else if (view === 'table') {
            // Create table with original data
            container.innerHTML = this._createTable(originalData);
            
            // Initialize DataTable
            setTimeout(() => {
                try {
                    const tableId = container.querySelector('table').id;
                    new simpleDatatables.DataTable(`#${tableId}`, {
                        searchable: true,
                        fixedHeight: false,
                        perPage: 10
                    });
                } catch (error) {
                    console.warn('Failed to initialize DataTable:', error);
                }
            }, 100);
        }
    }

    _findTableData(data) {
        // If data is already an array of objects with at least one row, it's tabular
        if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
            return data;
        }

        // Look for arrays in the object values
        if (typeof data === 'object') {
            for (const key in data) {
                const value = data[key];
                if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                    return value;
                }
            }
        }

        return null;
    }

    _createTable(data) {
        if (!Array.isArray(data) || !data.length) return '';

        const tableId = `table-${Date.now()}`;
        const headers = Object.keys(data[0]);
        const rows = data.map(row => headers.map(header => {
            const value = row[header];
            // Format dates and numbers
            if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                return new Date(value).toISOString().split('T')[0];
            }
            if (typeof value === 'number') {
                return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
            }
            return value;
        }));

        const html = `
            <div class="table-responsive">
                <table id="${tableId}" class="table table-sm">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th>${this._formatFieldName(header)}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `
                            <tr>
                                ${row.map(cell => `<td>${cell}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;

        // Initialize DataTable after a short delay to ensure the table is in the DOM
        setTimeout(() => {
            try {
                new simpleDatatables.DataTable(`#${tableId}`, {
                    searchable: true,
                    fixedHeight: false,
                    perPage: 10
                });
            } catch (error) {
                console.warn(`Failed to initialize DataTable for ${tableId}:`, error);
            }
        }, 100);

        return html;
    }

    _addCsvDownloadButton(container, data) {
        const toolActions = container.querySelector('.tool-actions');
        if (!toolActions || !data || !data.length) return;

        const headers = Object.keys(data[0]);
        const csvContent = [
            headers.join(','),
            ...data.map(row => headers.map(header => {
                let value = row[header];
                // Format dates and numbers
                if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                    value = new Date(value).toISOString().split('T')[0];
                } else if (typeof value === 'number') {
                    value = value.toFixed(2);
                }
                // Handle values that need quotes (contains commas, quotes, or newlines)
                if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                    value = `"${value.replace(/"/g, '""')}"`;
                }
                return value;
            }).join(','))
        ].join('\n');

        // Create download button
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const downloadButton = document.createElement('a');
        downloadButton.href = url;
        downloadButton.download = 'table_data.csv';
        downloadButton.className = 'btn btn-link btn text-primary p-0 ms-2';
        downloadButton.innerHTML = '<i class="fas fa-download"></i>';
        downloadButton.title = 'Download as CSV';
        
        // Clean up the URL on click
        downloadButton.addEventListener('click', () => {
            setTimeout(() => URL.revokeObjectURL(url), 100);
        });

        // Create copy button
        const copyButton = document.createElement('button');
        copyButton.className = 'btn btn-link btn text-primary p-0 ms-2';
        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
        copyButton.title = 'Copy CSV to clipboard';
        
        copyButton.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(csvContent);
                // Show success feedback
                const originalIcon = copyButton.innerHTML;
                copyButton.innerHTML = '<i class="fas fa-check text-success"></i>';
                setTimeout(() => {
                    copyButton.innerHTML = originalIcon;
                }, 1000);
            } catch (err) {
                console.error('Failed to copy:', err);
                // Show error feedback
                const originalIcon = copyButton.innerHTML;
                copyButton.innerHTML = '<i class="fas fa-times text-danger"></i>';
                setTimeout(() => {
                    copyButton.innerHTML = originalIcon;
                }, 1000);
            }
        });

        toolActions.appendChild(copyButton);
        toolActions.appendChild(downloadButton);
    }

    _findTimeSeriesData(data) {
        // Check if data is an array of objects with date/time and numeric fields
        if (!Array.isArray(data) || !data.length) return null;

        // Look for date/time fields (prefer 'date' or 'timestamp' if they exist)
        const dateFields = Object.keys(data[0]).filter(key => {
            const value = data[0][key];
            return typeof value === 'string' && !isNaN(Date.parse(value));
        });

        if (dateFields.length === 0) return null;

        // Prefer fields named 'date' or 'timestamp', otherwise take the first date field
        const dateField = dateFields.find(field => 
            field.toLowerCase() === 'date' || 
            field.toLowerCase() === 'timestamp'
        ) || dateFields[0];

        // Find numeric fields, excluding those that end with common suffixes for derived values
        const excludeSuffixes = ['_change', '_previous', '_percent', '_ratio', '_delta'];
        const numericFields = Object.keys(data[0]).filter(key => {
            if (key === dateField) return false;
            const value = data[0][key];
            // Check if it's a number and doesn't end with excluded suffixes
            return typeof value === 'number' && 
                   !excludeSuffixes.some(suffix => key.toLowerCase().endsWith(suffix.toLowerCase()));
        });

        if (numericFields.length === 0) return null;

        // Find potential categorical fields (string fields with a reasonable number of unique values)
        const maxCategories = 10; // Maximum number of unique categories to consider
        const categoricalFields = Object.keys(data[0]).filter(key => {
            if (key === dateField || numericFields.includes(key)) return false;
            const values = new Set(data.map(item => item[key]));
            return typeof data[0][key] === 'string' && values.size > 1 && values.size <= maxCategories;
        });

        // If we found categorical fields, use the first one for grouping
        const categoryField = categoricalFields.length > 0 ? categoricalFields[0] : null;

        // Group data by date and category (if exists)
        const groupedData = new Map();
        
        data.forEach(item => {
            const date = new Date(item[dateField]);
            const dateKey = date.toISOString().split('T')[0]; // Group by day
            const categoryKey = categoryField ? item[categoryField] : 'default';
            const groupKey = `${dateKey}|${categoryKey}`;
            
            if (!groupedData.has(groupKey)) {
                groupedData.set(groupKey, {
                    counts: {},
                    sums: {},
                    date,
                    category: categoryKey
                });
            }
            
            const group = groupedData.get(groupKey);
            numericFields.forEach(field => {
                if (typeof item[field] === 'number' && !isNaN(item[field])) {
                    group.sums[field] = (group.sums[field] || 0) + item[field];
                    group.counts[field] = (group.counts[field] || 0) + 1;
                }
            });
        });

        // Convert grouped data back to array format with averages
        const aggregatedData = Array.from(groupedData.values()).map(group => {
            const result = {
                [dateField]: group.date
            };
            if (categoryField) {
                result[categoryField] = group.category;
            }
            numericFields.forEach(field => {
                if (group.counts[field]) {
                    result[field] = group.sums[field] / group.counts[field];
                }
            });
            return result;
        });

        // Sort by date
        aggregatedData.sort((a, b) => a[dateField] - b[dateField]);

        return {
            dateField,
            numericFields,
            categoryField,
            data: aggregatedData
        };
    }

    _createChart(container, timeSeriesData) {
        const { dateField, numericFields, categoryField, data } = timeSeriesData;
        const chartId = `chart-${Date.now()}`;
        const canvas = document.createElement('canvas');
        canvas.id = chartId;
        container.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        
        // Create datasets based on numeric fields and categories
        let datasets = [];
        if (categoryField) {
            // Get unique categories
            const categories = [...new Set(data.map(item => item[categoryField]))];
            
            // For each numeric field and category combination
            numericFields.forEach(field => {
                categories.forEach(category => {
                    const categoryData = data.filter(item => item[categoryField] === category);
                    datasets.push({
                        label: `${this._formatFieldName(field)} - ${category}`,
                        data: categoryData.map(item => ({ x: new Date(item[dateField]), y: item[field] })),
                        borderColor: this._getRandomColor(),
                        tension: 0.4,
                        fill: false,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointHitRadius: 10
                    });
                });
            });
        } else {
            // Original behavior for no categories
            datasets = numericFields.map(field => ({
                label: this._formatFieldName(field),
                data: data.map(item => ({ x: new Date(item[dateField]), y: item[field] })),
                borderColor: this._getRandomColor(),
                tension: 0.4,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointHitRadius: 10
            }));
        }

        // Determine the time unit based on the data
        const dates = data.map(item => new Date(item[dateField]));
        const timeUnit = this._determineTimeUnit(dates);
        
        // Calculate min and max dates for the scale
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));
        
        // Calculate a reasonable number of ticks based on the date range
        const range = maxDate - minDate;
        const numberOfTicks = Math.min(10, data.length);
        
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: timeUnit,
                            displayFormats: {
                                hour: 'MMM d, HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy'
                            },
                            tooltipFormat: timeUnit === 'hour' ? 'MMM d, HH:mm' :
                                         timeUnit === 'day' ? 'MMM d, yyyy' :
                                         timeUnit === 'week' ? 'MMM d, yyyy' :
                                         'MMM yyyy'
                        },
                        min: minDate,
                        max: maxDate,
                        ticks: {
                            source: 'auto',
                            autoSkip: true,
                            maxTicksLimit: numberOfTicks
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Value'
                        },
                        ticks: {
                            autoSkip: true,
                            maxTicksLimit: 8
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Time Series Data'
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                return `${label}: ${value.toLocaleString(undefined, {maximumFractionDigits: 2})}`;
                            }
                        }
                    },
                    legend: {
                        position: 'top',
                        align: 'center'
                    }
                },
                elements: {
                    point: {
                        radius: 3,
                        hitRadius: 10,
                        hoverRadius: 5
                    },
                    line: {
                        tension: 0.4
                    }
                }
            }
        });

        // Set a fixed height for the chart container
        canvas.style.height = '400px';
        
        this.charts.set(chartId, chart);
        return chartId;
    }

    _formatFieldName(field) {
        // Convert camelCase or snake_case to Title Case
        return field
            .replace(/([A-Z])/g, ' $1') // Split camelCase
            .replace(/_/g, ' ')         // Replace underscores with spaces
            .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()); // Title case
    }

    _determineTimeUnit(dates) {
        if (dates.length < 2) return 'day'; // Default to day if not enough data points
        
        // Sort dates to ensure correct interval calculation
        dates.sort((a, b) => a - b);
        
        // Calculate all intervals between consecutive dates
        const intervals = [];
        for (let i = 1; i < dates.length; i++) {
            intervals.push(dates[i] - dates[i-1]);
        }
        
        // Get median interval in milliseconds
        intervals.sort((a, b) => a - b);
        const medianInterval = intervals[Math.floor(intervals.length / 2)];
        
        // Convert to hours for easier comparison
        const hours = medianInterval / (1000 * 60 * 60);
        
        // Determine appropriate unit based on median interval
        // For hourly data (intervals between 30 mins and 4 hours)
        if (hours <= 4) return 'hour';
        
        // For daily data (intervals between 4 hours and 5 days)
        if (hours <= 24 * 5) return 'day';
        
        // For weekly data (intervals between 5 days and 15 days)
        if (hours <= 24 * 15) return 'week';
        
        // For monthly data (intervals greater than 15 days)
        return 'month';
    }

    _getRandomColor() {
        const colors = [
            '#3498db', '#2ecc71', '#e74c3c', '#f1c40f', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#16a085', '#c0392b'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    _convertTimeSeriesDataToTable(timeSeriesData) {
        const { dateField, numericFields, data } = timeSeriesData;
        
        // Convert the time series data to a tabular format
        return data.map(item => {
            const row = {
                [dateField]: new Date(item[dateField]).toISOString()
            };
            numericFields.forEach(field => {
                row[field] = item[field];
            });
            return row;
        });
    }
}

export { ToolOutputManager };

================
File: static/agents/js/services/message_handler.js
================
class MessageHandler {
    constructor(messageList, toolOutputManager) {
        this.messageList = messageList;
        this.toolOutputManager = toolOutputManager;
        this.websocket = null;  // Will be set after construction
        this.messagesContainer = document.getElementById('chat-messages');
        this.currentToolContainer = null;
        this.loadingIndicator = null;
        this.onSystemMessage = null; // Callback for system messages
        this.lastHumanInputContext = null; // Store context for human input
    }

    handleMessage(message) {
        console.log('Received message:', message);

        switch (message.type) {
            case 'system_message':
                this.handleSystemMessage(message);
                break;
            case 'user_message':
                this.handleUserMessage(message);
                break;
            case 'agent_message':
                this.removeLoadingIndicator();
                this.handleAgentMessage(message);
                break;
            case 'crew_message':
                // Only remove loading indicator if crew execution is completed
                if (message.status && (message.status === 'DONE' || message.status === 'COMPLETED')) {
                    this.removeLoadingIndicator();
                }
                this.handleCrewMessage(message);
                break;
            case 'execution_update':
                this.handleExecutionUpdate(message);
                break;
            case 'agent_finish':
                console.log('Agent finish:', message);
                this.handleAgentFinish(message);
                break;
            case 'tool_start':
                this.handleToolStart(message);
                break;
            case 'tool_end':
                this.handleToolEnd(message);
                break;
            case 'tool_result':
                this.handleToolResult(message);
                break;
            case 'error':
                console.log('Error message:', message);
                this.handleErrorMessage(message);
                break;
            default:
                console.warn('Unknown message type:', message.type);
        }
    }

    showLoadingIndicator() {
        // Remove any existing loading indicator first
        this.removeLoadingIndicator();

        // Create the loading indicator
        const loadingContainer = document.createElement('div');
        loadingContainer.className = 'd-flex justify-content-start mb-4 streaming-message';
        loadingContainer.innerHTML = `
            <div class="avatar me-2">
                <img src="${this.messageList.currentAgent.avatar}" 
                     alt="${this.messageList.currentAgent.name}" 
                     class="border-radius-lg shadow">
            </div>
            <div class="agent-message" style="max-width: 75%;">
                <div class="message-content loading-content">
                    <div class="typing-indicator">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div class="typing-text ms-2">Thinking...</div>
                    </div>
                </div>
            </div>
        `;

        this.loadingIndicator = loadingContainer;
        this.messagesContainer.appendChild(loadingContainer);
        this.scrollToBottom();
    }

    removeLoadingIndicator() {
        if (this.loadingIndicator) {
            this.loadingIndicator.remove();
            this.loadingIndicator = null;
        }
    }

    scrollToBottom() {
        if (this.messagesContainer) {
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        }
    }

    handleSystemMessage(message) {
        // Call the system message callback if set
        if (this.onSystemMessage) {
            this.onSystemMessage(message);
        }

        if (message.connection_status) {
            this.handleConnectionStatus(message.connection_status);
        }
    }

    handleConnectionStatus(status) {
        const dot = document.querySelector('.connection-dot');
        if (dot) {
            dot.className = 'connection-dot ' + status;
        }
    }

    handleUserMessage(message) {
        // Only add to UI if this is the first time we're seeing this message
        if (message.id) {
            this.messageList.addMessage(message.message, false, null, message.id);
            
            // If we have stored human input context, send the response
            if (this.lastHumanInputContext && this.websocket) {
                this.websocket.send({
                    type: 'user_message',
                    message: message.message,
                    context: this.lastHumanInputContext
                });
                this.lastHumanInputContext = null;
            }
        }
        
        this.showLoadingIndicator();
    }

    handleAgentMessage(message) {
        // Handle structured tool messages
        if (message.content && message.content.tool) {
            this.toolOutputManager.handleToolStart({
                tool: message.content.tool,
                input: message.content.input
            });
            return;
        }

        // Handle legacy text-based tool messages
        if (typeof message.message === 'string') {
            if (message.message.startsWith('Tool Start:') || message.message.startsWith('Using Tool:')) {
                try {
                    const toolMessage = message.message;
                    const toolMatch = toolMessage.match(/^(?:Tool Start:|Using Tool:)\s*(.*?)\s*-/);
                    const toolName = toolMatch ? toolMatch[1].trim() : 'Tool';
                    
                    this.toolOutputManager.handleToolStart({
                        tool: toolName,
                        input: toolMessage
                    });
                } catch (error) {
                    console.error('Error parsing tool start message:', error);
                    this.messageList.addMessage(message.message, true, null, message.id);
                }
            } else if (message.message.startsWith('Tool Result:') || message.message.startsWith('Tool result:')) {
                try {
                    const jsonStr = message.message.replace(/^(Tool Result:|Tool result:)/, '').trim();
                    const data = JSON.parse(jsonStr);
                    
                    if (data.analytics_data && Array.isArray(data.analytics_data)) {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'table', 
                            data: data.analytics_data 
                        });
                    } else {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'json', 
                            data 
                        });
                    }
                } catch (error) {
                    console.error('Error parsing tool result message:', error);
                    this.messageList.addMessage(message.message, true, null, message.id);
                }
            } else if (message.message.startsWith('Tool Error:')) {
                const errorMessage = message.message.replace('Tool Error:', '').trim();
                this.toolOutputManager.handleToolResult({
                    type: 'error',
                    data: errorMessage
                });
            } else {
                this.messageList.addMessage(message.message, true, null, message.id);
            }
        } else {
            // Handle structured message
            this.messageList.addMessage(message.message, true, null, message.id);
        }
    }

    handleAgentFinish(message) {
        try {
            const data = typeof message.message === 'string' ? JSON.parse(message.message) : message.message;
            if (data.analytics_data && Array.isArray(data.analytics_data)) {
                this.toolOutputManager.handleToolResult({
                    type: 'table',
                    data: data.analytics_data
                });
            } else {
                this.messageList.addMessage(message.message, true, null, message.id);
            }
        } catch (error) {
            this.messageList.addMessage(message.message, true, null, message.id);
        }
    }

    handleToolStart(message) {
        const toolData = {
            tool: message.content?.tool || message.message?.tool,
            input: message.content?.input || message.message?.input
        };
        this.toolOutputManager.handleToolStart(toolData);
    }

    handleToolEnd(message) {
        // Handle tool end if needed
    }

    handleToolResult(message) {
        let result;
        try {
            // Handle both content and message formats
            const data = message.content || message.message;
            const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
            
            if (parsedData.error) {
                result = { type: 'error', data: parsedData.error };
            } else if (parsedData.analytics_data && Array.isArray(parsedData.analytics_data)) {
                result = { type: 'table', data: parsedData.analytics_data };
            } else {
                result = { type: 'json', data: parsedData };
            }
        } catch (error) {
            console.error('Error parsing tool result:', error);
            result = { type: 'text', data: message.content || message.message };
        }
        this.toolOutputManager.handleToolResult(result);
    }

    handleErrorMessage(message) {
        console.error('Server error:', message.message);
    }

    handleCrewMessage(message) {
        // Handle crew-specific messages
        if (message.message && typeof message.message === 'string') {
            // Handle tool messages
            if (message.message.startsWith('Using tool:') || message.message.startsWith('Tool Start:')) {
                // Don't add the tool start message directly to chat
                const toolMessage = message.message;
                const toolMatch = toolMessage.match(/^(?:Tool Start:|Using Tool:)\s*(.*?)(?:\nInput:|$)/);
                const toolName = toolMatch ? toolMatch[1].trim() : 'Tool';
                const inputMatch = toolMessage.match(/Input:(.*?)(?:\n|$)/s);
                const input = inputMatch ? inputMatch[1].trim() : '';
                
                this.toolOutputManager.handleToolStart({
                    tool: toolName,
                    input: input
                });
                return;
            } else if (message.message.startsWith('Tool Result:') || message.message.startsWith('Tool result:')) {
                // Don't add the tool result message directly to chat
                const resultContent = message.message.replace(/^(Tool Result:|Tool result:)/, '').trim();
                
                // Try to parse as JSON first
                try {
                    const jsonData = JSON.parse(resultContent);
                    if (jsonData.analytics_data && Array.isArray(jsonData.analytics_data)) {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'table', 
                            data: jsonData.analytics_data 
                        });
                    } else {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'json', 
                            data: jsonData 
                        });
                    }
                } catch (jsonError) {
                    // If not JSON, handle as text result
                    this.toolOutputManager.handleToolResult({ 
                        type: 'text', 
                        data: resultContent 
                    });
                }
                return;
            } else if (message.message.startsWith('Tool Error:')) {
                // Don't add the tool error message directly to chat
                const errorMessage = message.message.replace('Tool Error:', '').trim();
                this.toolOutputManager.handleToolResult({
                    type: 'error',
                    data: errorMessage
                });
                return;
            }
        }

        // If this is a human input request, store the context
        if (message.context?.is_human_input) {
            this.lastHumanInputContext = message.context;
            this.removeLoadingIndicator();
        }

        // Only add non-tool messages to UI
        if (!message.message?.startsWith('Using tool:') && 
            !message.message?.startsWith('Tool Start:') && 
            !message.message?.startsWith('Tool Result:') && 
            !message.message?.startsWith('Tool result:') && 
            !message.message?.startsWith('Tool Error:')) {
            this.messageList.addMessage(message, true);
            this.scrollToBottom();
        }
    }

    handleExecutionUpdate(message) {
        // Handle execution status updates
        if (message.status === 'RUNNING') {
            this.showLoadingIndicator();
        } else if (message.status === 'COMPLETED' || message.status === 'FAILED') {
            this.removeLoadingIndicator();
        }
        
        // Only add non-tool messages to UI
        if (message.message && 
            !message.message.startsWith('Using tool:') && 
            !message.message.startsWith('Tool Start:') && 
            !message.message.startsWith('Tool Result:') && 
            !message.message.startsWith('Tool result:') && 
            !message.message.startsWith('Tool Error:')) {
            this.messageList.addMessage({
                type: 'crew_message',
                message: message.message
            }, true, null, null);
            this.scrollToBottom();
        }
    }

    _sendMessage(message) {
        if (!this.websocket) {
            console.error('No websocket available for sending message');
            return;
        }

        // If we have human input context, send as human input response
        if (this.lastHumanInputContext) {
            this.websocket.send({
                type: 'user_message',
                message: message,
                context: this.lastHumanInputContext
            });
            this.lastHumanInputContext = null;
        } else {
            // Send as regular message
            this.websocket.send(message);
        }
    }
}

export { MessageHandler };

================
File: static/agents/js/crew_kanban.js
================
// Check required dependencies
if (typeof bootstrap === 'undefined') {
    console.error('Bootstrap is required but not loaded');
}
if (typeof markdownit === 'undefined') {
    console.error('markdown-it is required but not loaded');
}
if (typeof jKanban === 'undefined') {
    console.error('jKanban is required but not loaded');
}

// Verify required variables from template
if (typeof crewId === 'undefined') {
    console.error('crewId is required but not defined');
}
if (typeof clientId === 'undefined') {
    console.warn('clientId is not defined'); // warning since it can be null
}

// Initialize markdown-it globally
window.md = window.markdownit();

// WebSocket configuration and state
const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
let socket = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
let reconnectDelay = 1000;
let pingInterval = null;
let lastPongTime = Date.now();

// Task tracking
let lastUpdatedTaskId = null;
let lastUpdatedTaskIndex = null;  // Track last used task index

// DOM elements cache
const elements = {
    kanbanContainer: document.getElementById('kanban-tasks'),
    executionNumber: document.getElementById('execution-number'),
    cancelButton: document.getElementById('cancelExecutionBtn')
};

// Initialize CSRF token
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.error('CSRF token not found');
        return '';
    }
    return token.value;
}

// Import ContentExpander module
import { ContentExpander } from './modules/content_expander.js';
console.log('ContentExpander imported');
// Initialize content expander
const contentExpander = new ContentExpander();
console.log('ContentExpander initialized', contentExpander);
async function fetchActiveExecutions() {
    try {
        const response = await fetch(`/agents/crew/${crewId}/active-executions/`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        // Update cancel button based on active executions
        const hasActiveExecution = data.executions && data.executions.length > 0;
        const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
        updateCancelButton(hasActiveExecution, activeExecutionId);
        
        // Clear boards first
        document.querySelectorAll('.kanban-drag').forEach(board => {
            board.innerHTML = '';
        });
        
        // Repopulate with active executions
        data.executions.forEach(execution => {
            updateKanbanBoard({
                execution_id: execution.execution_id,
                task_id: execution.task_id,
                name: execution.name,
                status: execution.status,
                stages: execution.stages
            });
        });
        
        return data;
    } catch (error) {
        console.error('Error fetching active executions:', error);
        return null;
    }
}

function connectWebSocket() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        console.log('WebSocket already connected');
        return;
    }
    
    // Close existing socket if it exists
    if (socket) {
        socket.close();
    }

    // Clear all kanban boards
    document.querySelectorAll('.kanban-drag').forEach(board => {
        board.innerHTML = '';
    });
    
    try {
        socket = new WebSocket(
            `${wsScheme}://${window.location.host}/ws/crew/${crewId}/kanban/`
        );
        
        socket.onopen = function(e) {
            console.log('WebSocket connection established');
            // Fetch active executions when connection is established
            fetchActiveExecutions();
        };

        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            
            if (!data.type) {
                console.error("Message missing type:", data);
                return;
            }
            
            handleWebSocketMessage(data);
        };

        socket.onclose = function(e) {
            console.log('WebSocket connection closed', e.code, e.reason);
            stopPingInterval();
            
            // Don't reconnect if closed normally
            if (e.code === 1000 || e.code === 1001) {
                console.log('WebSocket closed normally');
                return;
            }
            
            // Attempt to reconnect if not at max attempts
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                
                // Exponential backoff with jitter
                reconnectDelay = Math.min(reconnectDelay * 2, 30000);
                const jitter = Math.random() * 1000;
                setTimeout(connectWebSocket, reconnectDelay + jitter);
            } else {
                console.error('Max reconnection attempts reached');
            }
        };

        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
            // Let onclose handle reconnection
        };
        
    } catch (error) {
        console.error('Error creating WebSocket:', error);
        // Attempt to reconnect on connection error
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(connectWebSocket, reconnectDelay);
        }
    }
}

// Ping interval to keep connection alive
function startPingInterval() {
    stopPingInterval(); // Clear any existing interval
    
    // Send ping every 15 seconds
    pingInterval = setInterval(() => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            // Check if we haven't received a pong in 45 seconds
            if (Date.now() - lastPongTime > 45000) {
                console.log('No pong received for 45 seconds, reconnecting...');
                socket.close();
                connectWebSocket();
                return;
            }
            
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 15000);
}

function stopPingInterval() {
    if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
    }
}

// Initial connection
connectWebSocket();

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    stopPingInterval();
    if (socket) {
        socket.close();
    }
});


function updateKanbanBoard(data) {
    // Only proceed if we have an execution_id
    if (!data.execution_id) {
        console.log('No execution_id provided, skipping update');
        return;
    }
    
    // Update cancel button based on execution status
    if (data.execution_id && data.status) {
        const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
        updateCancelButton(isActive, isActive ? data.execution_id : null);
    }
    
    // Update execution number in header
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = ` - Execution #${data.execution_id}`;
    }

    // Use task_index for board placement, fallback to last used index
    const taskIndex = data.task_index !== undefined ? data.task_index : lastUpdatedTaskIndex;
    console.log('Updating board with task index:', taskIndex, '(from data:', data.task_index, ', last:', lastUpdatedTaskIndex, ')');
    
    // Get all kanban boards in order
    const taskBoards = document.querySelectorAll('.kanban-board');
    let targetBoard;
    
    if (taskIndex !== null && taskIndex !== undefined && taskIndex < taskBoards.length) {
        targetBoard = taskBoards[taskIndex];
        lastUpdatedTaskIndex = taskIndex;  // Update the last used index
        console.log('Found target board for index:', taskIndex);
    } else {
        // Fallback to first board if no valid index available
        targetBoard = taskBoards[0];
        console.log('Using first board as fallback, no valid task index');
    }

    if (targetBoard) {
        addUpdateToBoard(targetBoard, data);
    } else {
        console.log('No board found for update');
    }
}

function handleHumanInputSubmit(button) {
    const stageItem = button.closest('.stage-item');
    const executionId = stageItem.getAttribute('data-execution-id');
    console.log("Submitting human input for execution:", executionId);
    
    if (!executionId) {
        console.error("No execution ID found for human input submission");
        alert('Error: Could not determine execution ID');
        return;
    }

    const textarea = button.parentElement.querySelector('textarea');
    const input = textarea.value.trim();
    
    if (!input) {
        alert('Please enter a response before submitting.');
        return;
    }
    
    // Disable the button and textarea while submitting
    button.disabled = true;
    textarea.disabled = true;
    
    console.log(`Sending human input to /agents/crew/execution/${executionId}/input/`);
    
    fetch(`/agents/crew/execution/${executionId}/input/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            input: input
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("Successfully submitted human input:", data);
        // Clear and disable the input after successful submission
        textarea.value = '';
    })
    .catch(error => {
        console.error('Error submitting human input:', error);
        alert('Failed to submit input. Please try again.');
        // Re-enable the button and textarea on error
        button.disabled = false;
        textarea.disabled = false;
    });
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function updateAgentProgress(data) {
    console.log('Updating agent progress:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    const stageContainer = execution.querySelector('.card-body');
    const agentSection = stageContainer.querySelector('.agent-progress') || 
        stageContainer.insertAdjacentHTML('beforeend', '<div class="agent-progress mt-3"></div>');

    const progressHtml = `
        <div class="alert alert-info mb-2">
            <strong>${data.agent || 'Agent'}</strong>: ${data.content}
        </div>
    `;
    
    if (agentSection.children.length > 5) {
        agentSection.removeChild(agentSection.firstChild);
    }
    agentSection.insertAdjacentHTML('beforeend', progressHtml);
}

function handleTaskComplete(data) {
    console.log('Task completed:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    // Show completion message
    const stageContainer = execution.querySelector('.card-body');
    const completionHtml = `
        <div class="alert alert-success mb-0">
            <strong>Task Complete!</strong> ${data.message || ''}
        </div>
    `;
    stageContainer.insertAdjacentHTML('beforeend', completionHtml);
}

function handleWebSocketMessage(data) {
    console.log('Received WebSocket message:', data);
    
    try {
        if (data.type === 'execution_update') {
            // For all updates, use task_index if provided, otherwise keep current
            const taskIndex = data.task_index !== undefined ? data.task_index : lastUpdatedTaskIndex;
            if (data.task_index !== undefined) {
                lastUpdatedTaskIndex = data.task_index;
            }
            console.log('Using task index:', taskIndex, '(from data:', data.task_index, ', last:', lastUpdatedTaskIndex, ')');
            
            updateKanbanBoard({
                ...data,
                task_index: taskIndex
            });
        } else if (data.type === 'human_input_request') {
            console.log('Received human input request:', data);
            // Create a stage object for the human input request
            const stageData = {
                execution_id: data.execution_id,
                task_index: data.task_index,
                stage: {
                    stage_type: 'human_input_request',
                    title: 'Human Input Required',
                    content: data.prompt,
                    status: 'waiting_for_human_input',
                    agent: 'System'
                },
                status: 'WAITING_FOR_HUMAN_INPUT'
            };
            updateKanbanBoard(stageData);
        } else {
            console.warn('Unknown message type:', data.type);
        }
    } catch (error) {
        console.error('Error processing WebSocket message:', error);
    }
}

// Initial fetch of active executions and setup of cancel button
document.addEventListener('DOMContentLoaded', async function() {
    const data = await fetchActiveExecutions();
    const hasActiveExecution = data && data.executions && data.executions.length > 0;
    const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
    updateCancelButton(hasActiveExecution, activeExecutionId);
});







function getCurrentTime() {
    return new Date().toLocaleTimeString();
}

function getStatusBadgeClass(status) {
    switch (status?.toLowerCase()) {
        case 'running':
            return 'info';
        case 'completed':
            return 'success';
        case 'failed':
            return 'danger';
        case 'waiting_for_human_input':
            return 'warning';
        case 'pending':
        default:
            return 'secondary';
    }
}

// Function to show/hide cancel button based on execution status
function updateCancelButton(hasActiveExecution, executionId) {
    const cancelBtn = document.getElementById('cancelExecutionBtn');
    if (!cancelBtn) {
        console.error('Cancel button not found');  // Debug log
        return;
    }
    cancelBtn.style.display = hasActiveExecution ? 'block' : 'none';
    if (hasActiveExecution) {
        cancelBtn.setAttribute('data-execution-id', executionId);
    } else {
        cancelBtn.removeAttribute('data-execution-id');
    }
}

// Add cancel execution functionality
async function cancelExecution(executionId) {
    try {
        const result = await Swal.fire({
            title: 'Cancel Execution',
            html: `
                <div class="text-start">
                    <p>Are you sure you want to cancel this execution?</p>
                    <p class="text-warning">This action cannot be undone.</p>
                </div>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, Cancel Execution',
            cancelButtonText: 'No, Keep Running',
            customClass: {
                confirmButton: 'btn bg-gradient-danger me-3',
                cancelButton: 'btn bg-gradient-secondary ms-3',
                actions: 'my-3'
            },
            buttonsStyling: false
        });

        if (result.isConfirmed) {
            const response = await fetch(`/agents/execution/${executionId}/cancel/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error('Failed to cancel execution');
            }
            
            Swal.fire({
                title: 'Execution Cancelled',
                text: 'The execution has been cancelled successfully.',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
            
            updateCancelButton(false);
        }
    } catch (error) {
        console.error('Error cancelling execution:', error);
        Swal.fire({
            title: 'Error',
            text: 'Failed to cancel execution. Please try again.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    }
}

// Add click handler for cancel button
document.getElementById('cancelExecutionBtn').addEventListener('click', function() {
    const executionId = this.getAttribute('data-execution-id');
    if (executionId) {
        cancelExecution(executionId);
    }
});

function addUpdateToBoard(taskBoard, data) {
    
    const kanbanDrag = taskBoard.querySelector('.kanban-drag');
    if (!kanbanDrag) return;
    
    const stageId = `stage-${data.execution_id}-${Date.now()}`;
    const stage = data.stage || {};
    
    // Special handling for human input request - only when it's an actual input request, not just a status update
    if (stage.stage_type === 'human_input_request' && data.status === 'WAITING_FOR_HUMAN_INPUT') {
        const cardHtml = `
            <div class="card mb-2 border-0 shadow-none">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="badge bg-gradient-${getStatusBadgeClass(stage.status)} text-xs">${stage.status || 'unknown'}</span>
                        <button class="btn btn-link text-dark p-0 expand-content" data-stage-id="${stageId}">
                            <i class="fas fa-expand-alt"></i>
                        </button>
                    </div>
                    <h6 class="text-sm mb-2">${stage.title || 'Human Input Required'}</h6>
                    <div class="content-preview text-sm mb-3">
                        ${stage.content || ''}
                    </div>
                    <div class="human-input-container">
                        <div class="form-group">
                            <textarea class="form-control" rows="3" placeholder="Enter your response here..."></textarea>
                            <button class="btn btn-primary btn-sm mt-2" onclick="handleHumanInputSubmit(this)">Submit</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Create card element
        const card = document.createElement('div');
        card.id = stageId;
        card.className = 'kanban-item stage-item';
        card.setAttribute('data-execution-id', data.execution_id);
        card.setAttribute('data-stage-id', stageId);
        card.innerHTML = cardHtml;
        console.log('Adding click listener to expand button')
        // Add click handler for expand button
        card.querySelector('.expand-content').addEventListener('click', (e) => {
            console.log('Expand button clicked');
            e.stopPropagation();
            contentExpander.expandContent(
                card,
                stage.title || 'Human Input Required',
                stage.content || '',
                {
                    Status: stage.status || 'unknown',
                    Agent: stage.agent || 'System',
                    'Stage Type': stage.stage_type || 'unknown',
                    Timestamp: getCurrentTime()
                }
            );
        });
        
        kanbanDrag.appendChild(card);
        return;
    }
    const contentPreview = stage.content ? window.md.render(stage.content) : '';
    
    const cardHtml = `
        <div class="card mb-2 border-0 shadow-none">
            <div class="card-body p-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="badge bg-gradient-${getStatusBadgeClass(stage.status)} text-xs">${stage.status || 'unknown'}</span>
                    <button class="btn btn-link text-dark p-0 expand-content" data-stage-id="${stageId}">
                        <i class="fas fa-expand-alt"></i>
                    </button>
                </div>
                <h6 class="text-sm mb-2">${stage.title || 'Untitled'}</h6>
                <div class="content-preview text-sm" style="max-height: 4.5em; overflow: hidden; position: relative;">
                    <div class="content-text markdown-content">${contentPreview}</div>
                    <div class="content-fade" style="position: absolute; bottom: 0; left: 0; right: 0; height: 20px; background: linear-gradient(transparent, white);"></div>
                </div>
            </div>
        </div>
    `;

    // Create card element
    const card = document.createElement('div');
    card.id = stageId;
    card.className = 'kanban-item';
    card.innerHTML = cardHtml;
    
    // Add click handler for expand button
    card.querySelector('.expand-content').addEventListener('click', (e) => {
        e.stopPropagation();
        contentExpander.expandContent(
            card,
            stage.title || 'Untitled',
            stage.content || '',
            {
                Status: stage.status || 'unknown',
                Agent: stage.agent || 'System',
                'Stage Type': stage.stage_type || 'unknown',
                Timestamp: getCurrentTime()
            }
        );
    });
    
    kanbanDrag.appendChild(card);
}

function showStartExecutionModal() {
    Swal.fire({
        title: 'Start Crew Execution',
        html: `
            <div class="text-start">
                <p>You are about to start a new crew execution.</p>
                ${!clientId ? '<p class="text-danger">Warning: No client selected. Please select a client first.</p>' : ''}
                <p>The crew will begin processing tasks in sequence.</p>
            </div>
        `,
        icon: 'info',
        showCancelButton: true,
        confirmButtonText: 'Start Execution',
        cancelButtonText: 'Cancel',
        customClass: {
            confirmButton: 'btn bg-gradient-success',
            cancelButton: 'btn bg-gradient-danger'
        },
        buttonsStyling: false
    }).then((result) => {
        if (result.isConfirmed) {
            startExecution();
        }
    });
}

function startExecution() {
    const csrfToken = getCsrfToken();
    
    if (!csrfToken) {
        Swal.fire({
            title: 'Error',
            text: 'CSRF token not found. Please refresh the page.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    if (!clientId) {
        Swal.fire({
            title: 'Error',
            text: 'No client selected. Please select a client first.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    // Clear all kanban boards
    const kanbanBoards = document.querySelectorAll('.kanban-board');
    kanbanBoards.forEach(board => {
        const kanbanDrag = board.querySelector('.kanban-drag');
        if (kanbanDrag) {
            kanbanDrag.innerHTML = '';
        }
    });

    // Reset execution number
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = '';
    }

    fetch(`/agents/crew/${crewId}/start-execution/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            client_id: clientId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            Swal.fire({
                title: 'Success',
                text: 'Execution started successfully',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
        } else {
            throw new Error(data.message || 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        Swal.fire({
            title: 'Error',
            text: 'Error starting execution: ' + error.message,
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    });
}

// Export functions that need to be globally accessible
window.showStartExecutionModal = showStartExecutionModal;
window.handleHumanInputSubmit = handleHumanInputSubmit;

================
File: websockets/chat_consumer.py
================
from .base import BaseWebSocketConsumer
from .handlers.agent_handler import AgentHandler
from .services.crew_chat_service import CrewChatService
from ..tools.manager import AgentToolManager
from ..clients.manager import ClientDataManager
from ..chat.history import DjangoCacheMessageHistory
from ..models import Conversation, CrewExecution, ChatMessage
from django.core.cache import cache
import logging
import uuid
import json
from datetime import datetime
from urllib.parse import parse_qs
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import (
    BaseMessage, 
    HumanMessage, 
    AIMessage,
    messages_from_dict, 
    messages_to_dict
)
from channels.db import database_sync_to_async

logger = logging.getLogger(__name__)

class ChatConsumer(BaseWebSocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.tool_manager = AgentToolManager()
        self.client_manager = ClientDataManager()
        self.session_id = None
        self.group_name = None
        self.agent_handler = AgentHandler(self)
        self.is_connected = False
        self.message_history = None
        self.crew_chat_service = None  # Will be initialized if this is a crew chat

    @database_sync_to_async
    def get_crew_execution(self, conversation):
        """Safely get crew execution in async context"""
        try:
            return conversation.crew_execution
        except Exception as e:
            logger.error(f"Error getting crew execution: {str(e)}")
            return None

    @database_sync_to_async
    def get_crew(self, crew_execution):
        """Safely get crew in sync context"""
        try:
            return crew_execution.crew
        except Exception as e:
            logger.error(f"Error getting crew: {str(e)}")
            return None

    async def send_json(self, content):
        """Override to add logging"""
        #logger.debug(f"Sending message: {content}")
        await super().send_json(content)

    async def connect(self):
        if self.is_connected:
            return

        try:
            # Get session ID from query parameters
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if param)
            self.session_id = params.get('session')
            
            if not self.session_id:
                logger.error("No session ID provided")
                await self.close()
                return
                
            self.user = self.scope.get("user")
            if not self.user or not self.user.is_authenticated:
                logger.error("User not authenticated")
                await self.close()
                return
        
            logger.debug(f"Connecting websocket for user {self.user.id} with session {self.session_id}")
                
            # Get or create conversation first
            conversation = await self.get_or_create_conversation()
            if not conversation:
                logger.error("Failed to get/create conversation")
                await self.close()
                return
            
            logger.debug(f"Found conversation {conversation.id} with title: {conversation.title}")
            logger.debug(f"Conversation participant type: {conversation.participant_type}")
                
            self.group_name = f"chat_{self.session_id}"

            # Initialize appropriate service based on participant type
            if conversation.participant_type == 'crew':
                self.crew_chat_service = CrewChatService(self.user, conversation)
                self.crew_chat_service.websocket_handler = self
                crew_execution = await self.get_crew_execution(conversation)
                if crew_execution:
                    await self.crew_chat_service.initialize_chat(crew_execution)
            
            # Initialize message history (used by both agent and crew chats)
            self.message_history = DjangoCacheMessageHistory(
                session_id=self.session_id,
                agent_id=conversation.agent_id if conversation.participant_type == 'agent' else None,
                conversation_id=conversation.id
            )
            
            await self.channel_layer.group_add(self.group_name, self.channel_name)
            await self.accept()
            self.is_connected = True
            
            # Send historical messages
            messages = await self.message_history.aget_messages()
            logger.debug(f"Retrieved {len(messages)} historical messages")
            
            for msg in messages:
                message_type = 'agent_message' if isinstance(msg, AIMessage) else 'user_message'
                if conversation.participant_type == 'crew':
                    message_type = 'crew_message' if isinstance(msg, AIMessage) else 'user_message'
                
                await self.send_json({
                    'type': message_type,
                    'message': msg.content,
                    'timestamp': conversation.updated_at.isoformat(),
                    'id': msg.additional_kwargs.get('id')
                })
            
            await self.send_json({
                'type': 'system_message',
                'message': 'Connected to chat server',
                'connection_status': 'connected',
                'session_id': self.session_id,
                'participant_type': conversation.participant_type
            })
            
        except Exception as e:
            logger.error(f"Error in connect: {str(e)}", exc_info=True)
            await self.close()
            return

    async def get_or_create_conversation(self):
        try:
            # Get existing conversation
            conversation = await Conversation.objects.filter(
                session_id=self.session_id,
                user=self.user
            ).afirst()
            
            if not conversation:
                # Create new conversation with placeholder title
                conversation = await Conversation.objects.acreate(
                    session_id=self.session_id,
                    user=self.user,
                    title="...",  # Will be updated with first message
                    participant_type='agent'  # Default to agent chat
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error getting/creating conversation: {str(e)}")
            return None

    @database_sync_to_async
    def set_cache_value(self, key, value):
        """Safely set cache value in async context"""
        cache.set(key, value)

    @database_sync_to_async
    def get_conversation_details(self, conversation):
        """Get conversation details in sync context"""
        details = {
            'participant_type': conversation.participant_type,
            'has_crew_execution': hasattr(conversation, 'crew_execution'),
            'title': conversation.title
        }
        
        # Get crew name if this is a crew chat
        if conversation.participant_type == 'crew' and conversation.crew_execution:
            details['crew_name'] = conversation.crew_execution.crew.name
        
        return details

    async def update_conversation(self, message, agent_id=None, client_id=None):
        """Update conversation details"""
        try:
            conversation = await Conversation.objects.filter(
                session_id=self.session_id
            ).afirst()
            
            if conversation:
                # Get conversation details in sync context
                details = await self.get_conversation_details(conversation)
                
                # Update title if it's still the default and we have a message
                if details['title'] == "..." and message:
                    # Format the message part of the title
                    title_message = message.strip().replace('\n', ' ')[:50]
                    if len(message) > 50:
                        title_message += "..."
                    
                    # Set title to just the message - participant name is shown separately in UI
                    conversation.title = title_message
                
                # Update agent/crew info based on participant type
                if details['participant_type'] == 'agent' and agent_id:
                    conversation.agent_id = agent_id
                
                # Update client if provided
                if client_id:
                    conversation.client_id = client_id
                    
                await conversation.asave()
                
        except Exception as e:
            logger.error(f"Error updating conversation: {str(e)}")
            raise

    async def execution_update(self, event):
        """Handle execution status updates from crew tasks"""
        try:
            status = event.get('status')
            message = event.get('message')
            task_index = event.get('task_index')
            
            # Only send status update - no message content
            await self.send_json({
                'type': 'execution_update',
                'status': status,
                'task_index': task_index,
                'timestamp': datetime.now().isoformat()
            })

            # If there's a message, send it as a crew message
            if message and self.crew_chat_service:
                await self.crew_chat_service.send_crew_message(
                    content=message,
                    task_id=task_index
                )

        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")

    async def crew_message(self, event):
        """Handle crew messages from tasks"""
        try:
            if self.crew_chat_service:
                await self.crew_chat_service.send_crew_message(
                    content=event.get('message'),
                    task_id=event.get('task_id')
                )
        except Exception as e:
            logger.error(f"Error handling crew message: {str(e)}")

    async def receive(self, text_data=None, bytes_data=None):
        try:
            # Handle binary data if present
            if bytes_data:
                data = await self.handle_binary_message(bytes_data)
            else:
                # Handle text data
                if isinstance(text_data, dict):
                    # Already parsed JSON (from websocket_receive)
                    data = text_data
                else:
                    try:
                        data = json.loads(text_data)
                    except (json.JSONDecodeError, TypeError):
                        # If not JSON or None, treat as plain text message
                        data = {
                            'type': 'user_message',
                            'message': text_data or ''
                        }

            logger.debug(f"Received data: {data}")

            # Process keep-alive messages
            if data.get('type') == 'keep_alive':
                return

            # Process message
            await self.process_message(data)

        except Exception as e:
            logger.error(f" Error: {str(e)}", exc_info=True)
            await self.send_json({
                'type': 'error',
                'message': f'Error processing message: {str(e)}',
                'timestamp': datetime.now().isoformat()
            })

    async def process_message(self, data):
        """Primary entry point for all messages"""
        try:
            # Handle human input response
            if data.get('context', {}).get('is_human_input'):
                context = data.get('context', {})
                message = data.get('message')
                
                # Store response in cache
                input_key = f"execution_{context.get('execution_id')}_task_{context.get('task_index')}_input"
                logger.debug(f"Storing human input response in cache with key: {input_key}")
                await self.set_cache_value(input_key, message)
                
                # Send user message back to show in chat
                await self.send_json({
                    'type': 'user_message',
                    'message': message,
                    'timestamp': datetime.now().isoformat()
                })
                return

            # Handle crew start request
            if data.get('type') == 'start_crew':
                crew_id = data.get('crew_id')
                if not crew_id:
                    raise ValueError('Missing crew ID')

                # Get conversation
                conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
                if not conversation:
                    raise ValueError('No active conversation found')

                # Create crew execution
                execution = await CrewExecution.objects.acreate(
                    crew_id=crew_id,
                    status='PENDING',
                    user=self.scope['user'],
                    conversation=conversation
                )
                
                # Update conversation
                conversation.participant_type = 'crew'
                conversation.crew_execution = execution
                await conversation.asave()

                # Initialize crew chat service
                self.crew_chat_service = CrewChatService(self.scope['user'], conversation)
                self.crew_chat_service.websocket_handler = self
                await self.crew_chat_service.initialize_chat(execution)

                # Start the execution
                from ..tasks import execute_crew
                task = execute_crew.delay(execution.id)
                
                # Update execution with task ID
                execution.task_id = task.id
                await execution.asave()

                # Send confirmation
                await self.send_json({
                    'type': 'system_message',
                    'message': 'Starting crew execution...',
                    'timestamp': datetime.now().isoformat()
                })
                return

            # Extract message data
            message = data.get('message', '').strip()
            agent_id = data.get('agent_id')
            model_name = data.get('model')
            client_id = data.get('client_id')
            is_edit = data.get('type') == 'edit'  # Check for edit type
            message_id = data.get('message_id')  # Get message ID for edits

            #logger.debug(f"Processing message: type={data.get('type')}, message_id={message_id}, is_edit={is_edit}")

            if not message and not is_edit:  # Allow empty message for edit
                raise ValueError('Missing required fields')

            # Handle message editing if needed
            if is_edit:
                if not message_id:
                    raise ValueError('Missing message ID for edit')
                logger.debug(f"Handling edit for message {message_id}")
                await self.message_history.handle_edit(message_id)
                return  # Return early for edit messages

            # Get current conversation to check participant type
            conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
            if not conversation:
                raise ValueError('No active conversation found')

            # Get conversation details in sync context
            details = await self.get_conversation_details(conversation)

            # Initialize crew chat service if needed
            if details['participant_type'] == 'crew' and not self.crew_chat_service:
                self.crew_chat_service = CrewChatService(self.scope['user'], conversation)
                self.crew_chat_service.websocket_handler = self
                self.crew_chat_service.message_history = self.message_history  # Share the same message history

            # Update conversation with agent and client info
            await self.update_conversation(message, agent_id, client_id)

            # Store user message in history and database
            stored_message = await self.message_history.add_message(
                HumanMessage(content=message)
            )

            # Send user message with ID
            await self.send_json({
                'type': 'user_message',
                'message': message,
                'timestamp': datetime.now().isoformat(),
                'id': str(stored_message.id) if stored_message else None
            })
            
            # Handle crew chat messages if this is a crew chat
            if details['participant_type'] == 'crew':
                if not self.crew_chat_service:
                    raise ValueError('Crew chat service not initialized')
                await self.crew_chat_service.handle_message(message)
                return

            # Process with agent - responses come via callback_handler
            await self.agent_handler.process_response(
                message, agent_id, model_name, client_id
            )

        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            await self.send_json({
                'type': 'error',
                'message': f'Error processing message: {str(e)}',
                'timestamp': datetime.now().isoformat()
            })

    async def receive_json(self, content):
        """Disabled in favor of receive() to prevent duplicate message processing"""
        pass

    async def human_input_request(self, event):
        """Handle human input request from crew tasks"""
        try:
            # Extract prompt from event - it could be in different fields
            prompt = event.get('human_input_request') or event.get('prompt') or event.get('message', 'Input required')
            
            # Send as a crew message
            await self.send_json({
                'type': 'crew_message',
                'message': str(prompt),  # Ensure it's a string
                'context': {  # Include context for handling the response
                    'is_human_input': True,
                    'execution_id': event.get('context', {}).get('execution_id'),
                    'task_index': event.get('task_index')
                },
                'timestamp': datetime.now().isoformat()
            })
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")

================
File: kanban_consumers.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
import logging

logger = logging.getLogger(__name__)
User = get_user_model()

class CrewKanbanConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        """
        Handle WebSocket connection setup
        """
        self.crew_id = self.scope['url_route']['kwargs']['crew_id']
        self.room_group_name = f'crew_{self.crew_id}_kanban'
        self.is_connected = False
        
        try:
            # Add to crew group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            await self.accept()
            self.is_connected = True
            logger.info(f"WebSocket connection established for crew {self.crew_id}")
        except Exception as e:
            logger.error(f"Error establishing WebSocket connection: {str(e)}")
            if not self.is_connected:
                await self.close()
    
    async def disconnect(self, close_code):
        """
        Handle WebSocket disconnection cleanup
        """
        try:
            self.is_connected = False
            await self.channel_layer.group_discard(
                self.room_group_name,
                self.channel_name
            )
            logger.info(f"WebSocket connection closed for crew {self.crew_id} with code {close_code}")
        except Exception as e:
            logger.error(f"Error during WebSocket disconnect: {str(e)}")
    
    async def receive(self, text_data):
        """
        Handle incoming WebSocket messages
        """
        if not self.is_connected:
            logger.warning("Received message but WebSocket is not connected")
            return
            
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            logger.debug(f"Received WebSocket message: {message_type}")
            
            # Handle ping messages immediately
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong'
                }))
                return
            
            handlers = {
                'execution_update': self.handle_execution_update,
                'agent_step': self.handle_agent_step,
                'human_input_request': self.handle_human_input_request,
                'task_complete': self.handle_task_complete
            }
            
            handler = handlers.get(message_type)
            if handler:
                await handler(data)
            else:
                logger.warning(f"Unknown message type received: {message_type}")
        
        except json.JSONDecodeError:
            logger.error(f"Failed to decode WebSocket message: {text_data}")
        except Exception as e:
            logger.error(f"Error processing WebSocket message: {str(e)}")
            if self.is_connected:
                await self.send(text_data=json.dumps({
                    'type': 'error',
                    'message': 'Internal server error occurred'
                }))
    
    async def handle_execution_update(self, data):
        """Handle execution status updates"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id from execution
            execution_id = data.get('execution_id')
            if execution_id:
                crewai_task_id = await self.get_task_id_for_execution(execution_id)
                data['crewai_task_id'] = crewai_task_id
            
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'execution_update',
                    **data
                }
            )
            logger.debug(f"Sent execution update for execution {execution_id}")
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            # Don't try to send error message if we already know connection is broken
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def handle_agent_step(self, data):
        """Handle individual agent step updates"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'agent_step',
                    'execution_id': data.get('execution_id'),
                    'agent': data.get('agent', ''),
                    'content': data.get('content', ''),
                    'step_type': data.get('step_type', ''),
                    'is_final_step': data.get('is_final_step', False)
                }
            )
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def handle_human_input_request(self, data):
        """Handle requests for human input"""
        if not self.is_connected:
            logger.warning("Cannot send human input request - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'human_input_request',
                    'execution_id': data.get('execution_id'),
                    'prompt': data.get('prompt', ''),
                    'context': data.get('context', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send human input request'
                    }))
                except:
                    pass

    async def handle_task_complete(self, data):
        """Handle task completion notifications"""
        if not self.is_connected:
            logger.warning("Cannot send task complete - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'task_complete',
                    'execution_id': data.get('execution_id'),
                    'message': data.get('message', ''),
                    'results': data.get('results', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending task complete: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send task complete'
                    }))
                except:
                    pass
    
    # WebSocket send handlers
    async def execution_update(self, event):
        """Send execution updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Ensure stage data has all required fields
            stage = event.get('stage', {})
            if stage:
                stage.setdefault('stage_type', 'processing')
                stage.setdefault('title', 'Processing...')
                stage.setdefault('content', '')
                stage.setdefault('status', 'in_progress')
                stage.setdefault('agent', 'System')
                stage.setdefault('completed', False)
                
                if stage.get('status') == 'completed':
                    stage['completed'] = True
                
                if 'chat_message_prompts' not in stage:
                    stage['chat_message_prompts'] = [{
                        'role': 'system',
                        'content': stage.get('content', 'Processing task...')
                    }]
            
            message = {
                'type': 'execution_update',
                'execution_id': event['execution_id'],
                'status': event['status'],
                'crewai_task_id': event.get('crewai_task_id'),
                'task_index': event.get('task_index'),
                'message': event.get('message'),
                'stage': stage,
                'human_input_request': event.get('human_input_request')
            }
            #logger.debug(f"Consumer sending message: {message}")
            await self.send(text_data=json.dumps(message))
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def agent_step(self, event):
        """Send agent step updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id for this execution
            execution_id = event['execution_id']
            crewai_task_id = await self.get_task_id_for_execution(execution_id)
            
            # Format agent step as a stage update with chat_message_prompts
            stage_data = {
                'stage_type': event.get('step_type', 'agent_step'),
                'title': f"Agent: {event.get('agent', 'System')}",
                'content': event.get('content', ''),
                'status': 'in_progress',
                'agent': event.get('agent', 'System'),
                'completed': False,
                'chat_message_prompts': [{
                    'role': 'assistant',
                    'content': event.get('content', '')
                }]
            }
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': execution_id,
                'crewai_task_id': crewai_task_id,
                'stage': stage_data
            }))
            
            # Send a completion update for this stage if it's the final step
            if event.get('is_final_step', False):
                stage_data.update({
                    'status': 'completed',
                    'completed': True
                })
                await self.send(text_data=json.dumps({
                    'type': 'execution_update',
                    'execution_id': execution_id,
                    'crewai_task_id': crewai_task_id,
                    'stage': stage_data
                }))
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def human_input_request(self, event):
        """Send human input requests to WebSocket"""
        logger.debug(f"Consumer received human_input_request event: {event}")
        try:
            message = {
                'type': 'human_input_request',
                'execution_id': event['execution_id'],
                'prompt': event['prompt'],
                'context': event.get('context', {})
            }
            #logger.debug(f"Consumer attempting to send message: {message}")
            await self.send(text_data=json.dumps(message))
            logger.debug("Consumer successfully sent message")
        except Exception as e:
            logger.error(f"Consumer failed to send message: {e}")

    async def task_complete(self, event):
        """Send task completion notifications to WebSocket"""
        execution_id = event['execution_id']
        crewai_task_id = await self.get_task_id_for_execution(execution_id)
        
        await self.send(text_data=json.dumps({
            'type': 'task_complete',
            'execution_id': execution_id,
            'crewai_task_id': crewai_task_id,
            'message': event['message'],
            'results': event['results']
        }))

    @database_sync_to_async
    def get_task_id_for_execution(self, execution_id):
        """Get CrewAI task ID for a given execution"""
        from .models import CrewExecution
        try:
            execution = CrewExecution.objects.get(id=execution_id)
            # Get the latest execution stage for this execution
            latest_stage = execution.executionstage_set.order_by('-created_at').first()
            return latest_stage.crewai_task_id if latest_stage else None
        except CrewExecution.DoesNotExist:
            return None

================
File: models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from apps.common.utils import get_models
from pydantic import BaseModel
import os
import importlib
import logging
import uuid
import random
import json
from django.contrib.postgres.fields import ArrayField
from django.conf import settings
from apps.agents.utils import load_tool, get_tool_description

logger = logging.getLogger(__name__)

User = get_user_model()

import glob

def get_agent_avatars():
    # Get the default avatar list
    default_avatars = [
        'team-5.jpg', 'team-4.jpg', 'team-3.jpg', 'team-2.jpg', 'kal-visuals-square.jpg',
        'team-1.jpg', 'marie.jpg', 'ivana-squares.jpg', 'ivana-square.jpg'
    ]
    
    # Get additional avatars from static directory
    static_path = os.path.join('static', 'assets', 'img', 'agent-avatar*')
    additional_avatars = [os.path.basename(f) for f in glob.glob(static_path)]
    
    return default_avatars + additional_avatars

AVATAR_CHOICES = get_agent_avatars()

def random_avatar():
    return random.choice(AVATAR_CHOICES)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for dir_name in dirs:
            if not dir_name.startswith('__'):  # Exclude directories like __pycache__
                tool_path = os.path.relpath(os.path.join(root, dir_name), tools_dir)
                available_tools.append(tool_path.replace(os.path.sep, '.'))

    return available_tools

def default_embedder():
    return {'provider': 'openai'}

def user_directory_path(instance, filename):
    # File will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    return f'user_{instance.crew_execution.user.id}/{filename}'

class Tool(models.Model):
    tool_class = models.CharField(max_length=255)
    tool_subclass = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    module_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.module_path:
            self.module_path = f"apps.agents.tools.{self.tool_class}"
        
        try:
            tool = load_tool(self)
            if tool:
                self.name = getattr(tool, 'name', self.tool_subclass)
                self.description = get_tool_description(tool.__class__)
            else:
                raise ValueError(f"Failed to load tool: {self.module_path}.{self.tool_subclass}. Check the logs for more details.")
        except Exception as e:
            logger.error(f"Error in Tool.save: {str(e)}")
            raise ValidationError(f"Error loading tool: {str(e)}")

        super().save(*args, **kwargs)

class ToolRun(models.Model):
    """Model to track tool executions"""
    TOOL_RUN_STATUS = (
        ('pending', 'Pending'),
        ('running', 'Running'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )
    
    tool = models.ForeignKey(Tool, on_delete=models.CASCADE)
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    message = models.ForeignKey('ChatMessage', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    status = models.CharField(max_length=20, choices=TOOL_RUN_STATUS, default='pending')
    inputs = models.JSONField()
    result = models.JSONField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.tool.name} - {self.status} ({self.created_at})"

class Agent(models.Model):
    name = models.CharField(max_length=255)
    role = models.CharField(max_length=100)
    goal = models.TextField()
    backstory = models.TextField()
    llm = models.CharField(max_length=100, default=settings.GENERAL_MODEL)
    tools = models.ManyToManyField(Tool, blank=True)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    max_iter = models.IntegerField(default=25)
    max_rpm = models.IntegerField(null=True, blank=True)
    max_execution_time = models.IntegerField(null=True, blank=True)
    verbose = models.BooleanField(default=False)
    allow_delegation = models.BooleanField(default=False)
    step_callback = models.CharField(max_length=255, null=True, blank=True)
    cache = models.BooleanField(default=True)
    system_template = models.TextField(null=True, blank=True)
    prompt_template = models.TextField(null=True, blank=True)
    response_template = models.TextField(null=True, blank=True)
    allow_code_execution = models.BooleanField(default=False)
    max_retry_limit = models.IntegerField(default=2)
    use_system_prompt = models.BooleanField(default=True)
    respect_context_window = models.BooleanField(default=True)
    avatar = models.CharField(max_length=100, default=random_avatar)

    def __str__(self):
        return self.name

    def clean(self):
        super().clean()
        available_models = get_models()
        if self.llm not in available_models:
            raise ValidationError({'llm': f"Selected LLM '{self.llm}' is not available. Please choose from: {', '.join(available_models)}"})

    def get_tool_settings(self, tool):
        """Get settings for a specific tool."""
        return self.tool_settings.filter(tool=tool).first()

    def get_forced_output_tools(self):
        """Get all tools that have force_output_as_result=True."""
        return self.tools.filter(
            id__in=self.tool_settings.filter(
                force_output_as_result=True
            ).values_list('tool_id', flat=True)
        )

    def has_force_output_enabled(self, tool):
        """Check if force output is enabled for a specific tool."""
        tool_setting = self.tool_settings.filter(tool=tool).first()
        return tool_setting.force_output_as_result if tool_setting else False

class Task(models.Model):
    description = models.TextField()
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    expected_output = models.TextField()
    tools = models.ManyToManyField(Tool, blank=True)
    async_execution = models.BooleanField(default=False)
    context = models.ManyToManyField('self', symmetrical=False, blank=True)
    config = models.JSONField(null=True, blank=True)
    output_json = models.CharField(max_length=255, null=True, blank=True)
    output_pydantic = models.CharField(max_length=255, null=True, blank=True)
    output_file = models.CharField(max_length=255, null=True, blank=True)
    output = models.TextField(null=True, blank=True)
    callback = models.CharField(max_length=255, null=True, blank=True)
    human_input = models.BooleanField(default=False)
    converter_cls = models.CharField(max_length=255, null=True, blank=True)

    def __str__(self):
        return self.description[:50]

    def save_output_file(self, content):
        if self.output_file:
            file_name = os.path.basename(self.output_file)
        else:
            file_name = f"task_{self.id}_output.txt"
        
        file_path = user_directory_path(self, file_name)
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        with open(full_path, 'w') as f:
            f.write(content)
        
        self.output_file = file_path
        self.save()

class Crew(models.Model):
    name = models.CharField(max_length=100)
    agents = models.ManyToManyField(Agent)
    tasks = models.ManyToManyField(Task, through='CrewTask')
    process = models.CharField(max_length=20, choices=[('sequential', 'Sequential'), ('hierarchical', 'Hierarchical')], default='sequential')
    verbose = models.BooleanField(default=False)
    manager_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    config = models.JSONField(null=True, blank=True)
    max_rpm = models.IntegerField(null=True, blank=True)
    language = models.CharField(max_length=50, default='English')
    language_file = models.CharField(max_length=255, null=True, blank=True)
    memory = models.BooleanField(default=False)
    cache = models.BooleanField(default=True)
    embedder = models.JSONField(default=default_embedder)
    full_output = models.BooleanField(default=False)
    share_crew = models.BooleanField(default=False)
    output_log_file = models.CharField(max_length=255, null=True, blank=True)
    manager_agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True, related_name='managed_crews')
    manager_callbacks = models.JSONField(null=True, blank=True)
    prompt_file = models.CharField(max_length=255, null=True, blank=True)
    planning = models.BooleanField(default=False)
    planning_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    input_variables = ArrayField(
        models.CharField(max_length=100),
        blank=True,
        null=True,
        default=list
    )

    def __str__(self):
        return self.name

class CrewExecution(models.Model):
    """Represents a single execution of a crew"""
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE, null=True)
    status = models.CharField(max_length=50, default='PENDING')
    task_id = models.CharField(max_length=50, null=True)
    inputs = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    conversation = models.ForeignKey('Conversation', on_delete=models.SET_NULL, null=True, related_name='crew_executions')
    crew_output = models.OneToOneField('CrewOutput', on_delete=models.SET_NULL, null=True, blank=True, related_name='crew_execution')
    human_input_request = models.JSONField(null=True, blank=True)
    human_input_response = models.JSONField(null=True, blank=True)
    error_message = models.TextField(blank=True, null=True)
    chat_enabled = models.BooleanField(default=False)

    def get_conversation_history(self):
        """Get formatted conversation history including messages and tool results"""
        if not self.conversation:
            return []
            
        messages = ChatMessage.objects.filter(
            conversation=self.conversation,
            is_deleted=False
        ).order_by('timestamp')
        
        # Use the formatted_message property for each message
        return [msg.formatted_message for msg in messages]

    def __str__(self):
        return f"{self.crew.name} - {self.status} ({self.created_at})"

    def save_task_output_file(self, task, content):
        task.save_output_file(content)

class CrewMessage(models.Model):
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='messages')
    content = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    agent = models.CharField(max_length=255, null=True, blank=True)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement

    def __str__(self):
        return f"{self.timestamp}: {self.content[:50]}"

class Pipeline(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    status = models.CharField(max_length=20, default='Idle')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

    def clean(self):
        # Validate that stages are properly structured
        stages = self.stages.all().order_by('order')
        for stage in stages:
            if stage.is_parallel:
                if stage.crew is not None:
                    raise ValidationError("Parallel stages should not have a single crew assigned.")
            else:
                if stage.crew is None:
                    raise ValidationError("Sequential stages must have a crew assigned.")

class PipelineStage(models.Model):
    pipeline = models.ForeignKey(Pipeline, related_name='stages', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    crew = models.ForeignKey('Crew', on_delete=models.SET_NULL, null=True, blank=True)
    order = models.PositiveIntegerField()
    is_parallel = models.BooleanField(default=False)
    is_router = models.BooleanField(default=False)

    class Meta:
        ordering = ['order']

    def __str__(self):
        return f"{self.pipeline.name} - {self.name}"

    def clean(self):
        if self.is_router and self.crew is not None:
            raise ValidationError("Router stages should not have a crew assigned.")

class PipelineRoute(models.Model):
    stage = models.ForeignKey(PipelineStage, related_name='routes', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    condition = models.TextField()  # This would store a serialized form of the condition
    target_pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.stage.name} - {self.name}"

class PipelineExecution(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, default='Pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.pipeline.name} Execution - {self.created_at}"

class PipelineRunResult(models.Model):
    execution = models.ForeignKey(PipelineExecution, related_name='run_results', on_delete=models.CASCADE)
    raw_output = models.TextField(blank=True)
    json_output = models.JSONField(null=True, blank=True)
    pydantic_output = models.TextField(null=True, blank=True)  # This would store a serialized form of the Pydantic model
    token_usage = models.JSONField(null=True, blank=True)
    trace = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"Run Result for {self.execution.pipeline.name}"

class CrewOutput(models.Model):
    raw = models.TextField()
    pydantic = models.JSONField(null=True, blank=True)
    json_dict = models.JSONField(null=True, blank=True)
    token_usage = models.JSONField(null=True, blank=True)

    @property
    def json(self):
        return json.dumps(self.json_dict) if self.json_dict else None

    def to_dict(self):
        return self.json_dict or (self.pydantic.dict() if self.pydantic else None) or {}

    def __str__(self):
        if self.pydantic:
            return str(self.pydantic)
        elif self.json_dict:
            return json.dumps(self.json_dict)
        else:
            return self.raw

    def save(self, *args, **kwargs):
        # Convert UsageMetrics to a dictionary if it's not already
        if self.token_usage and hasattr(self.token_usage, 'dict'):
            self.token_usage = self.token_usage.dict()
        super().save(*args, **kwargs)

class CrewTask(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE, related_name='crew_tasks')
    task = models.ForeignKey(Task, on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['order']
        unique_together = ('crew', 'task')

    def __str__(self):
        return f"{self.crew.name} - {self.task.description} (Order: {self.order})"

class AgentToolSettings(models.Model):
    agent = models.ForeignKey('Agent', on_delete=models.CASCADE, related_name='tool_settings')
    tool = models.ForeignKey('Tool', on_delete=models.CASCADE)
    force_output_as_result = models.BooleanField(default=False)

    class Meta:
        unique_together = ('agent', 'tool')

class SlackChannelClientMapping(models.Model):
    """Map Slack channels to clients for automatic client identification"""
    channel_id = models.CharField(max_length=32)
    team_id = models.CharField(max_length=32)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('channel_id', 'team_id')
        db_table = 'slack_channel_client_mappings'

    def __str__(self):
        return f"Slack Channel {self.channel_id} -> Client {self.client_id}"

class ExecutionStage(models.Model):
    STAGE_TYPES = [
        ('task_start', 'Task Start'),
        ('thinking', 'Thinking'),
        ('tool_usage', 'Tool Usage'),
        ('tool_results', 'Tool Results'),
        ('human_input', 'Human Input'),
        ('completion', 'Completion')
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ]
    
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='stages')
    stage_type = models.CharField(max_length=20, choices=STAGE_TYPES)
    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    metadata = models.JSONField(default=dict)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'Execution Stage'
        verbose_name_plural = 'Execution Stages'
    
    def __str__(self):
        return f"{self.get_stage_type_display()} - {self.title}"

class Conversation(models.Model):
    session_id = models.UUIDField(unique=True)
    user = models.ForeignKey(get_user_model(), on_delete=models.CASCADE)
    agent = models.ForeignKey('Agent', on_delete=models.SET_NULL, null=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.SET_NULL, null=True)
    participant_type = models.CharField(
        max_length=50, 
        choices=[
            ('agent', 'Agent Chat'),
            ('crew', 'Crew Chat')
        ],
        default='agent'
    )
    crew_execution = models.OneToOneField(
        'CrewExecution',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='chat_conversation'
    )
    title = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ['-updated_at']

    def __str__(self):
        return f"{self.title} ({self.session_id})"

    async def get_recent_messages(self, limit=10):
        """Get recent messages for this conversation"""
        return await self.chatmessage_set.filter(
            is_deleted=False
        ).order_by('-timestamp')[:limit]

    async def get_task_outputs(self, limit=5):
        """Get recent task outputs from crew execution"""
        if self.crew_execution and self.crew_execution.crew_output:
            return self.crew_execution.crew_output.to_dict()
        return None

class CrewChatSession(models.Model):
    conversation = models.OneToOneField(
        'Conversation',
        on_delete=models.CASCADE,
        related_name='crew_chat_session'
    )
    crew_execution = models.OneToOneField(
        'CrewExecution',
        on_delete=models.CASCADE,
        related_name='chat_session'
    )
    last_activity = models.DateTimeField(auto_now=True)
    status = models.CharField(
        max_length=50,
        choices=[
            ('active', 'Active'),
            ('paused', 'Paused'),
            ('completed', 'Completed'),
            ('cleaned', 'Cleaned')
        ],
        default='active'
    )
    context_data = models.JSONField(default=dict)

    class Meta:
        indexes = [
            models.Index(fields=['last_activity', 'status'])
        ]

    def __str__(self):
        return f"Crew Chat Session - {self.conversation.title}"

    async def get_full_context(self):
        """Get full context including messages, task outputs, and context data"""
        messages = await self.conversation.get_recent_messages()
        task_outputs = await self.conversation.get_task_outputs()
        
        return {
            'messages': messages,
            'task_outputs': task_outputs,
            'context_data': self.context_data
        }

    def update_context(self, key, value):
        """Update a specific context value"""
        if self.context_data is None:
            self.context_data = {}
        self.context_data[key] = value
        self.save(update_fields=['context_data', 'last_activity'])

class ChatMessage(models.Model):
    """Model for storing chat messages."""
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE)
    session_id = models.CharField(max_length=255)
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    is_agent = models.BooleanField(default=False)
    is_deleted = models.BooleanField(default=False)
    timestamp = models.DateTimeField(auto_now_add=True)
    model = models.CharField(max_length=255, default='unknown')
    task_id = models.IntegerField(null=True, blank=True)
    
    @property
    def formatted_message(self):
        """Get message with associated tool results"""
        base = {
            'type': 'agent_message' if self.is_agent else 'user_message',
            'content': self.content,
            'timestamp': self.timestamp.isoformat(),
            'model': self.model,
            'task_id': self.task_id
        }
        
        # Add tool results if any exist
        tool_runs = self.tool_runs.all()
        if tool_runs:
            base['tool_results'] = [
                {
                    'tool': run.tool.name,
                    'inputs': run.inputs,
                    'result': run.result,
                    'status': run.status
                }
                for run in tool_runs
            ]
            
        return base

    class Meta:
        ordering = ['timestamp']
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
            models.Index(fields=['session_id']),
            models.Index(fields=['is_deleted']),  # Add index for is_deleted field
        ]

    def __str__(self):
        return f"{self.timestamp}: {'Agent' if self.is_agent else 'User'} - {self.content[:50]}..."

class TokenUsage(models.Model):
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='token_usage')
    message = models.ForeignKey('ChatMessage', on_delete=models.SET_NULL, null=True, blank=True)
    tool_run = models.ForeignKey('ToolRun', on_delete=models.SET_NULL, null=True, blank=True)
    prompt_tokens = models.IntegerField(default=0)
    completion_tokens = models.IntegerField(default=0)
    total_tokens = models.IntegerField(default=0)
    model = models.CharField(max_length=100)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)  # Changed from JSONField to models.JSONField

    class Meta:
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
        ]

    def __str__(self):
        return f"{self.conversation_id} - {self.total_tokens} tokens"

class UserSlackIntegration(models.Model):
    """Store Slack integration details for users"""
    user = models.OneToOneField(get_user_model(), on_delete=models.CASCADE)
    access_token = models.CharField(max_length=255)
    team_id = models.CharField(max_length=32)
    team_name = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'user_slack_integrations'

    def __str__(self):
        return f"{self.user.username} - {self.team_name}"
