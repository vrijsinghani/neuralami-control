This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-03-01T05:21:00.994Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
migrations/
  0001_initial.py
  0002_research_guidance.py
  0003_research_reasoning_steps_alter_research_created_at_and_more.py
  0004_alter_research_learnings_and_more.py
static/
  research/
    js/
      research-websocket-init.js
      research-websocket.js
templates/
  research/
    partials/
      _report.html
      _step.html
      progress.html
      reasoning.html
      sources.html
      steps.html
    create.html
    detail.html
    list.html
templatetags/
  __init__.py
  research_tags.py
websockets/
  research_consumer.py
admin.py
apps.py
forms.py
models.py
services.py
tasks.py
template_app.md
urls.py
views.py

================================================================
Repository Files
================================================================

================
File: migrations/0001_initial.py
================
# Generated by Django 5.1.5 on 2025-02-10 01:31

import django.db.models.deletion
import django.utils.timezone
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Research',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('query', models.TextField()),
                ('breadth', models.IntegerField(default=4)),
                ('depth', models.IntegerField(default=2)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('in_progress', 'In Progress'), ('completed', 'Completed'), ('failed', 'Failed')], default='pending', max_length=20)),
                ('created_at', models.DateTimeField(default=django.utils.timezone.now)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('report', models.TextField(blank=True, null=True)),
                ('error', models.TextField(blank=True, null=True)),
                ('visited_urls', models.JSONField(default=list)),
                ('learnings', models.JSONField(default=list)),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name_plural': 'Research',
                'ordering': ['-created_at'],
            },
        ),
    ]

================
File: migrations/0002_research_guidance.py
================
# Generated by Django 5.1.5 on 2025-02-14 15:19

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('research', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='research',
            name='guidance',
            field=models.TextField(blank=True, help_text='Optional guidance for content processing', null=True),
        ),
    ]

================
File: migrations/0003_research_reasoning_steps_alter_research_created_at_and_more.py
================
# Generated by Django 5.1.5 on 2025-02-17 16:07

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('research', '0002_research_guidance'),
    ]

    operations = [
        migrations.AddField(
            model_name='research',
            name='reasoning_steps',
            field=models.JSONField(default=list),
        ),
        migrations.AlterField(
            model_name='research',
            name='created_at',
            field=models.DateTimeField(auto_now_add=True),
        ),
        migrations.AlterField(
            model_name='research',
            name='status',
            field=models.CharField(choices=[('pending', 'Pending'), ('in_progress', 'In Progress'), ('completed', 'Completed'), ('failed', 'Failed'), ('cancelled', 'Cancelled')], default='pending', max_length=20),
        ),
    ]

================
File: migrations/0004_alter_research_learnings_and_more.py
================
# Generated by Django 5.1.5 on 2025-02-17 21:49

import apps.research.models
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('research', '0003_research_reasoning_steps_alter_research_created_at_and_more'),
    ]

    operations = [
        migrations.AlterField(
            model_name='research',
            name='learnings',
            field=models.JSONField(default=apps.research.models.default_list),
        ),
        migrations.AlterField(
            model_name='research',
            name='reasoning_steps',
            field=models.JSONField(default=apps.research.models.default_list),
        ),
        migrations.AlterField(
            model_name='research',
            name='visited_urls',
            field=models.JSONField(default=apps.research.models.default_list),
        ),
    ]

================
File: static/research/js/research-websocket-init.js
================
import { ResearchWebSocketService } from './research-websocket.js';

console.log('Initializing research WebSocket...');
const researchId = window.RESEARCH_ID;

if (researchId) {
    const wsService = new ResearchWebSocketService(researchId);
    window.researchWsService = wsService;
    console.log('WebSocket service initialized');
} else {
    console.error('Error: RESEARCH_ID is not defined.');
}

================
File: static/research/js/research-websocket.js
================
// Research-specific WebSocket service
export class ResearchWebSocketService {
    constructor(researchId) {
        this.researchId = researchId;
        this.socket = null;
        this.isConnected = false;
        
        // Get DOM elements
        this.progressContainer = document.getElementById('progress-container');
        this.urlsList = document.querySelector('#sourcesList .sources-list');
        this.learningsList = document.querySelector('.learnings-list');
        this.reportContainer = document.querySelector('.card.d-none');  // Select the hidden report card
        this.statusBadge = document.getElementById('status-badge');
        this.cancelButton = document.getElementById('cancel-research');
        
        // Initialize markdown-it
        this.md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            highlight: function (str, lang) {
                if (lang && window.hljs && window.hljs.getLanguage(lang)) {
                    try {
                        return window.hljs.highlight(str, { language: lang }).value;
                    } catch (__) {}
                }
                return '';
            }
        });
        
        // Initialize badge animation if research is pending or in progress
        if (this.statusBadge) {
            const status = this.statusBadge.textContent.trim();
            if (status === 'In Progress' || status === 'Pending') {
                this.statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-warning');
                this.statusBadge.classList.add('bg-info', 'badge-animated');
                this.statusBadge.textContent = 'In Progress';
            }
        }
        
        this.connect();
    }

    connect() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}/ws/research/${this.researchId}/`;
        
        this.socket = new WebSocket(wsUrl);
        
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.setupCancelButton();
        };
        
        this.socket.onclose = () => {
            console.log('WebSocket disconnected');
            this.isConnected = false;
            // Try to reconnect after 5 seconds
            setTimeout(() => this.connect(), 5000);
        };
        
        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'research_update') {
                    this.handleResearchUpdate(data.data);
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };
    }

    setupCancelButton() {
        if (this.cancelButton) {
            this.cancelButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to cancel this research task?')) {
                    fetch(`/research/${this.researchId}/cancel/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': this.getCsrfToken(),
                        },
                    })
                    .then(response => {
                        if (response.ok) {
                            this.updateProgress('Research task cancelled by user.');
                            this.cancelButton.remove();
                            if (this.statusBadge) {
                                this.statusBadge.textContent = 'Cancelled';
                                this.statusBadge.className = 'badge bg-warning';
                            }
                        } else {
                            console.error('Failed to cancel research task');
                        }
                    })
                    .catch(error => {
                        console.error('Error cancelling research task:', error);
                    });
                }
            });
        }
    }

    getCsrfToken() {
        const name = 'csrftoken';
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    handleResearchUpdate(data) {
        switch (data.update_type) {
            case 'timing_update':
                this.updateProgress(`[${data.current_time}] ${data.message}`);
                break;
                
            case 'timing_info':
                const timingMessage = `Research completed in ${data.duration_minutes} minutes
                    (Started: ${data.start_time}, 
                    Ended: ${data.end_time})
                    Query: "${data.query}"
                    Breadth: ${data.breadth}, Depth: ${data.depth}`;
                this.updateProgress(timingMessage);
                break;
                
            case 'generating_queries':
                this.updateProgress(data.message);
                if (this.statusBadge) {
                    this.statusBadge.textContent = 'In Progress';
                    this.statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-warning');
                    this.statusBadge.classList.add('bg-info', 'badge-animated');
                }
                break;
                
            case 'queries_generated':
                this.updateProgress('Search queries generated: ' + data.queries.join(', '));
                break;
                
            case 'urls_found':
                this.updateUrls(data.urls);
                break;
                
            case 'processing_content':
                this.updateProgress(data.message);
                break;
                
            case 'learnings_extracted':
                this.updateLearnings(data.learnings);
                break;
                
            case 'completed':
                this.handleCompletion(data);
                break;
                
            case 'error':
                this.handleError(data.error);
                break;
                
            case 'cancelled':
                this.handleCancellation();
                break;
        }
    }

    updateProgress(message) {
        if (this.progressContainer) {
            const div = document.createElement('div');
            div.className = 'progress-update text-xs';
            
            // Handle long messages by adding word-wrap style
            div.style.whiteSpace = 'pre-wrap';
            div.style.wordBreak = 'break-word';
            
            // If message is a search query, format it nicely
            if (message.startsWith('Search queries generated:')) {
                const queries = message.replace('Search queries generated:', '').split(',');
                div.innerHTML = `<strong>Search queries generated:</strong><br>${queries.map(q => `• ${q.trim()}`).join('<br>')}`;
            } else {
                div.textContent = message;
            }
            
            this.progressContainer.appendChild(div);
            
            // Scroll to bottom of container
            this.progressContainer.scrollTop = this.progressContainer.scrollHeight;
        } else {
            console.error('Progress container not found for message:', message);
        }
    }

    updateUrls(urls) {
        if (this.urlsList && Array.isArray(urls)) {
            urls.forEach(url => {
                const sourceItem = document.createElement('div');
                sourceItem.className = 'source-item';
                sourceItem.innerHTML = `
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="text-xxs">
                        <i class="fas fa-link me-1"></i>
                        ${url.length > 50 ? url.substring(0, 47) + '...' : url}
                    </a>
                `;
                this.urlsList.appendChild(sourceItem);
            });
            
            // Scroll parent container to bottom when new URLs are added
            const sourcesContainer = this.urlsList.closest('.overflow-auto');
            if (sourcesContainer) {
                sourcesContainer.scrollTop = sourcesContainer.scrollHeight;
            }
        } else {
            console.error('URLs list container not found or invalid URLs:', urls);
        }
    }

    updateLearnings(learnings) {
        if (this.learningsList && Array.isArray(learnings)) {
            learnings.forEach((learning, index) => {
                // Skip if learning is null or undefined
                if (!learning) return;
                
                // Extract text based on learning type
                let learningText;
                let categoryText = '';
                
                if (typeof learning === 'object') {
                    if (learning.detail) {
                        learningText = learning.detail;
                        if (learning.category) {
                            categoryText = `<strong>${learning.category}</strong>`;
                        }
                    } else if (learning.fact) {
                        learningText = learning.fact;
                    } else {
                        learningText = JSON.stringify(learning);
                    }
                } else {
                    learningText = learning;
                }
                
                const learningBlock = document.createElement('div');
                learningBlock.className = 'learning-block';
                const uniqueId = `learning-${Date.now()}-${index}`;
                
                // Create a clean preview of the text (first sentence or truncated)
                const previewText = learningText.split('.')[0] + '.';
                const displayPreview = previewText.length > 50 ? previewText.substring(0, 50) + '...' : previewText;
                
                learningBlock.innerHTML = `
                    <div class="learning-header d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center cursor-pointer" data-bs-toggle="collapse" data-bs-target="#${uniqueId}">
                            <i class="fas fa-chevron-down me-2 toggle-icon"></i>
                            <h6 class="text-xs mb-0">${displayPreview}</h6>
                        </div>
                    </div>
                    <div class="learning-content mt-2 collapse" id="${uniqueId}">
                        <div class="learning-body">
                            ${categoryText}
                            ${learningText}
                        </div>
                    </div>
                `;
                
                // Add to the learnings list
                this.learningsList.appendChild(learningBlock);
                
                // Scroll parent container to bottom when new learnings are added
                const learningsContainer = this.learningsList.closest('.card-body');
                if (learningsContainer) {
                    learningsContainer.scrollTop = learningsContainer.scrollHeight;
                }
            });
        } else {
            console.error('Learnings list container not found or invalid learnings:', learnings);
        }
    }

    handleCompletion(data) {
        if (data.status === 'completed') {
            if (this.reportContainer) {
                // Get the markdown content div
                let markdownContent = this.reportContainer.querySelector('.markdown-content');
                if (!markdownContent) {
                    markdownContent = document.createElement('div');
                    markdownContent.className = 'markdown-content';
                    this.reportContainer.querySelector('.card-body').appendChild(markdownContent);
                }

                // Render and set the report content
                const htmlContent = this.md.render(data.report || '');
                markdownContent.innerHTML = htmlContent;
                
                // Show the report container
                this.reportContainer.classList.remove('d-none');
                
                // Apply syntax highlighting if available
                if (window.hljs) {
                    this.reportContainer.querySelectorAll('pre code').forEach((block) => {
                        window.hljs.highlightBlock(block);
                    });
                }
            }

            if (this.statusBadge) {
                this.statusBadge.textContent = 'Completed';
                this.statusBadge.classList.remove('bg-info', 'bg-danger', 'bg-warning', 'badge-animated');
                this.statusBadge.classList.add('bg-success');
            }
        } else if (data.status === 'failed') {
            this.handleError(data.error);
        }
    }

    handleError(error) {
        if (this.progressContainer) {
            const div = document.createElement('div');
            div.className = 'progress-update';
            div.style.borderLeft = '3px solid #dc3545';  // Red border for errors
            div.textContent = `Error: ${error}`;
            this.progressContainer.appendChild(div);
            div.scrollIntoView({ behavior: 'smooth' });
        }
        
        if (this.statusBadge) {
            this.statusBadge.textContent = 'Failed';
            this.statusBadge.classList.remove('bg-info', 'bg-success', 'bg-warning', 'badge-animated');
            this.statusBadge.classList.add('bg-danger');
        }
    }

    handleCancellation() {
        this.updateProgress('Research task has been cancelled.');
        if (this.cancelButton) {
            this.cancelButton.remove();
        }
        if (this.statusBadge) {
            this.statusBadge.textContent = 'Cancelled';
            this.statusBadge.classList.remove('bg-info', 'bg-success', 'bg-danger', 'badge-animated');
            this.statusBadge.classList.add('bg-warning');
        }
    }
}

================
File: templates/research/partials/_report.html
================
{% load markdown_filters %}
<div class="report-container">
    <div class="card">
        <div class="card-header pb-0">
            <h5 class="mb-0">Research Report</h5>
        </div>
        <div class="card-body">
            <div class="markdown-content">
                {{ research.report|markdown }}
            </div>
        </div>
    </div>
</div>

================
File: templates/research/partials/_step.html
================
{% load research_tags %}
<div class="step-item {% if is_last and step.step_type != 'complete' %}active{% endif %}" 
     id="step-{{ step.step_type }}-{{ step_number }}" 
     data-step-type="{{ step.step_type }}">
    
    <div class="step-icon {% if step.step_type == 'complete' %}bg-gradient-success{% elif is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %}">
        {% if step.step_type == 'query_planning' %}
            <i class="fas fa-search text-white"></i>
        {% elif step.step_type == 'content_analysis' %}
            <i class="fas fa-file-alt text-white"></i>
        {% elif step.step_type == 'insights_extracted' %}
            <i class="fas fa-lightbulb text-white"></i>
        {% elif step.step_type == 'complete' %}
            <i class="fas fa-check text-white"></i>
        {% else %}
            <i class="fas fa-check text-white"></i>
        {% endif %}
    </div>
    
    <div class="step-content">
        <div class="d-flex justify-content-between align-items-center">
            <h6 class="mb-1">{{ step.title }}</h6>
            <div>
                <span class="badge {% if step.step_type == 'complete' %}bg-gradient-success{% elif is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %} me-2">Step {{ step_number }}</span>
                <button type="button" class="btn btn-link btn-sm p-0 toggle-details" 
                        data-bs-toggle="collapse" 
                        data-bs-target="#step-details-{{ step.step_type }}-{{ step_number }}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
        </div>
        
        <p class="text-muted mb-2">{{ step.explanation }}</p>
        
        <div class="collapse" id="step-details-{{ step.step_type }}-{{ step_number }}">
            <div class="card card-body mt-2 mb-3 border">
                {% if step.step_type == 'query_planning' or step.step_type == 'search_queries' %}
                    {% if step.details.queries %}
                        <h6 class="text-sm mb-2">Search Queries</h6>
                        <div class="list-group mb-3">
                            {% for query in step.details.queries %}
                                <div class="list-group-item list-group-item-action">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-search text-white"></i>
                                        </div>
                                        <div>
                                            <code class="text-dark">{{ query }}</code>
                                            {% if step.details.goals %}
                                                <p class="text-xs text-muted mt-1 mb-0">Goal: {{ step.details.goals|index:forloop.counter0 }}</p>
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}

                {% if step.step_type == 'content_analysis' %}
                    <div class="mb-3">
                        <h6 class="text-sm mb-2">Source Information</h6>
                        <div class="d-flex align-items-center mb-2">
                            <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                <i class="fas fa-file-alt text-white"></i>
                            </div>
                            <span class="text-sm">Analyzing {{ step.details.source_length|filesizeformat }} from <a href="{{ step.details.url }}" target="_blank" class="text-primary">{{ step.details.url }}</a></span>
                        </div>
                        <div class="d-flex align-items-center">
                            <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                <i class="fas fa-bullseye text-white"></i>
                            </div>
                            <span class="text-sm">Focus: <code class="text-dark">{{ step.details.focus }}</code></span>
                        </div>
                    </div>

                    {% if step.details.key_findings %}
                        <h6 class="text-sm mb-2">Key Findings</h6>
                        <div class="list-group mb-3">
                            {% for finding in step.details.key_findings %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-lightbulb text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ finding }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}

                    {% if step.details.follow_up_questions %}
                        <h6 class="text-sm mb-2">Follow-up Questions</h6>
                        <div class="list-group">
                            {% for question in step.details.follow_up_questions %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-warning text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-question text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ question }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}

                {% if step.step_type == 'insights_extracted' %}
                    {% if step.details.key_findings %}
                        <h6 class="text-sm mb-2">Key Insights</h6>
                        <div class="list-group mb-3">
                            {% for finding in step.details.key_findings %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-lightbulb text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ finding }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                    
                    {% if step.details.follow_up_questions %}
                        <h6 class="text-sm mb-2">Follow-up Questions</h6>
                        <div class="list-group">
                            {% for question in step.details.follow_up_questions %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-warning text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-question text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ question }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </div>
</div>

================
File: templates/research/partials/progress.html
================
<!-- Research Progress Section -->
<div class="progress-section card mb-4">
    <div class="card-body p-3">
        <div id="progress-container">
            <div class="progress mb-3">
                <div id="research-progress" 
                     class="progress-bar bg-gradient-{{ research.status|status_color }}" 
                     role="progressbar" 
                     style="width: {{ progress }}%"
                     aria-valuenow="{{ progress }}" 
                     aria-valuemin="0" 
                     aria-valuemax="100">
                </div>
            </div>
            
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div>
                    <span id="status-badge" class="badge bg-gradient-{{ research.status|status_color }}">
                        {{ research.status|title }}
                    </span>
                    {% if research.status == 'in_progress' %}
                        <span class="text-sm text-muted ms-2">
                            <i class="fas fa-spinner fa-spin me-1"></i>Processing...
                        </span>
                    {% endif %}
                </div>
                
                <div>
                    {% if research.status == 'in_progress' or research.status == 'pending' %}
                    <button id="cancel-btn" 
                            class="btn btn-sm btn-outline-danger"
                            hx-post="{% url 'research:cancel' research.id %}"
                            hx-confirm="Are you sure you want to cancel this research?">
                        <i class="fas fa-times me-1"></i>Cancel
                    </button>
                    {% endif %}
                </div>
            </div>
        </div>
        
        <!-- Progress Updates -->
        <div class="progress-updates overflow-auto" style="max-height: 300px;">
            <div id="progress-container" class="d-flex flex-column gap-2">
                {% if research.error %}
                <div class="alert alert-danger text-white" role="alert">
                    {{ research.error }}
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Template for progress updates -->
<template id="progress-update-template">
    <div class="progress-item bg-white p-3 border-radius-lg shadow-sm">
        <div class="d-flex align-items-center">
            <div class="icon icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                <i class="fas fa-info-circle text-white"></i>
            </div>
            <div class="ms-2">
                <div class="text-xs update-message"></div>
                <div class="text-xxs text-muted update-time"></div>
            </div>
        </div>
    </div>
</template>

================
File: templates/research/partials/reasoning.html
================
{% load research_tags %}

<div class="timeline timeline-one-side" hx-swap-oob="true" id="timeline-container">
    {% for step in research.reasoning_steps %}
    <div class="timeline-block mb-3" data-step-type="{{ step.step_type }}">
        <span class="timeline-step {% if step.step_type == 'complete' %}bg-gradient-success{% elif forloop.last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %}">
            {% if step.step_type == 'query_planning' %}
                <i class="fas fa-search text-white"></i>
            {% elif step.step_type == 'content_analysis' %}
                <i class="fas fa-file-alt text-white"></i>
            {% elif step.step_type == 'insights_extracted' %}
                <i class="fas fa-lightbulb text-white"></i>
            {% elif step.step_type == 'complete' %}
                <i class="fas fa-check text-white"></i>
            {% else %}
                <i class="fas fa-check text-white"></i>
            {% endif %}
        </span>
        <div class="timeline-content">
            <div class="d-flex justify-content-between">
                <h6 class="text-dark text-sm font-weight-bold mb-0">{{ step.title }}</h6>
                <div class="d-flex align-items-center">
                    <span class="badge badge-sm {% if step.step_type == 'complete' %}bg-gradient-success{% elif forloop.last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %} me-3">Step {{ forloop.counter }}</span>
                    <a href="javascript:;" data-bs-toggle="collapse" data-bs-target="#step-{{ forloop.counter }}" 
                        class="text-secondary font-weight-bold text-xs">
                        <i class="fas fa-chevron-down"></i>
                    </a>
                </div>
            </div>
            <p class="text-secondary text-sm mt-1 mb-0">{{ step.explanation }}</p>
            <div class="collapse" id="step-{{ forloop.counter }}" data-step-number="{{ forloop.counter }}" hx-preserve="true">
                <div class="mt-3">
                    {% if step.step_type == 'query_planning' or step.step_type == 'search_queries' %}
                        {% if step.details.queries %}
                            {% for query in step.details.queries %}
                                <div class="alert alert-light border mb-3">
                                    <div class="d-flex">
                                        <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-search text-white"></i>
                                        </div>
                                        <div>
                                            <code class="text-dark">{{ query }}</code>
                                            {% if step.details.goals %}
                                                <p class="text-sm text-secondary mt-1 mb-0">Goal: {{ step.details.goals|index:forloop.counter0 }}</p>
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        {% endif %}
                    {% elif step.step_type == 'content_analysis' %}
                        <div class="alert alert-light border">
                            <div class="d-flex align-items-center mb-2">
                                <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-file-alt text-white"></i>
                                </div>
                                <span class="text-sm">Analyzing {{ step.details.source_length|filesizeformat }} of content</span>
                            </div>
                            <div class="d-flex align-items-center">
                                <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-bullseye text-white"></i>
                                </div>
                                <span class="text-sm">Focus: <code class="text-dark">{{ step.details.focus }}</code></span>
                            </div>
                        </div>
                    {% elif step.step_type == 'insights_extracted' %}
                        {% if step.details.key_findings %}
                            <div class="alert alert-light border mb-3">
                                <h6 class="text-dark mb-2 d-flex align-items-center">
                                    <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                        <i class="fas fa-lightbulb text-white"></i>
                                    </div>
                                    Key Findings
                                </h6>
                                <ul class="mb-0 ps-4">
                                    {% for finding in step.details.key_findings %}
                                        <li class="text-sm text-secondary">{{ finding }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                        {% if step.details.follow_up_areas %}
                            <div class="alert alert-light border">
                                <h6 class="text-dark mb-2 d-flex align-items-center">
                                    <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                        <i class="fas fa-forward text-white"></i>
                                    </div>
                                    Follow-up Areas
                                </h6>
                                <ul class="mb-0 ps-4">
                                    {% for question in step.details.follow_up_areas %}
                                        <li class="text-sm text-secondary">{{ question }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                    {% else %}
                        <div class="alert alert-light border">
                            {% for key, value in step.details.items %}
                                <div class="text-sm mb-2">
                                    <strong class="text-dark">{{ key|title }}:</strong> 
                                    <span class="text-secondary">{{ value }}</span>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}

    {% if research.status == 'in_progress' %}
        <div class="timeline-block">
            <span class="timeline-step bg-gradient-info">
                <i class="fas fa-circle-notch fa-spin text-white"></i>
            </span>
            <div class="timeline-content">
                <h6 class="text-dark text-sm font-weight-bold mb-0">Processing Next Step</h6>
                <p class="text-secondary text-sm mt-1 mb-0">
                    <i class="fas fa-spinner fa-spin me-2"></i>Analyzing and gathering information...
                </p>
            </div>
        </div>
    {% endif %}
</div>

<script>
    // Only initialize once
    if (!window.timelineManager) {
        window.timelineManager = {
            expandedSteps: new Set(),
            
            init: function() {
                document.addEventListener('show.bs.collapse', function(evt) {
                    if (evt.target.hasAttribute('data-step-number')) {
                        window.timelineManager.expandedSteps.add(evt.target.getAttribute('data-step-number'));
                    }
                });
                
                document.addEventListener('hide.bs.collapse', function(evt) {
                    if (evt.target.hasAttribute('data-step-number')) {
                        window.timelineManager.expandedSteps.delete(evt.target.getAttribute('data-step-number'));
                    }
                });
                
                document.addEventListener('htmx:afterSwap', function(evt) {
                    if (evt.target.id === 'timeline-container') {
                        window.timelineManager.expandedSteps.forEach(stepNumber => {
                            const collapseEl = document.querySelector(`#step-${stepNumber}`);
                            if (collapseEl) {
                                const bsCollapse = new bootstrap.Collapse(collapseEl, { toggle: false });
                                collapseEl.classList.add('show');
                            }
                        });
                    }
                });
            }
        };
        
        window.timelineManager.init();
    }
</script>

================
File: templates/research/partials/sources.html
================
<!-- Sources Section -->
<div id="sources-container">
    <div class="card">
        <div class="card-header pb-0">
            <h6 class="mb-0">Sources <span class="badge bg-primary">{{ research.visited_urls|length }}</span></h6>
        </div>
        <div class="card-body p-3">
            {% if research.visited_urls %}
                <div class="list-group">
                    {% for url in research.visited_urls %}
                        <a href="{{ url }}" target="_blank" class="list-group-item list-group-item-action">
                            <div class="d-flex align-items-center">
                                <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-link text-white"></i>
                                </div>
                                <div class="text-sm text-truncate">{{ url }}</div>
                            </div>
                        </a>
                    {% endfor %}
                </div>
            {% else %}
                <div class="text-center py-4">
                    <div class="icon icon-shape icon-md bg-gradient-secondary shadow text-center mb-3">
                        <i class="fas fa-search opacity-10"></i>
                    </div>
                    <p class="text-muted mb-0">No sources found yet</p>
                </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Template for source items -->
<template id="source-item-template">
    <div class="source-item bg-white p-2 border-radius-lg shadow-sm">
        <div class="d-flex align-items-center">
            <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                <i class="fas fa-link text-white"></i>
            </div>
            <a href="" target="_blank" rel="noopener noreferrer" class="text-xs text-primary text-truncate source-url"></a>
        </div>
    </div>
</template>

================
File: templates/research/partials/steps.html
================
{% load research_tags %}
<div id="steps-container" class="steps-timeline">
    {% for step in research.reasoning_steps %}
        {% include "research/partials/_step.html" with step=step step_number=forloop.counter is_last=forloop.last %}
    {% endfor %}
    
    {% if research.status == 'in_progress' %}
    <!-- Processing indicator -->
    <div id="processing-indicator" class="step-item processing">
        <div class="step-icon bg-gradient-info">
            <i class="fas fa-circle-notch fa-spin text-white"></i>
        </div>
        <div class="step-content">
            <h6 class="mb-1">Processing Next Step</h6>
            <p class="text-muted mb-0">
                <i class="fas fa-spinner fa-spin me-2"></i>Analyzing and gathering information...
            </p>
        </div>
    </div>
    {% endif %}
</div>

================
File: templates/research/create.html
================
{% extends 'layouts/base.html' %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">New Research</h6>
                        <a href="{% url 'research:list' %}" class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-arrow-left me-2"></i>Back to List
                        </a>
                    </div>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        
                        <div class="form-group mb-4">
                            <label for="{{ form.query.id_for_label }}" class="form-control-label">Research Query</label>
                            {{ form.query }}
                            <small class="form-text text-muted">Enter a detailed research question or topic to investigate</small>
                            {% if form.query.errors %}
                                <div class="text-danger mt-1">{{ form.query.errors }}</div>
                            {% endif %}
                        </div>

                        <div class="card mb-4">
                            <div class="card-header p-3 pb-0">
                                <h6 class="mb-0">Advanced Settings</h6>
                            </div>
                            <div class="card-body pt-2">
                                <div class="row">
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="{{ form.breadth.id_for_label }}" class="form-control-label">Search Breadth</label>
                                            {{ form.breadth }}
                                            <small class="form-text text-muted">Number of parallel search queries (2-10)</small>
                                            {% if form.breadth.errors %}
                                                <div class="text-danger mt-1">{{ form.breadth.errors }}</div>
                                            {% endif %}
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="{{ form.depth.id_for_label }}" class="form-control-label">Search Depth</label>
                                            {{ form.depth }}
                                            <small class="form-text text-muted">Number of recursive iterations (1-5)</small>
                                            {% if form.depth.errors %}
                                                <div class="text-danger mt-1">{{ form.depth.errors }}</div>
                                            {% endif %}
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="model" class="form-control-label">Language Model</label>
                                            <select name="model" id="model" class="form-control">
                                                {% for model in available_models %}
                                                    <option value="{{ model }}" {% if model == selected_model %}selected{% endif %}>{{ model }}</option>
                                                {% endfor %}
                                            </select>
                                            <small class="form-text text-muted">Model to use for research</small>
                                        </div>
                                    </div>
                                </div>

                                <div class="form-group mb-0">
                                    <label for="{{ form.guidance.id_for_label }}" class="form-control-label">Research Guidance</label>
                                    {{ form.guidance }}
                                    <small class="form-text text-muted">Optional guidance to influence how research findings are analyzed</small>
                                    {% if form.guidance.errors %}
                                        <div class="text-danger mt-1">{{ form.guidance.errors }}</div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        
                        <div class="d-flex justify-content-end">
                            <button type="submit" class="btn bg-gradient-primary">
                                <i class="fas fa-search me-2"></i>Start Research
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add form-control class to all form inputs
        document.querySelectorAll('input, textarea, select').forEach(function(el) {
            if (!el.classList.contains('form-control')) {
                el.classList.add('form-control');
            }
        });
        
        // Make textarea taller
        document.querySelectorAll('textarea').forEach(function(el) {
            el.style.minHeight = '100px';
        });
    });
</script>
{% endblock %}

================
File: templates/research/detail.html
================
{% extends 'layouts/base.html' %}
{% load static %}
{% load research_tags %}
{% load markdown_filters %}

{% block content %}
<div class="container-fluid py-4" 
     hx-ext="ws"
     ws-connect="/ws/research/{{ research.id }}/">
    
    <!-- Research Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="mb-0">{{ research.query }}</h5>
                            <p class="text-sm text-muted mb-0">Created {{ research.created_at|date:"M d, Y" }}</p>
                        </div>
                        <div class="d-flex align-items-center">
                            <span class="text-sm text-muted me-3" id="sources-count">
                                <i class="fas fa-link me-1"></i>{{ research.visited_urls|length }} sources
                            </span>
                            <span id="status-badge" class="badge bg-gradient-{{ research.status|status_color }}">
                                {{ research.status|title }}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="card-body p-3">
                    <!-- Progress Bar -->
                    <div class="progress mb-3">
                        <div id="research-progress" 
                             class="progress-bar bg-gradient-primary" 
                             role="progressbar" 
                             {% if research.status == 'completed' %}
                             style="width: 100%"
                             aria-valuenow="100"
                             {% elif research.status == 'in_progress' %}
                             style="width: 50%"
                             aria-valuenow="50"
                             {% else %}
                             style="width: 0%"
                             aria-valuenow="0"
                             {% endif %}
                             aria-valuemin="0"
                             aria-valuemax="100">
                        </div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="d-flex justify-content-end mb-3">
                        {% if research.status == 'in_progress' or research.status == 'pending' %}
                        <button id="cancel-btn" 
                                class="btn btn-sm btn-outline-danger"
                                hx-post="{% url 'research:cancel' research.id %}"
                                hx-confirm="Are you sure you want to cancel this research?">
                            <i class="fas fa-times me-1"></i>Cancel
                        </button>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Research Content -->
    <div class="row">
        <!-- Steps Timeline -->
        <div class="col-12 col-lg-8 mb-4">
            <div class="card h-100">
                <div class="card-header pb-0">
                    <h6 class="mb-0">Research Progress</h6>
                </div>
                <div class="card-body p-3">
                    <!-- Steps will be loaded here -->
                    {% include "research/partials/steps.html" with research=research %}
                </div>
            </div>
        </div>
        
        <!-- Report Section -->
        <div class="col-12 col-lg-4">
            <div id="report-section" class="h-100">
                {% if research.report %}
                    {% include "research/partials/_report.html" with research=research %}
                {% else %}
                    <div class="card h-100">
                        <div class="card-header pb-0">
                            <h5 class="mb-0">Research Report</h5>
                        </div>
                        <div class="card-body d-flex flex-column align-items-center justify-content-center text-center">
                            <div class="icon icon-shape icon-lg bg-gradient-secondary shadow text-center">
                                <i class="fas fa-file-alt opacity-10"></i>
                            </div>
                            <h6 class="mt-3">Report Not Available</h6>
                            <p class="text-sm text-muted">
                                {% if research.status == 'in_progress' %}
                                    The report will be generated once the research is complete.
                                {% elif research.status == 'pending' %}
                                    The research has not started yet.
                                {% elif research.status == 'failed' %}
                                    The research failed to complete.
                                {% elif research.status == 'cancelled' %}
                                    The research was cancelled.
                                {% else %}
                                    No report was generated for this research.
                                {% endif %}
                            </p>
                        </div>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<!-- Markdown Styling -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
<style>
    /* Markdown Content Styling */
    .markdown-content {
        font-size: 0.875rem;
        line-height: 1.6;
    }
    .markdown-content h1, 
    .markdown-content h2, 
    .markdown-content h3 {
        margin-top: 1.5rem;
        margin-bottom: 1rem;
        font-weight: 600;
    }
    .markdown-content p {
        margin-bottom: 1rem;
    }
    .markdown-content code {
        background: #f8f9fa;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-size: 0.8125rem;
    }
    .markdown-content pre {
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
    }
    
    /* Steps Timeline Styling */
    .steps-timeline {
        position: relative;
        margin-left: 1rem;
        padding-left: 2rem;
    }
    
    .steps-timeline::before {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0.75rem;
        width: 2px;
        background-color: #e9ecef;
        transform: translateX(-50%);
    }
    
    .step-item {
        position: relative;
        padding-bottom: 1.5rem;
    }
    
    .step-item:last-child {
        padding-bottom: 0;
    }
    
    .step-icon {
        position: absolute;
        left: -2.75rem;
        width: 2rem;
        height: 2rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }
    
    .step-content {
        padding-left: 0.5rem;
    }
    
    .step-item.active .step-icon {
        box-shadow: 0 0 0 3px rgba(94, 114, 228, 0.2);
    }
    
    .step-item.processing .step-icon {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(17, 205, 239, 0.4);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(17, 205, 239, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(17, 205, 239, 0);
        }
    }
</style>
{% endblock %}

{% block extra_js %}
<!-- HTMX WebSocket Extension -->
<script src="https://unpkg.com/htmx.org/dist/ext/ws.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // WebSocket event listeners for debugging
        document.body.addEventListener('htmx:wsOpen', function(evt) {
            console.log('WebSocket connected');
        });
        
        document.body.addEventListener('htmx:wsClose', function(evt) {
            console.log('WebSocket disconnected');
        });
        
        document.body.addEventListener('htmx:wsError', function(evt) {
            console.error('WebSocket error:', evt.detail);
        });
        
        // Handle WebSocket messages
        document.body.addEventListener('htmx:wsAfterMessage', function(evt) {
            try {
                const data = JSON.parse(evt.detail.message);
                console.log('WebSocket message:', data);
                
                if (data.type === 'status_update') {
                    updateStatus(data);
                } else if (data.type === 'error') {
                    showError(data.message);
                }
            } catch (e) {
                // Not JSON data, likely HTML for HTMX to process
            }
        });
        
        // Update status badge and progress bar
        function updateStatus(data) {
            if (data.status) {
                const statusColors = {
                    'pending': 'secondary',
                    'in_progress': 'primary',
                    'completed': 'success',
                    'failed': 'danger',
                    'cancelled': 'warning'
                };
                
                const statusBadge = document.getElementById('status-badge');
                if (statusBadge) {
                    statusBadge.className = `badge bg-gradient-${statusColors[data.status] || 'secondary'}`;
                    statusBadge.textContent = data.status.charAt(0).toUpperCase() + data.status.slice(1);
                }
                
                // Update progress bar
                if (data.progress !== undefined) {
                    const progressBar = document.getElementById('research-progress');
                    if (progressBar) {
                        progressBar.style.width = `${data.progress}%`;
                    }
                }
                
                // Hide cancel button if research is complete
                if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn) {
                        cancelBtn.style.display = 'none';
                    }
                }
            }
        }
        
        // Show error message
        function showError(message) {
            // You could use a toast notification library here
            console.error('Error:', message);
        }
    });
</script>
{% endblock %}

================
File: templates/research/list.html
================
{% extends 'layouts/base.html' %}
{% load research_tags %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header pb-0 d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">Research History</h6>
                    <a href="{% url 'research:create' %}" class="btn btn-sm btn-primary">
                        <i class="fas fa-plus me-2"></i>New Research
                    </a>
                </div>
                
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <table class="table align-items-center mb-0">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Query</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Created</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Sources</th>
                                    <th class="text-secondary opacity-7"></th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for research in researches %}
                                <tr>
                                    <td>
                                        <div class="d-flex px-3 py-1">
                                            <div class="d-flex flex-column justify-content-center">
                                                <h6 class="mb-0 text-sm">{{ research.query|truncatechars:50 }}</h6>
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <span class="badge bg-gradient-{{ research.status|status_color }}">
                                            {{ research.status|title }}
                                        </span>
                                    </td>
                                    <td>
                                        <p class="text-xs font-weight-bold mb-0">{{ research.created_at|date:"M d, Y" }}</p>
                                        <p class="text-xs text-secondary mb-0">{{ research.created_at|date:"H:i" }}</p>
                                    </td>
                                    <td>
                                        <span class="text-xs font-weight-bold">
                                            <i class="fas fa-link me-1"></i>{{ research.visited_urls|length }}
                                        </span>
                                    </td>
                                    <td class="align-middle text-end pe-3">
                                        <a href="{% url 'research:detail' research_id=research.id %}" class="btn btn-link text-dark px-3 mb-0">
                                            <i class="fas fa-eye text-dark me-2"></i>View
                                        </a>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="5" class="text-center py-5">
                                        <div class="d-flex flex-column align-items-center">
                                            <div class="icon icon-shape icon-lg bg-gradient-secondary shadow text-center mb-3">
                                                <i class="fas fa-search opacity-10"></i>
                                            </div>
                                            <h6 class="mb-2">No Research Found</h6>
                                            <p class="text-sm text-muted mb-3">You haven't created any research tasks yet.</p>
                                            <a href="{% url 'research:create' %}" class="btn btn-sm btn-primary">
                                                <i class="fas fa-plus me-2"></i>Start Your First Research
                                            </a>
                                        </div>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: templatetags/__init__.py
================
# This file is intentionally empty to make the directory a Python package

================
File: templatetags/research_tags.py
================
from django import template
import json as json_lib
import hashlib

register = template.Library()

@register.filter
def index(indexable, i):
    """Get item at index i from an indexable object"""
    try:
        return indexable[i]
    except (IndexError, TypeError, KeyError):
        return ''

@register.filter
def json(value):
    """Convert a Python object to a JSON string"""
    try:
        return json_lib.dumps(value)
    except (TypeError, ValueError):
        return '{}'

@register.filter
def md5(value):
    """Generate MD5 hash of a string value"""
    try:
        if not value:
            return ''
        return hashlib.md5(str(value).encode()).hexdigest()
    except (TypeError, ValueError):
        return ''

@register.filter
def status_color(status):
    """Return Bootstrap color class for a status."""
    status_colors = {
        'pending': 'secondary',
        'in_progress': 'primary',
        'completed': 'success',
        'failed': 'danger',
        'cancelled': 'warning'
    }
    return status_colors.get(status, 'secondary')

================
File: websockets/research_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.template.loader import render_to_string
from ..models import Research
from ..services import ResearchService
import logging
import json
import asyncio

logger = logging.getLogger(__name__)

class ResearchConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer for research app that handles real-time updates.
    Uses a standardized message protocol for all communications.
    """
    
    async def connect(self):
        """Handle WebSocket connection"""
        self.research_id = self.scope['url_route']['kwargs']['research_id']
        self.group_name = f"research_{self.research_id}"
        
        # Join the group
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        
        # Accept the connection
        await self.accept()
        logger.info(f"WebSocket connected for research {self.research_id}")
        
        # Send initial state
        await self.send_initial_state()
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection"""
        logger.info(f"WebSocket disconnected for research {self.research_id} with code {close_code}")
        
        # Leave the group
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """Handle messages from WebSocket client"""
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'get_state':
                await self.send_initial_state()
            elif message_type == 'cancel_research':
                await self.cancel_research()
            else:
                logger.warning(f"Unknown message type: {message_type}")
                
        except json.JSONDecodeError:
            logger.error(f"Invalid JSON received: {text_data}")
            await self.send_error("Invalid message format")
        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            await self.send_error(f"Error processing message: {str(e)}")

    @database_sync_to_async
    def get_research(self):
        """Get research object from database"""
        try:
            return Research.objects.get(id=self.research_id)
        except Research.DoesNotExist:
            logger.error(f"Research {self.research_id} not found")
            return None

    @database_sync_to_async
    def cancel_research(self):
        """Cancel the research task"""
        try:
            research = Research.objects.get(id=self.research_id)
            if research.status in ['pending', 'in_progress']:
                research.status = 'cancelled'
                research.save(update_fields=['status'])
                
                # Send cancellation message to group
                async_to_sync(self.channel_layer.group_send)(
                    self.group_name,
                    {
                        "type": "status_update",
                        "status": "cancelled",
                        "message": "Research cancelled by user"
                    }
                )
                return True
            return False
        except Research.DoesNotExist:
            logger.error(f"Research {self.research_id} not found")
            return False
    
    @database_sync_to_async
    def render_template_async(self, template_name, context):
        """Render a template asynchronously"""
        return render_to_string(template_name, context)
    
    async def send_initial_state(self):
        """Send initial state to the client"""
        research = await self.get_research()
        if not research:
            await self.send_error("Research not found")
            return
        
        # Send current state
        await self.send_json({
            'type': 'initial_state',
            'research': {
                'id': research.id,
                'status': research.status,
                'progress': self._calculate_progress(research),
                'query': research.query,
                'created_at': research.created_at.isoformat(),
                'error': research.error
            }
        })
        
        # Send HTML for steps
        if research.reasoning_steps:
            html = await self.render_template_async(
                'research/partials/steps.html',
                {'research': research}
            )
            await self.send(text_data=html)
    
    def _calculate_progress(self, research):
        """Calculate progress percentage based on research state"""
        if research.status == 'completed':
            return 100
        elif research.status == 'failed' or research.status == 'cancelled':
            return 0
        elif research.status == 'pending':
            return 0
        
        # For in_progress, calculate based on steps
        if not research.reasoning_steps:
            return 5  # Just started
        
        # Estimate progress based on number of steps and expected total
        step_count = len(research.reasoning_steps)
        expected_total = 10  # Typical number of steps for a complete research
        
        progress = min(95, int((step_count / expected_total) * 100))
        return progress
    
    async def send_json(self, data):
        """Send JSON data to the WebSocket"""
        await self.send(text_data=json.dumps(data))
    
    async def send_error(self, message):
        """Send error message to the WebSocket"""
        await self.send_json({
            'type': 'error',
            'message': message
        })
    
    # Channel layer event handlers
    
    async def status_update(self, event):
        """Handle status update event from channel layer"""
        await self.send_json({
            'type': 'status_update',
            'status': event['status'],
            'message': event.get('message', ''),
            'progress': event.get('progress')
        })
    
    async def step_update(self, event):
        """Handle step update event from channel layer"""
        step_data = event.get('step', {})
        
        # Render the step HTML
        html = await self.render_template_async(
            'research/partials/_step.html',
            {
                'step': step_data,
                'step_number': event.get('step_number', 1),
                'is_last': True
            }
        )
        
        # Send both the raw data and the HTML
        await self.send_json({
            'type': 'step_update',
            'step': step_data,
            'step_number': event.get('step_number', 1)
        })
        
        # Send the HTML with OOB swap instruction
        step_id = f"step-{step_data.get('step_type', 'unknown')}-{event.get('step_number', 1)}"
        await self.send(text_data=f'''
            <div id="{step_id}" 
                 hx-swap-oob="beforeend:#steps-container">
                {html}
            </div>
        ''')
        
    async def report_update(self, event):
        """Handle report update event from channel layer"""
        research = await self.get_research()
        if not research or not research.report:
            return
        
        # Render the report HTML
        html = await self.render_template_async(
            'research/partials/_report.html',
            {'research': research}
        )
        
        # Send the HTML with OOB swap instruction
        await self.send(text_data=f'''
            <div id="report-section" hx-swap-oob="innerHTML">
                {html}
            </div>
        ''')

================
File: admin.py
================
from django.contrib import admin
from django.utils.html import format_html
from .models import Research

@admin.register(Research)
class ResearchAdmin(admin.ModelAdmin):
    list_display = ['id', 'truncated_query', 'user', 'status', 'created_at', 'source_count', 'has_report']
    list_filter = ['status', 'created_at', 'user']
    search_fields = ['query', 'user__username', 'report']
    readonly_fields = ['created_at', 'updated_at', 'visited_urls', 'learnings', 'reasoning_steps']
    date_hierarchy = 'created_at'
    
    def truncated_query(self, obj):
        return obj.query[:50] + "..." if len(obj.query) > 50 else obj.query
    truncated_query.short_description = 'Query'
    
    def source_count(self, obj):
        return len(obj.visited_urls)
    source_count.short_description = 'Sources'
    
    def has_report(self, obj):
        return format_html(
            '<span style="color: {};">&#x2022;</span> {}',
            '#2ecc71' if obj.report else '#e74c3c',
            'Yes' if obj.report else 'No'
        )
    has_report.short_description = 'Report'
    
    fieldsets = [
        ('Basic Information', {
            'fields': ['user', 'query', 'status', 'created_at', 'updated_at']
        }),
        ('Research Parameters', {
            'fields': ['breadth', 'depth', 'guidance']
        }),
        ('Results', {
            'fields': ['report', 'error']
        }),
        ('Research Data', {
            'classes': ['collapse'],
            'fields': ['visited_urls', 'learnings', 'reasoning_steps']
        }),
    ]

================
File: apps.py
================
from django.apps import AppConfig


class ResearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.research'
    path = __file__.replace('apps.py', '')

================
File: forms.py
================
from django import forms
from .models import Research

class ResearchForm(forms.ModelForm):
    class Meta:
        model = Research
        fields = ['query', 'breadth', 'depth', 'guidance']
        widgets = {
            'query': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Enter your research query...'
            }),
            'breadth': forms.NumberInput(attrs={
                'class': 'form-control',
                'min': 2,
                'max': 10
            }),
            'depth': forms.NumberInput(attrs={
                'class': 'form-control',
                'min': 1,
                'max': 5
            }),
            'guidance': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Optional: Provide guidance on what aspects to focus on...'
            })
        }

================
File: models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone

User = get_user_model()

def default_list():
    return []

class Research(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    query = models.TextField()
    breadth = models.IntegerField(default=4)
    depth = models.IntegerField(default=2)
    guidance = models.TextField(null=True, blank=True, help_text="Optional guidance for content processing")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    report = models.TextField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    
    # Store intermediate results using callable defaults
    visited_urls = models.JSONField(default=default_list)
    learnings = models.JSONField(default=default_list)
    reasoning_steps = models.JSONField(default=default_list)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = 'Research'

    def __str__(self):
        return f"Research: {self.query[:50]}..."

================
File: services.py
================
import logging
from typing import Dict, Optional, List
from .models import Research
import json
from django.db import transaction

logger = logging.getLogger(__name__)

class ResearchService:
    @staticmethod
    def update_research_steps(research_id: int, step_data: Dict) -> Optional[Research]:
        """Update research steps in the database."""
        try:
            #logger.info(f"Updating research steps for research {research_id}")
            #logger.info(f"Step data received: {json.dumps(step_data)}")
            
            # Use transaction context manager
            with transaction.atomic():
                # Get research object with select_for_update to prevent race conditions
                research = Research.objects.select_for_update().get(id=research_id)
                
                # Ensure we have a valid list for current_steps
                current_steps = research.reasoning_steps
                if current_steps is None or not isinstance(current_steps, list):
                    logger.warning(f"Current steps was not a valid list, resetting. Type was: {type(current_steps)}")
                    current_steps = []
                
                #logger.info(f"Current step count before update: {len(current_steps)}")
                
                # Validate step data
                if not all(key in step_data for key in ['step_type', 'title', 'explanation']):
                    logger.error(f"Invalid step data format: {json.dumps(step_data)}")
                    return None
                
                # Only append if this is a new step
                is_duplicate = False
                if current_steps:
                    # Check for duplicate step based on step_type and title
                    for existing_step in current_steps:
                        if (existing_step.get('step_type') == step_data.get('step_type') and 
                            existing_step.get('title') == step_data.get('title')):
                            # Update the existing step instead of adding a new one
                            existing_step.update(step_data)
                            is_duplicate = True
                            logger.info(f"Updated existing step: {step_data.get('title')}")
                            break
                    
                    # Special case: don't add 'complete' step if it's already there
                    if step_data.get('step_type') == 'complete' and any(s.get('step_type') == 'complete' for s in current_steps):
                        is_duplicate = True
                        logger.info("Skipping duplicate complete step")
                
                if not is_duplicate:
                    current_steps.append(step_data)
                    #logger.info(f"Added new step: {step_data.get('title')}")
                
                logger.info(f"Current step count after update: {len(current_steps)}")
                
                # Save the updated steps
                research.reasoning_steps = current_steps
                research.save(update_fields=['reasoning_steps'])
                
                # Verify the save
                research.refresh_from_db()
                #logger.info(f"Verified step count after save: {len(research.reasoning_steps)}")
                
                return research
                
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research steps: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_status(research_id: int, status: str) -> Optional[Research]:
        """Update research status."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.status = status
                research.save(update_fields=['status'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research status: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_error(research_id: int, error_message: str) -> Optional[Research]:
        """Update research error state."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.error = error_message
                research.status = 'failed'
                research.save(update_fields=['error', 'status'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research error: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_report(research_id: int, report: str) -> Optional[Research]:
        """Update research report."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.report = report
                research.save(update_fields=['report'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research report: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_data(research_id: int, data: Dict) -> Optional[Research]:
        """Update research data fields (report, visited_urls, learnings)."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                
                fields_to_update = []
                
                if 'report' in data:
                    research.report = data['report']
                    fields_to_update.append('report')
                    
                if 'visited_urls' in data:
                    research.visited_urls = data['visited_urls']
                    fields_to_update.append('visited_urls')
                    
                if 'learnings' in data:
                    research.learnings = data['learnings']
                    fields_to_update.append('learnings')
                    
                if fields_to_update:
                    research.save(update_fields=fields_to_update)
                    
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research data: {str(e)}", exc_info=True)
            return None

================
File: tasks.py
================
from celery import shared_task
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from apps.agents.tools.deep_research_tool.deep_research_tool import DeepResearchTool
from .models import Research
from .services import ResearchService
import logging
from pydantic import Field
from typing import Any, Dict, List, Optional
from celery.exceptions import Ignore
import json

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

class ProgressTracker:
    """Tracks progress of research tasks and sends updates via WebSockets."""
    
    def __init__(self, research_id):
        self.research_id = research_id
        self.group_name = f"research_{research_id}"
        self.step_count = 0
        logger.info(f"Initialized ProgressTracker for research {research_id}")

    def send_update(self, update_type: str, data: Dict):
        """Send an update to the WebSocket group."""
        try:
            # Determine the message type based on the update type
            if update_type in ['generating_queries', 'queries_generated', 'urls_found']:
                message_type = 'status_update'
                message_data = {
                    'status': 'in_progress',
                    'message': data.get('message', f'Processing {update_type}'),
                    'progress': self._calculate_progress(update_type)
                }
            elif update_type == 'step_added':
                message_type = 'step_update'
                self.step_count += 1
                message_data = {
                    'step': data.get('step', {}),
                    'step_number': self.step_count
                }
            elif update_type == 'completed':
                message_type = 'status_update'
                message_data = {
                    'status': 'completed',
                    'message': 'Research completed successfully',
                    'progress': 100
                }
            elif update_type == 'report_ready':
                message_type = 'report_update'
                message_data = {
                    'report_id': self.research_id
                }
            elif update_type == 'error':
                message_type = 'status_update'
                message_data = {
                    'status': 'failed',
                    'message': data.get('error', 'An error occurred'),
                    'progress': 0
                }
            elif update_type == 'cancelled':
                message_type = 'status_update'
                message_data = {
                    'status': 'cancelled',
                    'message': 'Research was cancelled',
                    'progress': 0
                }
            else:
                # Default to status update
                message_type = 'status_update'
                message_data = {
                    'status': 'in_progress',
                    'message': f'Processing {update_type}',
                    'progress': self._calculate_progress(update_type)
                }
            
            # Send the message to the group
            async_to_sync(channel_layer.group_send)(
                self.group_name,
                {
                    "type": message_type,
                    **message_data
                }
            )
            logger.debug(f"Sent {message_type} update for research {self.research_id}")
            
        except Exception as e:
            logger.error(f"Error sending WebSocket update for research {self.research_id}: {str(e)}", exc_info=True)
    
    def _calculate_progress(self, update_type: str) -> int:
        """Calculate progress percentage based on the update type."""
        # Define progress milestones for different stages
        progress_map = {
            'generating_queries': 10,
            'queries_generated': 20,
            'urls_found': 30,
            # Steps will increment between 30-90%
        }
        
        if update_type in progress_map:
            return progress_map[update_type]
        
        # For step updates, calculate based on expected total steps
        expected_total_steps = 10
        progress = 30 + min(60, int((self.step_count / expected_total_steps) * 60))
        return progress

    def check_cancelled(self) -> bool:
        """Check if the research has been cancelled."""
        try:
            research = Research.objects.get(id=self.research_id)
            return research.status == 'cancelled'
        except Research.DoesNotExist:
            return True

class ProgressDeepResearchTool(DeepResearchTool):
    """Extended DeepResearchTool that tracks progress and sends updates."""
    
    progress_tracker: Any = Field(None, exclude=True)

    def __init__(self, progress_tracker: ProgressTracker, **kwargs):
        super().__init__(**kwargs)
        self.progress_tracker = progress_tracker

    def _generate_serp_queries(self, query, num_queries, learnings=None, guidance=None):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
            
        self.progress_tracker.send_update("generating_queries", {
            "message": f"Generating {num_queries} search queries..."
        })
        
        result = super()._generate_serp_queries(query, num_queries, learnings, guidance)
        
        self.progress_tracker.send_update("queries_generated", {
            "queries": [q["query"] for q in result]
        })
        
        return result

    def _extract_urls(self, search_results):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
            
        urls = super()._extract_urls(search_results)
        
        self.progress_tracker.send_update("urls_found", {
            "urls": urls
        })
        
        return urls

    def _process_content(self, query, content, num_learnings=3, guidance=None):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
        
        # Log content type and size for debugging
        content_type = type(content).__name__
        content_size = len(content) if isinstance(content, (str, dict)) else "unknown"
        logger.info(f"Processing content of type {content_type}, size {content_size}")
        
        # Create a proper content dictionary if content is a string
        if isinstance(content, str):
            # Check if we have URL information from the parent class call context
            url = getattr(self, '_current_url', 'unknown source')
            content_dict = {
                'url': url,
                'content': content
            }
            # Store the original content string
            original_content = content
            # Use the dictionary for processing
            result = super()._process_content(query, original_content, num_learnings, guidance)
        else:
            # Content is already a dictionary
            content_dict = content
            result = super()._process_content(query, content.get('content', content), num_learnings, guidance)
        
        # Validate result
        if not result:
            logger.error("Empty result from content processing")
            return {
                'learnings': [f"Unable to extract learnings from content about: {query}"],
                'follow_up_questions': [f"What are the key aspects of {query}?"]
            }
        
        # Log the result for debugging
        logger.info(f"Content processing result has {len(result.get('learnings', []))} learnings")
        if result.get('learnings'):
            for i, learning in enumerate(result.get('learnings', [])[:2]):
                logger.info(f"Task processor learning {i+1}: {learning[:100]}...")
        
        # Send step update
        if result and 'learnings' in result:
            url = content_dict.get('url', 'unknown source')
            content_length = len(content_dict.get('content', content_dict))
                
            step_data = {
                'step_type': 'content_analysis',
                'title': f"Analyzing content from {url}",
                'explanation': f"Extracting information relevant to the research query",
                'details': {
                    'url': url,
                    'source_length': content_length,
                    'focus': query,
                    'key_findings': result.get('learnings', []),
                    'follow_up_questions': result.get('follow_up_questions', [])
                }
            }
            
            # Add step to database
            research = ResearchService.update_research_steps(self.progress_tracker.research_id, step_data)
            
            # Send WebSocket update
            self.progress_tracker.send_update("step_added", {
                "step": step_data
            })
        
        return result

@shared_task
def run_research(research_id, model_name=None, tool_params=None):
    """Run a research task with progress tracking."""
    research = None
    progress_tracker = None
    
    try:
        research = Research.objects.get(id=research_id)
        
        # Check if already cancelled before starting
        if research.status == 'cancelled':
            logger.info(f"Research task {research_id} was already cancelled")
            return
            
        # Update status to in_progress
        ResearchService.update_research_status(research_id, 'in_progress')

        # Initialize progress tracker
        progress_tracker = ProgressTracker(research_id)
        
        # Check if cancelled after tracker initialization
        if progress_tracker.check_cancelled():
            logger.info(f"Research task {research_id} was cancelled before starting")
            ResearchService.update_research_status(research_id, 'cancelled')
            progress_tracker.send_update("cancelled", {})
            return
            
        # Initialize tool with model name and any additional params
        tool_kwargs = {
            'progress_tracker': progress_tracker,
        }
        if tool_params:
            tool_kwargs.update(tool_params)
            
        # Create tool instance
        tool = ProgressDeepResearchTool(**tool_kwargs)

        # Get result from tool
        tool_result = tool._run(
            query=research.query,
            breadth=research.breadth,
            depth=research.depth,
            user_id=research.user_id,
            guidance=research.guidance
        )
        
        # For text-based output, store as is
        if isinstance(tool_result, str):
            logger.info(f"Report content length: {len(tool_result)}")
            report = tool_result
        # For JSON output, extract just the report field
        elif isinstance(tool_result, dict):
            # Check for deep_research_data structure
            if 'deep_research_data' in tool_result and 'report' in tool_result['deep_research_data']:
                # Extract just the report content
                report = tool_result['deep_research_data']['report']
                logger.info(f"Extracted report content length: {len(report)}")
            else:
                # Fallback to JSON string if structure is unexpected
                logger.warning("Unexpected tool result structure, converting to JSON string")
                report = json.dumps(tool_result, indent=2)
            
            # Get learnings from the appropriate location
            learnings = tool_result.get('deep_research_data', {}).get('learnings', [])
            visited_urls = tool_result.get('deep_research_data', {}).get('sources', [])
            
            logger.info(f"Received {len(learnings)} learnings from research tool")
            if learnings and len(learnings) > 0:
                logger.debug(f"First few learnings: {', '.join(str(l) for l in learnings[:3])}")
        else:
            # Fallback for unexpected types
            report = str(tool_result)

        # Process the result
        if report:
            # Update research with all data including report
            ResearchService.update_research_data(research_id, {
                'report': report,
                'visited_urls': visited_urls if 'visited_urls' in locals() else [],
                'learnings': learnings if 'learnings' in locals() else []
            })
            
            # Verify report was saved
            research.refresh_from_db()
            if not research.report:
                logger.error(f"Report save failed for research {research_id}")
                ResearchService.update_research_error(research_id, "Failed to save report")
                progress_tracker.send_update("error", {"error": "Failed to save report"})
            else:
                # Update status to completed
                ResearchService.update_research_status(research_id, 'completed')
                
                # Send report ready notification
                progress_tracker.send_update("report_ready", {})
                
                # Send completion notification
                progress_tracker.send_update("completed", {})
        else:
            # Handle error
            error_message = "Unknown error occurred"
            ResearchService.update_research_error(research_id, error_message)
            progress_tracker.send_update("error", {"error": error_message})

    except Ignore:
        # Task was cancelled
        logger.info(f"Research task {research_id} was cancelled")
        if research:
            ResearchService.update_research_status(research_id, 'cancelled')
        if progress_tracker:
            progress_tracker.send_update("cancelled", {})

    except Exception as e:
        # Handle unexpected exceptions
        logger.error(f"Error in research task: {str(e)}", exc_info=True)
        if research:
            ResearchService.update_research_error(research_id, str(e))
            
            if progress_tracker:
                progress_tracker.send_update("error", {"error": str(e)})

================
File: template_app.md
================
# Django App Template with WebSockets and HTMX

This document outlines the structure and best practices for creating a new Django app in this project using WebSockets, HTMX, and agent-driven functionality.

## Table of Contents

1. [App Structure](#app-structure)
2. [Models](#models)
3. [WebSockets Integration](#websockets-integration)
4. [Templates with HTMX](#templates-with-htmx)
5. [Static Files](#static-files)
6. [Services Layer](#services-layer)
7. [Tasks and Asynchronous Processing](#tasks-and-asynchronous-processing)
8. [URL Configuration](#url-configuration)
9. [Forms](#forms)
10. [Admin Configuration](#admin-configuration)
11. [Progress Tracking with WebSockets](#progress-tracking-with-websockets)

## App Structure

```
app_name/
├── admin.py                  # Admin configuration
├── apps.py                   # App configuration
├── forms.py                  # Form definitions
├── models.py                 # Model definitions
├── services.py               # Business logic
├── tasks.py                  # Celery tasks
├── urls.py                   # URL routing
├── views.py                  # View controllers
├── migrations/               # Database migrations
├── static/                   # Static assets
│   └── app_name/
│       ├── css/              # CSS files
│       ├── js/               # JavaScript files
│       └── img/              # Images
├── templates/                # HTML templates
│   └── app_name/
│       ├── list.html         # Main list view
│       ├── detail.html       # Detail view
│       ├── create.html       # Creation form
│       └── partials/         # HTMX partial templates
│           ├── _item.html    # Individual item template
│           └── _step.html    # Process step template
├── templatetags/             # Custom template tags
│   ├── __init__.py
│   └── app_tags.py
└── websockets/               # WebSockets consumers
    ├── __init__.py
    └── app_consumer.py
```

## Models

Define your models with appropriate fields, choices, and default values:

```python
from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone

User = get_user_model()

def default_list():
    return []

class YourModel(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    title = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    # For storing JSON data
    progress_data = models.JSONField(default=default_list)
    result_data = models.JSONField(default=dict)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = 'YourModels'

    def __str__(self):
        return self.title
```

## WebSockets Integration

### 1. Consumer Definition

Create a WebSocket consumer in `websockets/app_consumer.py`:

```python
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.template.loader import render_to_string
from ..models import YourModel
from ..services import YourService
import logging
import json

logger = logging.getLogger(__name__)

class YourConsumer(AsyncWebsocketConsumer):
    """
    WebSocket consumer that handles real-time updates.
    Uses a standardized message protocol for all communications.
    """
    
    async def connect(self):
        """Handle WebSocket connection"""
        self.item_id = self.scope['url_route']['kwargs']['item_id']
        self.group_name = f"item_{self.item_id}"
        
        # Join the group
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        
        # Accept the connection
        await self.accept()
        logger.info(f"WebSocket connected for item {self.item_id}")
        
        # Send initial state
        await self.send_initial_state()
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection"""
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
    
    async def receive(self, text_data):
        """Handle messages from WebSocket client"""
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'get_state':
                await self.send_initial_state()
            elif message_type == 'cancel_task':
                await self.cancel_task()
            else:
                logger.warning(f"Unknown message type: {message_type}")
                
        except json.JSONDecodeError:
            await self.send_error("Invalid message format")
        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            await self.send_error(f"Error processing message: {str(e)}")

    @database_sync_to_async
    def get_item(self):
        """Get item object from database"""
        try:
            return YourModel.objects.get(id=self.item_id)
        except YourModel.DoesNotExist:
            logger.error(f"Item {self.item_id} not found")
            return None

    @database_sync_to_async
    def render_template_async(self, template_name, context):
        """Render a template asynchronously"""
        return render_to_string(template_name, context)
    
    async def send_initial_state(self):
        """Send initial state to the client"""
        item = await self.get_item()
        if not item:
            await self.send_error("Item not found")
            return
        
        # Send current state
        await self.send_json({
            'type': 'initial_state',
            'item': {
                'id': item.id,
                'status': item.status,
                'title': item.title,
                'created_at': item.created_at.isoformat()
            }
        })
        
        # Send HTML for progress steps if available
        if item.progress_data:
            html = await self.render_template_async(
                'app_name/partials/progress.html',
                {'item': item}
            )
            await self.send(text_data=html)
    
    async def send_json(self, data):
        """Send JSON data to the WebSocket"""
        await self.send(text_data=json.dumps(data))
    
    async def send_error(self, message):
        """Send error message to the WebSocket"""
        await self.send_json({
            'type': 'error',
            'message': message
        })
    
    # Channel layer event handlers
    
    async def status_update(self, event):
        """Handle status update event from channel layer"""
        await self.send_json({
            'type': 'status_update',
            'status': event['status'],
            'message': event.get('message', ''),
            'progress': event.get('progress')
        })
    
    async def step_update(self, event):
        """Handle step update event from channel layer"""
        step_data = event.get('step', {})
        
        # Render the step HTML
        html = await self.render_template_async(
            'app_name/partials/_step.html',
            {
                'step': step_data,
                'step_number': event.get('step_number', 1)
            }
        )
        
        # Send both the data and the HTML with OOB swap instruction
        await self.send_json({
            'type': 'step_update',
            'step': step_data,
            'step_number': event.get('step_number', 1)
        })
        
        # Send HTML with OOB swap instruction for HTMX
        await self.send(text_data=f'''
            <div id="step-{event.get('step_number', 1)}" 
                 hx-swap-oob="beforeend:#steps-container">
                {html}
            </div>
        ''')
```

### 2. Register WebSocket URL

Add your consumer to the WebSocket URL patterns in `core/routing.py`:

```python
from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
from apps.your_app.websockets.app_consumer import YourConsumer

websocket_urlpatterns = [
    # Other websocket patterns...
    re_path(r'ws/your_app/(?P<item_id>\d+)/$', YourConsumer.as_asgi()),
]

application = ProtocolTypeRouter({
    "websocket": AuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})
```

## Templates with HTMX

### 1. Main Template with WebSocket Connection

Example `detail.html`:

```html
{% extends 'layouts/base.html' %}
{% load static %}
{% load app_tags %}

{% block content %}
<div class="container-fluid py-4" 
     hx-ext="ws"
     ws-connect="/ws/your_app/{{ item.id }}/">
    
    <!-- Item Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="mb-0">{{ item.title }}</h5>
                            <p class="text-sm text-muted mb-0">Created {{ item.created_at|date:"M d, Y" }}</p>
                        </div>
                        <div>
                            <span id="status-badge" class="badge bg-gradient-{{ item.status|status_color }}">
                                {{ item.status|title }}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="card-body p-3">
                    <!-- Progress Bar -->
                    <div class="progress mb-3">
                        <div id="item-progress" 
                             class="progress-bar bg-gradient-primary" 
                             role="progressbar" 
                             style="width: 0%"
                             aria-valuenow="0"
                             aria-valuemin="0"
                             aria-valuemax="100">
                        </div>
                    </div>
                    
                    <!-- Cancel Button (shown if in progress) -->
                    {% if item.status == 'in_progress' or item.status == 'pending' %}
                    <div class="d-flex justify-content-end">
                        <button id="cancel-btn" 
                                class="btn btn-sm btn-outline-danger"
                                hx-post="{% url 'your_app:cancel' item.id %}"
                                hx-confirm="Are you sure you want to cancel this task?">
                            <i class="fas fa-times me-1"></i>Cancel
                        </button>
                    </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
    
    <!-- Content Sections -->
    <div class="row">
        <!-- Progress Steps -->
        <div class="col-12 col-lg-8 mb-4">
            <div class="card h-100">
                <div class="card-header pb-0">
                    <h6 class="mb-0">Progress</h6>
                </div>
                <div class="card-body p-3">
                    <!-- Steps container for HTMX updates -->
                    <div id="steps-container" class="steps-timeline">
                        <!-- Steps will be loaded here -->
                        {% include "your_app/partials/steps.html" with item=item %}
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Results Section -->
        <div class="col-12 col-lg-4">
            <div id="results-section" class="h-100">
                {% if item.result_data %}
                    {% include "your_app/partials/_results.html" with item=item %}
                {% else %}
                    <div class="card h-100">
                        <div class="card-header pb-0">
                            <h5 class="mb-0">Results</h5>
                        </div>
                        <div class="card-body d-flex flex-column align-items-center justify-content-center text-center">
                            <div class="icon icon-shape icon-lg bg-gradient-secondary shadow text-center">
                                <i class="fas fa-file-alt opacity-10"></i>
                            </div>
                            <h6 class="mt-3">Results Not Available</h6>
                            <p class="text-sm text-muted">
                                {% if item.status == 'in_progress' %}
                                    Processing in progress...
                                {% else %}
                                    No results available yet.
                                {% endif %}
                            </p>
                        </div>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'your_app/js/app-websocket.js' %}"></script>
<script>
    // Initialize WebSocket service
    document.addEventListener('DOMContentLoaded', function() {
        window.ITEM_ID = {{ item.id }};
        const wsService = new AppWebSocketService({{ item.id }});
        window.appWsService = wsService;
    });
</script>
{% endblock %}
```

### 2. Partial Templates

Create reusable partial templates for HTMX updates:

**`partials/steps.html`**:
```html
<div class="steps-timeline">
    {% for step in item.progress_data %}
        {% include "your_app/partials/_step.html" with step=step step_number=forloop.counter %}
    {% empty %}
        <div class="text-center p-4">
            <p class="text-muted mb-0">No progress steps available yet.</p>
        </div>
    {% endfor %}
</div>
```

**`partials/_step.html`**:
```html
<div class="step-item {% if is_last %}active{% endif %}" 
     id="step-{{ step_number }}" 
     data-step-type="{{ step.step_type }}">
    
    <div class="step-icon {% if is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %}">
        <i class="fas fa-check text-white"></i>
    </div>
    
    <div class="step-content">
        <div class="d-flex justify-content-between align-items-center">
            <h6 class="mb-1">{{ step.title }}</h6>
            <div>
                <span class="badge {% if is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %} me-2">Step {{ step_number }}</span>
                <button type="button" class="btn btn-link btn-sm p-0 toggle-details" 
                        data-bs-toggle="collapse" 
                        data-bs-target="#step-details-{{ step_number }}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
        </div>
        
        <p class="text-muted mb-2">{{ step.explanation }}</p>
        
        <div class="collapse" id="step-details-{{ step_number }}">
            <div class="card card-body mt-2 mb-3 border">
                {{ step.details|safe }}
            </div>
        </div>
    </div>
</div>
```

**`partials/_results.html`**:
```html
<div class="card h-100">
    <div class="card-header pb-0">
        <h5 class="mb-0">Results</h5>
    </div>
    <div class="card-body">
        <div class="results-content">
            {{ item.result_data.content|safe }}
        </div>
    </div>
</div>
```

## Static Files

### 1. JavaScript WebSocket Client

Create a WebSocket service in `static/your_app/js/app-websocket.js`:

```javascript
// Your app WebSocket service
export class AppWebSocketService {
    constructor(itemId) {
        this.itemId = itemId;
        this.socket = null;
        this.isConnected = false;
        
        // DOM elements
        this.progressBar = document.getElementById('item-progress');
        this.statusBadge = document.getElementById('status-badge');
        this.cancelButton = document.getElementById('cancel-btn');
        this.stepsContainer = document.getElementById('steps-container');
        
        // Initialize
        this.connect();
    }

    connect() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}/ws/your_app/${this.itemId}/`;
        
        this.socket = new WebSocket(wsUrl);
        
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
        };
        
        this.socket.onclose = () => {
            console.log('WebSocket disconnected');
            this.isConnected = false;
            // Try to reconnect after 5 seconds
            setTimeout(() => this.connect(), 5000);
        };
        
        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        this.socket.onmessage = (event) => {
            try {
                // Check if message is HTML (HTMX updates)
                if (event.data.trim().startsWith('<')) {
                    // Let HTMX handle this
                    return;
                }
                
                // Handle JSON messages
                const data = JSON.parse(event.data);
                
                switch (data.type) {
                    case 'initial_state':
                        this.handleInitialState(data);
                        break;
                    case 'status_update':
                        this.handleStatusUpdate(data);
                        break;
                    case 'step_update':
                        // Handled by HTMX, but can add additional processing here
                        break;
                    case 'error':
                        this.handleError(data);
                        break;
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };
    }

    handleInitialState(data) {
        const item = data.item;
        
        // Update status badge
        if (this.statusBadge && item.status) {
            this.updateStatusBadge(item.status);
        }
        
        // Update progress if needed
        if (this.progressBar && item.progress) {
            this.updateProgress(item.progress);
        }
    }

    handleStatusUpdate(data) {
        // Update status badge
        if (this.statusBadge && data.status) {
            this.updateStatusBadge(data.status);
        }
        
        // Update progress bar
        if (this.progressBar && data.progress !== undefined) {
            this.updateProgress(data.progress);
        }
        
        // Handle completion
        if (data.status === 'completed') {
            if (this.cancelButton) {
                this.cancelButton.remove();
            }
            
            // Reload page to show results if needed
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        }
        
        // Handle cancellation
        if (data.status === 'cancelled') {
            if (this.cancelButton) {
                this.cancelButton.remove();
            }
        }
    }

    updateStatusBadge(status) {
        this.statusBadge.textContent = status.charAt(0).toUpperCase() + status.slice(1);
        
        // Remove all existing color classes
        this.statusBadge.classList.remove(
            'bg-gradient-primary', 
            'bg-gradient-success', 
            'bg-gradient-warning', 
            'bg-gradient-danger', 
            'bg-gradient-info'
        );
        
        // Add appropriate color class
        switch (status) {
            case 'pending':
                this.statusBadge.classList.add('bg-gradient-warning');
                break;
            case 'in_progress':
                this.statusBadge.classList.add('bg-gradient-info');
                break;
            case 'completed':
                this.statusBadge.classList.add('bg-gradient-success');
                break;
            case 'failed':
                this.statusBadge.classList.add('bg-gradient-danger');
                break;
            case 'cancelled':
                this.statusBadge.classList.add('bg-gradient-warning');
                break;
            default:
                this.statusBadge.classList.add('bg-gradient-primary');
        }
    }

    updateProgress(progress) {
        this.progressBar.style.width = `${progress}%`;
        this.progressBar.setAttribute('aria-valuenow', progress);
    }

    handleError(data) {
        console.error('WebSocket error:', data.message);
        // Optionally show an error toast or modal here
    }
}
```

## Services Layer

Create a services layer for business logic in `services.py`:

```python
import logging
from typing import Dict, Optional, List
from django.db import transaction
from .models import YourModel

logger = logging.getLogger(__name__)

class YourService:
    @staticmethod
    def update_item_status(item_id: int, status: str) -> Optional[YourModel]:
        """Update item status."""
        try:
            with transaction.atomic():
                item = YourModel.objects.select_for_update().get(id=item_id)
                item.status = status
                item.save(update_fields=['status'])
                return item
        except YourModel.DoesNotExist:
            logger.error(f"Item {item_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating item status: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_item_progress(item_id: int, step_data: Dict) -> Optional[YourModel]:
        """Update item progress steps."""
        try:
            with transaction.atomic():
                item = YourModel.objects.select_for_update().get(id=item_id)
                
                # Ensure progress_data is a valid list
                progress_data = item.progress_data
                if progress_data is None or not isinstance(progress_data, list):
                    progress_data = []
                
                # Add the step data
                progress_data.append(step_data)
                item.progress_data = progress_data
                item.save(update_fields=['progress_data'])
                
                return item
        except YourModel.DoesNotExist:
            logger.error(f"Item {item_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating item progress: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_item_results(item_id: int, results: Dict) -> Optional[YourModel]:
        """Update item results."""
        try:
            with transaction.atomic():
                item = YourModel.objects.select_for_update().get(id=item_id)
                item.result_data = results
                item.save(update_fields=['result_data'])
                return item
        except YourModel.DoesNotExist:
            logger.error(f"Item {item_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating item results: {str(e)}", exc_info=True)
            return None
```

## Tasks and Asynchronous Processing

Set up Celery tasks for asynchronous processing with progress tracking in `tasks.py`:

```python
from celery import shared_task
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from .models import YourModel
from .services import YourService
import logging
from typing import Dict, Any

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

class ProgressTracker:
    """Tracks progress of tasks and sends updates via WebSockets."""
    
    def __init__(self, item_id):
        self.item_id = item_id
        self.group_name = f"item_{item_id}"
        self.step_count = 0
        logger.info(f"Initialized ProgressTracker for item {item_id}")

    def send_update(self, update_type: str, data: Dict):
        """Send an update to the WebSocket group."""
        try:
            # Determine the message type based on the update type
            if update_type == 'status':
                message_type = 'status_update'
                message_data = {
                    'status': data.get('status', 'in_progress'),
                    'message': data.get('message', ''),
                    'progress': data.get('progress', 0)
                }
            elif update_type == 'step':
                message_type = 'step_update'
                self.step_count += 1
                message_data = {
                    'step': data.get('step', {}),
                    'step_number': self.step_count
                }
            else:
                # Default to status update
                message_type = 'status_update'
                message_data = {
                    'message': data.get('message', f'Processing {update_type}'),
                    'progress': data.get('progress', 0)
                }
            
            # Send the message to the group
            async_to_sync(channel_layer.group_send)(
                self.group_name,
                {
                    "type": message_type,
                    **message_data
                }
            )
            logger.debug(f"Sent {message_type} update for item {self.item_id}")
            
        except Exception as e:
            logger.error(f"Error sending WebSocket update for item {self.item_id}: {str(e)}", exc_info=True)
    
    def check_cancelled(self) -> bool:
        """Check if the task has been cancelled."""
        try:
            item = YourModel.objects.get(id=self.item_id)
            return item.status == 'cancelled'
        except YourModel.DoesNotExist:
            return True

@shared_task
def run_task(item_id, **kwargs):
    """Run a task with progress tracking."""
    item = None
    progress_tracker = None
    
    try:
        item = YourModel.objects.get(id=item_id)
        
        # Check if already cancelled before starting
        if item.status == 'cancelled':
            logger.info(f"Task {item_id} was already cancelled")
            return
            
        # Update status to in_progress
        YourService.update_item_status(item_id, 'in_progress')

        # Initialize progress tracker
        progress_tracker = ProgressTracker(item_id)
        
        # Check if cancelled after tracker initialization
        if progress_tracker.check_cancelled():
            logger.info(f"Task {item_id} was cancelled before starting")
            YourService.update_item_status(item_id, 'cancelled')
            progress_tracker.send_update("status", {
                "status": "cancelled",
                "message": "Task was cancelled"
            })
            return
        
        # Send initial progress update
        progress_tracker.send_update("status", {
            "status": "in_progress",
            "message": "Starting task processing",
            "progress": 10
        })
        
        # Add steps for task processing
        step1_data = {
            "step_type": "initialization",
            "title": "Initializing Task",
            "explanation": "Setting up the task parameters and environment",
            "details": "Task initialized with parameters: " + str(kwargs)
        }
        
        YourService.update_item_progress(item_id, step1_data)
        progress_tracker.send_update("step", {"step": step1_data})
        progress_tracker.send_update("status", {"progress": 20})
        
        # Check for cancellation between steps
        if progress_tracker.check_cancelled():
            YourService.update_item_status(item_id, 'cancelled')
            progress_tracker.send_update("status", {
                "status": "cancelled",
                "message": "Task was cancelled"
            })
            return
        
        # Execute the main task logic here
        # ...
        
        # Update with final step and results
        final_step = {
            "step_type": "completion",
            "title": "Task Completed",
            "explanation": "Task processing has been completed successfully",
            "details": "Final results are ready for review"
        }
        
        YourService.update_item_progress(item_id, final_step)
        progress_tracker.send_update("step", {"step": final_step})
        
        # Save the results
        results = {
            "content": "<h4>Task Results</h4><p>Processing completed successfully.</p>",
            "summary": "Task completed with all steps executed."
        }
        YourService.update_item_results(item_id, results)
        
        # Mark as completed
        YourService.update_item_status(item_id, 'completed')
        progress_tracker.send_update("status", {
            "status": "completed",
            "message": "Task has been completed successfully",
            "progress": 100
        })
        
    except Exception as e:
        logger.error(f"Error processing task {item_id}: {str(e)}", exc_info=True)
        
        # Update status to failed
        if item:
            YourService.update_item_status(item_id, 'failed')
        
        # Send error update
        if progress_tracker:
            progress_tracker.send_update("status", {
                "status": "failed",
                "message": f"Error: {str(e)}",
                "progress": 0
            })
```

## URL Configuration

Set up URL paths in `urls.py`:

```python
from django.urls import path
from . import views

app_name = 'your_app'

urlpatterns = [
    path('', views.item_list, name='list'),
    path('create/', views.item_create, name='create'),
    path('<int:item_id>/', views.item_detail, name='detail'),
    path('<int:item_id>/cancel/', views.cancel_item, name='cancel'),
    # HTMX endpoints
    path('<int:item_id>/progress/', views.item_progress, name='progress'),
    path('<int:item_id>/results/', views.item_results, name='results'),
]
```

## Forms

Create forms for data input in `forms.py`:

```python
from django import forms
from .models import YourModel

class ItemForm(forms.ModelForm):
    class Meta:
        model = YourModel
        fields = ['title', 'description']
        widgets = {
            'title': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter title...'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Enter description...'
            })
        }
```

## Admin Configuration

Set up Django admin in `admin.py`:

```python
from django.contrib import admin
from .models import YourModel

@admin.register(YourModel)
class YourModelAdmin(admin.ModelAdmin):
    list_display = ('title', 'user', 'status', 'created_at')
    list_filter = ('status', 'created_at')
    search_fields = ('title', 'user__username')
    readonly_fields = ('created_at', 'updated_at')
    
    fieldsets = (
        ('Basic Information', {
            'fields': ('user', 'title', 'description')
        }),
        ('Status Information', {
            'fields': ('status', 'created_at', 'updated_at')
        }),
        ('Data', {
            'fields': ('progress_data', 'result_data'),
            'classes': ('collapse',)
        })
    )
```

## Progress Tracking with WebSockets

The above components work together to create a seamless progress tracking system:

1. **Backend Processing**: 
   - Celery task executes asynchronously
   - ProgressTracker updates WebSocket channels

2. **WebSocket Communication**:
   - Consumer handles connections and messages
   - Sends both JSON data and HTML fragments for HTMX

3. **Frontend Updates**:
   - HTMX automatically applies HTML updates from WebSocket
   - JavaScript handles other state updates

### Communication Protocol

The standardized message protocol for WebSocket communication uses consistent message types:

1. `initial_state` - Sends current state when client connects
2. `status_update` - Updates the status, progress bar, and status badge 
3. `step_update` - Adds or updates a progress step
4. `error` - Communicates error information

### HTMX Out-of-Band Swaps

For dynamic updates without full page refresh, use HTMX's out-of-band swaps:

```html
<div id="unique-id" hx-swap-oob="beforeend:#container-id">
    <!-- Content to be inserted -->
</div>
```

This allows the consumer to send HTML fragments that update specific parts of the page without JavaScript.

## Conclusion

This template provides a complete structure for creating agent-driven apps with real-time updates using WebSockets and HTMX. By following these patterns, you can quickly create new apps that leverage the existing infrastructure for:

1. Model definition and persistence
2. WebSocket real-time communication
3. HTMX-powered dynamic updates
4. Asynchronous task processing with Celery
5. Progress tracking and visualization
6. Standardized UI components
7. Error handling and recovery

For new apps, simply copy this template structure, customize the models and business logic, and leverage the existing patterns for WebSocket and HTMX integration.

================
File: urls.py
================
from django.urls import path
from . import views

app_name = 'research'

urlpatterns = [
    path('', views.research_list, name='list'),
    path('create/', views.research_create, name='create'),
    path('<int:research_id>/', views.research_detail, name='detail'),
    path('<int:research_id>/cancel/', views.cancel_research, name='cancel'),
    # HTMX endpoints
    path('<int:research_id>/progress/', views.research_progress, name='progress'),
    path('<int:research_id>/sources/', views.research_sources, name='sources'),
    path('<int:research_id>/reasoning/', views.research_reasoning, name='reasoning'),
]

================
File: views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse
from django.urls import reverse
from django.template.loader import render_to_string
from django.views.decorators.csrf import ensure_csrf_cookie
from django.views.decorators.http import require_POST
from django.conf import settings
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import json
import logging

from .models import Research
from .forms import ResearchForm
from .tasks import run_research
from apps.common.utils import get_models

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

@login_required
def research_create(request):
    """Create a new research task."""
    available_models = get_models()
    selected_model = getattr(settings, 'GENERAL_MODEL', available_models[0] if available_models else None)
    
    if request.method == 'POST':
        form = ResearchForm(request.POST)
        if form.is_valid():
            # Create and save the research object
            research = form.save(commit=False)
            research.user = request.user
            research.save()
            
            # Get selected model from form
            model_name = request.POST.get('model', selected_model)
            
            # Start Celery task with selected model
            run_research.delay(
                research_id=research.id,
                model_name=model_name,
                tool_params={
                    'llm_model': model_name
                }
            )
            
            return redirect('research:detail', research_id=research.id)
    else:
        form = ResearchForm()
    
    return render(request, 'research/create.html', {
        'form': form,
        'available_models': available_models,
        'selected_model': selected_model
    })

@ensure_csrf_cookie
@login_required
def research_detail(request, research_id):
    """View details of a research task."""
    research = get_object_or_404(Research, id=research_id, user=request.user)
    available_models = get_models()
    selected_model = getattr(settings, 'GENERAL_MODEL', available_models[0] if available_models else None)
    
    return render(request, 'research/detail.html', {
        'research': research,
        'available_models': json.dumps(available_models),
        'selected_model': selected_model
    })

@login_required
def research_list(request):
    """List all research tasks for the current user."""
    researches = Research.objects.filter(user=request.user)
    return render(request, 'research/list.html', {
        'researches': researches
    })

@require_POST
@login_required
def cancel_research(request, research_id):
    """Cancel a running research task."""
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    if research.status in ['pending', 'in_progress']:
        # Update status in database
        research.status = 'cancelled'
        research.save(update_fields=['status'])
        
        # Send cancellation message through WebSocket
        async_to_sync(channel_layer.group_send)(
            f"research_{research_id}",
            {
                "type": "status_update",
                "status": "cancelled",
                "message": "Research cancelled by user",
                "progress": 0
            }
        )
        
        return HttpResponse(status=200)
    
    return HttpResponse(status=400)

@login_required
def research_progress(request, research_id):
    """HTMX endpoint for progress updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    # Calculate progress percentage
    progress = 0
    if research.status == 'completed':
        progress = 100
    elif research.status == 'in_progress':
        # Estimate progress based on steps
        step_count = len(research.reasoning_steps)
        expected_total = 10  # Typical number of steps
        progress = min(95, int((step_count / expected_total) * 100))
    
    return render(request, 'research/partials/progress.html', {
        'research': research,
        'progress': progress
    })

@login_required
def research_sources(request, research_id):
    """HTMX endpoint for sources updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    return render(request, 'research/partials/sources.html', {
        'research': research
    })

@login_required
def research_reasoning(request, research_id):
    """HTMX endpoint for reasoning chain updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    return render(request, 'research/partials/steps.html', {
        'research': research
    })
