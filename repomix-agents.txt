This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-21T14:30:42.000Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
agents/
  chat/
    formatters/
      __init__.py
      output_formatter.py
      table_formatter.py
      tool_formatter.py
    managers/
      message_manager.py
      prompt_manager.py
      token_manager.py
      tool_manager.py
    tests/
      test_callback_handler.py
    history.py
  clients/
    manager.py
  static/
    agents/
      js/
        chat/
          app.js
          index.js
        components/
          tool_outputs/
            base.js
          message_list.js
          message.js
        services/
          message_handler.js
          websocket.js
        crew_kanban.js
  templates/
    agents/
      modals/
        details_modal.html
        human_input_modal.html
        start_execution_modal.html
      agent_form.html
      base_agents.html
      chat.html
      confirm_delete.html
      connection_test.html
      crew_detail.html
      crew_form.html
      crew_kanban.html
      crew_list.html
      crewai_home.html
      dashboard_home.html
      execution_detail.html
      execution_list.html
      manage_agents_card_view.html
      manage_agents.html
      manage_crews_card_view.html
      manage_crews.html
      manage_pipelines.html
      manage_tasks.html
      manage_tools.html
      task_form.html
      tool_form.html
  templatetags/
    __init__.py
    agent_filters.py
    agent_tags.py
  tests/
    integration/
      test_callback_flow.py
  utils/
    error_handling.py
    formatters.py
  websockets/
    handlers/
      agent_handler.py
      callback_handler.py
    services/
      chat_service.py
    __init__.py
    base.py
    chat_consumer.py
    consumers.py
    crew_consumer.py
  admin.py
  apps.py
  celery.py
  consumers.py
  forms.py
  kanban_consumers.py
  models.py
  routing.py
  tasks.py
  tests.py
  tools.py
  urls.py
  utils.py
  views_agents.py
  views_chat.py
  views_crews.py
  views_kanban.py
  views_tasks.py
  views_tools.py
  views.py

================================================================
Repository Files
================================================================

================
File: agents/chat/formatters/__init__.py
================
from .table_formatter import TableFormatter
from .tool_formatter import ToolFormatter
from .output_formatter import OutputFormatter

__all__ = ['TableFormatter', 'ToolFormatter', 'OutputFormatter']

================
File: agents/chat/formatters/output_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class OutputFormatter:
    """Handles general output formatting"""
    
    @staticmethod
    def format_response(response: Dict) -> str:
        """Format agent response"""
        try:
            output = response.get("output")
            if not output:
                return "No response generated"
                
            # If output is a dict, check for tabular data
            if isinstance(output, dict):
                if "formatted_table" in output:
                    return output["formatted_table"]
                if TableFormatter.detect_tabular_data(output):
                    return TableFormatter.format_table(output)
                return json.dumps(output, indent=2)
                
            # If output is a string but contains JSON, try to parse and format
            if isinstance(output, str) and (output.startswith('{') or output.startswith('[')):
                try:
                    json_data = json.loads(output)
                    if "formatted_table" in json_data:
                        return json_data["formatted_table"]
                    if TableFormatter.detect_tabular_data(json_data):
                        return TableFormatter.format_table(json_data)
                    return json.dumps(json_data, indent=2)
                except json.JSONDecodeError:
                    pass
                    
            return output

        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}", exc_info=True)
            return "Error formatting response"

    @staticmethod
    def format_final_answer(content: Any) -> str:
        """Format the final agent response"""
        try:
            # Format as table if possible
            if TableFormatter.detect_tabular_data(content):
                content = TableFormatter.format_table(content)
            return f'<div class="agent-response">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting final answer: {str(e)}")
            return str(content)

================
File: agents/chat/formatters/table_formatter.py
================
from typing import Any, Dict, List, Union
import json
import logging

logger = logging.getLogger(__name__)

class TableFormatter:
    """Generic table formatter for structured data"""
    
    @staticmethod
    def _is_json(data: str) -> bool:
        """Check if string is valid JSON"""
        try:
            json.loads(data)
            return True
        except (json.JSONDecodeError, TypeError):
            return False

    @staticmethod
    def _is_csv(data: str) -> bool:
        """Check if string appears to be CSV data"""
        if not isinstance(data, str):
            return False
        return (',' in data and 
                '\n' in data and 
                '{' not in data and 
                '[' not in data)

    @staticmethod
    def _parse_csv(csv_data: str) -> List[Dict]:
        """Convert CSV string to list of dictionaries"""
        try:
            lines = csv_data.strip().split('\n')
            headers = [h.strip() for h in lines[0].split(',')]
            
            return [
                {
                    headers[i]: value.strip() 
                    for i, value in enumerate(line.split(','))
                    if i < len(headers)
                }
                for line in lines[1:]
            ]
        except Exception as e:
            logger.error(f"Error parsing CSV: {str(e)}", exc_info=True)
            return []

    @staticmethod
    def _find_tabular_data(data: Any) -> Union[List[Dict], None]:
        """
        Recursively search for tabular data in the structure.
        Returns the first found list of dictionaries with consistent keys.
        """
        # Handle string input
        if isinstance(data, str):
            if TableFormatter._is_json(data):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return None
            elif TableFormatter._is_csv(data):
                return TableFormatter._parse_csv(data)
            else:
                return None

        # Handle list of dictionaries
        if isinstance(data, list) and data:
            if all(isinstance(item, dict) for item in data):
                # Get all unique keys from all objects
                keys = set().union(*(item.keys() for item in data))
                if keys:  # If we have keys, it's tabular
                    return data
            
            # Check each list item for nested tabular data
            for item in data:
                result = TableFormatter._find_tabular_data(item)
                if result:
                    return result

        # Handle dictionary
        if isinstance(data, dict):
            # First check direct values
            for value in data.values():
                if isinstance(value, list) and value:
                    if all(isinstance(item, dict) for item in value):
                        return value
            
            # Then check nested structures
            for value in data.values():
                result = TableFormatter._find_tabular_data(value)
                if result:
                    return result

        return None

    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data contains tabular structure anywhere in the hierarchy"""
        try:
            return TableFormatter._find_tabular_data(data) is not None
        except Exception:
            logger.error("Error detecting tabular data", exc_info=True)
            return False

    @staticmethod
    def format_table(data: Any) -> str:
        """Format tabular data into a markdown table"""
        try:
            tabular_data = TableFormatter._find_tabular_data(data)
            if not tabular_data:
                return str(data)

            # Get all unique keys from all objects
            keys = list(set().union(*(item.keys() for item in tabular_data)))
            
            # Calculate column widths
            col_widths = {key: len(str(key)) for key in keys}
            for row in tabular_data:
                for key in keys:
                    value = row.get(key)
                    if value is None:
                        continue
                    elif isinstance(value, (dict, list)):
                        str_value = json.dumps(value)
                    else:
                        str_value = str(value)
                    col_widths[key] = max(col_widths[key], len(str_value))

            # Build table
            # Header row
            table = "| " + " | ".join(
                str(key).ljust(col_widths[key]) 
                for key in keys
            ) + " |\n"
            
            # Separator row
            table += "|" + "|".join(
                "-" * (col_widths[key] + 2) 
                for key in keys
            ) + "|\n"
            
            # Data rows
            for row in tabular_data:
                table += "| " + " | ".join(
                    str(row.get(key, '')).ljust(col_widths[key]) 
                    for key in keys
                ) + " |\n"

            return table

        except Exception as e:
            logger.error(f"Error formatting table: {str(e)}", exc_info=True)
            return str(data)  # Return original data if formatting fails

================
File: agents/chat/formatters/tool_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class ToolFormatter:
    """Handles formatting of tool outputs and usage messages"""
    
    @staticmethod
    def format_tool_output(content: Any) -> str:
        """Format tool output with proper styling"""
        try:
            if isinstance(content, dict):
                return f'<div class="json-output">{json.dumps(content, indent=2)}</div>'
            elif isinstance(content, str):
                # Try to parse as JSON first
                try:
                    json_content = json.loads(content)
                    return f'<div class="json-output">{json.dumps(json_content, indent=2)}</div>'
                except json.JSONDecodeError:
                    pass
                
                # Format as table if possible
                if TableFormatter.detect_tabular_data(content):
                    content = TableFormatter.format_table(content)
            
            return f'<div class="tool-output">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting tool output: {str(e)}")
            return str(content)

    @staticmethod
    def format_tool_usage(content: str, message_type: str = None) -> str:
        """Format tool usage messages"""
        if message_type == "tool_start" and content.startswith('Using tool:'):
            tool_info = content.split('\n')
            formatted = f'''
            <div class="tool-usage">
                <i class="fas fa-tools"></i>
                <div>
                    <strong>{tool_info[0]}</strong>
                    <div class="tool-input">{tool_info[1] if len(tool_info) > 1 else ''}</div>
                </div>
            </div>
            '''
            return formatted
        elif message_type == "tool_error":
            return f'''
            <div class="tool-error">
                <i class="fas fa-exclamation-triangle"></i>
                <div>{content}</div>
            </div>
            '''
        return content

    @staticmethod
    def format_tool_result(observation: Any) -> Dict:
        """Format tool output into a standardized structure"""
        try:
            result_data = {
                'tool_type': None,
                'format': None,
                'data': None,
                'metadata': {}
            }

            if isinstance(observation, dict):
                # Handle tabular data
                if TableFormatter.detect_tabular_data(observation):
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'table',
                        'data': TableFormatter.format_table(observation),
                        'metadata': {
                            'raw_data': observation.get('raw_data', {}),
                            'tool': observation.get('tool')
                        }
                    })
                
                # Handle validation errors
                elif observation.get('type') == 'error':
                    result_data.update({
                        'tool_type': 'error',
                        'format': 'error',
                        'data': {
                            'message': observation.get('message'),
                            'error_type': observation.get('error'),
                            'suggestion': observation.get('suggestion')
                        }
                    })
                
                # Handle other structured data
                else:
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'json',
                        'data': json.dumps(observation, indent=2),
                        'metadata': {
                            'tool': observation.get('tool')
                        }
                    })

            return result_data

        except Exception as e:
            logger.error(f"Error formatting tool result: {str(e)}", exc_info=True)
            return {
                'tool_type': 'error',
                'format': 'error',
                'data': {
                    'message': str(e),
                    'error_type': 'formatting_error'
                }
            }

================
File: agents/chat/managers/message_manager.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage, SystemMessage
from django.core.cache import cache
from typing import List, Optional, Dict, Any
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter
from apps.agents.chat.formatters.table_formatter import TableFormatter
from apps.agents.models import ChatMessage
import logging
import json

logger = logging.getLogger(__name__)

def messages_to_dict(messages: List[BaseMessage]) -> List[Dict]:
    """Convert message objects to dictionary format for storage."""
    return [{
        'type': message.__class__.__name__,
        'content': message.content,
        'additional_kwargs': message.additional_kwargs
    } for message in messages]

def dict_to_messages(messages_dict: List[Dict]) -> List[BaseMessage]:
    """Convert dictionary format back to message objects."""
    message_types = {
        'HumanMessage': HumanMessage,
        'AIMessage': AIMessage,
        'SystemMessage': SystemMessage
    }
    
    return [
        message_types[msg['type']](
            content=msg['content'],
            additional_kwargs=msg.get('additional_kwargs', {})
        ) for msg in messages_dict
    ]

class MessageManager(BaseChatMessageHistory):
    """
    Manages chat message history, storage, and formatting.
    Consolidates message-related functionality from across the codebase.
    """
    
    def __init__(self, 
                 conversation_id: Optional[str] = None,
                 session_id: Optional[str] = None,
                 agent_id: Optional[int] = None,
                 ttl: int = 3600):
        """
        Initialize the MessageManager.
        
        Args:
            conversation_id: Unique identifier for the conversation
            session_id: Unique identifier for the current session
            agent_id: ID of the agent associated with this conversation
            ttl: Time-to-live for cached messages in seconds
        """
        super().__init__()
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.agent_id = agent_id
        self.ttl = ttl
        self.tool_formatter = ToolFormatter()
        self.messages_cache_key = f"messages_{self.session_id}"
        self._messages = []

    @property
    def messages(self) -> List[BaseMessage]:
        """Get all messages in the history. Required by BaseChatMessageHistory."""
        if self.messages_cache_key:
            messages_dict = cache.get(self.messages_cache_key, [])
            return dict_to_messages(messages_dict)
        return self._messages.copy()

    @messages.setter
    def messages(self, messages: List[BaseMessage]) -> None:
        """Set messages in the history. Required by BaseChatMessageHistory."""
        self._messages = messages.copy()
        if self.messages_cache_key:
            messages_dict = messages_to_dict(messages)
            cache.set(self.messages_cache_key, messages_dict, self.ttl)

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> None:
        """
        Add a message to the history and persist it.
        This is the central function for all message persistence.
        
        Args:
            message: The message to add
            token_usage: Optional token usage stats
        """
        try:
            # Store in database only if we have a conversation ID
            if self.conversation_id:
                await self._store_message_in_db(message, token_usage)
                
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    async def get_messages(self) -> List[BaseMessage]:
        """Get all messages in the history."""
        try:
            if self.conversation_id:
                from apps.agents.models import ChatMessage
                messages = await database_sync_to_async(
                    lambda: list(ChatMessage.objects.filter(
                        conversation_id=self.conversation_id
                    ).order_by('timestamp'))
                )()
                return [
                    HumanMessage(content=msg.content) if not msg.is_agent 
                    else AIMessage(content=msg.content)
                    for msg in messages
                ]
            return []
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}")
            return []

    def add_messages(self, messages: List[BaseMessage]) -> None:
        """Add multiple messages to the history."""
        for message in messages:
            self.add_message(message)

    def clear(self) -> None:
        """Required abstract method: Clear all messages."""
        pass  # No cache to clear anymore

    async def clear_messages(self) -> None:
        """Clear all messages from the history."""
        try:
            if self.conversation_id:
                await database_sync_to_async(ChatMessage.objects.filter(
                    conversation_id=self.conversation_id
                ).delete)()
                
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    @database_sync_to_async
    def _store_message_in_db(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> None:
        """
        Store a message in the database.
        Centralized database persistence function.
        """
        try:
            from apps.agents.models import ChatMessage, Conversation, TokenUsage, ToolRun, Tool
            
            # Get the conversation
            conversation = Conversation.objects.filter(
                id=self.conversation_id
            ).select_related('user', 'agent').first()
            
            if not conversation:
                logger.error(f"No conversation found with ID: {self.conversation_id}")
                return None
                
            # Determine if message is from agent or user
            is_agent = not isinstance(message, HumanMessage)
            
            # Create the message
            chat_message = ChatMessage.objects.create(
                session_id=self.session_id,
                conversation=conversation,
                agent=conversation.agent,
                user=conversation.user,
                content=message.content,
                is_agent=is_agent,
                model=token_usage.get('model', 'unknown') if token_usage else 'unknown'
            )
            
            # Store token usage if provided
            if token_usage:
                TokenUsage.objects.create(
                    conversation=conversation,
                    message=chat_message,
                    prompt_tokens=token_usage.get('prompt_tokens', 0),
                    completion_tokens=token_usage.get('completion_tokens', 0),
                    total_tokens=token_usage.get('total_tokens', 0),
                    model=token_usage.get('model', 'unknown'),
                    metadata={'message_type': message.__class__.__name__}
                )
            
            # Store tool runs if this is a tool-related message
            if message.additional_kwargs.get('tool_call'):
                tool_call = message.additional_kwargs['tool_call']
                tool_name = tool_call.get('name')
                tool_input = tool_call.get('input', {})
                tool_output = tool_call.get('output')
                
                if tool_name:
                    tool = Tool.objects.filter(name=tool_name).first()
                    if tool:
                        ToolRun.objects.create(
                            tool=tool,
                            conversation=conversation,
                            message=chat_message,
                            status='completed',
                            inputs=tool_input,
                            result=tool_output
                        )
                
        except Exception as e:
            logger.error(f"Error storing message in database: {str(e)}", exc_info=True)
            raise

    @database_sync_to_async
    def _delete_subsequent_messages(self, from_index: int) -> None:
        """Delete messages after the specified index from the database."""
        try:
            if self.conversation_id:
                messages = ChatMessage.objects.filter(
                    conversation_id=self.conversation_id
                ).order_by('timestamp')[from_index:]
                messages.delete()
        except Exception as e:
            logger.error(f"Error deleting subsequent messages: {str(e)}")
            raise

    async def handle_edit(self) -> None:
        """Handle message editing by removing the edited message and subsequent messages."""
        try:
            messages = await self.get_messages()
            
            # Find the last human message index
            last_human_idx = None
            for i in range(len(messages) - 1, -1, -1):
                if isinstance(messages[i], HumanMessage):
                    last_human_idx = i
                    break

            if last_human_idx is not None:
                # Keep messages up to the last human message
                messages = messages[:last_human_idx]
                
                # Update cache
                if self.messages_cache_key:
                    messages_dict = messages_to_dict(messages)
                    cache.set(self.messages_cache_key, messages_dict, self.ttl)
                
                # Update database
                if self.conversation_id:
                    await self._delete_subsequent_messages(last_human_idx)
                    
        except Exception as e:
            logger.error(f"Error handling message edit: {str(e)}")
            raise

    def format_message(self, content: Any, message_type: Optional[str] = None) -> str:
        """Format a message for display."""
        try:
            # If content is a dict, convert to string representation
            if isinstance(content, dict):
                return json.dumps(content, indent=2)
                
            # Handle tool messages
            if message_type and message_type.startswith('tool_'):
                return self.tool_formatter.format_tool_usage(str(content), message_type)
                
            return str(content)
        except Exception as e:
            logger.error(f"Error formatting message: {str(e)}")
            return str(content)

    async def get_conversation_summary(self) -> str:
        """Get a summary of the conversation."""
        messages = await self.get_messages()
        if not messages:
            return "No messages in conversation"
        
        summary_parts = []
        for msg in messages:
            msg_type = msg.__class__.__name__.replace('Message', '')
            summary_parts.append(f"{msg_type}: {msg.content[:100]}...")
        
        return "\n".join(summary_parts)

================
File: agents/chat/managers/prompt_manager.py
================
import logging
from typing import Dict, List, Optional, Any, Union
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import SystemMessage, HumanMessage, AIMessage
from langchain_core.messages import BaseMessage
from django.utils import timezone
import json

logger = logging.getLogger(__name__)

class PromptManager:
    """
    Manages prompt generation, formatting, and template management for chat agents.
    Consolidates prompt-related functionality from across the codebase.
    """
    
    def __init__(self, system_prompt: Optional[str] = None):
        """
        Initialize the PromptManager.
        
        Args:
            system_prompt: Optional system prompt to use as default
        """
        self.system_prompt = system_prompt or self._get_default_system_prompt()
        self.prompt_templates = {}
        self._box_width = 80

    def _get_default_system_prompt(self) -> str:
        """Get the default system prompt."""
        return """You are a helpful AI assistant. You aim to provide accurate, helpful responses
        while maintaining a professional and friendly tone. You will:
        1. Answer questions clearly and concisely
        2. Use appropriate tools when needed
        3. Admit when you don't know something
        4. Ask for clarification when needed"""

    def create_chat_prompt(self, 
                         system_prompt: Optional[str] = None,
                         additional_context: Optional[Dict] = None) -> ChatPromptTemplate:
        """
        Create a chat prompt template with system message and message history.
        
        Args:
            system_prompt: Optional override for system prompt
            additional_context: Optional additional context to include
        """
        # Create the system prompt with explicit JSON format instructions
        system_template = '''{system_prompt}

You have access to the following tools:

{tools}

Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

Valid "action" values: "Final Answer" or {tool_names}

Provide only ONE action per $JSON_BLOB, as shown:

```
{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}
```

Follow this format:

Question: input question to answer
Thought: consider previous and subsequent steps
Action:
```
$JSON_BLOB
```
Observation: action result
... (repeat Thought/Action/Observation N times)
Thought: I know what to respond
Action:
```
{{
  "action": "Final Answer",
  "action_input": "Final response to human"
}}
```

Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate. Format is Action:```$JSON_BLOB```then Observation'''

        human_template = '''
{input}

{agent_scratchpad}

(reminder to respond in a JSON blob no matter what)'''

        # Create messages with proper order and format
        messages = [
            ("system", system_template),
            MessagesPlaceholder(variable_name="chat_history"),
            ("human", human_template),
        ]
            
        # Create the prompt template
        prompt = ChatPromptTemplate.from_messages(messages)
        
        # Get chat history from additional context and ensure it's properly formatted
        chat_history = additional_context.get('chat_history', [])
        if isinstance(chat_history, str):
            # If it's a string, try to parse it as messages
            try:
                chat_history = self.format_chat_history(chat_history)
            except:
                chat_history = []
        
        # Partial with the provided values, ensuring system_prompt is used
        return prompt.partial(
            system_prompt=system_prompt or self.system_prompt,
            tools=additional_context.get('tools', ''),
            tool_names=additional_context.get('tool_names', ''),
            chat_history=chat_history
        )

    def format_chat_history(self, messages: Union[str, List[BaseMessage], List[Dict]]) -> List[BaseMessage]:
        """
        Format chat history for prompt inclusion.
        Handles string, dict, and BaseMessage formats.
        """
        if isinstance(messages, str):
            # Try to parse string as JSON list of messages
            try:
                messages = json.loads(messages)
            except:
                return []
        
        formatted_messages = []
        for msg in messages:
            if isinstance(msg, BaseMessage):
                formatted_messages.append(msg)
            elif isinstance(msg, dict):
                # Convert dict to appropriate message type
                content = msg.get('content', '')
                if msg.get('type') == 'human' or msg.get('is_user', False):
                    formatted_messages.append(HumanMessage(content=content))
                else:
                    formatted_messages.append(AIMessage(content=content))
            else:
                self.logger.warning(f"Unhandled message format: {type(msg)}")
                
        return formatted_messages

    def _format_context(self, context: Dict) -> str:
        """Format additional context into a string."""
        context_parts = []
        for key, value in context.items():
            if isinstance(value, (list, dict)):
                context_parts.append(f"{key}:\n{self._format_structured_value(value)}")
            else:
                context_parts.append(f"{key}: {value}")
        return "\n".join(context_parts)

    def _format_structured_value(self, value: Any, indent: int = 2) -> str:
        """Format structured values (lists/dicts) with proper indentation."""
        if isinstance(value, list):
            return "\n".join(" " * indent + f"- {item}" for item in value)
        elif isinstance(value, dict):
            return "\n".join(" " * indent + f"{k}: {v}" for k, v in value.items())
        return str(value)

    def create_tool_prompt(self, tool_name: str, tool_args: Dict) -> str:
        """Create a prompt for tool execution."""
        return f"Using tool: {tool_name}\nInput: {tool_args}"

    def create_error_prompt(self, error: str) -> str:
        """Create a prompt for error messages."""
        return f"Error occurred: {error}\nPlease try again or use a different approach."

    def register_prompt_template(self, name: str, template: str) -> None:
        """Register a new prompt template."""
        self.prompt_templates[name] = template

    def get_prompt_template(self, name: str) -> Optional[str]:
        """Get a registered prompt template."""
        return self.prompt_templates.get(name)

    def format_prompt(self, template_name: str, **kwargs) -> Optional[str]:
        """Format a registered prompt template with provided arguments."""
        template = self.get_prompt_template(template_name)
        if template:
            try:
                return template.format(**kwargs)
            except KeyError as e:
                logger.error(f"Missing required argument in prompt template: {str(e)}")
            except Exception as e:
                logger.error(f"Error formatting prompt template: {str(e)}")
        return None 

    def create_agent_prompt(self, agent, client_data: Optional[Dict] = None) -> str:
        """
        Create the system prompt for the agent with client context.
        
        Args:
            agent: The agent instance
            client_data: Optional dictionary containing client information
        """
        try:
            # Base agent prompt with escaped variables
            prompt = f"""You are {agent.name}, an AI assistant.

Role: {agent.role}

Goal: {{{{goal}}}}

Backstory: {agent.backstory if hasattr(agent, 'backstory') else ''}
"""
            # Add client context if available
            if client_data:
                client_context = self._create_client_context(client_data)
                prompt += f"\n{client_context}"
            else:
                prompt += f"\nCurrent Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

            # Replace the goal placeholder with actual goal if available
            if hasattr(agent, 'goal'):
                prompt = prompt.replace('{{goal}}', agent.goal)
            else:
                prompt = prompt.replace('{{goal}}', 'Help users accomplish their tasks effectively.')

            return prompt

        except Exception as e:
            logger.error(f"Error creating agent prompt: {str(e)}", exc_info=True)
            return self._get_default_system_prompt()

    def _create_client_context(self, client_data: Dict) -> str:
        """Create formatted client context string."""
        try:
            client = client_data.get('client')
            if not client:
                return f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

            context = f"""Current Context:
- Client ID: {client.id}
- Client Name: {client.name}
- Website URL: {client.website_url}
- Target Audience: {client.target_audience or 'N/A'}
- Current Date: {timezone.now().strftime('%Y-%m-%d')}

IMPORTANT: When using tools that require client_id, always use {client.id} as the client_id parameter.
"""
            # Add business objectives if present
            if client.business_objectives:
                objectives_text = "\n".join([f"- {obj}" for obj in client.business_objectives])
                context += f"\n\nBusiness Objectives:\n{objectives_text}"

            # Add client profile if available
            if client.client_profile:
                context += f"\n\nClient Profile:\n{client.client_profile}"

            return self._create_box(context, "🔍 CLIENT CONTEXT")

        except Exception as e:
            logger.error(f"Error creating client context: {str(e)}", exc_info=True)
            return f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

    def _create_box(self, content: str, title: str = "") -> str:
        """Create a pretty ASCII box with content for logging."""
        lines = []
        width = self._box_width
        
        # Top border with title
        if title:
            title = f" {title} "
            padding = (width - len(title)) // 2
            lines.append("╔" + "═" * padding + title + "═" * (width - padding - len(title)) + "╗")
        else:
            lines.append("╔" + "═" * width + "╗")
            
        # Content
        for line in content.split('\n'):
            # Split long lines
            while len(line) > width:
                split_at = line[:width].rfind(' ')
                if split_at == -1:
                    split_at = width
                lines.append("║ " + line[:split_at].ljust(width-2) + " ║")
                line = line[split_at:].lstrip()
            lines.append("║ " + line.ljust(width-2) + " ║")
            
        # Bottom border
        lines.append("╚" + "═" * width + "╝")
        
        return "\n".join(lines)

================
File: agents/chat/managers/token_manager.py
================
import logging
import tiktoken
from django.core.cache import cache
from django.db import models
from typing import Dict, Optional, Any
from channels.db import database_sync_to_async
from apps.agents.models import TokenUsage
from apps.common.utils import get_llm
from datetime import datetime
import uuid

logger = logging.getLogger(__name__)

class TokenManager:
    """
    Manages token counting, tracking, and limits for chat conversations.
    Consolidates token-related functionality from across the codebase.
    """
    
    def __init__(self, 
                 conversation_id: Optional[str] = None,
                 session_id: Optional[str] = None,
                 max_token_limit: int = 16384,
                 model_name: str = "gpt-3.5-turbo"):
        """
        Initialize the TokenManager.
        
        Args:
            conversation_id: Unique identifier for the conversation
            session_id: Unique identifier for the current session
            max_token_limit: Maximum number of tokens allowed in conversation history
            model_name: Name of the model to use for tokenization
        """
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.max_token_limit = max_token_limit
        self.model_name = model_name
        # Use the same tokenizer setup as utils.py
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
        self.input_tokens = 0
        self.output_tokens = 0
        self.token_callback = None

    def count_tokens(self, text: str) -> int:
        """Count tokens in text using the initialized tokenizer."""
        try:
            return len(self.tokenizer.encode(text, disallowed_special=()))
        except Exception as e:
            logger.error(f"Error counting tokens: {str(e)}")
            return 0

    def set_token_callback(self, callback):
        """Set the token callback from the LLM."""
        self.token_callback = callback

    def track_token_usage(self, prompt_tokens: int, completion_tokens: int) -> None:
        """Track token usage for the current session."""
        self.input_tokens += prompt_tokens
        self.output_tokens += completion_tokens
        
        if self.session_id:
            session_cache_key = f"token_totals_{self.session_id}"
            session_totals = cache.get(session_cache_key, {
                'prompt_tokens': 0,
                'completion_tokens': 0,
                'total_tokens': 0
            })
            
            session_totals['prompt_tokens'] += prompt_tokens
            session_totals['completion_tokens'] += completion_tokens
            session_totals['total_tokens'] += (prompt_tokens + completion_tokens)
            
            cache.set(session_cache_key, session_totals, 3600)  # 1 hour expiry

    def get_current_usage(self) -> Dict[str, int]:
        """Get current token usage for the session."""
        if self.token_callback:
            input_tokens = getattr(self.token_callback, 'input_tokens', 0) or 0
            output_tokens = getattr(self.token_callback, 'output_tokens', 0) or 0
            return {
                'prompt_tokens': input_tokens,
                'completion_tokens': output_tokens,
                'total_tokens': input_tokens + output_tokens,
                'model': self.model_name
            }
        return {
            'prompt_tokens': self.input_tokens or 0,
            'completion_tokens': self.output_tokens or 0,
            'total_tokens': (self.input_tokens or 0) + (self.output_tokens or 0),
            'model': self.model_name
        }

    def reset_tracking(self):
        """Reset token tracking for the current session."""
        self.input_tokens = 0
        self.output_tokens = 0
        if self.token_callback:
            self.token_callback.input_tokens = 0
            self.token_callback.output_tokens = 0

    async def _reset_session_token_totals(self):
        """Reset token totals for the session."""
        if self.session_id:
            cache.delete(f"token_totals_{self.session_id}")

    @database_sync_to_async
    def store_token_usage(self, message_id: str, token_usage: Dict[str, Any]):
        """Store token usage in the database."""
        if not self.conversation_id:
            return

        try:
            TokenUsage.objects.create(
                conversation_id=self.conversation_id,
                message_id=message_id,
                prompt_tokens=token_usage.get('prompt_tokens', 0),
                completion_tokens=token_usage.get('completion_tokens', 0),
                total_tokens=token_usage.get('total_tokens', 0),
                model=token_usage.get('model', ''),
                metadata=token_usage.get('metadata', {})
            )
        except Exception as e:
            logger.error(f"Error storing token usage: {str(e)}")

    @database_sync_to_async
    def get_conversation_token_usage(self) -> Dict[str, int]:
        """Get total token usage for the conversation."""
        if not self.conversation_id:
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

        try:
            usage = TokenUsage.objects.filter(conversation_id=self.conversation_id).aggregate(
                total_tokens=models.Sum('total_tokens'),
                prompt_tokens=models.Sum('prompt_tokens'),
                completion_tokens=models.Sum('completion_tokens')
            )
            return {
                'total_tokens': usage['total_tokens'] or 0,
                'prompt_tokens': usage['prompt_tokens'] or 0,
                'completion_tokens': usage['completion_tokens'] or 0
            }
        except Exception as e:
            logger.error(f"Error getting conversation token usage: {str(e)}")
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

    async def track_conversation_tokens(self):
        """Track token usage for the entire conversation."""
        if not self.conversation_id:
            return

        current_usage = self.get_current_usage()
        if current_usage['total_tokens'] > 0:
            await self.store_token_usage(
                message_id=None,  # Set to None since we're tracking conversation-level usage
                token_usage={
                    **current_usage,
                    'metadata': {'type': 'conversation_tracking'}
                }
            )

================
File: agents/chat/managers/tool_manager.py
================
import logging
from typing import List, Dict, Any, Optional
from langchain.tools import Tool, StructuredTool
from apps.agents.utils import get_tool_classes
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter

logger = logging.getLogger(__name__)

class ToolManager:
    """
    Manages tool loading, execution, and formatting.
    Consolidates tool-related functionality from across the codebase.
    """
    
    def __init__(self):
        """Initialize the ToolManager."""
        self.tools = []
        self.tool_formatter = ToolFormatter()

    async def load_tools(self, agent) -> List[Tool]:
        """Load and initialize agent tools."""
        try:
            tools = []
            seen_tools = set()
            
            # Get tools using database_sync_to_async
            agent_tools = await self._get_agent_tools(agent)
            
            for tool_model in agent_tools:
                try:
                    tool_key = f"{tool_model.tool_class}_{tool_model.tool_subclass}"
                    if tool_key in seen_tools:
                        continue
                    seen_tools.add(tool_key)

                    tool_classes = get_tool_classes(tool_model.tool_class)
                    tool_class = next((cls for cls in tool_classes 
                                   if cls.__name__ == tool_model.tool_subclass), None)
                    
                    if tool_class:
                        logger.info(f"Initializing tool: {tool_class.__name__}")
                        tool_instance = tool_class()
                        
                        # Convert to Langchain format
                        langchain_tool = self._create_langchain_tool(tool_instance)
                        if langchain_tool:
                            tools.append(langchain_tool)
                            
                except Exception as e:
                    logger.error(f"Error initializing tool {tool_model.tool_subclass}: {str(e)}")
                    continue

            self.tools = tools
            return tools
            
        except Exception as e:
            logger.error(f"Error loading tools: {str(e)}")
            raise

    @database_sync_to_async
    def _get_agent_tools(self, agent):
        """Get agent tools from database."""
        return list(agent.tools.all())

    def _create_langchain_tool(self, tool_instance) -> Optional[Tool]:
        """Create a Langchain tool from a tool instance."""
        try:
            # Use StructuredTool if args_schema is present
            if hasattr(tool_instance, 'args_schema'):
                return StructuredTool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None,
                    args_schema=tool_instance.args_schema
                )
            else:
                return Tool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None
                )
        except Exception as e:
            logger.error(f"Error creating Langchain tool: {str(e)}")
            return None

    def _create_tool_description(self, tool_instance) -> str:
        """Create a description for the tool."""
        description = tool_instance.description
        if hasattr(tool_instance, 'args_schema'):
            schema = tool_instance.args_schema.schema()
            if 'properties' in schema:
                args_desc = []
                for name, details in schema['properties'].items():
                    arg_desc = f"- {name}: {details.get('description', 'No description')}"
                    if details.get('type'):
                        arg_desc += f" (type: {details['type']})"
                    args_desc.append(arg_desc)
                if args_desc:
                    description += "\nArguments:\n" + "\n".join(args_desc)
        return description

    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute a tool with given arguments."""
        try:
            tool = next((t for t in self.tools if t.name == tool_name), None)
            if not tool:
                raise ValueError(f"Tool not found: {tool_name}")
            
            if tool.coroutine:
                result = await tool.coroutine(**kwargs)
            else:
                result = tool.func(**kwargs)
                
            return result
            
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {str(e)}")
            raise

    def format_tool_output(self, content: Any) -> str:
        """Format tool output for display."""
        return self.tool_formatter.format_tool_output(content)

    def format_tool_usage(self, content: str, message_type: str = None) -> str:
        """Format tool usage messages."""
        return self.tool_formatter.format_tool_usage(content, message_type)

================
File: agents/chat/tests/test_callback_handler.py
================
import pytest
import asyncio
from unittest.mock import Mock, patch
from datetime import datetime
from langchain_core.agents import AgentFinish
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler

@pytest.fixture
def mock_consumer():
    consumer = Mock()
    consumer.session_id = "test_session"
    consumer.send_json = Mock()
    return consumer

@pytest.fixture
def callback_handler(mock_consumer):
    return WebSocketCallbackHandler(consumer=mock_consumer)

@pytest.mark.asyncio
async def test_send_message(callback_handler, mock_consumer):
    test_message = {
        'type': 'test_message',
        'content': 'test content'
    }
    await callback_handler._send_message(test_message)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_tool_start(callback_handler, mock_consumer):
    serialized = {'name': 'test_tool'}
    input_str = 'test input'
    await callback_handler.on_tool_start(serialized, input_str)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_tool_end(callback_handler, mock_consumer):
    output = 'test output'
    await callback_handler.on_tool_end(output)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_agent_finish(callback_handler, mock_consumer):
    finish = AgentFinish(
        return_values={'output': 'test output'},
        log='test log'
    )
    await callback_handler.on_agent_finish(finish)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_duplicate_agent_finish_prevention(callback_handler, mock_consumer):
    finish = AgentFinish(
        return_values={'output': 'test output'},
        log='test log'
    )
    # First call should send message
    await callback_handler.on_agent_finish(finish)
    # Second call with same output should not send message
    await callback_handler.on_agent_finish(finish)
    assert mock_consumer.send_json.call_count == 1

@pytest.mark.asyncio
async def test_message_lock(callback_handler, mock_consumer):
    # Test that message lock prevents concurrent sends
    async def send_messages():
        messages = [{'type': f'msg_{i}'} for i in range(5)]
        await asyncio.gather(*[callback_handler._send_message(msg) for msg in messages])
    
    await send_messages()
    assert mock_consumer.send_json.call_count == 5

================
File: agents/chat/history.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage
from typing import List, Optional, Dict
import logging

logger = logging.getLogger(__name__)

class DjangoCacheMessageHistory(BaseChatMessageHistory):
    """Message history that uses Django's cache and database for storage."""
    
    def __init__(self, session_id: str, conversation_id: Optional[str] = None, agent_id: Optional[int] = None, ttl: int = 3600):
        """Initialize with session ID and optional conversation ID."""
        # Store these as instance variables since they're used by other parts of the system
        self.session_id = session_id
        self.conversation_id = conversation_id
        self.agent_id = agent_id
        self.ttl = ttl
        
        # Initialize the message manager for all operations
        from apps.agents.chat.managers.message_manager import MessageManager
        self.message_manager = MessageManager(
            conversation_id=conversation_id,
            session_id=session_id,
            agent_id=agent_id,
            ttl=ttl
        )

    async def aget_messages(self) -> List[BaseMessage]:
        """Get messages from the message manager."""
        try:
            return await self.message_manager.get_messages()
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}")
            return []

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> None:
        """Add message using the message manager."""
        try:
            await self.message_manager.add_message(message, token_usage)
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    def clear(self) -> None:
        """Clear message history."""
        try:
            self.message_manager.clear()
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    async def handle_edit(self) -> None:
        """Handle message editing through the message manager."""
        try:
            await self.message_manager.handle_edit()
        except Exception as e:
            logger.error(f"Error handling message edit: {str(e)}")
            raise

================
File: agents/clients/manager.py
================
import logging
from django.utils import timezone
from apps.seo_manager.models import Client
from channels.db import database_sync_to_async

logger = logging.getLogger(__name__)

class ClientDataManager:
    def __init__(self):
        pass

    @database_sync_to_async
    def get_client_data(self, client_id):
        """Get and format client data"""
        if not client_id:
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
            
        try:
            client = Client.objects.get(id=client_id)
            current_date = timezone.now().date()
            
            return {
                'client_id': client.id,
                'current_date': current_date.isoformat(),
            }
        except Client.DoesNotExist:
            logger.info(f"No client found with ID {client_id}, returning default data")
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
        except Exception as e:
            logger.error(f"Error getting client data: {str(e)}", exc_info=True)
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }

================
File: agents/static/agents/js/chat/app.js
================
import { MessageList } from '/static/agents/js/components/message_list.js';
import { ChatWebSocket } from '/static/agents/js/services/websocket.js';
import { MessageHandler } from '/static/agents/js/services/message_handler.js';
import { ToolOutputManager } from '/static/agents/js/components/tool_outputs/base.js';

class ChatApp {
    constructor(config) {
        this.config = config;
        this.elements = {
            messages: document.getElementById('chat-messages'),
            input: document.getElementById('message-input'),
            sendButton: document.getElementById('send-message'),
            agentSelect: document.getElementById('agent-select'),
            modelSelect: document.getElementById('model-select'),
            clientSelect: document.getElementById('client-select'),
            newChatBtn: document.getElementById('new-chat-btn')
        };
        
        // Initialize components
        this.messageList = new MessageList(this.elements.messages);
        this.toolOutputManager = new ToolOutputManager();
        this.messageHandler = new MessageHandler(this.messageList, this.toolOutputManager);
        this.websocket = new ChatWebSocket(config, this.messageHandler);
        
        // Bind event handlers
        this._bindEvents();

        // Expose functions globally
        window.editMessage = this.editMessage.bind(this);
        window.copyMessage = this.copyMessage.bind(this);
        window.deleteConversation = this.deleteConversation.bind(this);
    }

    editMessage(button) {
        const messageContent = button.closest('.message').querySelector('.message-content');
        const originalText = messageContent.textContent.trim();
        
        // Set input value to message content
        this.elements.input.value = originalText;
        autosize.update(this.elements.input);
        
        // Focus input
        this.elements.input.focus();
    }

    copyMessage(button) {
        const messageContent = button.closest('.message').querySelector('.message-content');
        const text = messageContent.textContent.trim();
        
        navigator.clipboard.writeText(text).then(() => {
            // Show temporary success indicator
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            setTimeout(() => {
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1000);
        }).catch(err => {
            console.error('Failed to copy text:', err);
        });
    }

    initialize() {
        // Connect WebSocket
        this.websocket.connect();
        
        // Initialize autosize for textarea
        if (this.elements.input) {
            autosize(this.elements.input);
        }
        
        // Set initial agent avatar and initialize chatConfig
        if (!window.chatConfig.currentAgent) {
            const selectedOption = this.elements.agentSelect?.selectedOptions[0];
            console.log('Initial agent avatar setup:', {
                selectedOption,
                avatar: selectedOption?.dataset.avatar,
                name: selectedOption?.dataset.name,
                allOptions: Array.from(this.elements.agentSelect?.options || []).map(opt => ({
                    name: opt.dataset.name,
                    avatar: opt.dataset.avatar
                }))
            });
            window.chatConfig.currentAgent = {
                avatar: selectedOption ? selectedOption.dataset.avatar : '/static/assets/img/team-3.jpg',
                name: selectedOption ? selectedOption.dataset.name : 'AI Assistant'
            };
        }
        this._updateAgentAvatar();
    }

    _bindEvents() {
        // Message sending
        if (this.elements.input && this.elements.sendButton) {
            this.elements.input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this._sendMessage();
                }
            });
            
            this.elements.sendButton.addEventListener('click', () => {
                this._sendMessage();
            });
        }

        // Agent selection
        if (this.elements.agentSelect) {
            this.elements.agentSelect.addEventListener('change', () => {
                this._updateAgentAvatar();
            });
        }

        // New chat button
        if (this.elements.newChatBtn) {
            this.elements.newChatBtn.addEventListener('click', () => {
                window.location.href = this.elements.newChatBtn.dataset.url;
            });
        }
    }

    _sendMessage() {
        const message = this.elements.input.value.trim();
        if (!message) return;

        const agentId = this.elements.agentSelect.value;
        const modelName = this.elements.modelSelect.value;
        const clientId = this.elements.clientSelect.value;

        // Display user message immediately
        this.messageList.addMessage(message, false);

        // Send message to server
        this.websocket.send({
            message: message,
            agent_id: agentId,
            model: modelName,
            client_id: clientId
        });

        // Clear input
        this.elements.input.value = '';
        autosize.update(this.elements.input);
    }

    _updateAgentAvatar() {
        const selectedOption = this.elements.agentSelect.selectedOptions[0];
        if (selectedOption) {
            const avatarPath = selectedOption.dataset.avatar || '/static/assets/img/team-3.jpg';
            const avatarUrl = avatarPath.startsWith('/') ? avatarPath : `/static/assets/img/${avatarPath}`;
            const name = selectedOption.dataset.name;
            
            console.log('Updating agent avatar:', {
                avatarPath,
                avatarUrl,
                name,
                selectedOption,
                allDataset: {...selectedOption.dataset}
            });
            
            const avatarImg = document.getElementById('agent-avatar').querySelector('img');
            if (avatarImg) {
                avatarImg.src = avatarUrl;
                avatarImg.alt = name;
            }
            
            const nameElement = document.getElementById('agent-name');
            if (nameElement) {
                nameElement.textContent = name;
            }
            
            // Update global config for Message component
            window.chatConfig.currentAgent = {
                avatar: avatarUrl,
                name: name
            };
        }
    }

    async deleteConversation(sessionId, event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }

        if (!confirm('Are you sure you want to delete this conversation?')) {
            return;
        }

        try {
            const url = this.config.urls.deleteConversation.replace('{sessionId}', sessionId);
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.config.csrfToken,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('Failed to delete conversation');
            }

            // Redirect to new chat if we're deleting the current conversation
            if (sessionId === this.config.sessionId) {
                window.location.href = this.config.urls.newChat;
            } else {
                // Otherwise just remove the conversation from the list
                const conversationElement = event.target.closest('.position-relative');
                if (conversationElement) {
                    conversationElement.remove();
                }
            }
        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Failed to delete conversation. Please try again.');
        }
    }
}

export { ChatApp };

================
File: agents/static/agents/js/chat/index.js
================
import { ToolHandler } from './components/tool_outputs/base.js';

export function deleteConversation(sessionId, event) {
    event.preventDefault();
    event.stopPropagation();
    
    if (confirm('Are you sure you want to delete this conversation?')) {
        fetch(window.chatConfig.urls.deleteConversation.replace('{sessionId}', sessionId), {
            method: 'POST',
            headers: {
                'X-CSRFToken': window.chatConfig.csrfToken,
            }
        })
        .then(response => {
            if (response.ok) {
                if (window.location.href.includes(sessionId)) {
                    window.location.href = window.chatConfig.urls.newChat;
                } else {
                    event.target.closest('.position-relative').remove();
                }
            } else {
                throw new Error('Failed to delete conversation');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to delete conversation');
        });
    }
}

export class ChatManager {
    constructor(options) {
        // Get required elements from options
        this.elements = {
            input: document.getElementById('message-input'),
            sendButton: document.getElementById('send-message'),
            messages: document.getElementById('chat-messages'),
            status: document.getElementById('connection-status')
        };

        // Store current agent info
        this.currentAgent = {
            id: options.agentId,
            avatar: options.agentAvatar || '/static/agents/img/agent-avatar.png',
            name: options.agentName || 'Agent'
        };

        // Store user avatar
        this.userAvatar = options.userAvatar || '/static/agents/img/user-avatar.jpg';

        // Store other options
        this.currentModel = options.model;
        this.clientId = options.clientId;
        this.isLoading = false;
        this.isEditing = false;

        // Initialize components
        this.toolHandler = new ToolHandler(this);

        // Setup WebSocket
        this.setupWebSocket();
    }

    disableInput() {
        if (this.elements.input) {
            this.elements.input.disabled = true;
            this.isLoading = true;
        }
        if (this.elements.sendButton) {
            this.elements.sendButton.disabled = true;
        }
    }

    enableInput() {
        if (this.elements.input) {
            this.elements.input.disabled = false;
            this.isLoading = false;
            this.elements.input.value = '';
            this.elements.input.style.height = 'auto';
            if (typeof autosize === 'function') {
                autosize.update(this.elements.input);
            }
        }
        if (this.elements.sendButton) {
            this.elements.sendButton.disabled = false;
        }
    }

    async sendMessage(event) {
        try {
            // Get message from input
            const message = this.elements.input.value;
            if (!message || !message.trim() || this.isLoading) return;

            // Disable input while processing
            this.disableInput();

            // Display user message immediately
            this.appendMessage(message, false);

            // Send to server
            await this.socket.send(JSON.stringify({
                message: message,
                agent_id: this.currentAgent.id,
                model: this.currentModel,
                client_id: this.clientId,
                is_edit: this.isEditing
            }));

            // Reset edit state
            this.isEditing = false;

        } catch (error) {
            console.error('Error sending message:', error);
            this.showError('Failed to send message');
            this.enableInput();
        }
    }

    setupWebSocket() {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        this.socket = new WebSocket(
            `${wsProtocol}//${window.location.host}/ws/chat/?session=${this.elements.messages.dataset.sessionId}`
        );
        this.setupEventListeners();
    }

    setupEventListeners() {
        // WebSocket event listeners
        this.socket.onmessage = (event) => this.handleMessage(event.data);
        this.socket.onclose = () => {
            this.showError('Connection lost. Attempting to reconnect...');
            setTimeout(() => this.reconnect(), 2000);
        };
        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.showError('Connection error occurred');
        };

        // Input event listeners
        if (this.elements.input) {
            this.elements.input.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.sendMessage();
                }
            });
        }

        if (this.elements.sendButton) {
            this.elements.sendButton.addEventListener('click', () => this.sendMessage());
        }
    }

    updateStatus(status) {
        const dot = this.elements.status?.querySelector('.connection-dot');
        if (dot) {
            dot.classList.toggle('connected', status === 'connected');
        }
    }

    handleMessage(data) {
        try {
            const message = JSON.parse(data);
            console.log('Received message:', message);
            
            if (!message) {
                console.warn('Empty message received');
                return;
            }

            switch (message.type) {
                case 'system_message':
                    console.log('System message:', message);
                    if (message.connection_status) {
                        this.updateStatus(message.connection_status);
                    }
                    break;

                case 'tool_start':
                    console.log('Tool start:', message);
                    const toolContainer = this.toolHandler.handleToolStart(message.message);
                    if (toolContainer) {
                        this.appendToChat(toolContainer);
                    }
                    break;

                case 'tool_end':
                    console.log('Tool end:', message);
                    const resultContainer = this.toolHandler.handleToolResult({
                        type: 'text',
                        data: message.message.output
                    });
                    if (resultContainer) {
                        this.appendToChat(resultContainer);
                    }
                    break;

                case 'agent_finish':
                    console.log('Agent finish:', message);
                    this.appendMessage(message.message, true, false);
                    break;

                default:
                    console.log('Unknown message type:', message.type);
            }
        } catch (error) {
            console.error('Error handling message:', error);
            this.showError('Failed to process message');
        }
    }

    handleToolStart(content) {
        if (!content) return;

        // Format tool name for display
        const prettyToolName = content.name.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');

        const messageId = `tool-${Date.now()}`;
        const html = `
            <div class="d-flex justify-content-start mb-4">
                <div class="avatar me-2">
                    <img src="${this.currentAgent.avatar}" alt="${this.currentAgent.name}" class="border-radius-lg shadow">
                </div>
                <div class="tool-message start w-100" style="max-width: 75%;">
                    <div class="message-content tool-usage">
                        <div class="tool-header d-flex align-items-center collapsed" 
                             data-bs-toggle="collapse" 
                             data-bs-target="#${messageId}" 
                             aria-expanded="false" 
                             aria-controls="${messageId}"
                             role="button">
                            <i class="fas fa-cog me-2"></i>
                            <strong>${prettyToolName}</strong>
                            <i class="fas fa-chevron-down ms-auto"></i>
                        </div>
                        <div class="collapse" id="${messageId}">
                            <div class="tool-details mt-3">
                                <div class="tool-input">
                                    <strong>Input:</strong>
                                    <pre class="json-output mt-2">${JSON.stringify(content.input, null, 2)}</pre>
                                </div>
                                ${content.log ? `
                                <div class="tool-log mt-3">
                                    <strong>Log:</strong>
                                    <div class="mt-2">${content.log}</div>
                                </div>` : ''}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        
        // Initialize collapse with show: false
        const collapseElement = document.getElementById(messageId);
        if (collapseElement) {
            new bootstrap.Collapse(collapseElement, {
                toggle: false  // This ensures it starts collapsed
            });
        }

        this.scrollToBottom();
    }

    handleToolOutput(content) {
        if (!content) return;

        // Find the last tool message and append output
        const lastToolMessage = this.elements.messages.querySelector('.tool-message.start:last-child');
        if (lastToolMessage) {
            const collapseContent = lastToolMessage.querySelector('.collapse');
            const outputHtml = `
                <div class="tool-output mt-3">
                    <strong>Output:</strong>
                    <pre class="json-output mt-2">${JSON.stringify(content, null, 2)}</pre>
                </div>
            `;
            collapseContent.insertAdjacentHTML('beforeend', outputHtml);
        }
        
        this.scrollToBottom();
    }

    handleToolError(content) {
        if (!content) return;

        const messageId = `msg-${Date.now()}`;
        const html = `
            <div class="d-flex justify-content-start mb-4" id="${messageId}-container">
                <div class="avatar me-3">
                    <img src="${this.currentAgent.avatar}" alt="${this.currentAgent.name}" 
                         class="border-radius-lg shadow-sm" width="48" height="48">
                </div>
                <div class="tool-message error" style="max-width: 75%;">
                    <div class="message-content position-relative">
                        <div class="message-actions position-absolute top-0 end-0 m-2 opacity-0">
                            <button class="btn btn-link btn-sm p-0 copy-message" title="Copy to clipboard">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                        <div class="message-text">
                            <i class="fas fa-exclamation-triangle me-2"></i>
                            ${typeof content === 'object' ? content.message : content}
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        this.addMessageEventListeners(messageId);
        this.scrollToBottom();
    }

    handleEditMessage(messageId) {
        const messageElement = document.getElementById(`${messageId}-container`);
        if (!messageElement) return;

        const messageText = messageElement.querySelector('.message-text').textContent.trim();
        this.elements.input.value = messageText;
        this.elements.input.focus();
        this.isEditing = true;
        this.editingMessageId = messageId;

        // Remove the edited message and all messages after it
        let currentElement = messageElement;
        while (currentElement) {
            const nextElement = currentElement.nextElementSibling;
            currentElement.remove();
            currentElement = nextElement;
        }

        // Update autosize if available
        if (typeof autosize === 'function') {
            autosize.update(this.elements.input);
        }
    }

    appendMessage(content, isAgent = false, withActions = true) {
        const messageId = `msg-${Date.now()}`;
        const html = `
            <div id="${messageId}-container" class="d-flex justify-content-${isAgent ? 'start' : 'end'} mb-4">
                ${isAgent ? `
                <div class="avatar me-2">
                    <img src="${this.currentAgent.avatar}" alt="${this.currentAgent.name}" class="border-radius-lg shadow">
                </div>` : ''}
                <div class="message ${isAgent ? 'agent' : 'user'}" style="max-width: 75%;">
                    <div class="message-content position-relative">
                        <div class="message-text">${content}</div>
                        ${withActions ? `
                        <div class="message-actions opacity-0">
                            <button class="btn btn-link text-secondary p-1 copy-message">
                                <i class="fas fa-copy"></i>
                            </button>
                            ${!isAgent ? `
                            <button class="btn btn-link text-secondary p-1 edit-message">
                                <i class="fas fa-edit"></i>
                            </button>` : ''}
                        </div>` : ''}
                    </div>
                </div>
                ${!isAgent ? `
                <div class="avatar ms-2">
                    <img src="${this.userAvatar}" alt="User" class="border-radius-lg shadow">
                </div>` : ''}
            </div>
        `;
        
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        if (withActions) {
            this.addMessageEventListeners(messageId);
        }
        this.scrollToBottom();
    }

    addMessageEventListeners(messageId) {
        const container = document.getElementById(`${messageId}-container`);
        if (!container) return;

        const messageContent = container.querySelector('.message-content');
        const messageActions = container.querySelector('.message-actions');
        const copyButton = container.querySelector('.copy-message');
        const editButton = container.querySelector('.edit-message');

        // Show/hide actions on hover
        if (messageContent && messageActions) {
            messageContent.addEventListener('mouseenter', () => {
                messageActions.classList.remove('opacity-0');
            });
            messageContent.addEventListener('mouseleave', () => {
                messageActions.classList.add('opacity-0');
            });
        }

        // Copy button functionality
        if (copyButton) {
            copyButton.addEventListener('click', () => {
                const messageText = container.querySelector('.message-text').textContent.trim();
                navigator.clipboard.writeText(messageText);
                this.showNotification('Message copied to clipboard!');
            });
        }

        // Edit button functionality
        if (editButton) {
            editButton.addEventListener('click', () => {
                this.handleEditMessage(messageId);
            });
        }
    }

    showError(message) {
        if (!message) return;

        const html = `
            <div class="d-flex justify-content-center mb-4">
                <div class="alert alert-danger d-flex align-items-center w-75" role="alert">
                    <div class="text-white me-3">
                        <i class="fas fa-exclamation-circle"></i>
                    </div>
                    <div class="text-white">
                        ${message}
                    </div>
                </div>
            </div>
        `;
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        this.scrollToBottom();
    }

    scrollToBottom() {
        this.elements.messages.scrollTop = this.elements.messages.scrollHeight;
    }

    reconnect() {
        if (this.socket?.readyState === WebSocket.CLOSED) {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            this.socket = new WebSocket(
                `${wsProtocol}//${window.location.host}/ws/chat/?session=${this.elements.messages.dataset.sessionId}`
            );
            this.setupEventListeners();
        }
    }

    appendCollapsedMessage({ tool, content, type, rawData }) {
        const prettyToolName = tool.split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');

        const messageId = `msg-${Date.now()}`;
        const html = `
            <div class="d-flex justify-content-start mb-4">
                <div class="avatar me-2">
                    <img src="${this.currentAgent.avatar}" alt="${this.currentAgent.name}" class="border-radius-lg shadow">
                </div>
                <div class="tool-message start w-100" style="max-width: 75%;">
                    <div class="message-content tool-usage">
                        <div class="tool-header d-flex align-items-center" 
                             data-bs-toggle="collapse" 
                             data-bs-target="#${messageId}" 
                             aria-expanded="false" 
                             aria-controls="${messageId}"
                             role="button">
                            <i class="fas fa-cog me-2"></i>
                            <strong>${prettyToolName}</strong>
                            <i class="fas fa-chevron-down ms-auto"></i>
                        </div>
                        <div class="collapse show" id="${messageId}">
                            <div class="tool-details mt-3">
                                ${type === 'table' ? `
                                    <div class="table-responsive">
                                        ${content}
                                    </div>
                                ` : `
                                    <div class="json-output">
                                        <pre style="white-space: pre-wrap; word-break: break-word;">${content}</pre>
                                    </div>
                                `}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        
        // Initialize collapse and start expanded for tables
        const collapseElement = document.getElementById(messageId);
        if (collapseElement) {
            new bootstrap.Collapse(collapseElement, {
                toggle: true
            });
            if (type === 'table') {
                bootstrap.Collapse.getInstance(collapseElement).show();
            }
        }

        this.scrollToBottom();
    }

    showLoadingIndicator() {
        // Remove any existing loading indicator
        this.removeLoadingIndicator();

        const html = `
            <div class="d-flex justify-content-start mb-4 streaming-message">
                <div class="avatar me-2">
                    <img src="${this.currentAgent.avatar}" alt="${this.currentAgent.name}" class="border-radius-lg shadow">
                </div>
                <div class="agent-message" style="max-width: 75%;">
                    <div class="message-content loading-content">
                        <div class="typing-indicator">
                            <div class="typing-dots">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                            <div class="typing-text ms-2">Thinking...</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        this.elements.messages.insertAdjacentHTML('beforeend', html);
        this.scrollToBottom();
        this.isLoading = true;
    }

    removeLoadingIndicator() {
        const loadingMessage = this.elements.messages.querySelector('.streaming-message');
        if (loadingMessage) {
            loadingMessage.remove();
        }
        this.isLoading = false;
    }

    // Add method to convert markdown tables to HTML
    markdownTableToHtml(markdownTable) {
        const rows = markdownTable.trim().split('\n');
        const headers = rows[0].split('|').filter(cell => cell.trim()).map(cell => cell.trim());
        
        let html = '<table class="table table-striped table-hover">\n<thead>\n<tr>';
        
        // Add headers
        headers.forEach(header => {
            html += `<th>${header}</th>`;
        });
        html += '</tr>\n</thead>\n<tbody>';
        
        // Add data rows (skip header and separator rows)
        rows.slice(2).forEach(row => {
            const cells = row.split('|').filter(cell => cell.trim()).map(cell => cell.trim());
            html += '\n<tr>';
            cells.forEach(cell => {
                html += `<td>${cell}</td>`;
            });
            html += '</tr>';
        });
        
        html += '\n</tbody>\n</table>';
        return html;
    }

    // Add method to format analytics summary data
    formatAnalyticsSummary(stats) {
        let html = '<div class="analytics-summary">';
        for (const [metric, values] of Object.entries(stats)) {
            html += `
                <div class="metric-group mb-3">
                    <h5 class="metric-title">${this.formatMetricName(metric)}</h5>
                    <table class="table table-sm">
                        <tbody>
                            ${Object.entries(values).map(([key, value]) => `
                                <tr>
                                    <td>${this.formatMetricName(key)}</td>
                                    <td>${typeof value === 'number' ? value.toFixed(2) : value}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }
        html += '</div>';
        return html;
    }

    formatMetricName(name) {
        return name
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, str => str.toUpperCase())
            .trim();
    }

    appendToChat(element) {
        if (element instanceof Element) {
            this.elements.messages.appendChild(element);
        } else if (typeof element === 'string') {
            this.elements.messages.insertAdjacentHTML('beforeend', element);
        }
        this.scrollToBottom();
    }

    handleNewChat() {
        // Check if we have the new chat URL in window.chatConfig
        if (window.chatConfig?.urls?.newChat) {
            window.location.href = window.chatConfig.urls.newChat;
        } else {
            // Fallback to a default path if config URL isn't available
            window.location.href = '/chat/new/';
        }
    }
}

// Initialize everything when the document is ready
document.addEventListener('DOMContentLoaded', () => {
    try {
        window.chatManager = new ChatManager({
            sessionId: window.chatConfig.sessionId,
            currentConversation: window.chatConfig.currentConversation,
            defaultModel: window.chatConfig.defaultModel
        });

        // Make deleteConversation available globally
        window.deleteConversation = deleteConversation;

        console.log('Chat manager initialized baby!');
    } catch (error) {
        console.error('Failed to initialize chat:', error);
        const messages = document.getElementById('chat-messages');
        if (messages) {
            messages.innerHTML = `
                <div class="alert alert-danger">
                    <strong>Error:</strong> Failed to initialize chat: ${error.message}
                </div>
            `;
        }
    }
});

================
File: agents/static/agents/js/components/tool_outputs/base.js
================
class ToolOutputManager {
    constructor() {
        this.activeTools = new Map();
    }

    handleToolStart(message) {
        try {
            const toolData = typeof message === 'string' ? JSON.parse(message) : message;
            console.log('Tool start data:', toolData);

            // Parse input if it's a string
            let parsedInput;
            try {
                parsedInput = typeof toolData.input === 'string' ? 
                    JSON.parse(toolData.input.replace(/'/g, '"')) : 
                    toolData.input;
            } catch (e) {
                parsedInput = toolData.input;
            }

            // Create container for tool output
            const container = document.createElement('div');
            container.className = 'tool-output mb-3';
            container.id = `tool-${Date.now()}`; // Add unique ID
            
            // Create header with collapse functionality
            const header = document.createElement('div');
            header.className = 'd-flex align-items-center mb-2 cursor-pointer';
            header.setAttribute('data-bs-toggle', 'collapse');
            header.setAttribute('data-bs-target', `#${container.id}-content`);
            header.setAttribute('aria-expanded', 'false');
            header.innerHTML = `
                <i class="fas fa-chevron-right me-2 toggle-icon"></i>
                <i class="fas fa-tools me-2"></i>
                <span class="tool-name">${toolData.name}</span>
            `;
            
            // Create collapsible content area
            const content = document.createElement('div');
            content.className = 'tool-content p-3 border rounded collapse';
            content.id = `${container.id}-content`;
            content.innerHTML = `
                <div class="tool-status mb-3">
                    <div class="spinner-border spinner-border-sm text-primary" role="status">
                        <span class="visually-hidden">Running...</span>
                    </div>
                    <span class="ms-2">Running tool...</span>
                </div>
                <div class="tool-input mb-3">
                    <strong>Input:</strong>
                    <pre><code class="json">${JSON.stringify(parsedInput, null, 2)}</code></pre>
                </div>
                <div class="tool-result mt-3" style="display: none;"></div>
            `;
            
            // Add click handler for chevron rotation
            header.addEventListener('click', () => {
                const icon = header.querySelector('.toggle-icon');
                icon.style.transform = icon.style.transform === 'rotate(90deg)' ? '' : 'rotate(90deg)';
            });
            
            // Assemble container
            container.appendChild(header);
            container.appendChild(content);
            
            // Store reference to container
            this.activeTools.set(toolData.name, container);
            
            return container;
        } catch (error) {
            console.error('Error handling tool start:', error);
            return null;
        }
    }

    formatTableData(data) {
        if (!Array.isArray(data) || data.length === 0) return null;
        
        // Get headers from first row
        const headers = Object.keys(data[0]);
        
        // Create table HTML
        const tableHtml = `
            <div class="table-responsive">
                <table class="table table-sm table-hover">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th>${header}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${data.map(row => `
                            <tr>
                                ${headers.map(header => `<td>${row[header]}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
        
        return tableHtml;
    }

    handleToolEnd(message) {
        try {
            // Parse the outer message if it's a string
            const messageData = typeof message.message === 'string' ? JSON.parse(message.message) : message.message;
            console.log('Parsed message data:', messageData);
            
            // Parse the output field which is another level of stringified JSON
            let output;
            try {
                output = typeof messageData.output === 'string' ? JSON.parse(messageData.output) : messageData.output;
                console.log('Parsed output:', output);
            } catch (e) {
                console.error('Error parsing output:', e);
                output = messageData.output;
            }

            // Find the tool's container - use the last active tool if name not available
            const container = this.activeTools.values().next().value;
            if (!container) {
                console.warn('No active tool found');
                return null;
            }

            // Update the tool's status and output
            const content = container.querySelector('.tool-content');
            if (content) {
                // Update status - remove loading indicator
                const statusDiv = content.querySelector('.tool-status');
                if (statusDiv) {
                    statusDiv.innerHTML = `
                        <i class="fas fa-check-circle text-success me-2"></i>
                        <span>Tool completed</span>
                    `;
                }

                // Update result
                const resultDiv = content.querySelector('.tool-result');
                if (resultDiv && output) {
                    resultDiv.style.display = 'block';
                    
                    try {
                        // Handle nested analytics_data if present
                        if (output.analytics_data) {
                            const tableHtml = this.formatTableData(output.analytics_data);
                            if (tableHtml) {
                                resultDiv.innerHTML = `
                                    <strong>Analytics Data:</strong>
                                    ${tableHtml}
                                `;
                                return;
                            }
                        }
                        
                        // If not analytics data, display as formatted JSON
                        resultDiv.innerHTML = `
                            <strong>Output:</strong>
                            <pre><code class="json">${JSON.stringify(output, null, 2)}</code></pre>
                        `;
                    } catch (e) {
                        console.error('Error formatting output:', e);
                        // If parsing fails, display as plain text
                        resultDiv.innerHTML = `
                            <strong>Output:</strong>
                            <pre><code>${output}</code></pre>
                        `;
                    }
                } else {
                    console.warn('No output or result div found');
                }
            }

            // Remove from active tools
            this.activeTools.clear();  // Clear all active tools
            
            return null;
        } catch (error) {
            console.error('Error handling tool end:', error);
            return null;
        }
    }

    handleToolResult(result) {
        try {
            console.log('handleToolResult - received:', result);
            
            // Find the active tool's container
            const activeContainer = this.activeTools.values().next().value;
            console.log('handleToolResult - active container:', activeContainer);
            
            if (activeContainer) {
                // Add result to the existing tool container
                const resultDiv = activeContainer.querySelector('.tool-result');
                console.log('handleToolResult - result div:', resultDiv);
                
                if (resultDiv) {
                    resultDiv.style.display = 'block';
                    
                    let content;
                    console.log('handleToolResult - processing result:', {
                        result_exists: !!result,
                        data_exists: result && result.data !== undefined,
                        type: result?.type,
                        data: result?.data
                    });
                    
                    if (result && result.data !== undefined) {
                        if (Array.isArray(result.data)) {
                            console.log('handleToolResult - handling array data');
                            content = this.formatTableData(result.data) || 
                                     `<pre class="mb-0"><code>${JSON.stringify(result.data, null, 2)}</code></pre>`;
                        } else {
                            console.log('handleToolResult - handling by type:', result.type);
                            switch (result.type) {
                                case 'text':
                                    content = `<pre class="mb-0"><code>${result.data}</code></pre>`;
                                    break;
                                case 'json':
                                    // Check for analytics_data
                                    if (result.data.analytics_data) {
                                        console.log('handleToolResult - found analytics_data:', result.data.analytics_data);
                                        const tableHtml = this.formatTableData(result.data.analytics_data);
                                        if (tableHtml) {
                                            content = `
                                                <strong>Analytics Data:</strong>
                                                ${tableHtml}
                                            `;
                                            break;
                                        }
                                    }
                                    content = `<pre class="mb-0"><code class="json">${JSON.stringify(result.data, null, 2)}</code></pre>`;
                                    break;
                                case 'error':
                                    content = `<div class="alert alert-danger mb-0">${result.data}</div>`;
                                    break;
                                default:
                                    content = `<div class="mb-0">${result.data}</div>`;
                            }
                        }
                    } else {
                        console.log('handleToolResult - no data available');
                        content = '<div class="alert alert-warning mb-0">No data available</div>';
                    }
                    
                    console.log('handleToolResult - final content:', content);
                    resultDiv.innerHTML = `
                        <strong>Result:</strong>
                        ${content}
                    `;
                }
                return null;
            }
            
            // If no active tool container, create a standalone result container
            console.log('handleToolResult - creating standalone container');
            const container = document.createElement('div');
            container.className = 'tool-result mb-3';
            container.id = `tool-result-${Date.now()}`;
            
            let content;
            if (result && result.data !== undefined) {
                if (Array.isArray(result.data)) {
                    content = this.formatTableData(result.data) || 
                             `<pre class="mb-0"><code>${JSON.stringify(result.data, null, 2)}</code></pre>`;
                } else {
                    switch (result.type) {
                        case 'text':
                            content = `<pre class="mb-0"><code>${result.data}</code></pre>`;
                            break;
                        case 'json':
                            content = `<pre class="mb-0"><code class="json">${JSON.stringify(result.data, null, 2)}</code></pre>`;
                            break;
                        case 'error':
                            content = `<div class="alert alert-danger mb-0">${result.data}</div>`;
                            break;
                        default:
                            content = `<div class="mb-0">${result.data}</div>`;
                    }
                }
            } else {
                content = '<div class="alert alert-warning mb-0">No data available</div>';
            }
            
            container.innerHTML = `
                <div class="d-flex align-items-center mb-2 cursor-pointer" data-bs-toggle="collapse" data-bs-target="#${container.id}-content" aria-expanded="false">
                    <i class="fas fa-chevron-right me-2 toggle-icon"></i>
                    <span>Tool Result</span>
                </div>
                <div class="collapse" id="${container.id}-content">
                    <div class="tool-content p-3 border rounded">
                        ${content}
                    </div>
                </div>
            `;
            
            // Add click handler for chevron rotation
            const header = container.querySelector('[data-bs-toggle="collapse"]');
            header.addEventListener('click', () => {
                const icon = header.querySelector('.toggle-icon');
                icon.style.transform = icon.style.transform === 'rotate(90deg)' ? '' : 'rotate(90deg)';
            });
            
            return container;
        } catch (error) {
            console.error('Error handling tool result:', error);
            return null;
        }
    }
}

export { ToolOutputManager };

================
File: agents/static/agents/js/components/message_list.js
================
import { Message } from '/static/agents/js/components/message.js';

class MessageList {
    constructor(container) {
        this.container = container;
        this.messages = [];
        this._setupContainer();
    }

    _setupContainer() {
        // Ensure container has proper styling
        this.container.style.height = '70vh';
        this.container.style.overflowY = 'auto';
    }

    addMessage(content, isAgent = false, avatar = null, timestamp = null) {
        const message = new Message(content, isAgent, avatar, timestamp);
        this.messages.push(message);
        this._appendMessageToDOM(message);
        this._scrollToBottom();
    }

    _appendMessageToDOM(message) {
        const messageElement = message.render();
        this.container.appendChild(messageElement);
        
        // Handle code blocks if any
        const codeBlocks = messageElement.querySelectorAll('pre code');
        if (codeBlocks.length > 0) {
            codeBlocks.forEach(block => {
                hljs.highlightElement(block);
            });
        }
    }

    _scrollToBottom() {
        this.container.scrollTop = this.container.scrollHeight;
    }

    clear() {
        this.messages = [];
        this.container.innerHTML = '';
    }

    // Method to handle historical messages
    loadHistory(messages) {
        this.clear();
        messages.forEach(msg => {
            this.addMessage(
                msg.content,
                msg.is_agent,
                msg.avatar,
                msg.timestamp
            );
        });
    }
}

export { MessageList };

================
File: agents/static/agents/js/components/message.js
================
class Message {
    constructor(content, isAgent = false, avatar = null, timestamp = null) {
        this.content = content;
        this.isAgent = isAgent;
        this.avatar = avatar || (isAgent ? window.chatConfig.currentAgent.avatar : '/static/agents/img/user-avatar.jpg');
        this.timestamp = timestamp || new Date().toISOString();
    }

    render() {
        const messageDiv = document.createElement('div');
        messageDiv.className = `d-flex ${this.isAgent ? 'justify-content-start' : 'justify-content-end'} mb-4`;
        
        const html = `
            ${this.isAgent ? `
            <div class="avatar me-2">
                <img src="${this.avatar}" alt="agent" class="border-radius-lg shadow">
            </div>` : ''}
            <div class="message ${this.isAgent ? 'agent' : 'user'}" style="max-width: 75%;">
                <div class="message-content">
                    ${marked.parse(this.content)}
                </div>
                <div class="message-timestamp text-xxs">
                    ${new Date(this.timestamp).toLocaleTimeString()}
                </div>
            </div>
            ${!this.isAgent ? `
            <div class="avatar ms-2">
                <img src="${this.avatar}" alt="user" class="border-radius-lg shadow">
            </div>` : ''}
        `;
        
        messageDiv.innerHTML = html;
        return messageDiv;
    }
}

export { Message };

================
File: agents/static/agents/js/services/message_handler.js
================
class MessageHandler {
    constructor(messageList, toolOutputManager) {
        this.messageList = messageList;
        this.toolOutputManager = toolOutputManager;
        this.statusElement = document.getElementById('connection-status');
    }

    handleMessage(data) {
        console.log('Received message:', data);
        
        if (!data) {
            console.warn('Empty message received');
            return;
        }

        switch (data.type) {
            case 'system_message':
                console.log('System message:', data);
                if (data.connection_status) {
                    this.handleConnectionStatus(data.connection_status);
                }
                break;

            case 'user_message':
                console.log('User message:', data);
                this.messageList.addMessage(data.message, false);
                break;

            case 'agent_message':
                console.log('Agent message:', data);
                // Check if this is a tool-related message
                if (data.message.startsWith('Tool Start:')) {
                    // Handle tool start
                    const toolMessage = data.message.replace('Tool Start:', '').trim();
                    if (this.toolOutputManager) {
                        const toolContainer = this.toolOutputManager.handleToolStart(toolMessage);
                        if (toolContainer) {
                            this.messageList.container.appendChild(toolContainer);
                        }
                    }
                } else if (data.message.startsWith('tool_start:')) {
                    // Handle tool start JSON format
                    const toolMessage = data.message.replace('tool_start:', '').trim();
                    if (this.toolOutputManager) {
                        const toolContainer = this.toolOutputManager.handleToolStart(toolMessage);
                        if (toolContainer) {
                            this.messageList.container.appendChild(toolContainer);
                        }
                    }
                } else if (data.message.startsWith('tool_end:')) {
                    // Handle tool end
                    const toolMessage = data.message.replace('tool_end:', '').trim();
                    if (this.toolOutputManager) {
                        try {
                            const messageData = JSON.parse(toolMessage);
                            const outputData = typeof messageData.output === 'string' ? JSON.parse(messageData.output) : messageData.output;
                            const resultData = {
                                type: 'json',
                                data: outputData
                            };
                            const resultContainer = this.toolOutputManager.handleToolResult(resultData);
                            if (resultContainer) {
                                this.messageList.container.appendChild(resultContainer);
                            }
                        } catch (error) {
                            console.error('Error parsing tool end message:', error);
                        }
                    }
                } else if (data.message.startsWith('Tool Result:')) {
                    // Handle tool result
                    const toolMessage = data.message.replace('Tool Result:', '').trim();
                    if (this.toolOutputManager) {
                        try {
                            const resultData = {
                                type: 'json',
                                data: JSON.parse(toolMessage)
                            };
                            const resultContainer = this.toolOutputManager.handleToolResult(resultData);
                            if (resultContainer) {
                                this.messageList.container.appendChild(resultContainer);
                            }
                        } catch (error) {
                            console.error('Error parsing tool result message:', error);
                        }
                    }
                } else {
                    // Regular agent message
                    this.messageList.addMessage(data.message, true);
                }
                break;

            case 'agent_finish':
                console.log('Agent finish:', data);
                this.messageList.addMessage(data.message, true);
                break;

            default:
                console.log('Unknown message type:', data.type);
        }
    }

    handleConnectionStatus(status) {
        if (!this.statusElement) return;
        
        const dot = this.statusElement.querySelector('.connection-dot');
        if (!dot) return;

        // Remove all existing status classes
        dot.classList.remove('connected', 'disconnected', 'error');
        
        switch (status) {
            case 'connected':
                dot.classList.add('connected');
                break;
            case 'disconnected':
                dot.classList.add('disconnected');
                break;
            case 'error':
                dot.classList.add('error');
                break;
        }
    }

    handleError(error) {
        console.error('Error:', error);
        // Add error message to chat
        this.messageList.addMessage(
            `Error: ${error}`,
            true,
            null,
            new Date().toISOString()
        );
    }
}

export { MessageHandler };

================
File: agents/static/agents/js/services/websocket.js
================
class ChatWebSocket {
    constructor(config, messageHandler) {
        this.config = config;
        this.messageHandler = messageHandler;
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // Start with 1 second
    }

    connect() {
        const wsUrl = `${this.config.urls.wsBase}?session=${this.config.sessionId}`;
        this.socket = new WebSocket(wsUrl);

        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
            this.messageHandler.handleConnectionStatus('connected');
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.messageHandler.handleMessage(data);
            } catch (error) {
                console.error('Error handling message:', error);
            }
        };

        this.socket.onclose = (event) => {
            console.log('WebSocket closed:', event);
            this.messageHandler.handleConnectionStatus('disconnected');
            this._handleReconnect();
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.messageHandler.handleConnectionStatus('error');
        };
    }

    send(message) {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(message));
        } else {
            console.error('WebSocket is not connected');
            this.messageHandler.handleError('Connection lost. Please try again.');
        }
    }

    _handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            console.log(`Attempting to reconnect in ${delay}ms...`);
            
            setTimeout(() => {
                console.log('Reconnecting...');
                this.connect();
            }, delay);
        } else {
            console.error('Max reconnection attempts reached');
            this.messageHandler.handleError('Connection lost. Please refresh the page.');
        }
    }

    disconnect() {
        if (this.socket) {
            this.socket.close();
        }
    }
}

export { ChatWebSocket };

================
File: agents/static/agents/js/crew_kanban.js
================
// Check required dependencies
if (typeof bootstrap === 'undefined') {
    console.error('Bootstrap is required but not loaded');
}
if (typeof markdownit === 'undefined') {
    console.error('markdown-it is required but not loaded');
}
if (typeof jKanban === 'undefined') {
    console.error('jKanban is required but not loaded');
}

// Verify required variables from template
if (typeof crewId === 'undefined') {
    console.error('crewId is required but not defined');
}
if (typeof clientId === 'undefined') {
    console.warn('clientId is not defined'); // warning since it can be null
}

// Initialize markdown
const md = window.markdownit();

// WebSocket configuration and state
const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
let socket = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
let reconnectDelay = 1000;
let pingInterval = null;
let lastPongTime = Date.now();

// Task tracking
let lastUpdatedTaskId = null;

// DOM elements cache
const elements = {
    kanbanContainer: document.getElementById('kanban-tasks'),
    executionNumber: document.getElementById('execution-number'),
    cancelButton: document.getElementById('cancelExecutionBtn'),
    modalContent: document.getElementById('modalContent'),
    contentModal: document.getElementById('contentModal'),
    humanInputModal: document.getElementById('humanInputModal'),
    humanInputText: document.getElementById('humanInputText')
};

// Initialize CSRF token
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.error('CSRF token not found');
        return '';
    }
    return token.value;
}

// Rest of your code...
async function fetchActiveExecutions() {
    try {
        const response = await fetch(`/agents/crew/${crewId}/active-executions/`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        // Update cancel button based on active executions
        const hasActiveExecution = data.executions && data.executions.length > 0;
        const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
        updateCancelButton(hasActiveExecution, activeExecutionId);
        
        // Clear boards first
        document.querySelectorAll('.kanban-drag').forEach(board => {
            board.innerHTML = '';
        });
        
        // Repopulate with active executions
        data.executions.forEach(execution => {
            updateKanbanBoard({
                execution_id: execution.execution_id,
                task_id: execution.task_id,
                name: execution.name,
                status: execution.status,
                stages: execution.stages
            });
        });
        
        return data;
    } catch (error) {
        console.error('Error fetching active executions:', error);
        return null;
    }
}

function connectWebSocket() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        console.log('WebSocket already connected');
        return;
    }
    
    // Close existing socket if it exists
    if (socket) {
        socket.close();
    }

    // Clear all kanban boards
    document.querySelectorAll('.kanban-drag').forEach(board => {
        board.innerHTML = '';
    });
    
    try {
        socket = new WebSocket(
            `${wsScheme}://${window.location.host}/ws/crew/${crewId}/kanban/`
        );
        
        socket.onopen = function(e) {
            console.log('WebSocket connection established');
            // Fetch active executions when connection is established
            fetchActiveExecutions();
        };

        socket.onmessage = function(e) {
            try {
                const data = JSON.parse(e.data);
                
                if (data.type === 'pong') {
                    lastPongTime = Date.now(); // Track last pong time
                    return;
                }
                
                if (data.type === 'error') {
                    console.error('Server error:', data.message);
                    return;
                }
                
                // Handle different message types
                switch (data.type) {
                    case 'execution_update':
                        updateKanbanBoard(data);
                        break;
                    case 'agent_step':
                        updateAgentProgress(data);
                        break;
                    case 'task_complete':
                        handleTaskComplete(data);
                        break;
                    case 'human_input_request':
                        handleHumanInputRequest(data);
                        break;
                    case 'execution_status_update':
                        handleWebSocketMessage(data);
                        break;
                    default:
                        console.log('Unknown message type:', data.type);
                }
            } catch (error) {
                console.error('Error processing WebSocket message:', error);
            }
        };

        socket.onclose = function(e) {
            console.log('WebSocket connection closed', e.code, e.reason);
            stopPingInterval();
            
            // Don't reconnect if closed normally
            if (e.code === 1000 || e.code === 1001) {
                console.log('WebSocket closed normally');
                return;
            }
            
            // Attempt to reconnect if not at max attempts
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                
                // Exponential backoff with jitter
                reconnectDelay = Math.min(reconnectDelay * 2, 30000);
                const jitter = Math.random() * 1000;
                setTimeout(connectWebSocket, reconnectDelay + jitter);
            } else {
                console.error('Max reconnection attempts reached');
            }
        };

        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
            // Let onclose handle reconnection
        };
        
    } catch (error) {
        console.error('Error creating WebSocket:', error);
        // Attempt to reconnect on connection error
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(connectWebSocket, reconnectDelay);
        }
    }
}

// Ping interval to keep connection alive
function startPingInterval() {
    stopPingInterval(); // Clear any existing interval
    
    // Send ping every 15 seconds
    pingInterval = setInterval(() => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            // Check if we haven't received a pong in 45 seconds
            if (Date.now() - lastPongTime > 45000) {
                console.log('No pong received for 45 seconds, reconnecting...');
                socket.close();
                connectWebSocket();
                return;
            }
            
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 15000);
}

function stopPingInterval() {
    if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
    }
}

// Initial connection
connectWebSocket();

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    stopPingInterval();
    if (socket) {
        socket.close();
    }
});

function showContentModal(stageId, content) {
    try {
        const modalContent = document.getElementById('modalContent');
        if (!modalContent) {
            console.error('Modal content element not found');
            return;
        }
        modalContent.innerHTML = md.render(content);
        const modal = new bootstrap.Modal(document.getElementById('contentModal'));
        modal.show();
    } catch (error) {
        console.error('Error showing modal:', error);
    }
}
function updateKanbanBoard(data) {
    console.log('Updating kanban board:', data);
    
    // Only proceed if we have an execution_id
    if (!data.execution_id) {
        console.log('No execution_id provided, skipping update');
        return;
    }
    
    // Update cancel button based on execution status
    if (data.execution_id && data.status) {
        const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
        updateCancelButton(isActive, isActive ? data.execution_id : null);
    }
    
    // Update execution number in header
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = ` - Execution #${data.execution_id}`;
    }

    // Get CrewAI task ID for kanban board placement
    let crewaiTaskId = data.crewai_task_id;
    
    // Handle system updates (like PENDING, RUNNING, COMPLETED) or null crewai_task_id
    if (!crewaiTaskId || (typeof crewaiTaskId === 'string' && crewaiTaskId.includes('-'))) {
        // If we have a last updated task ID, use that
        if (lastUpdatedTaskId) {
            crewaiTaskId = lastUpdatedTaskId;
        } else {
            // If no last updated task ID, use the first task board
            const firstTaskBoard = document.querySelector('.kanban-board');
            if (firstTaskBoard) {
                addUpdateToBoard(firstTaskBoard, data);
                return;
            } else {
                console.log('No task boards found for system update');
                return;
            }
        }
    } else if (typeof crewaiTaskId === 'number' || (typeof crewaiTaskId === 'string' && !crewaiTaskId.includes('-'))) {
        // This is a regular task update (number or non-hyphenated string)
        // Update the last updated task ID
        lastUpdatedTaskId = crewaiTaskId;
    }

    // Find the task board for this specific task
    const taskBoard = document.querySelector(`[data-task-id="${crewaiTaskId}"]`);
    if (!taskBoard) {
        console.log('Task board not found for CrewAI task ID:', crewaiTaskId);
        // Fallback to first task board if no specific board found
        const firstTaskBoard = document.querySelector('.kanban-board');
        if (firstTaskBoard) {
            addUpdateToBoard(firstTaskBoard, data);
        }
        return;
    }

    // Add the update to the board
    addUpdateToBoard(taskBoard, data);

    // Update all cards in this task board if status is COMPLETED
    const status = data.status?.toUpperCase();
    if (status === 'COMPLETED') {
        const cards = taskBoard.querySelectorAll('.kanban-item');
        cards.forEach(card => {
            const header = card.querySelector('.card-header');
            if (header) {
                header.className = 'card-header bg-gradient-success text-white p-2';
            }
        });
    }
}


function addUpdateToBoard(taskBoard, data) {
const kanbanDrag = taskBoard.querySelector('.kanban-drag');
if (!kanbanDrag) return;

    const stageId = `${data.stage?.stage_type || 'status'}-${Date.now()}`;
    const content = data.stage?.content || '';
    const truncatedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
    
    const stageHtml = `
        <div class="stage-item" data-execution-id="${data.execution_id}" data-stage-id="${stageId}">
            <div class="d-flex justify-content-between align-items-center">
                <div class="d-flex align-items-center gap-2">
                    <span class="stage-status status-${(data.stage?.status || data.status)?.toLowerCase()}">
                        ${data.stage?.status || data.status}
                    </span>
                </div>
                <div class="d-flex align-items-center gap-2">
                    <button class="btn btn-link btn-sm p-0 text-muted" 
                            onclick="showDetailsModal('${stageId}', ${JSON.stringify(data).replace(/"/g, '&quot;')})">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    ${data.stage?.artifacts ? `
                        <button class="btn btn-link btn-sm p-0 text-muted" 
                                onclick="downloadArtifacts('${data.execution_id}', '${stageId}')">
                            <i class="fas fa-download"></i>
                        </button>
                    ` : ''}
                    <span class="time-stamp">${new Date().toLocaleTimeString()}</span>
                </div>
            </div>
            
            <h6 class="stage-title">${data.stage?.title || 'Status Update'}</h6>
            
            <div class="stage-content">
                ${md.render(truncatedContent)}
                <button class="btn btn-sm bg-gradient-info text-white mt-2" 
                        data-stage-id="${stageId}"
                        data-content="${encodeURIComponent(content)}"
                        data-metadata="${encodeURIComponent(JSON.stringify(data.stage?.metadata || {}))}"
                        data-status="${data.stage?.status || 'Unknown'}"
                        data-stage-type="${data.stage?.type || 'Unknown'}"
                        data-agent="${data.stage?.agent || 'Unknown'}">
                    <i class="fas fa-eye me-1"></i>View Details
                </button>
            </div>
            
            ${data.stage?.agent ? `
                <div class="stage-agent">
                    <i class="fas fa-${data.stage.type === 'message' ? 'comment' : 'robot'}"></i>
                    ${data.stage.agent}
                </div>
            ` : ''}
        </div>`;

    kanbanDrag.insertAdjacentHTML('beforeend', stageHtml);
}


function updateAgentProgress(data) {
    console.log('Updating agent progress:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    const stageContainer = execution.querySelector('.card-body');
    const agentSection = stageContainer.querySelector('.agent-progress') || 
        stageContainer.insertAdjacentHTML('beforeend', '<div class="agent-progress mt-3"></div>');

    const progressHtml = `
        <div class="alert alert-info mb-2">
            <strong>${data.agent || 'Agent'}</strong>: ${data.content}
        </div>
    `;
    
    if (agentSection.children.length > 5) {
        agentSection.removeChild(agentSection.firstChild);
    }
    agentSection.insertAdjacentHTML('beforeend', progressHtml);
}

function handleTaskComplete(data) {
    console.log('Task completed:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    // Show completion message
    const stageContainer = execution.querySelector('.card-body');
    const completionHtml = `
        <div class="alert alert-success mb-0">
            <strong>Task Complete!</strong> ${data.message || ''}
        </div>
    `;
    stageContainer.insertAdjacentHTML('beforeend', completionHtml);
}

function handleHumanInputRequest(data) {
    console.log('Human input requested:', data);
    showInputModal(data.execution_id);
}

function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.error('CSRF token not found');
        return '';
    }
    return token.value;
}

function showStartExecutionModal() {
    Swal.fire({
        title: 'Start Crew Execution',
        html: `
            <div class="text-start">
                <p>You are about to start a new crew execution.</p>
                ${!clientId ? '<p class="text-danger">Warning: No client selected. Please select a client first.</p>' : ''}
                <p>The crew will begin processing tasks in sequence.</p>
            </div>
        `,
        icon: 'info',
        showCancelButton: true,
        confirmButtonText: 'Start Execution',
        cancelButtonText: 'Cancel',
        customClass: {
            confirmButton: 'btn bg-gradient-success',
            cancelButton: 'btn bg-gradient-danger'
        },
        buttonsStyling: false
    }).then((result) => {
        if (result.isConfirmed) {
            startExecution();
        }
    });
}

function startExecution() {
    const csrfToken = getCsrfToken();
    
    if (!csrfToken) {
        Swal.fire({
            title: 'Error',
            text: 'CSRF token not found. Please refresh the page.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    if (!clientId) {
        Swal.fire({
            title: 'Error',
            text: 'No client selected. Please select a client first.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    // Clear all kanban boards
    const kanbanBoards = document.querySelectorAll('.kanban-board');
    kanbanBoards.forEach(board => {
        const kanbanDrag = board.querySelector('.kanban-drag');
        if (kanbanDrag) {
            kanbanDrag.innerHTML = '';
        }
    });

    // Reset execution number
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = '';
    }

    fetch(`/agents/crew/${crewId}/start-execution/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            client_id: clientId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            Swal.fire({
                title: 'Success',
                text: 'Execution started successfully',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
        } else {
            throw new Error(data.message || 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        Swal.fire({
            title: 'Error',
            text: 'Error starting execution: ' + error.message,
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    });
}

function showInputModal(executionId) {
    const modal = new bootstrap.Modal(document.getElementById('humanInputModal'));
    document.getElementById('humanInputModal').dataset.executionId = executionId;
    modal.show();
}

function submitHumanInput() {
    const executionId = document.getElementById('humanInputModal').dataset.executionId;
    const inputText = document.getElementById('humanInputText').value;
    const csrfToken = getCsrfToken();
    
    if (!csrfToken) {
        alert('Error: CSRF token not found. Please refresh the page.');
        return;
    }
    
    fetch(`/agents/crew/execution/${executionId}/input/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({ input: inputText })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            bootstrap.Modal.getInstance(document.getElementById('humanInputModal')).hide();
            document.getElementById('humanInputText').value = '';
        } else {
            alert('Error submitting input');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error submitting input');
    });
}

// Update the event listener to match the new showDetailsModal format
document.addEventListener('click', function(e) {
    if (e.target.matches('.view-full-content')) {
        const stageData = {
            stage: {
                stage_id: e.target.dataset.stageId,
                content: decodeURIComponent(e.target.dataset.content),
                metadata: JSON.parse(decodeURIComponent(e.target.dataset.metadata || '{}')),
                status: e.target.dataset.status || 'Unknown',
                type: e.target.dataset.stageType || 'Unknown',
                agent: e.target.dataset.agent || 'Unknown'
            }
        };
        
        showDetailsModal(stageData.stage.stage_id, stageData);
    }
});

// Keep the showDetailsModal function as is since it's now handling the data correctly
function showDetailsModal(stageId, data) {
    try {
        // Parse the data if it's a string
        const stageData = typeof data === 'string' ? JSON.parse(data) : data;
        
        // Set modal content
        document.getElementById('modalStatus').textContent = stageData.stage?.status || stageData.status || 'Unknown';
        document.getElementById('modalStageType').textContent = stageData.stage?.type || 'Unknown';
        document.getElementById('modalAgent').textContent = stageData.stage?.agent || 'Unknown';
        document.getElementById('modalContent').innerHTML = md.render(stageData.stage?.content || '');
        
        // Store the data for export
        document.getElementById('detailsModal').dataset.exportData = JSON.stringify(stageData);
        
        const modal = new bootstrap.Modal(document.getElementById('detailsModal'));
        modal.show();
    } catch (error) {
        console.error('Error showing modal:', error);
    }
}

function exportDetails() {
    const modal = document.getElementById('detailsModal');
    const data = JSON.parse(modal.dataset.exportData || '{}');
    
    // Create export content
    const content = [
        `# Stage Details\n`,
        `## Basic Information`,
        `- Status: ${data.stage?.status || data.status || 'Unknown'}`,
        `- Stage Type: ${data.stage?.type || 'Unknown'}`,
        `- Agent: ${data.stage?.agent || 'Unknown'}\n`,
        `## Content`,
        `${data.stage?.content || ''}\n`
    ].join('\n');
    
    // Create and trigger download
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `stage-details-${Date.now()}.md`;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
}

// Function to show/hide cancel button based on execution status
function updateCancelButton(hasActiveExecution, executionId) {
    console.log('updateCancelButton:', { hasActiveExecution, executionId });  // Debug log
    const cancelBtn = document.getElementById('cancelExecutionBtn');
    if (!cancelBtn) {
        console.error('Cancel button not found');  // Debug log
        return;
    }
    cancelBtn.style.display = hasActiveExecution ? 'block' : 'none';
    if (hasActiveExecution) {
        cancelBtn.setAttribute('data-execution-id', executionId);
    } else {
        cancelBtn.removeAttribute('data-execution-id');
    }
}

// Add cancel execution functionality
async function cancelExecution(executionId) {
    try {
        const result = await Swal.fire({
            title: 'Cancel Execution',
            html: `
                <div class="text-start">
                    <p>Are you sure you want to cancel this execution?</p>
                    <p class="text-warning">This action cannot be undone.</p>
                </div>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, Cancel Execution',
            cancelButtonText: 'No, Keep Running',
            customClass: {
                confirmButton: 'btn bg-gradient-danger me-3',
                cancelButton: 'btn bg-gradient-secondary ms-3',
                actions: 'my-3'
            },
            buttonsStyling: false
        });

        if (result.isConfirmed) {
            const response = await fetch(`/agents/execution/${executionId}/cancel/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error('Failed to cancel execution');
            }
            
            Swal.fire({
                title: 'Execution Cancelled',
                text: 'The execution has been cancelled successfully.',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
            
            updateCancelButton(false);
        }
    } catch (error) {
        console.error('Error cancelling execution:', error);
        Swal.fire({
            title: 'Error',
            text: 'Failed to cancel execution. Please try again.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    }
}

// Add click handler for cancel button
document.getElementById('cancelExecutionBtn').addEventListener('click', function() {
    const executionId = this.getAttribute('data-execution-id');
    if (executionId) {
            cancelExecution(executionId);
        }
    });

function handleWebSocketMessage(data) {
    if (data.type === 'execution_status_update' || data.type === 'execution_update') {
        // Update cancel button based on execution status
        const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
        updateCancelButton(isActive, isActive ? data.execution_id : null);
    }
}
// Initial fetch of active executions and setup of cancel button
document.addEventListener('DOMContentLoaded', async function() {
    const data = await fetchActiveExecutions();
    const hasActiveExecution = data && data.executions && data.executions.length > 0;
    const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
    updateCancelButton(hasActiveExecution, activeExecutionId);
});

================
File: agents/templates/agents/modals/details_modal.html
================
<!-- Details Modal -->
<div class="modal fade" id="detailsModal" tabindex="-1" aria-labelledby="detailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-xl">
        <div class="modal-content">
            <div class="modal-header bg-gradient-primary">
                <h5 class="modal-title text-white" id="detailsModalLabel">
                    <i class="fas fa-info-circle me-2"></i>Stage Details
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-3">  <!-- reduced padding from p-4 -->
                <div class="row">
                    <div class="col-12">  <!-- changed from col-md-6 -->
                        <div class="card card-plain">
                            <div class="card-header pb-0">
                                <h6 class="text-uppercase text-primary">Basic Information</h6>
                            </div>
                            <div class="card-body py-2">  <!-- reduced padding -->
                                <dl class="row mb-0">  <!-- added mb-0 to remove bottom margin -->
                                    <dt class="col-auto text-dark me-2">Status:</dt>  <!-- modified for inline -->
                                    <dd class="col-auto me-4"><span class="badge bg-gradient-info" id="modalStatus"></span></dd>
                                    <dt class="col-auto text-dark me-2">Stage Type:</dt>
                                    <dd class="col-auto me-4"><span class="badge bg-gradient-success" id="modalStageType"></span></dd>
                                    <dt class="col-auto text-dark me-2">Agent:</dt>
                                    <dd class="col-auto"><span class="badge bg-gradient-warning" id="modalAgent"></span></dd>
                                </dl>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-3">  <!-- reduced margin from mt-4 -->
                    <div class="col-12">
                        <div class="card card-plain">
                            <div class="card-header pb-0">
                                <h6 class="text-uppercase text-primary">Content</h6>
                            </div>
                            <div class="card-body">
                                <div class="bg-gray-100 border rounded p-3" style="max-height: 600px; overflow-y: auto;">  <!-- increased from 400px -->
                                    <div id="modalContent"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer bg-gray-100">
                <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn bg-gradient-primary">
                    <i class="fas fa-download me-2"></i>Export Details
                </button>
            </div>
        </div>
    </div>
</div>

================
File: agents/templates/agents/modals/human_input_modal.html
================
<!-- Human Input Modal -->
<div class="modal fade" id="humanInputModal" tabindex="-1" role="dialog" aria-labelledby="humanInputModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="humanInputModalLabel">Provide Human Input</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="humanInputText">Input</label>
          <textarea class="form-control" id="humanInputText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="submitHumanInput()">Submit</button>
      </div>
    </div>
  </div>
</div>

================
File: agents/templates/agents/modals/start_execution_modal.html
================
<!-- Start Execution Modal -->
<div class="modal fade" id="startExecutionModal" tabindex="-1" role="dialog" aria-labelledby="startExecutionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="startExecutionModalLabel">Start New Execution</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to start a new execution for this crew?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="startExecution()">Start Execution</button>
      </div>
    </div>
  </div>
</div>

================
File: agents/templates/agents/agent_form.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load agent_filters %}

{% block title %} {% if agent %}Edit Agent{% else %}Add Agent{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if agent %}Edit Agent{% else %}Add Agent{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% if request.GET.next %}
                            <input type="hidden" name="next" value="{{ request.GET.next }}">
                        {% endif %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.name.errors %}has-error{% endif %}">
                                    <label for="{{ form.name.id_for_label }}" class="form-control-label">Name</label>
                                    {{ form.name }}
                                    {% if form.name.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.name.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group {% if form.role.errors %}has-error{% endif %}">
                                    <label for="{{ form.role.id_for_label }}" class="form-control-label">Role</label>
                                    {{ form.role }}
                                    {% if form.role.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.role.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.goal.errors %}has-error{% endif %}">
                                    <label for="{{ form.goal.id_for_label }}" class="form-control-label">Goal</label>
                                    {{ form.goal }}
                                    {% if form.goal.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.goal.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.backstory.errors %}has-error{% endif %}">
                                    <label for="{{ form.backstory.id_for_label }}" class="form-control-label">Backstory</label>
                                    {{ form.backstory }}
                                    {% if form.backstory.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.backstory.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.llm.errors %}has-error{% endif %}">
                                    <label for="{{ form.llm.id_for_label }}" class="form-control-label">Language Model</label>
                                    <select name="llm" id="{{ form.llm.id_for_label }}" class="form-select">
                                        {% for value, display in form.llm.field.choices %}
                                            <option value="{{ value }}" {% if value == form.llm.value %}selected{% endif %}>{{ display }}</option>
                                        {% endfor %}
                                    </select>
                                    {% if form.llm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group {% if form.function_calling_llm.errors %}has-error{% endif %}">
                                    <label for="{{ form.function_calling_llm.id_for_label }}" class="form-control-label">Function Calling LLM</label>
                                    <select name="function_calling_llm" id="{{ form.function_calling_llm.id_for_label }}" class="form-select">
                                        {% for value, display in form.function_calling_llm.field.choices %}
                                            <option value="{{ value }}" {% if value == form.function_calling_llm.value %}selected{% endif %}>{{ display }}</option>
                                        {% endfor %}
                                    </select>
                                    {% if form.function_calling_llm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.function_calling_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.tools.errors %}has-error{% endif %}">
                                    <label for="{{ form.tools.id_for_label }}" class="form-control-label">Tools</label>
                                    <div class="tool-selection">
                                        {% for tool in form.tools.field.queryset %}
                                        <div class="tool-option mb-2">
                                            <div class="d-flex align-items-center">
                                                <div class="form-check">
                                                    <input type="checkbox" 
                                                           name="tools" 
                                                           value="{{ tool.id }}" 
                                                           id="tool_{{ tool.id }}"
                                                           class="form-check-input tool-checkbox"
                                                           {% if tool.id|stringformat:"i" in form.tools.value|stringformat:"s" %}checked{% endif %}>
                                                    <label class="form-check-label" for="tool_{{ tool.id }}">{{ tool.name }}</label>
                                                </div>
                                                <div class="ms-3 form-check">
                                                    <input type="checkbox" 
                                                           name="force_tool_output_{{ tool.id }}" 
                                                           id="force_tool_{{ tool.id }}"
                                                           class="form-check-input"
                                                           {% if agent and agent|has_force_output_enabled:tool %}checked{% endif %}>
                                                    <label class="form-check-label" for="force_tool_{{ tool.id }}">
                                                        <small>Force Output as Result</small>
                                                        <i class="fas fa-info-circle" data-bs-toggle="tooltip" title="When checked, the tool's output will be used directly as the task result without agent modifications."></i>
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_iter.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_iter.id_for_label }}" class="form-control-label">Max Iterations</label>
                                    {{ form.max_iter }}
                                    {% if form.max_iter.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_iter.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_rpm.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_rpm.id_for_label }}" class="form-control-label">Max RPM</label>
                                    {{ form.max_rpm }}
                                    {% if form.max_rpm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_rpm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_execution_time.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_execution_time.id_for_label }}" class="form-control-label">Max Execution Time</label>
                                    {{ form.max_execution_time }}
                                    {% if form.max_execution_time.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_execution_time.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.verbose.errors %}has-error{% endif %}">
                                    {{ form.verbose }}
                                    <label class="form-check-label" for="{{ form.verbose.id_for_label }}">Verbose</label>
                                    {% if form.verbose.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.verbose.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.allow_delegation.errors %}has-error{% endif %}">
                                    {{ form.allow_delegation }}
                                    <label class="form-check-label" for="{{ form.allow_delegation.id_for_label }}">Allow Delegation</label>
                                    {% if form.allow_delegation.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.allow_delegation.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.cache.errors %}has-error{% endif %}">
                                    {{ form.cache }}
                                    <label class="form-check-label" for="{{ form.cache.id_for_label }}">Cache</label>
                                    {% if form.cache.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.cache.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.step_callback.errors %}has-error{% endif %}">
                                    <label for="{{ form.step_callback.id_for_label }}" class="form-control-label">Step Callback</label>
                                    {{ form.step_callback }}
                                    {% if form.step_callback.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.step_callback.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.system_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.system_template.id_for_label }}" class="form-control-label">System Template</label>
                                    {{ form.system_template }}
                                    {% if form.system_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.system_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.prompt_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.prompt_template.id_for_label }}" class="form-control-label">Prompt Template</label>
                                    {{ form.prompt_template }}
                                    {% if form.prompt_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.prompt_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.response_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.response_template.id_for_label }}" class="form-control-label">Response Template</label>
                                    {{ form.response_template }}
                                    {% if form.response_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.response_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.allow_code_execution.errors %}has-error{% endif %}">
                                    {{ form.allow_code_execution }}
                                    <label class="form-check-label" for="{{ form.allow_code_execution.id_for_label }}">Allow Code Execution</label>
                                    {% if form.allow_code_execution.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.allow_code_execution.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.use_system_prompt.errors %}has-error{% endif %}">
                                    {{ form.use_system_prompt }}
                                    <label class="form-check-label" for="{{ form.use_system_prompt.id_for_label }}">Use System Prompt</label>
                                    {% if form.use_system_prompt.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.use_system_prompt.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.respect_context_window.errors %}has-error{% endif %}">
                                    {{ form.respect_context_window }}
                                    <label class="form-check-label" for="{{ form.respect_context_window.id_for_label }}">Respect Context Window</label>
                                    {% if form.respect_context_window.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.respect_context_window.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.max_retry_limit.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_retry_limit.id_for_label }}" class="form-control-label">Max Retry Limit</label>
                                    {{ form.max_retry_limit }}
                                    {% if form.max_retry_limit.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_retry_limit.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group {% if form.avatar.errors %}has-error{% endif %}">
                                    <label class="form-control-label">Avatar</label>
                                    <div class="avatar-selection">
                                        {% for choice in form.avatar.field.choices %}
                                        <div class="avatar-option">
                                            <input type="radio" name="{{ form.avatar.name }}" id="avatar_{{ forloop.counter }}" value="{{ choice.0 }}" {% if form.avatar.value == choice.0 %}checked{% endif %} class="avatar-input">
                                            <label for="avatar_{{ forloop.counter }}" class="avatar-label">
                                                <img src="{% static 'assets/img/'|add:choice.0 %}" alt="{{ choice.0 }}" class="avatar-image">
                                            </label>
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{{ request.GET.next|default:'/agents/manage/' }}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Agent</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>


{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<style>
    .avatar-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
    }
    .avatar-option {
        position: relative;
    }
    .avatar-input {
        display: none;
    }
    .avatar-label {
        cursor: pointer;
        display: inline-block;
        padding: 2px;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    .avatar-image {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid #fff;
        box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
        transition: all 0.15s ease;
    }
    .avatar-input:checked + .avatar-label .avatar-image {
        border-color: #5e72e4;
        box-shadow: 0 0 0 2px #5e72e4;
    }
    .avatar-input:checked + .avatar-label::after {
        content: '✓';
        position: absolute;
        top: -5px;
        right: -5px;
        background-color: #2dce89;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
    }
    .tool-selection {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ced4da;
        padding: 10px;
        border-radius: 4px;
    }
    .tool-selection label {
        display: block;
        margin-bottom: 5px;
    }
</style>
{% endblock extrastyle %}

{% block extra_js %}
{{ block.super }}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add 'form-control' class to all input, select, and textarea elements
        var formElements = document.querySelectorAll('input, select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        // Add 'form-select' class to select elements
        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        // Add 'form-check-input' class to checkbox inputs
        var checkboxInputs = document.querySelectorAll('input[type="checkbox"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Add click event for avatar selection
        var avatarInputs = document.querySelectorAll('.avatar-input');
        avatarInputs.forEach(function(input) {
            input.addEventListener('change', function() {
                document.querySelectorAll('.avatar-label').forEach(function(label) {
                    label.classList.remove('selected');
                });
                if (this.checked) {
                    this.nextElementSibling.classList.add('selected');
                }
            });
        });

        // Trigger change event on the checked avatar input to highlight it on page load
        var checkedAvatar = document.querySelector('.avatar-input:checked');
        if (checkedAvatar) {
            checkedAvatar.dispatchEvent(new Event('change'));
        }

        // Add form validation
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                event.preventDefault();
                alert('Please fill in all required fields.');
            }
        });
    });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/base_agents.html
================
{% extends "layouts/base.html" %}

{% block title %} CrewAI Agents {% endblock %}

{% block content %}

<div class="container-fluid">
    <div class="row">
        <div class="col-md-3">
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Agents</h5>
                    <a href="{% url 'agents:manage_agents' %}" class="text-muted">
                        <i class="fas fa-cog"></i>
                    </a>
                </div>
                <div class="card-body">
                    {% block agents_list %}{% endblock %}
                </div>
            </div>
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">Previous Tasks</h5>
                </div>
                <div class="card-body">
                    {% block previous_tasks %}{% endblock %}
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">CrewAI Execution</h5>
                </div>
                <div class="card-body">
                    {% block main_content %}{% endblock %}
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
    // Add any JavaScript specific to the agents app here
</script>
{% endblock extra_js %}

{% block extrastyle %}
<style>
    .card-header .fa-cog {
        font-size: 1.2em;
        transition: transform 0.3s ease;
    }
    .card-header .fa-cog:hover {
        transform: rotate(90deg);
    }
</style>
{% endblock extrastyle %}

================
File: agents/templates/agents/chat.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
{% csrf_token %}
<div class="container-fluid py-4">
    <div class="row">
        <!-- Conversation List Sidebar -->
        <div class="col-md-3">
            <div class="card">
                <div class="card-header p-3">
                    <h6 class="mb-0">Conversations</h6>
                </div>
                <div class="card-body p-2" style="height: 75vh; overflow-y: auto;">
                    <div class="list-group list-group-flush" id="conversation-list">
                        {% for conv in conversations %}
                        <div class="position-relative mb-2">
                            <a href="{% url 'agents:chat' session_id=conv.session_id %}" 
                               class="list-group-item list-group-item-action border-radius-lg py-2 px-3 d-flex flex-column
                               {% if current_conversation and current_conversation.id == conv.id %}
                               bg-gradient-primary active
                               {% else %}
                               bg-transparent
                               {% endif %}">
                                <div class="d-flex justify-content-between align-items-center pe-4">
                                    <h6 class="mb-1 text-sm font-weight-bold {% if current_conversation and current_conversation.id == conv.id %}text-white{% else %}text-default{% endif %}">
                                        {{ conv.title|truncatechars:30 }}
                                    </h6>
                                    <small class="{% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-secondary{% endif %}">
                                        {{ conv.updated_at|date:"M d, Y" }}
                                    </small>
                                </div>
                                <div class="d-flex justify-content-between align-items-center">
                                    <small class="{% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-body{% endif %}">
                                        {% if conv.agent %}{{ conv.agent.name }}{% endif %}
                                        {% if conv.client %} - {{ conv.client.name }}{% endif %}
                                    </small>
                                </div>
                            </a>
                            <button type="button"
                                    class="btn btn-link position-absolute top-0 end-0 mt-2 me-1 p-1 z-index-3 {% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-danger{% endif %}"
                                    onclick="deleteConversation('{{ conv.session_id }}', event)"
                                    title="Delete conversation">
                                <i class="fas fa-trash-alt text-xs"></i>
                            </button>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="col-md-9">
            <div class="row mb-4">
                <div class="col-lg-2 col-md-6">
                    <div class="card">
                        <div class="card-body p-3 d-flex justify-content-between align-items-center">
                            <div id="connection-status" class="d-flex align-items-center">
                                <span class="connection-dot"></span>
                            </div>
                            <button id="new-chat-btn" class="btn btn-primary btn-sm ms-3" data-url="{% url 'agents:chat' %}">
                                <i class="fas fa-plus me-2"></i>New Chat
                            </button>
                        </div>
                    </div>
                </div>
                <div class="col-lg-3 col-md-6">
                    <div class="card">
                        <div class="card-body p-3">
                            <div class="form-group">
                                <label for="agent-select" class="form-control-label">Select Agent</label>
                                <select class="form-control" id="agent-select" searchable="true">
                                    {% for agent in agents %}
                                        <option value="{{ agent.id }}" 
                                            data-avatar="{{ agent.avatar }}"
                                            data-name="{{ agent.name }}"
                                            {% if current_conversation and current_conversation.agent_id == agent.id %}selected{% endif %}>
                                            {{ agent.name }}
                                        </option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4 col-md-6">
                    <div class="card">
                        <div class="card-body p-3">
                            <div class="form-group">
                                <label for="model-select" class="form-control-label">Select Model</label>
                                <select class="form-control" id="model-select" searchable="true">
                                    {% for model in models %}
                                        <option value="{{ model }}" {% if model == default_model %}selected{% endif %}>
                                            {{ model }}
                                        </option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-3 col-md-6">
                    <div class="card">
                        <div class="card-body p-3">
                            <div class="form-group">
                                <label for="client-select" class="form-control-label">Select Client</label>
                                <select class="form-control" id="client-select" searchable="true">
                                    <option value="">No Client</option>
                                    {% for client in clients %}
                                        <option value="{{ client.id }}" {% if current_conversation and current_conversation.client_id == client.id %}selected{% endif %}>
                                            {{ client.name }}
                                        </option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div class="card">
                <div class="card-header p-3">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="d-flex align-items-center">
                                <div class="avatar avatar-sm me-2" id="agent-avatar">
                                    <img src="{% static 'assets/img/team-3.jpg' %}" class="avatar-img rounded-circle" alt="AI">
                                </div>
                                <h6 class="mb-0" id="agent-name">AI Assistant</h6>
                            </div>
                        </div>
                        <div class="col-md-6 d-flex justify-content-end align-items-center">
                            <span class="badge bg-gradient-primary" id="selected-model">
                                {{ default_model }}
                            </span>
                        </div>
                    </div>
                </div>
                <div class="card-body p-3" 
                     id="chat-messages" 
                     data-session-id="{{ session_id }}"
                     {% if current_conversation %}data-conversation-id="{{ current_conversation.id }}"{% endif %}
                     style="height: 70vh; overflow-y: auto;">
                    <!-- Messages will be inserted here by JavaScript -->
                </div>
                <div class="card-footer p-3">
                    <div class="row">
                        <div class="col">
                            <div class="input-group">
                                <textarea id="message-input" class="form-control" 
                                    placeholder="Type your message..." rows="1"
                                    style="resize: none;"></textarea>
                                <button class="btn btn-primary mb-0 px-4" id="send-message" style="min-width: 100px;">
                                    <i class="fas fa-paper-plane me-2"></i>Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="{% static 'agents/css/chat.css' %}?v={% now 'U' %}">
{% endblock extrastyle %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/autosize.js/6.0.1/autosize.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

<script>
    // Initialize chat configuration
    window.chatConfig = {
        sessionId: '{{ session_id }}',
        currentConversation: {% if current_conversation %}{{ current_conversation.id }}{% else %}null{% endif %},
        urls: {
            newChat: '{% url "agents:chat" %}',
            deleteConversation: '/agents/chat/{sessionId}/delete/',
            wsBase: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/chat/`
        },
        csrfToken: document.querySelector('[name=csrfmiddlewaretoken]').value,
        defaultModel: '{{ default_model }}'
    };
</script>

<script type="module">
    import { ChatApp } from "{% static 'agents/js/chat/app.js' %}";
    
    // Initialize chat application
    document.addEventListener('DOMContentLoaded', () => {
        const app = new ChatApp(window.chatConfig);
        app.initialize();
    });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/confirm_delete.html
================
{% extends "layouts/base.html" %}

{% block title %} Confirm Delete {% endblock %}

{% block content %}
<div class="container-fluid">
    <h1 class="mb-4">Confirm Delete</h1>
    <p>Are you sure you want to delete the following {{ type }}?</p>
    <p><strong>{{ object }}</strong></p>
    <form method="post">
        {% csrf_token %}
        <button type="submit" class="btn btn-danger">Confirm Delete</button>
        <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-secondary">Cancel</a>
    </form>
</div>
{% endblock content %}

================
File: agents/templates/agents/connection_test.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} WebSocket Connection Test {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>WebSocket Connection Test</h6>
        </div>
        <div class="card-body">
          <div id="status" class="alert alert-info">Initializing...</div>
          <button id="connect-btn" class="btn btn-primary mb-3">Connect to WebSocket</button>
          <button id="send-btn" class="btn btn-secondary mb-3" disabled>Send Test Message</button>
          <div id="log" class="bg-light p-3" style="height: 300px; overflow-y: auto;">
            <pre><code></code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const statusDiv = document.getElementById('status');
    const logDiv = document.getElementById('log');
    const connectBtn = document.getElementById('connect-btn');
    const sendBtn = document.getElementById('send-btn');
    let socket = null;

    function log(message) {
      const logContent = logDiv.querySelector('code');
      logContent.innerHTML += message + '\n';
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function connect() {
      log('Attempting to connect...');
      
      const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsPath = `${wsScheme}${window.location.host}/ws/connection_test/`;
      
      log(`Connecting to: ${wsPath}`);
      
      socket = new WebSocket(wsPath);

      socket.onopen = function(e) {
        log('WebSocket connection established');
        statusDiv.textContent = 'Connected';
        statusDiv.className = 'alert alert-success';
        connectBtn.disabled = true;
        sendBtn.disabled = false;
      };

      socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        if (data.error) {
          log(`Error: ${data.error}`);
        } else {
          log(`Received message: ${data.message}`);
        }
      };

      socket.onclose = function(event) {
        if (event.wasClean) {
          log(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
        } else {
          log('Connection died');
        }
        statusDiv.textContent = 'Disconnected';
        statusDiv.className = 'alert alert-danger';
        connectBtn.disabled = false;
        sendBtn.disabled = true;
      };

      socket.onerror = function(error) {
        log(`WebSocket Error: ${error.message}`);
        console.error('WebSocket Error:', error);
        statusDiv.textContent = 'Error occurred';
        statusDiv.className = 'alert alert-danger';
      };
    }

    connectBtn.onclick = connect;

    sendBtn.onclick = function() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const message = 'Test message from client';
        socket.send(JSON.stringify({ message: message }));
        log(`Sent message: ${message}`);
      } else {
        log('WebSocket is not connected');
      }
    };
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/crew_detail.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Detail {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-lg-8 col-md-12">
      <!-- Existing crew details card -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between">
            <h6 class="mb-0">{{ crew.name }}</h6>
          </div>
          <p class="text-sm mb-0">{{ crew.description }}</p>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder">Process</h6>
              <p class="text-sm mb-3">{{ crew.get_process_display }}</p>
            </div>
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder">Verbose</h6>
              <p class="text-sm mb-3">{{ crew.verbose|yesno:"Yes,No" }}</p>
            </div>
          </div>
          <hr class="horizontal dark">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Agents</h6>
              <ul class="list-group">
                {% for agent in crew.agents.all %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">
                  <strong class="text-dark">{{ agent.name }}</strong> &nbsp;|&nbsp; {{ agent.role }}
                </li>
                {% empty %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">No agents assigned to this crew.</li>
                {% endfor %}
              </ul>
            </div>
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Tasks</h6>
              <ul class="list-group">
                {% for task in crew.tasks.all %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">{{ task.description|slice:":250" }}</li>
                {% empty %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">No tasks assigned to this crew.</li>
                {% endfor %}
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Modify the "Start New Execution" card -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6 class="mb-0">Start New Execution for {{ crew.name }}</h6>
          {% if selected_client %}
            <p class="text-sm mb-0">Selected Client: {{ selected_client.name }}</p>
            <p class="text-sm mb-0">Selected Client URL: {{ selected_client.website_url }}</p>
          {% else %}
            <p class="text-sm mb-0">No client selected</p>
          {% endif %}
        </div>
        <div class="card-body">
          <form method="post" id="crew-execution-form">
            {% csrf_token %}
            {% for field in form %}
              {% if field.name != 'crew' %}
                <div class="form-group">
                  <label for="{{ field.id_for_label }}" class="form-control-label">{{ field.label }}</label>
                  {% if field.field.widget.input_type == 'textarea' %}
                    <textarea class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}" rows="4">{{ field.value|default:'' }}</textarea>
                  {% elif field.field.widget.input_type == 'select' %}
                    <select class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}">
                      {% for choice in field.field.choices %}
                        <option value="{{ choice.0 }}" {% if choice.0 == field.value %}selected{% endif %}>{{ choice.1 }}</option>
                      {% endfor %}
                    </select>
                  {% else %}
                    <input type="{{ field.field.widget.input_type }}" class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}" value="{{ field.value|default:'' }}">
                  {% endif %}
                  {% if field.help_text %}
                    <small class="form-text text-muted">{{ field.help_text }}</small>
                  {% endif %}
                  {% for error in field.errors %}
                    <div class="invalid-feedback d-block">{{ error }}</div>
                  {% endfor %}
                </div>
              {% endif %}
            {% endfor %}

            <!-- Add dynamic input fields based on crew.input_variables -->
            {% if crew.input_variables %}
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mt-4 mb-3">Input Variables</h6>
              {% for variable in crew.input_variables %}
                <div class="form-group">
                  <label for="input_{{ variable }}" class="form-control-label">{{ variable|title }}</label>
                  <input type="text" class="form-control" id="input_{{ variable }}" name="input_variables[{{ variable }}]" required>
                </div>
              {% endfor %}
            {% endif %}

            <button type="submit" class="btn btn-primary mt-3" id="submit-btn">Start Execution</button>
          </form>
        </div>
      </div>
      <!-- New card for real-time updates -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Real-time Execution Updates</h6>
          <p class="text-sm">
            <i class="fa fa-clock me-1"></i>
            Status: <span id="execution-status" class="badge bg-gradient-info">No active execution</span>
          </p>
        </div>
        <div class="card-body p-3">
          <!-- Human input section -->
          <div id="human-input-section" style="display: none; margin-bottom: 20px;">
            <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Human Input Required</h6>
            <div id="human-input-prompt" class="text-sm mb-2"></div>
            <textarea id="human-input-response" class="form-control mb-3" rows="3"></textarea>
            <button id="submit-human-input" class="btn btn-primary">Submit Input</button>
          </div>

          <!-- Messages container with timeline styling -->
          <div class="messages-container" style="width: 100%; padding-left: 45px; position: relative;">
            <!-- Timeline vertical line -->
            <div style="position: absolute; left: 16px; top: 0; bottom: 0; width: 2px; background-color: #dee2e6;"></div>
            
            <div id="execution-messages">
              <!-- Messages will be dynamically inserted here -->
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-4 col-md-12 mt-4 mt-lg-0">
      <div class="card h-100">
        <div class="card-header pb-0">
          <h6 class="mb-0">Recent Executions</h6>
        </div>
        <div class="card-body p-3">
          <div class="timeline timeline-one-side">
            {% for execution in recent_executions %}
            <div class="timeline-block mb-3">
              <span class="timeline-step">
                <i class="ni ni-bell-55 text-{% if execution.status == 'COMPLETED' %}success{% elif execution.status == 'FAILED' %}danger{% else %}warning{% endif %}"></i>
              </span>
              <div class="timeline-content">
                <h6 class="text-dark text-sm font-weight-bold mb-0">{{ execution.get_status_display }}</h6>
                <p class="text-secondary font-weight-bold text-xs mt-1 mb-0">{{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}</p>
                <p class="text-sm mt-3 mb-2">
                  <a href="{% url 'agents:execution_detail' execution.id %}" class="text-primary">View Details</a>
                </p>
              </div>
            </div>
            {% empty %}
            <p class="text-sm mb-0">No previous executions for this crew.</p>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- Human Input Modal -->
<div class="modal fade" id="human-input-modal" tabindex="-1" role="dialog" aria-labelledby="human-input-modal-label" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="human-input-modal-label">Human Input Required</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="human-input-prompt" class="form-control-label">Prompt:</label>
          <p id="human-input-prompt" class="text-sm mb-3"></p>
          <label for="human-input-response" class="form-control-label">Your Response:</label>
          <textarea class="form-control" id="human-input-response" rows="4"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="submit-human-input">Submit</button>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  $(function () {
    let socket = null;
    let activeExecutionId = null;

    $('#crew-execution-form').on('submit', function(e) {
      e.preventDefault();
      var form = $(this);
      var url = form.attr('action');
      
      // Serialize the form data, including the dynamic input variables
      var formData = form.serializeArray();
      var inputVariables = {};
      formData.forEach(function(item) {
        if (item.name.startsWith('input_variables[')) {
          var key = item.name.match(/\[(.*?)\]/)[1];
          inputVariables[key] = item.value;
        }
      });
      
      // Add the input_variables to the form data
      formData.push({name: 'input_variables', value: JSON.stringify(inputVariables)});
      
      $.ajax({
        type: "POST",
        url: url,
        data: $.param(formData),
        success: function(data) {
          activeExecutionId = data.execution_id;
          connectWebSocket(activeExecutionId);
          $('#execution-status').text('Execution started');
          $('#execution-messages').empty();
        },
        error: function(xhr, status, error) {
          var errorMessage = xhr.status + ': ' + xhr.statusText;
          alert('Error - ' + errorMessage);
        }
      });
    });

    function connectWebSocket(executionId) {
      const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsPath = `${wsScheme}${window.location.host}/ws/crew_execution/${executionId}/`;
      
      socket = new WebSocket(wsPath);

      socket.onopen = function(e) {
        console.log('WebSocket connection established');
      };

      socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      };

      socket.onclose = function(event) {
        console.log('WebSocket connection closed');
      };

      socket.onerror = function(error) {
        console.error('WebSocket Error:', error);
      };
    }

    function handleWebSocketMessage(data) {
      if (data.status) {
        let statusClass = 'info';
        if (data.status === 'COMPLETED') statusClass = 'success';
        else if (data.status === 'FAILED') statusClass = 'danger';
        else if (data.status === 'WAITING_FOR_HUMAN_INPUT') statusClass = 'warning';
        
        $('#execution-status').removeClass().addClass(`badge bg-gradient-${statusClass}`).text(data.status);
      }
      
      if (data.messages && data.messages.length > 0) {
        data.messages.forEach(msg => {
          const timestamp = new Date().toLocaleString();
          const messageHtml = `
            <div class="message-block">
              <span class="timeline-step">
                <i class="ni ${msg.agent ? 'ni-spaceship text-primary' : 'ni-bell-55 text-success'} text-gradient"></i>
              </span>
              <div class="message-content">
                <div class="d-flex justify-content-between">
                  <h6 class="text-dark text-sm font-weight-bold mb-0">${msg.agent || 'System Message'}</h6>
                  <p class="text-secondary font-weight-bold text-xs mt-1 mb-0">${timestamp}</p>
                </div>
                <div class="message-content">
                  <div class="text-sm mt-2 mb-0 message-preview">
                    ${msg.content.substring(0, 150)}${msg.content.length > 150 ? '...' : ''}
                  </div>
                  <div class="message-full collapse">
                    <div class="text-sm mt-2 mb-0">
                      ${msg.content}
                    </div>
                  </div>
                  ${msg.content.length > 150 ? `
                    <a href="javascript:;" class="text-xs text-primary toggle-message">Show more</a>
                  ` : ''}
                </div>
              </div>
            </div>
          `;
          $('#execution-messages').append(messageHtml);
        });
        
        // Scroll to the bottom of the messages container
        const messagesContainer = document.querySelector('.messages-container');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      if (data.human_input_request) {
        showHumanInputPrompt(data.human_input_request);
      } else if (data.status !== 'WAITING_FOR_HUMAN_INPUT') {
        $('#human-input-section').hide();
      }

      if (data.status === 'COMPLETED' || data.status === 'FAILED') {
        socket.close();
        activeExecutionId = null;
      }
    }

    function showHumanInputPrompt(prompt) {
      $('#human-input-prompt').text(prompt);
      $('#human-input-section').show();
      $('#human-input-response').focus();
    }

    // Update this event listener
    $(document).on('click', '#submit-human-input', function() {
    let userInput = $('#human-input-response').val();
    let inputKey = `human_input_request_${activeExecutionId}`;
    
    $.ajax({
        type: "POST",
        url: `/agents/execution/${activeExecutionId}/submit_human_input/`,
        data: {
            input_key: inputKey,
            response: userInput
        },
        headers: {
            "X-CSRFToken": getCookie("csrftoken")
        },
        success: function(data) {
            $('#human-input-section').hide();
            $('#human-input-response').val('');
            
            // Scroll to the bottom of the messages container
            const messagesContainer = document.getElementById('execution-messages-container');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        },
        error: function(xhr, status, error) {
            console.error('Error submitting human input:', error);
            alert('Error submitting input. Please try again.');
        }
    });
});
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }

    // Add this event handler for the show more/less functionality
    $(document).on('click', '.toggle-message', function(e) {
      e.preventDefault();
      const messageContent = $(this).closest('.message-content');
      const preview = messageContent.find('.message-preview');
      const full = messageContent.find('.message-full');
      
      if (full.hasClass('show')) {
        full.collapse('hide');
        preview.show();
        $(this).text('Show more');
      } else {
        full.collapse('show');
        preview.hide();
        $(this).text('Show less');
      }
    });
  });
</script>
{% endblock extra_js %}

{% block extrastyle %}
{{ block.super }}
<style>
  .message-block {
    position: relative;
    margin-bottom: 1.5rem;
    width: 100%;
  }

  .timeline-step {
    position: absolute;
    left: -29px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #dee2e6;
  }

  .message-content {
    width: 100%;
  }

  .message-preview {
    display: block !important; /* Override the previous -webkit-box display */
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  .message-full {
    margin-top: 0.5rem;
    display: none; /* Hide by default */
  }

  .message-full.show {
    display: block;
  }

  .messages-container {
    max-height: 600px;
    overflow-y: auto;
  }

  /* Add styles for code blocks within messages */
  .message-content pre {
    background-color: #f8f9fa;
    padding: 1rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-size: 0.875em;
  }

  .message-content code {
    font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
</style>
{% endblock extrastyle %}

================
File: agents/templates/agents/crew_form.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} {% if crew %}Edit Crew{% else %}Add Crew{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if crew %}Edit Crew{% else %}Add Crew{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post" id="crew-form">
                        {% csrf_token %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.name.id_for_label }}" class="form-control-label">Name</label>
                                    {{ form.name }}
                                    {% if form.name.errors %}
                                        <div class="text-danger">
                                            {{ form.name.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.agents.id_for_label }}" class="form-control-label">Agents</label>
                                    {{ form.agents }}
                                    {% if form.agents.errors %}
                                        <div class="text-danger">
                                            {{ form.agents.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="{{ form.tasks.id_for_label }}" class="form-control-label">Tasks</label>
                                    {{ form.tasks }}
                                    {% if form.tasks.errors %}
                                        <div class="text-danger">
                                            {{ form.tasks.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label class="form-control-label">Task Order</label>
                                    <ul id="task-order-list" class="list-group">
                                        {% for crew_task in crew.crew_tasks.all %}
                                            <li class="list-group-item" data-task-id="{{ crew_task.task.id }}">
                                                <span class="badge bg-primary me-2">{{ forloop.counter }}</span>
                                                {{ crew_task.task.description }}
                                                <input type="hidden" name="task_order[]" value="{{ crew_task.task.id }}">
                                            </li>
                                        {% endfor %}
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.process.id_for_label }}" class="form-control-label">Process</label>
                                    {{ form.process }}
                                    {% if form.process.errors %}
                                        <div class="text-danger">
                                            {{ form.process.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_llm.id_for_label }}" class="form-control-label">Manager LLM</label>
                                    {{ form.manager_llm }}
                                    {% if form.manager_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.function_calling_llm.id_for_label }}" class="form-control-label">Function Calling LLM</label>
                                    {{ form.function_calling_llm }}
                                    {% if form.function_calling_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.function_calling_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.config.id_for_label }}" class="form-control-label">Config</label>
                                    {{ form.config }}
                                    {% if form.config.errors %}
                                        <div class="text-danger">
                                            {{ form.config.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.max_rpm.id_for_label }}" class="form-control-label">Max RPM</label>
                                    {{ form.max_rpm }}
                                    {% if form.max_rpm.errors %}
                                        <div class="text-danger">
                                            {{ form.max_rpm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.language.id_for_label }}" class="form-control-label">Language</label>
                                    {{ form.language }}
                                    {% if form.language.errors %}
                                        <div class="text-danger">
                                            {{ form.language.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.language_file.id_for_label }}" class="form-control-label">Language File</label>
                                    {{ form.language_file }}
                                    {% if form.language_file.errors %}
                                        <div class="text-danger">
                                            {{ form.language_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.embedder.id_for_label }}" class="form-control-label">Embedder</label>
                                    {{ form.embedder }}
                                    {% if form.embedder.errors %}
                                        <div class="text-danger">
                                            {{ form.embedder.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.output_log_file.id_for_label }}" class="form-control-label">Output Log File</label>
                                    {{ form.output_log_file }}
                                    {% if form.output_log_file.errors %}
                                        <div class="text-danger">
                                            {{ form.output_log_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_agent.id_for_label }}" class="form-control-label">Manager Agent</label>
                                    {{ form.manager_agent }}
                                    {% if form.manager_agent.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_agent.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_callbacks.id_for_label }}" class="form-control-label">Manager Callbacks</label>
                                    {{ form.manager_callbacks }}
                                    {% if form.manager_callbacks.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_callbacks.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.prompt_file.id_for_label }}" class="form-control-label">Prompt File</label>
                                    {{ form.prompt_file }}
                                    {% if form.prompt_file.errors %}
                                        <div class="text-danger">
                                            {{ form.prompt_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.planning_llm.id_for_label }}" class="form-control-label">Planning LLM</label>
                                    {{ form.planning_llm }}
                                    {% if form.planning_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.planning_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.verbose }}
                                    <label class="form-check-label" for="{{ form.verbose.id_for_label }}">Verbose</label>
                                    {% if form.verbose.errors %}
                                        <div class="text-danger">
                                            {{ form.verbose.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.memory }}
                                    <label class="form-check-label" for="{{ form.memory.id_for_label }}">Memory</label>
                                    {% if form.memory.errors %}
                                        <div class="text-danger">
                                            {{ form.memory.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.cache }}
                                    <label class="form-check-label" for="{{ form.cache.id_for_label }}">Cache</label>
                                    {% if form.cache.errors %}
                                        <div class="text-danger">
                                            {{ form.cache.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.full_output }}
                                    <label class="form-check-label" for="{{ form.full_output.id_for_label }}">Full Output</label>
                                    {% if form.full_output.errors %}
                                        <div class="text-danger">
                                            {{ form.full_output.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.share_crew }}
                                    <label class="form-check-label" for="{{ form.share_crew.id_for_label }}">Share Crew</label>
                                    {% if form.share_crew.errors %}
                                        <div class="text-danger">
                                            {{ form.share_crew.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.planning }}
                                    <label class="form-check-label" for="{{ form.planning.id_for_label }}">Planning</label>
                                    {% if form.planning.errors %}
                                        <div class="text-danger">
                                            {{ form.planning.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <!-- Replace the existing input variables section with this -->
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="input_variables" class="form-control-label">Input Variables</label>
                                    <div id="input-variables-container" class="row">
                                        <!-- We'll populate this dynamically with JavaScript -->
                                    </div>
                                    <button type="button" id="add-variable" class="btn btn-outline-primary btn-sm mt-2">Add Variable</button>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{% url 'agents:manage_crews' %}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Crew</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Choices.js for select fields
        var selectFields = document.querySelectorAll('select');
        selectFields.forEach(function(select) {
            new Choices(select, {
                removeItemButton: true,
                placeholder: true,
                placeholderValue: 'Select an option'
            });
        });
        try {
            const initialInputVariables = JSON.parse('{{ input_variables_json|safe }}');
            // ... rest of your code ...
        } catch (error) {
            console.error('Error parsing initial input variables:', error, '{{ input_variables_json|safe }}'); //log the json
        }
        // Add classes to form elements
        var formElements = document.querySelectorAll('input:not([type="checkbox"]):not([type="radio"]), select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        var checkboxInputs = document.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Form validation and submission
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                alert('Please fill in all required fields.');
                return;
            }

            const formData = new FormData(form);
            const inputVariables = formData.getAll('input_variables[]');
            console.log('Submitting form with input variables:', inputVariables);
            form.submit();
        });

        const taskSelect = document.getElementById('{{ form.tasks.id_for_label }}');
        const taskOrderList = document.getElementById('task-order-list');

        // Initialize Sortable
        new Sortable(taskOrderList, {
            animation: 150,
            onEnd: function() {
                updateTaskOrder();
            }
        });

        // Update task order when tasks are selected or deselected
        taskSelect.addEventListener('change', function() {
            updateTaskList();
        });

        function updateTaskList() {
            const selectedTasks = Array.from(taskSelect.selectedOptions);
            const currentOrder = Array.from(taskOrderList.children).map(li => li.dataset.taskId);
            
            // Remove tasks that are no longer selected
            currentOrder.forEach(taskId => {
                if (!selectedTasks.some(option => option.value === taskId)) {
                    const li = taskOrderList.querySelector(`li[data-task-id="${taskId}"]`);
                    if (li) li.remove();
                }
            });

            // Add newly selected tasks
            selectedTasks.forEach(function(option) {
                if (!currentOrder.includes(option.value)) {
                    const listItem = document.createElement('li');
                    listItem.className = 'list-group-item';
                    listItem.dataset.taskId = option.value;
                    listItem.innerHTML = `
                        <span class="badge bg-primary me-2"></span>
                        ${option.text}
                        <input type="hidden" name="task_order[]" value="${option.value}">
                    `;
                    taskOrderList.appendChild(listItem);
                }
            });

            updateTaskOrder();
        }

        function updateTaskOrder() {
            const items = taskOrderList.querySelectorAll('li');
            items.forEach(function(item, index) {
                item.querySelector('.badge').textContent = index + 1;
                item.querySelector('input[name="task_order[]"]').value = item.dataset.taskId;
            });
        }

        const inputVariablesContainer = document.getElementById('input-variables-container');
    const addVariableButton = document.getElementById('add-variable');

    addVariableButton.addEventListener('click', function() {
        addInputVariable();
    });

    inputVariablesContainer.addEventListener('click', function(e) {
        if (e.target.classList.contains('remove-variable') || e.target.closest('.remove-variable')) {
            e.target.closest('.col-md-4').remove();
        }
    });

    function addInputVariable(value = '') {
        const newInput = document.createElement('div');
        newInput.className = 'col-md-4 mb-2';
        newInput.innerHTML = `
            <div class="input-group">
                <input type="text" name="input_variables[]" class="form-control form-control-sm" value="${value}" required>
                <button type="button" class="btn btn-outline-secondary btn-sm remove-variable">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        inputVariablesContainer.appendChild(newInput);
    }

    // Parse and render initial input variables
    try {
        const initialInputVariables = JSON.parse('{{ input_variables_json|safe }}');
        console.log('Initial input variables:', initialInputVariables);
        
        if (Array.isArray(initialInputVariables)) {
            initialInputVariables.forEach(variable => {
                addInputVariable(variable);
                console.log('Added input variable:', variable);
            });
        }
    } catch (error) {
        console.error('Error parsing initial input variables:', error);
    }
});
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/crew_kanban.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Kanban {% endblock %}
{% block extrastyle %}
{{ block.super }}
<link rel="stylesheet" type="text/css" href="{% static 'agents/css/crew_kanban.css' %}?v=29" crossorigin="anonymous"/>
{% endblock extrastyle %}

{% block content %}
{% csrf_token %}

<div class="container-fluid py-4">
    <!-- Header Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <!-- Left side with crew info -->
                        <div class="d-flex">
                            <div class="me-3">
                                <div class="avatar avatar-xl position-relative">
                                    <img src="{% static 'assets/img/team-1.jpg' %}" alt="profile_image" class="w-100 border-radius-lg shadow-sm">
                                </div>
                            </div>
                            <div>
                                <h5 class="mb-1">{{ crew.name }}</h5>
                                <p class="mb-0 font-weight-bold text-sm">Execution #{{ execution.id }}</p>
                                <p class="mb-0 text-sm">Started: {{ execution.created_at|date:"Y-m-d H:i:s" }}</p>
                                <p class="mb-0 text-sm">Client: {{client.name}} - {{client.website_url}}</p>
                            </div>
                        </div>
                        
                        <!-- Right side with buttons -->
                        <div class="d-flex gap-2">
                            <button id="cancelExecutionBtn" class="btn btn-danger" style="display: none;">
                                <i class="fas fa-stop-circle me-2"></i>Cancel Execution
                            </button>
                            <button class="btn btn-primary" onclick="showStartExecutionModal()">
                                <i class="fas fa-play me-2"></i>Start Crew Execution
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Tasks Section -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex align-items-center">
                        <h6 class="mb-0">Tasks</h6>
                        <span id="execution-number" class="text-sm ms-2"></span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="kanban-container" id="kanban-tasks">
                        {% for task in tasks %}
                        <!-- Task Board -->
                        <div class="kanban-board" data-task-id="{{ task.id }}">
                            <header class="kanban-board-header rounded-top p-3">
                                <div class="text-white">
                                    <div class="task-description" data-bs-toggle="collapse" 
                                         href="#taskDesc{{ task.id }}" role="button" 
                                         aria-expanded="false" aria-controls="taskDesc{{ task.id }}">
                                        {{ task.name|truncatechars:200 }}
                                    </div>
                                    <div class="collapse" id="taskDesc{{ task.id }}">
                                        <div class="text-white-50 mt-2">
                                            {{ task.name }}
                                        </div>
                                    </div>
                                </div>
                            </header>
                            <div class="kanban-drag bg-white rounded-bottom border border-top-0">
                                <!-- Task items will be dynamically added here -->
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% include "agents/modals/human_input_modal.html" %}
{% include "agents/modals/details_modal.html" %}

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- Add SweetAlert2 -->
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<!-- jKanban -->
<script src="{% static 'assets/js/plugins/jkanban/jkanban.min.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script>
    // Initialize crew and client IDs from Django template
    const crewId = "{{ crew.id }}";
    const clientId = "{% if client %}{{ client.id }}{% else %}null{% endif %}";
</script>
<script src="{% static 'agents/js/crew_kanban.js' %}?v={% now 'YmdHis' %}"></script>
{% endblock extra_js %}

================
File: agents/templates/agents/crew_list.html
================
{% extends "agents/base_agents.html" %}

{% block agents_list %}
<ul class="list-group">
    {% for crew in crews %}
    <li class="list-group-item">
        <a href="{% url 'agents:crew_detail' crew.id %}" data-toggle="tooltip" title="{{ crew.description }}">
            {{ crew.name }}
        </a>
    </li>
    {% empty %}
    <li class="list-group-item">No CrewAI crews available.</li>
    {% endfor %}
</ul>
{% endblock %}

{% block previous_tasks %}
<ul class="list-group">
    {% for execution in request.user.crewaiexecution_set.all|slice:":5" %}
    <li class="list-group-item">
        <a href="{% url 'agents:execution_detail' execution.id %}">
            {{ execution.crew.name }} - {{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}
        </a>
    </li>
    {% empty %}
    <li class="list-group-item">No previous tasks.</li>
    {% endfor %}
</ul>
{% endblock %}

{% block main_content %}
<h2>Welcome to CrewAI Agents</h2>
<p>Select a crew from the list on the left to start a new execution or view previous tasks.</p>
{% endblock %}

{% block extra_js %}
{{ block.super }}
<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    })
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/crewai_home.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Dashboard {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <!-- Client Selection Dropdown -->
  <div class="row mb-4">
    <div class="col-6">
      <div class="card">
        <div class="card-body p-3">
          <form id="client-select-form" method="get">
            <div class="row align-items-center">
              <div class="col-md-3">
                <label for="client-select" class="form-label mb-0">Select Client:</label>
              </div>
              <div class="col-md-9">
                <select class="form-select" name="client_id" id="client-select">
                  <option value="">None</option>
                  {% for client in clients %}
                    <option value="{{ client.id }}" {% if client.id|stringformat:"s" == selected_client_id %}selected{% endif %}>
                      {{ client.name }}
                    </option>
                  {% endfor %}
                </select>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>

    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Crews</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ crews.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Recent Executions</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ recent_executions.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div> 

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-lg-6">
              <div class="d-flex flex-column h-100">
                <p class="mb-1 pt-2 text-bold">Welcome back, {{ request.user.username|capfirst }}</p>
                <h5 class="font-weight-bolder">Crew Dashboard</h5>
                <p class="mb-5">What do you want to do with your crews today.</p>
                <a class="text-body text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews_card_view' %}">
                  View All Crews
                  <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
                </a>
              </div>
            </div>
            <div class="col-lg-5 ms-auto text-center mt-5 mt-lg-0">
              <div class="bg-gradient-primary border-radius-lg h-100">
                <img src="{% static 'assets/img/shapes/waves-white.svg' %}" class="position-absolute h-100 w-50 top-0 d-lg-block d-none" alt="waves">
                <div class="position-relative d-flex align-items-center justify-content-center h-100">
                  <img class="w-100 position-relative z-index-2 pt-4" src="{% static 'assets/img/illustrations/rocket-white.png' %}" alt="rocket">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card h-100 p-3">
        <div class="overflow-hidden position-relative border-radius-lg bg-cover h-100" style="background-image: url('{% static 'assets/img/ivancik.jpg' %}');">
          <span class="mask bg-gradient-dark"></span>
          <div class="card-body position-relative z-index-1 d-flex flex-column h-100 p-3">
            <h5 class="text-white font-weight-bolder mb-4 pt-2">Manage Your Crews</h5>
            <p class="text-white">Create, edit, and manage your crews and their executions.</p>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews' %}">
              Read More
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Crews List -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Your Crews</h6>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Crew</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Process</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Language</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for crew in crews %}
                <tr>
                  <td>
                    <div class="d-flex px-3 py-1">
                      <div>
                        <img src="{% static 'assets/img/team-3.jpg' %}" class="avatar avatar-sm me-3" alt="crew">
                      </div>
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">
                          {% if selected_client_id %}
                            <a href="{% url 'agents:crew_kanban' crew.id %}?client_id={{ selected_client_id }}" class="text-sm mb-0">{{ crew.name }}</a>
                          {% else %}
                            {{ crew.name }}
                          {% endif %}
                        </h6>
                        <p class="text-xs text-secondary mb-0">{{ crew.agents.count }} Agents</p>
                      </div>
                    </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.get_process_display }}</p>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.language }}</p>
                  </td>
                  <td class="align-middle">
                    {% if selected_client_id %}
                    <a href="{% url 'agents:execution_list' %}?client_id={{ selected_client_id }}" class="btn btn-link text-dark px-3 mb-0">
                      <i class="fas fa-info-circle text-dark me-2"></i>Details
                    </a>
                    {% else %}
                    <span class="text-xs text-secondary">Select a client first</span>
                    {% endif %}
                  </td>
                </tr>
                {% empty %}
                <tr>
                  <td colspan="4" class="text-center py-4">
                    <p class="text-sm mb-0">No crews found.</p>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<!-- Add jQuery if not already included in base template -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle client selection change
    document.getElementById('client-select').addEventListener('change', function() {
      document.getElementById('client-select-form').submit();
    });
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/dashboard_home.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Dashboard {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <!-- New Client Selection Card -->
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Select Client</p>
                <form id="client-select-form" method="get">
                  <select class="form-control" name="client_id" id="client-select">
                    <option value="">All Clients</option>
                    {% for client in clients %}
                      <option value="{{ client.id }}" {% if client.id|stringformat:"s" == selected_client_id %}selected{% endif %}>
                        {{ client.name }}
                      </option>
                    {% endfor %}
                  </select>
                </form>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-building text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Crews</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ crews.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Recent Executions</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ recent_executions.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-lg-6">
              <div class="d-flex flex-column h-100">
                <p class="mb-1 pt-2 text-bold">Welcome back, {{ request.user.username }}</p>
                <h5 class="font-weight-bolder">CrewAI Dashboard</h5>
                <p class="mb-5">Here's what's happening with your CrewAI today.</p>
                <a class="text-body text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews' %}">
                  View All Crews
                  <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
                </a>
              </div>
            </div>
            <div class="col-lg-5 ms-auto text-center mt-5 mt-lg-0">
              <div class="bg-gradient-primary border-radius-lg h-100">
                <img src="{% static 'assets/img/shapes/waves-white.svg' %}" class="position-absolute h-100 w-50 top-0 d-lg-block d-none" alt="waves">
                <div class="position-relative d-flex align-items-center justify-content-center h-100">
                  <img class="w-100 position-relative z-index-2 pt-4" src="{% static 'assets/img/illustrations/rocket-white.png' %}" alt="rocket">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card h-100 p-3">
        <div class="overflow-hidden position-relative border-radius-lg bg-cover h-100" style="background-image: url('{% static 'assets/img/ivancik.jpg' %}');">
          <span class="mask bg-gradient-dark"></span>
          <div class="card-body position-relative z-index-1 d-flex flex-column h-100 p-3">
            <h5 class="text-white font-weight-bolder mb-4 pt-2">Quick Actions</h5>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:add_crew' %}">
              Create New Crew
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:execution_list' %}">
              View Executions
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Crew Summaries</h6>
        </div>
        <div class="card-body p-3">
          {% for crew in crews %}
          <div class="d-flex mb-3">
            <div class="icon icon-shape bg-gradient-dark shadow text-center border-radius-md">
              <i class="ni ni-mobile-button text-lg opacity-10" aria-hidden="true"></i>
            </div>
            <div class="ms-3">
              <div class="numbers">
                <h6 class="mb-1 text-dark text-sm">{{ crew.name }}</h6>
                <span class="text-sm">Agents: {{ crew.agent_set.count }}, Tasks: {{ crew.task_set.count }}</span>
              </div>
            </div>
            <div class="ms-auto">
              <a class="btn btn-link text-dark px-3 mb-0" href="{% url 'agents:crew_detail' crew.id %}">
                <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>View
              </a>
            </div>
          </div>
          {% endfor %}
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Recent Executions</h6>
        </div>
        <div class="card-body p-3">
          <ul class="list-group">
            {% for execution in recent_executions %}
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-mobile-button text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">{{ execution.crew.name }}</h6>
                  <span class="text-xs">{{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}</span>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:execution_detail' execution.id %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            {% endfor %}
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Add links to existing pages -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Navigation</h6>
        </div>
        <div class="card-body p-3">
          <ul class="list-group">
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-bullet-list-67 text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">Manage Crews</h6>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:manage_crews' %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-calendar-grid-58 text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">Execution List</h6>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:execution_list' %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            <!-- Add more links to other existing pages as needed -->
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>

<script>
  $(function() {
    $('#client-select').change(function() {
      $('#client-select-form').submit();
    });
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/execution_detail.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Execution Detail {% endblock %}

{% block extrastyle %}
{{ block.super }}
<!-- jKanban styles -->
<!-- <link rel="stylesheet" href="{% static 'assets/css/plugins/jkanban/jkanban.min.css' %}"/> -->
<style>
.kanban-container {
  padding: 1.25rem;
  display: flex;
  overflow-x: auto;
}

.kanban-board {
  min-width: 320px;
  max-width: 640px;
  margin: 0 0.9375rem;
}

.kanban-drag {
  min-height: 200px;
  padding: 1.25rem;
}

.kanban-item {
  margin-bottom: 0.9375rem;
}

/* Custom scrollbar for better visibility */
.kanban-container::-webkit-scrollbar {
  height: 0.5rem;
}

.kanban-container::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
}

.kanban-container::-webkit-scrollbar-thumb {
  background: var(--bs-primary);
  border-radius: 0.25rem;
}

.kanban-container::-webkit-scrollbar-thumb:hover {
  background: var(--bs-primary-darker);
}

/* Stage status indicators */
.stage-status {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.875rem;
  font-weight: 600;
}

.status-completed { background-color: #28a745; color: white; }
.status-in_progress { background-color: #007bff; color: white; }
.status-pending { background-color: #6c757d; color: white; }
.status-error { background-color: #dc3545; color: white; }

.stage-item {
  border: 1px solid #e9ecef;
  border-radius: 0.5rem;
  padding: 1rem;
  margin-bottom: 1rem;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  transition: all 0.3s ease;
}

.stage-item:hover {
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}

.stage-content {
  margin-top: 1rem;
}

.stage-metadata {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #6c757d;
}

.stage-agent {
  display: inline-flex;
  align-items: center;
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #495057;
}

.stage-agent i {
  margin-right: 0.25rem;
}

/* Progress bar styles */
.progress-wrapper {
  margin-top: 1rem;
}

.progress {
  height: 8px;
  margin-bottom: 0.5rem;
  overflow: hidden;
  background-color: #e9ecef;
  border-radius: 0.25rem;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar {
  height: 100%;
  background-color: var(--bs-primary);
  transition: width .6s ease;
}

.progress-percentage {
  font-size: 0.75rem;
  color: #6c757d;
  text-align: right;
}

/* Task description styles */
.task-description {
  cursor: pointer;
  position: relative;
  padding-right: 1.5rem;
}

.task-description:after {
  content: '\f107';
  font-family: 'Font Awesome 5 Free';
  font-weight: 900;
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  transition: transform .2s;
}

.task-description[aria-expanded="true"]:after {
  transform: translateY(-50%) rotate(180deg);
}

/* Modal styles */
.modal-content {
  border: none;
  border-radius: 0.5rem;
  box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
}

.modal-header {
  border-bottom: 1px solid #e9ecef;
  padding: 1.25rem;
}

.modal-body {
  padding: 1.25rem;
}

.modal-footer {
  border-top: 1px solid #e9ecef;
  padding: 1.25rem;
}

/* Button styles */
.btn-icon {
  padding: 0.5rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem;
  transition: all .15s ease-in-out;
}

.btn-icon i {
  font-size: 1rem;
}

.btn-icon:hover {
  transform: translateY(-1px);
}

/* Utility classes */
.text-xs {
  font-size: 0.75rem !important;
}

.text-sm {
  font-size: 0.875rem !important;
}

.font-weight-bold {
  font-weight: 600 !important;
}

.text-truncate-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</style>
{% endblock extrastyle %}

{% block content %}
<div class="container-fluid py-4">
  <!-- Execution Header -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="row align-items-center">
            <div class="col-auto">
              <div class="avatar avatar-xl position-relative">
                <img src="{% static 'assets/img/team-1.jpg' %}" alt="profile_image" class="w-100 border-radius-lg shadow-sm">
              </div>
            </div>
            <div class="col">
              <div class="h-100">
                <h5 class="mb-1">{{ crew.name }}</h5>
                <p class="mb-0 font-weight-bold text-sm">Execution #{{ execution.id }}</p>
                <p class="mb-0 text-sm">Started: {{ execution.created_at|date:"Y-m-d H:i:s" }}</p>
                <p class="mb-0 text-sm">Client: {{client.name}} - {{client.website_url}}</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Kanban Board -->
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Tasks</h6>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="kanban-container">
            {% for column in columns %}
            <div class="kanban-board card">
              <header class="kanban-board-header bg-gradient-primary p-3">
                <div class="d-flex align-items-center">
                  <h6 class="text-white mb-0">{{ column.name }}</h6>
                </div>
              </header>
              <div class="kanban-drag p-3">
                {% for stage in column.stages %}
                <div class="stage-item">
                  <div class="d-flex justify-content-between align-items-center">
                    <span class="stage-status status-{{ stage.status|lower }}">{{ stage.status }}</span>
                    <small class="text-muted">{{ stage.created_at|date:"H:i:s" }}</small>
                  </div>
                  <h6 class="mt-2 mb-1">{{ stage.title }}</h6>
                  <div class="stage-content">
                    <div class="content-preview">
                      <p class="text-sm mb-2">{{ stage.content|truncatechars:150 }}</p>
                      {% if stage.content|length > 150 %}
                      <button class="btn btn-link btn-sm p-0 toggle-content" 
                              data-bs-toggle="collapse" 
                              data-bs-target="#content-{{ stage.id }}" 
                              aria-expanded="false">
                        Show More
                      </button>
                      <div class="collapse" id="content-{{ stage.id }}">
                        <div class="pt-2">
                          {{ stage.content|linebreaks }}
                          {% if stage.metadata %}
                          <div class="stage-metadata">
                            <h6 class="text-sm font-weight-bold">Metadata:</h6>
                            {% if stage.type == 'output' and stage.metadata.json_output %}
                            <pre class="text-sm">{{ stage.metadata.json_output|pprint }}</pre>
                            {% if stage.metadata.token_usage %}
                            <div class="mt-2">
                              <h6 class="text-sm font-weight-bold">Token Usage:</h6>
                              <pre class="text-sm">{{ stage.metadata.token_usage|pprint }}</pre>
                            </div>
                            {% endif %}
                            {% else %}
                            <pre class="text-sm">{{ stage.metadata|pprint }}</pre>
                            {% endif %}
                          </div>
                          {% endif %}
                        </div>
                      </div>
                      {% endif %}
                    </div>
                  </div>
                  {% if stage.agent %}
                  <div class="stage-agent">
                    <i class="fas fa-{% if stage.type == 'message' %}comment{% else %}robot{% endif %}"></i>
                    {{ stage.agent }}
                  </div>
                  {% endif %}
                </div>
                {% endfor %}
              </div>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Add event listeners for content toggling
    document.querySelectorAll('.toggle-content').forEach(button => {
        button.addEventListener('click', function() {
            const expanded = this.getAttribute('aria-expanded') === 'true';
            this.textContent = expanded ? 'Show More' : 'Show Less';
        });
    });
});
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/execution_list.html
================
{% extends "agents/base_agents.html" %}
{% load static %}

{% block main_content %}
<div class="container mt-4">
    <h2>Executions</h2>

    <div class="card mb-4">
        <div class="card-header">
            <h3>Filter Executions</h3>
        </div>
        <div class="card-body">
            <form method="get" class="form-inline">
                <div class="form-group mr-2">
                    <label for="crew" class="mr-2">Crew:</label>
                    <select name="crew" id="crew" class="form-control">
                        <option value="">All Crews</option>
                        {% for crew in crews %}
                        <option value="{{ crew.id }}" {% if request.GET.crew == crew.id|stringformat:"s" %}selected{% endif %}>{{ crew.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group mr-2">
                    <label for="status" class="mr-2">Status:</label>
                    <select name="status" id="status" class="form-control">
                        <option value="">All Statuses</option>
                        <option value="PENDING" {% if request.GET.status == 'PENDING' %}selected{% endif %}>Pending</option>
                        <option value="RUNNING" {% if request.GET.status == 'RUNNING' %}selected{% endif %}>Running</option>
                        <option value="COMPLETED" {% if request.GET.status == 'COMPLETED' %}selected{% endif %}>Completed</option>
                        <option value="FAILED" {% if request.GET.status == 'FAILED' %}selected{% endif %}>Failed</option>
                    </select>
                </div>
                <button type="submit" class="btn btn-primary">Filter</button>
            </form>
        </div>
    </div>

    <div class="card">
        <div class="card-header">
            <h3>Execution List</h3>
        </div>
        <div class="card-body">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Crew</th>
                        <th>Status</th>
                        <th>Started</th>
                        <th>Last Updated</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for execution in executions %}
                    <tr>
                        <td>{{ execution.crew.name }}</td>
                        <td>
                            <span class="badge badge-{% if execution.status == 'COMPLETED' %}success{% elif execution.status == 'FAILED' %}danger{% elif execution.status == 'RUNNING' %}warning{% else %}secondary{% endif %}">
                                {{ execution.get_status_display }}
                            </span>
                        </td>
                        <td>{{ execution.created_at|date:"Y-m-d H:i:s" }}</td>
                        <td>{{ execution.updated_at|date:"Y-m-d H:i:s" }}</td>
                        <td>
                            <a href="{% url 'agents:execution_detail' execution.id %}" class="btn btn-sm btn-info">View Details</a>
                        </td>
                    </tr>
                    {% empty %}
                    <tr>
                        <td colspan="5">No executions found.</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>

            {% if is_paginated %}
            <nav aria-label="Execution list pagination">
                <ul class="pagination justify-content-center">
                    {% if page_obj.has_previous %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.previous_page_number }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}" aria-label="Previous">
                            <span aria-hidden="true">&laquo;</span>
                        </a>
                    </li>
                    {% endif %}

                    {% for num in page_obj.paginator.page_range %}
                    {% if page_obj.number == num %}
                    <li class="page-item active"><a class="page-link" href="#">{{ num }}</a></li>
                    {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                    <li class="page-item"><a class="page-link" href="?page={{ num }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}">{{ num }}</a></li>
                    {% endif %}
                    {% endfor %}

                    {% if page_obj.has_next %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.next_page_number }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}" aria-label="Next">
                            <span aria-hidden="true">&raquo;</span>
                        </a>
                    </li>
                    {% endif %}
                </ul>
            </nav>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
{{ block.super }}
<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    })
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_agents_card_view.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Agents - Card View {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
            <h6 class="mb-0">Agents</h6>
            <p class="text-sm mb-0">
                View and manage your AI agents.
            </p>
            </div>
            <div class="d-flex align-items-center">
            <a href="{% url 'agents:manage_agents' %}" class="btn btn-sm  me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
            </a>
            <a href="{% url 'agents:manage_agents_card_view' %}" class="btn btn-sm  me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
            </a>
            <a href="{% url 'agents:add_agent' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Agent</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="p-3">
            <div class="row g-3 mb-4">
              <div class="col-md-6">
                <input type="text" id="searchInput" class="form-control" placeholder="Search agents...">
              </div>
              <div class="col-md-6">
                <select id="roleFilter" class="form-select">
                  <option value="">All Roles</option>
                  <option value="Analyst">Analyst</option>
                  <option value="Support">Support</option>
                  <option value="Creator">Creator</option>
                  <option value="Engineer">Engineer</option>
                  <option value="Manager">Manager</option>
                </select>
              </div>
            </div>
            <div class="row" id="agentCards">
              {% for agent in agents %}
              <div class="col-lg-4 col-md-6 mb-4">
                <div class="card h-100">
                  <div class="card-header p-3 pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                      <div>
                        <h5 class="mb-0">{{ agent.name }}</h5>
                        <p class="text-sm mb-0">{{ agent.role }}</p>
                      </div>
                      <div class="avatar avatar-xl position-relative">
                        <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="Agent avatar" class="w-100 border-radius-lg shadow-sm">
                      </div>
                    </div>
                  </div>
                  <div class="card-body p-3">
                    <p class="text-sm mb-2"><strong>Goal:</strong> {{ agent.goal|truncatechars:100 }}</p>
                    <p class="text-sm mb-2"><strong>LLM:</strong> {{ agent.llm }}</p>
                    <p class="text-sm mb-2"><strong>Crews:</strong> 
                      {% for crew in agent.crew_set.all %}
                        <span class="badge bg-gradient-info"><a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit crew">{{ crew.name }}</a></span>
                      {% empty %}
                        <span class="text-muted">No crews</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-2"><strong>Tasks:</strong> 
                      {% for task in agent.task_set.all %}
                        <span class="badge bg-gradient-dark"><a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">{{ task.description|truncatechars:20 }}</a></span>
                      {% empty %}
                        <span class="text-muted">No tasks</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-0"><strong>Tools:</strong></p>
                    <div class="d-flex flex-wrap gap-1 mb-2">
                      {% for tool in agent.tools.all %}
                        <span class="badge bg-gradient-success">{{ tool.name }}</span>
                      {% empty %}
                        <span class="text-muted">No tools</span>
                      {% endfor %}
                    </div>
                  </div>
                  <div class="card-footer p-3">
                    <div class="d-flex justify-content-between">
                        <a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="btn btn-link text-dark mb-0 ps-0" data-toggle="tooltip" data-original-title="Edit agent">
                          <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit
                        </a>
                        <a href="{% url 'agents:delete_agent' agent.id %}" class="btn btn-link text-danger mb-0 pe-0" data-toggle="tooltip" data-original-title="Delete agent">
                          <i class="far fa-trash-alt me-2"></i>Delete
                        </a>
                      </div>
                  </div>
                </div>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Agent Modal -->
<div class="modal fade" id="agentModal" tabindex="-1" role="dialog" aria-labelledby="agentModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="agentModalLabel">Create New Agent</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="agentForm">
          <div class="form-group mb-3">
            <label for="agentName" class="form-control-label">Name</label>
            <input type="text" class="form-control" id="agentName" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentRole" class="form-control-label">Role</label>
            <input type="text" class="form-control" id="agentRole" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentGoal" class="form-control-label">Goal</label>
            <textarea class="form-control" id="agentGoal" rows="3" required></textarea>
          </div>
          <div class="form-group mb-3">
            <label for="agentLLM" class="form-control-label">LLM</label>
            <input type="text" class="form-control" id="agentLLM" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentAvatar" class="form-control-label">Avatar</label>
            <select class="form-control" id="agentAvatar" name="avatar" required>
              {% for avatar in form.avatar.field.choices %}
                <option value="{{ avatar.0 }}" data-img="{% static 'assets/img/'|add:avatar.0 %}">Avatar {{ forloop.counter }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="text-center">
            <img id="avatarPreview" src="" alt="Avatar preview" class="img-fluid rounded-circle" style="width: 100px; height: 100px; object-fit: cover;">
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" onclick="saveAgent()">Save Agent</button>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  let currentAgentId = null;

  function editAgent(agentId) {
    currentAgentId = agentId;
    // Fetch agent details and populate the form
    // This is a placeholder - you'll need to implement the actual data fetching
    $('#agentModalLabel').text('Edit Agent');
    $('#agentModal').modal('show');
  }

  function saveAgent() {
    const agentData = {
      name: $('#agentName').val(),
      role: $('#agentRole').val(),
      goal: $('#agentGoal').val(),
      llm: $('#agentLLM').val(),
      avatar: $('#agentAvatar').val(),
      // Add more fields as needed
    };

    const url = currentAgentId ? `/agents/manage/agents/${currentAgentId}/update/` : '/agents/manage/agents/add/';
    const method = currentAgentId ? 'PUT' : 'POST';

    $.ajax({
      url: url,
      method: method,
      data: JSON.stringify(agentData),
      contentType: 'application/json',
      success: function(response) {
        $('#agentModal').modal('hide');
        // Refresh the page or update the cards
        location.reload();
      },
      error: function(error) {
        console.error('Error saving agent:', error);
      }
    });
  }

  function deleteAgent(agentId) {
    if (confirm('Are you sure you want to delete this agent?')) {
      $.ajax({
        url: `/agents/manage/agents/${agentId}/delete/`,
        method: 'DELETE',
        success: function(response) {
          // Remove the agent card or refresh the page
          location.reload();
        },
        error: function(error) {
          console.error('Error deleting agent:', error);
        }
      });
    }
  }

  $(document).ready(function() {
    $('#searchInput').on('keyup', function() {
      var value = $(this).val().toLowerCase();
      $("#agentCards .col-md-4").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });

    $('#roleFilter, #statusFilter').on('change', function() {
      var roleValue = $('#roleFilter').val().toLowerCase();
      var statusValue = $('#statusFilter').val().toLowerCase();
      $("#agentCards .col-md-4").filter(function() {
        var roleMatch = roleValue === '' || $(this).find('.text-capitalize').text().toLowerCase().indexOf(roleValue) > -1;
        var statusMatch = statusValue === '' || $(this).find('.badge').text().toLowerCase().indexOf(statusValue) > -1;
        $(this).toggle(roleMatch && statusMatch);
      });
    });

    // Avatar preview functionality
    $('#agentAvatar').change(function() {
      const selectedOption = $(this).find('option:selected');
      const imgSrc = selectedOption.data('img');
      $('#avatarPreview').attr('src', imgSrc);
    });

    // Trigger change event to show initial avatar
    $('#agentAvatar').trigger('change');
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_agents.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Agents {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
              <h5 class="mb-0">Agents</h5>
              <p class="text-sm mb-0">
                  View and manage your AI agents.
              </p>
          </div>
          <div class="d-flex align-items-center">
              <!-- Removed btn-group to separate the icons -->
              <a href="{% url 'agents:manage_agents' %}" class="btn btn-sm  me-2" title="Table View">
                  <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_agents_card_view' %}" class="btn btn-sm  me-2" title="Card View">
                  <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_agent' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Agent</a>
          </div>
      </div>
        <div class="table-responsive">
          <table class="table table-flush" id="agents-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Avatar</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Role</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">LLM</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for agent in agents %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="{{ agent.name }}'s avatar" class="avatar avatar-sm rounded-circle me-2">
                </td>
                <td class="text-sm font-weight-normal">
                  {{ agent.name }}
                </td>
                <td class="text-sm font-weight-normal">{{ agent.role }}</td>
                <td class="text-sm font-weight-normal">{{ agent.llm }}</td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit agent">
                    Edit
                  </a>
                  |
                  <a href="{% url 'agents:delete_agent' agent.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete agent">
                    Delete
                  </a>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="5" class="text-sm font-weight-normal">No agents found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  {% include 'includes/footer.html' %}
</div>

{% endblock content %}

{% block extra_js %}
  <script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>

  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#agents-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      pageLength: [25, 50, 100, 200]
    });
  </script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_crews_card_view.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Crews {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  {% if selected_client %}
    <div class="alert alert-info" role="alert">
      Selected Client: {{ selected_client.name }}
    </div>
  {% else %}
    <div class="alert alert-warning" role="alert">
      No client selected. Showing all crews.
    </div>
  {% endif %}
  
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-0">Crews</h6>
              <p class="text-sm mb-0">
                View and manage your AI agent crews.
              </p>
            </div>
            <div class="d-flex align-items-center">
              <a href="{% url 'agents:manage_crews' %}" class="btn btn-sm me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-sm me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_crew' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Crew</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="p-3">
            <div class="row g-3 mb-4">
              <div class="col-md-6">
                <input type="text" id="searchInput" class="form-control" placeholder="Search crews...">
              </div>
              <div class="col-md-6">
                <select id="processFilter" class="form-select">
                  <option value="">All Processes</option>
                  <option value="Sequential">Sequential</option>
                  <option value="Parallel">Parallel</option>
                  <option value="Hierarchical">Hierarchical</option>
                </select>
              </div>
            </div>
            <div class="row" id="crewCards">
              {% for crew in crews %}
              <div class="col-lg-4 col-md-6 mb-4">
                <div class="card h-100">
                  <div class="card-header p-3 pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                      <div>
                        <h5 class="mb-0">
                          <a href="{% url 'agents:crew_kanban' crew.id %}{% if selected_client %}?client_id={{ selected_client.id }}{% endif %}" class="text-dark">
                            {{ crew.name }}
                            <i class="fas fa-play ms-1" aria-hidden="true"></i>
                          </a>
                        </h5>
                        <p class="text-sm mb-0">{{ crew.get_process_display }}</p>
                      </div>
                      <div class="avatar-group">
                        {% for agent in crew.agents.all|slice:":3" %}
                          <a href="javascript:;" class="avatar avatar-sm rounded-circle" data-bs-toggle="tooltip" data-bs-placement="bottom" title="{{ agent.name }}">
                            <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="{{ agent.name }}">
                          </a>
                        {% endfor %}
                        {% if crew.agents.count > 3 %}
                          <a href="javascript:;" class="avatar avatar-sm rounded-circle" data-bs-toggle="tooltip" data-bs-placement="bottom" title="{{ crew.agents.count|add:'-3' }} more">
                            <span class="avatar-text bg-gradient-primary">+{{ crew.agents.count|add:'-3' }}</span>
                          </a>
                        {% endif %}
                      </div>
                    </div>
                  </div>
                  <div class="card-body p-3">
                    <p class="text-sm mb-2"><strong>Agents:</strong> 
                      {% for agent in crew.agents.all %}
                        <span class="badge bg-gradient-info"><a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit agent">{{ agent.name }}</a></span>
                      {% empty %}
                        <span class="text-muted">No agents</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-2"><strong>Tasks:</strong> 
                      {% for task in crew.tasks.all %}
                        <span class="badge bg-gradient-dark"><a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-white" font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">{{ task.description|truncatechars:20 }}</a></span>
                      {% empty %}
                        <span class="text-muted">No tasks</span>
                      {% endfor %}
                    </p>
                  </div>
                  <div class="card-footer p-3">
                    <div class="d-flex justify-content-between">
                      <a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="btn btn-link text-dark mb-0 ps-0" data-toggle="tooltip" data-original-title="Edit crew">
                        <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit
                      </a>

                      <a href="{% url 'agents:delete_crew' crew.id %}" class="btn btn-link text-danger mb-0 pe-0" data-toggle="tooltip" data-original-title="Delete crew">
                        <i class="far fa-trash-alt me-2"></i>Delete
                      </a>
                    </div>
                  </div>
                </div>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  $(document).ready(function() {
    $('#searchInput').on('keyup', function() {
      var value = $(this).val().toLowerCase();
      $("#crewCards .col-lg-4").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });

    $('#processFilter').on('change', function() {
      var processValue = $(this).val().toLowerCase();
      $("#crewCards .col-lg-4").filter(function() {
        var processMatch = processValue === '' || $(this).find('.text-sm').text().toLowerCase().indexOf(processValue) > -1;
        $(this).toggle(processMatch);
      });
    });

    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl)
    });
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_crews.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Crews {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  {% if selected_client %}
    <div class="alert alert-info" role="alert">
      Selected Client: {{ selected_client.name }}
    </div>
  {% else %}
    <div class="alert alert-warning" role="alert">
      No client selected. Showing all crews.
    </div>
  {% endif %}

  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-0">Crews</h6>
              <p class="text-sm mb-0">
                Manage your AI agent crews
              </p>
            </div>
            <div class="d-flex align-items-center">
              <a href="{% url 'agents:manage_crews' %}" class="btn btn-sm me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-sm me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_crew' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Crew</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Crew</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Process</th>
                  <th class="text-center text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Agents</th>
                  <th class="text-center text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Tasks</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for crew in crews %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">
                          <a href="{% url 'agents:crew_kanban' crew.id %}{% if selected_client %}?client_id={{ selected_client.id }}{% endif %}" class="text-dark font-weight-bold">
                            {{ crew.name }}
                          </a>
                        </h6>
                        <p class="text-xs text-secondary mb-0">{{ crew.description|truncatechars:50 }}</p>
                      </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.get_process_display }}</p>
                  </td>
                  <td class="align-middle text-center text-sm">
                    <span class="badge badge-sm bg-gradient-success">{{ crew.agents.count }}</span>
                  </td>
                  <td class="align-middle text-center">
                    <span class="text-secondary text-xs font-weight-bold">{{ crew.tasks.count }}</span>
                  </td>
                  <td class="align-middle">
                    <a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit crew">
                      Edit
                    </a>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_pipelines.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Pipelines {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Pipeline Dashboard</h6>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <div class="d-flex justify-content-between align-items-center mb-3 px-3">
              <div class="d-flex align-items-center">
                <span class="mr-2">Search:</span>
                <input type="text" id="searchInput" class="form-control form-control-sm" placeholder="Search pipelines...">
              </div>
              <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#createPipelineModal">
                <i class="fas fa-plus"></i> Create Pipeline
              </button>
            </div>
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Pipeline</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Stages</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for pipeline in pipelines %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">{{ pipeline.name }}</h6>
                        <p class="text-xs text-secondary mb-0">{{ pipeline.description }}</p>
                      </div>
                    </div>
                  </td>
                  <td>
                    <span class="badge badge-sm bg-gradient-{{ pipeline.status|lower }}">{{ pipeline.status }}</span>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ pipeline.stages.count }} stages</p>
                  </td>
                  <td class="align-middle">
                    <div class="dropdown">
                      <a href="#" class="btn btn-link text-secondary mb-0" data-bs-toggle="dropdown" id="navbarDropdownMenuLink2">
                        <i class="fa fa-ellipsis-v text-xs"></i>
                      </a>
                      <ul class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink2">
                        <li>
                          <a class="dropdown-item" href="#" onclick="changePipelineStatus({{ pipeline.id }}, 'Running')">
                            <i class="fas fa-play text-success"></i> Start
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item" href="#" onclick="changePipelineStatus({{ pipeline.id }}, 'Paused')">
                            <i class="fas fa-pause text-warning"></i> Pause
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item" href="#" onclick="changePipelineStatus({{ pipeline.id }}, 'Idle')">
                            <i class="fas fa-stop text-danger"></i> Stop
                          </a>
                        </li>
                        <li><hr class="dropdown-divider"></li>
                        <li>
                          <a class="dropdown-item" href="#" onclick="editPipeline({{ pipeline.id }})">
                            <i class="fas fa-edit text-info"></i> Edit
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item" href="#" onclick="deletePipeline({{ pipeline.id }})">
                            <i class="fas fa-trash text-danger"></i> Delete
                          </a>
                        </li>
                      </ul>
                    </div>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Pipeline Modal -->
<div class="modal fade" id="pipelineModal" tabindex="-1" role="dialog" aria-labelledby="pipelineModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="pipelineModalLabel">Create New Pipeline</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="pipelineForm">
          <div class="form-group">
            <label for="pipelineName">Name</label>
            <input type="text" class="form-control" id="pipelineName" required>
          </div>
          <div class="form-group">
            <label for="pipelineDescription">Description</label>
            <textarea class="form-control" id="pipelineDescription" rows="3"></textarea>
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" onclick="savePipeline()">Save Pipeline</button>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  let currentPipelineId = null;

  function editPipeline(pipelineId) {
    currentPipelineId = pipelineId;
    // Fetch pipeline details and populate the form
    // This is a placeholder - you'll need to implement the actual data fetching
    $('#pipelineModalLabel').text('Edit Pipeline');
    $('#pipelineModal').modal('show');
  }

  function savePipeline() {
    const pipelineData = {
      name: $('#pipelineName').val(),
      description: $('#pipelineDescription').val(),
    };

    const url = currentPipelineId ? `/agents/pipelines/${currentPipelineId}/update/` : '/agents/pipelines/create/';
    const method = currentPipelineId ? 'PUT' : 'POST';

    $.ajax({
      url: url,
      method: method,
      data: JSON.stringify(pipelineData),
      contentType: 'application/json',
      success: function(response) {
        $('#pipelineModal').modal('hide');
        // Refresh the page or update the table
        location.reload();
      },
      error: function(error) {
        console.error('Error saving pipeline:', error);
      }
    });
  }

  function deletePipeline(pipelineId) {
    if (confirm('Are you sure you want to delete this pipeline?')) {
      $.ajax({
        url: `/agents/pipelines/${pipelineId}/delete/`,
        method: 'DELETE',
        success: function(response) {
          // Remove the pipeline from the table or refresh the page
          location.reload();
        },
        error: function(error) {
          console.error('Error deleting pipeline:', error);
        }
      });
    }
  }

  function changePipelineStatus(pipelineId, newStatus) {
    $.ajax({
      url: `/agents/pipelines/${pipelineId}/change-status/`,
      method: 'POST',
      data: JSON.stringify({ status: newStatus }),
      contentType: 'application/json',
      success: function(response) {
        // Update the status in the table or refresh the page
        location.reload();
      },
      error: function(error) {
        console.error('Error changing pipeline status:', error);
      }
    });
  }

  $(document).ready(function() {
    $('#searchInput').on('keyup', function() {
      var value = $(this).val().toLowerCase();
      $("table tbody tr").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });
  });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_tasks.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Tasks {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Tasks</h5>
            <p class="text-sm mb-0">
              View and manage your AI agent tasks.
            </p>
          </div>
          <div>
            <a href="{% url 'agents:add_task' %}" class="btn btn-primary btn-sm">Add New Task</a>
          </div>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="tasks-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Description</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Agent</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Async Execution</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Human Input</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Output Type</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for task in tasks %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}">{{ task.description|truncatechars:50 }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ task.agent.name|default:"N/A" }}</td>
                <td class="text-sm font-weight-normal">{% if task.async_execution %}Yes{% else %}No{% endif %}</td>
                <td class="text-sm font-weight-normal">{% if task.human_input %}Yes{% else %}No{% endif %}</td>
                <td class="text-sm font-weight-normal">
                  {% if task.output_json %}JSON
                  {% elif task.output_pydantic %}Pydantic
                  {% elif task.output_file %}File
                  {% else %}Default
                  {% endif %}
                </td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">
                    Edit
                  </a>
                  |
                  <a href="{% url 'agents:delete_task' task.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete task">
                    Delete
                  </a>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="6" class="text-sm font-weight-normal">No tasks found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  {% include 'includes/footer.html' %}
</div>
{% endblock content %}

{% block extra_js %}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#tasks-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      pageLength: [25, 50, 100, 200]
    });
  </script>
{% endblock extra_js %}

================
File: agents/templates/agents/manage_tools.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Tools {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Tools</h5>
            <p class="text-sm mb-0">
              View and manage your AI agent tools.
            </p>
          </div>
          <a href="{% url 'agents:add_tool' %}" class="btn btn-primary btn-sm">Add New Tool</a>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="tools-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Description</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Tool Class</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for tool in tools %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_tool' tool.id %}">{{ tool.name }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ tool.description|truncatechars:50 }}</td>
                <td class="text-sm font-weight-normal">{{ tool.tool_class }}</td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_tool' tool.id %}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit tool">
                    Edit
                  </a>
                  |
                  <a href="#" class="text-primary font-weight-bold text-xs test-tool-btn" data-tool-id="{{ tool.id }}" data-bs-toggle="modal" data-bs-target="#testToolModal">
                    Test
                  </a>
                  |
                  <a href="{% url 'agents:delete_tool' tool.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete tool">
                    Delete
                  </a>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="4" class="text-sm font-weight-normal">No tools found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Test Tool Modal -->
<div class="modal fade" id="testToolModal" tabindex="-1" aria-labelledby="testToolModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="testToolModalLabel">Test Tool</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="toolTestForm" onsubmit="return false;">
          {% csrf_token %}
          <div id="toolInputs" class="mb-3">
            <!-- Tool inputs will be dynamically added here -->
          </div>
          <div class="mb-3">
            <label class="form-label">Output:</label>
            <div id="toolOutput" class="border rounded p-3 bg-light overflow-auto" style="min-height: 100px; max-height: 400px;">
              <!-- Tool output will appear here -->
            </div>
          </div>
          <div id="outputTableContainer" style="display: none;"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="submit" class="btn btn-primary" id="testToolBtn">Test</button>
      </div>
    </div>
  </div>
</div>


{% include 'includes/footer.html' %}
{% endblock content %}
{% block extrastyle %}
  {{ block.super }}
  
<style>
  /* Ensure modal doesn't exceed viewport height */
  .modal-dialog-scrollable {
    max-height: 90vh;
    margin-top: 5vh;
    margin-bottom: 5vh;
  }
  
  /* Make modal wider on larger screens */
  @media (min-width: 1200px) {
    .modal-xl {
      max-width: 1140px;
    }
  }

  /* For extra large screens */
  @media (min-width: 1400px) {
    .modal-xl {
      max-width: 1320px;
    }
  }
  
  /* Style for pre-formatted output */
  #toolOutput pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  /* Custom scrollbar styling for better visibility */
  #toolOutput::-webkit-scrollbar {
    width: 8px;
  }
  
  #toolOutput::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  #toolOutput::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
  }
  
  #toolOutput::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
  </style>
{% endblock extrastyle %}
{% block extra_js %}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#tools-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      pageLength: [25, 50, 100, 200]
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const toolInputs = document.getElementById('toolInputs');
      const toolOutput = document.getElementById('toolOutput');
      const testToolBtn = document.getElementById('testToolBtn');
      const testToolModal = document.getElementById('testToolModal');
      const toolTestForm = document.getElementById('toolTestForm');
      let currentToolId = null;

      // Helper function to check if string is JSON
      function isJSON(str) {
        try {
          JSON.parse(str);
          return true;
        } catch (e) {
          return false;
        }
      }

      // Helper function to parse JSON safely
      function parseJSON(jsonStr) {
        try {
          return JSON.parse(jsonStr);
        } catch (e) {
          return null;
        }
      }

      // Helper function to check if string is CSV
      function isCSV(str) {
        return str.includes(',') && str.includes('\n') && !str.includes('{') && !str.includes('[');
      }

      // Helper function to parse CSV
      function parseCSV(csv) {
        const lines = csv.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        const rows = lines.slice(1).map(line => {
          const values = line.split(',').map(v => v.trim());
          return headers.reduce((obj, header, i) => {
            obj[header] = values[i];
            return obj;
          }, {});
        });
        return rows;
      }

      // Function to create a table from data
      function createTable(data, tableName) {
        if (!Array.isArray(data) || data.length === 0) return null;
        
        // Get all unique keys from all objects
        const keys = [...new Set(data.flatMap(obj => Object.keys(obj)))];
        
        const table = document.createElement('table');
        table.className = 'table table-striped table-bordered mt-3';
        
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          th.className = 'text-xs font-weight-bold';
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');
        data.forEach(row => {
          const tr = document.createElement('tr');
          keys.forEach(key => {
            const td = document.createElement('td');
            const value = row[key];
            if (value === undefined || value === null) {
              td.textContent = '';
            } else if (typeof value === 'object') {
              if (Array.isArray(value)) {
                td.textContent = value.map(item => {
                  if (typeof item === 'object') {
                    return JSON.stringify(item, null, 2);
                  }
                  return item;
                }).join(', ');
              } else {
                td.textContent = JSON.stringify(value, null, 2);
              }
            } else {
              td.textContent = value.toString();
            }
            td.className = 'text-xs';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        
        // Add table title
        const titleDiv = document.createElement('div');
        titleDiv.className = 'h6 mb-2';
        titleDiv.textContent = tableName;
        
        const container = document.createElement('div');
        container.appendChild(titleDiv);
        container.appendChild(table);
        
        return container;
      }

      // Function to display multiple tables
      function displayMultipleTables(data) {
        const container = document.getElementById('outputTableContainer');
        container.innerHTML = '';
        container.style.display = 'block';
        
        if (Array.isArray(data)) {
          if (data.length > 0 && typeof data[0] === 'object') {
            const table = createTable(data, 'Data Table');
            if (table) container.appendChild(table);
          }
        } else if (typeof data === 'object') {
          for (const [key, value] of Object.entries(data)) {
            if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
              const table = createTable(value, key);
              if (table) container.appendChild(table);
            } else if (typeof value === 'object' && value !== null) {
              // Handle nested objects
              for (const [nestedKey, nestedValue] of Object.entries(value)) {
                if (Array.isArray(nestedValue) && nestedValue.length > 0 && typeof nestedValue[0] === 'object') {
                  const table = createTable(nestedValue, `${key}.${nestedKey}`);
                  if (table) container.appendChild(table);
                }
              }
            }
          }
        }
      }

      // Function to fetch tool schema
      async function fetchToolSchema(toolId) {
        try {
          const response = await fetch(`/agents/tool-schema/${toolId}/`, {
            headers: {
              'Accept': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const contentType = response.headers.get("content-type");
          if (!contentType || !contentType.includes("application/json")) {
            throw new TypeError("Oops, we haven't got JSON!");
          }
          
          const data = await response.json();
          console.log('Received schema:', data);  // Debug log
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          toolInputs.innerHTML = '';
          
          // Create input fields based on schema
          Object.entries(data.properties || {}).forEach(([key, prop]) => {
            const div = document.createElement('div');
            div.className = 'mb-3';
            
            const label = document.createElement('label');
            label.className = 'form-label';
            label.textContent = prop.title || key;
            
            if (prop.description) {
              const description = document.createElement('small');
              description.className = 'form-text text-muted d-block';
              description.textContent = prop.description;
              div.appendChild(label);
              div.appendChild(description);
            } else {
              div.appendChild(label);
            }
            
            const input = document.createElement('input');
            input.className = 'form-control';
            input.name = key;
            input.type = prop.type === 'number' ? 'number' : 'text';
            input.required = (data.required || []).includes(key);
            
            div.appendChild(input);
            toolInputs.appendChild(div);
          });
          
          toolOutput.innerHTML = '';
        } catch (error) {
          console.error('Error fetching schema:', error);
          toolInputs.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }

      // Handle test button click in the table
      document.querySelectorAll('.test-tool-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          currentToolId = this.dataset.toolId;
          fetchToolSchema(currentToolId);
        });
      });

      // Function to run tool test
      async function runToolTest(e) {
        e.preventDefault();
        if (!currentToolId) return;
        
        const formData = new FormData(toolTestForm);
        toolOutput.innerHTML = `
          <div class="d-flex align-items-center">
            <div class="spinner-border text-primary me-2" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <span>Testing tool...</span>
          </div>
        `;
        
        try {
          const response = await fetch(`/agents/test-tool/${currentToolId}/`, {
            method: 'POST',
            body: formData,
            headers: {
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          if (data.task_id) {
            pollStatus(data.task_id);
          } else {
            toolOutput.innerHTML = `<pre>${JSON.stringify(data.result, null, 2)}</pre>`;
          }
        } catch (error) {
          console.error('Error testing tool:', error);
          toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }

      // Handle form submission (both button click and Enter key)
      toolTestForm.addEventListener('submit', runToolTest);
      testToolBtn.addEventListener('click', runToolTest);

      // Function to poll task status
      async function pollStatus(taskId) {
        try {
          const response = await fetch(`/agents/tool-status/${taskId}/`);
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          if (data.status === 'PENDING' || data.status === 'STARTED') {
            toolOutput.innerHTML = `
              <div class="d-flex align-items-center">
                <div class="spinner-border text-primary me-2" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <span>Tool is running...</span>
              </div>
            `;
            setTimeout(() => pollStatus(taskId), 1000);
          } else if (data.status === 'SUCCESS') {
            const result = data.result;
            
            // Clear any previous output
            toolOutput.innerHTML = '';
            const outputTableContainer = document.getElementById('outputTableContainer');
            outputTableContainer.innerHTML = '';
            outputTableContainer.style.display = 'none';
            
            // Handle different types of output
            if (typeof result === 'string') {
              if (isJSON(result)) {
                const jsonData = parseJSON(result);
                displayMultipleTables(jsonData);
                toolOutput.textContent = result;
              } else if (isCSV(result)) {
                const csvData = parseCSV(result);
                displayTable(csvData);
                toolOutput.textContent = result;
              } else {
                toolOutput.textContent = result;
              }
            } else if (result && typeof result === 'object') {
              displayMultipleTables(result);
              toolOutput.textContent = JSON.stringify(result, null, 2);
            } else {
              toolOutput.textContent = 'Task completed successfully';
            }
          } else if (data.status === 'FAILURE') {
            throw new Error(data.error || 'Task failed');
          }
        } catch (error) {
          console.error('Error polling status:', error);
          toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }
    });
  </script>
{% endblock %}

================
File: agents/templates/agents/task_form.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} {% if task %}Edit Task{% else %}Add Task{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if task %}Edit Task{% else %}Add Task{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.description.id_for_label }}" class="form-control-label">Description</label>
                                    {{ form.description }}
                                    {% if form.description.errors %}
                                        <div class="text-danger">
                                            {{ form.description.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.agent.id_for_label }}" class="form-control-label">Agent</label>
                                    {{ form.agent }}
                                    {% if form.agent.errors %}
                                        <div class="text-danger">
                                            {{ form.agent.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.expected_output.id_for_label }}" class="form-control-label">Expected Output</label>
                                    {{ form.expected_output }}
                                    {% if form.expected_output.errors %}
                                        <div class="text-danger">
                                            {{ form.expected_output.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.tools.id_for_label }}" class="form-control-label">Tools</label>
                                    {{ form.tools }}
                                    {% if form.tools.errors %}
                                        <div class="text-danger">
                                            {{ form.tools.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="{{ form.context.id_for_label }}" class="form-control-label">Context</label>
                                    {{ form.context }}
                                    {% if form.context.errors %}
                                        <div class="text-danger">
                                            {{ form.context.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.config.id_for_label }}" class="form-control-label">Config (JSON)</label>
                                    {{ form.config }}
                                    {% if form.config.errors %}
                                        <div class="text-danger">
                                            {{ form.config.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.converter_cls.id_for_label }}" class="form-control-label">Converter Class</label>
                                    {{ form.converter_cls }}
                                    {% if form.converter_cls.errors %}
                                        <div class="text-danger">
                                            {{ form.converter_cls.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_json.id_for_label }}" class="form-control-label">Output JSON</label>
                                    {{ form.output_json }}
                                    {% if form.output_json.errors %}
                                        <div class="text-danger">
                                            {{ form.output_json.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_pydantic.id_for_label }}" class="form-control-label">Output Pydantic</label>
                                    {{ form.output_pydantic }}
                                    {% if form.output_pydantic.errors %}
                                        <div class="text-danger">
                                            {{ form.output_pydantic.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_file.id_for_label }}" class="form-control-label">Output File Path</label>
                                    {{ form.output_file }}
                                    {% if form.output_file.errors %}
                                        <div class="text-danger">
                                            {{ form.output_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                    <small class="form-text text-muted">Enter the relative path in the media directory (e.g., 'outputs/task_result.txt')</small>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <div class="form-check form-switch">
                                    {{ form.async_execution }}
                                    <label class="form-check-label" for="{{ form.async_execution.id_for_label }}">Async Execution</label>
                                    {% if form.async_execution.errors %}
                                        <div class="text-danger">
                                            {{ form.async_execution.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-check form-switch">
                                    {{ form.human_input }}
                                    <label class="form-check-label" for="{{ form.human_input.id_for_label }}">Human Input</label>
                                    {% if form.human_input.errors %}
                                        <div class="text-danger">
                                            {{ form.human_input.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{% url 'agents:manage_tasks' %}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Task</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Choices.js for select fields
        var selectFields = document.querySelectorAll('select');
        selectFields.forEach(function(select) {
            new Choices(select, {
                removeItemButton: true,
                placeholder: true,
                placeholderValue: 'Select an option'
            });
        });

        // Add classes to form elements
        var formElements = document.querySelectorAll('input:not([type="checkbox"]):not([type="radio"]), select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        var checkboxInputs = document.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Form validation
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                event.preventDefault();
                alert('Please fill in all required fields.');
            }
        });

        // JSON validation for config field
        var configField = document.getElementById('{{ form.config.id_for_label }}');
        if (configField) {
            configField.addEventListener('blur', function() {
                try {
                    JSON.parse(this.value);
                    this.classList.remove('is-invalid');
                } catch (error) {
                    this.classList.add('is-invalid');
                    alert('Invalid JSON format in Config field');
                }
            });
        }
    });
</script>
{% endblock extra_js %}

================
File: agents/templates/agents/tool_form.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} {% if tool %}Edit Tool{% else %}Add Tool{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-lg-12 col-xl-12">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">{% if tool %}Edit Tool{% else %}Add Tool{% endif %}</h5>
                </div>
                <div class="card-body">
                    <form method="post" id="toolForm">
                        {% csrf_token %}
                        {% if form.errors %}
                            <div class="alert alert-danger">
                                <ul>
                                    {% for field in form %}
                                        {% for error in field.errors %}
                                            <li>{{ field.label }}: {{ error }}</li>
                                        {% endfor %}
                                    {% endfor %}
                                    {% for error in form.non_field_errors %}
                                        <li>{{ error }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                        <div class="mb-4">
                            <label for="{{ form.tool_class.id_for_label }}" class="form-label">Tool Class</label><br>
                            {{ form.tool_class }}
                        </div>
                        <div class="mb-4">
                            <label for="{{ form.tool_subclass.id_for_label }}" class="form-label">Tool Subclass</label><br>
                            {{ form.tool_subclass }}
                        </div>
                        <div class="mb-4">
                            <label class="form-label">Description</label><br>
                            <textarea id="tool_description" name="description" class="form-control" readonly rows="2"></textarea>
                        </div>
                        <div id="errorMessage" class="alert alert-danger" style="display: none;"></div>
                        <div class="d-flex justify-content-end">
                            <a href="{% url 'agents:manage_tools' %}" class="btn btn-secondary me-2">Cancel</a>
                            <button type="submit" id="submitButton" class="btn btn-primary" disabled>Save</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
            {% if tool %}
            <div class="row">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0">Test Tool</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-3">
                                    <div class="card">
                                        <div class="card-header">
                                            <h6 class="mb-0">Tool Inputs</h6>
                                        </div>
                                        <div class="card-body">
                                            <form id="toolTestForm">
                                                <!-- Tool input fields will be dynamically added here -->
                                                <div id="toolInputs"></div>
                                                <button type="button" id="testToolBtn" class="btn btn-primary mt-3">Test</button>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-9">
                                    <div class="card">
                                        <div class="card-header d-flex justify-content-between align-items-center">
                                            <h6 class="mb-0">Tool Output</h6>
                                            <span id="tokenCount">Token Count: 0</span>
                                            <button id="copyOutputBtn" class="btn btn-sm btn-outline-primary">Copy to clipboard</button>
                                        </div>
                                        <div class="card-body">
                                            <div id="toolOutput" class="border p-3" style="height: 300px; overflow-y: auto;"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Add this new container for output tables -->
            <div id="outputTableContainer" class="col-12 mt-4" style="display: none;">
                <!-- Tables will be dynamically inserted here -->
            </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<style>
    .card {
        box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
        border: 0;
    }
    .card-header {
        background-color: #f8f9fa;
        border-bottom: 1px solid rgba(0,0,0,.125);
        padding: 1rem 1.5rem;
    }
    .card-body {
        padding: 1.5rem;
    }
    .form-label {
        font-weight: 600;
        color: #344767;
        margin-bottom: 0.5rem;
        display: block;
    }
    .form-control, .form-select {
        width: 100%;
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
        border: 1px solid #d2d6da;
        border-radius: 0.375rem;
        margin-top: 0.25rem;
    }
    .form-control:focus, .form-select:focus {
        border-color: #5e72e4;
        box-shadow: 0 0 0 0.2rem rgba(94, 114, 228, 0.25);
    }
    textarea.form-control {
        min-height: 150px;
    }
    .btn {
        font-size: 0.875rem;
        font-weight: 600;
        padding: 0.625rem 1.25rem;
        border-radius: 0.375rem;
    }
    .btn-primary {
        background-color: #5e72e4;
        border-color: #5e72e4;
    }
    .btn-secondary {
        background-color: #8392ab;
        border-color: #8392ab;
    }
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0,0,0,.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        -webkit-animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
        to { -webkit-transform: rotate(360deg); }
    }
    @-webkit-keyframes spin {
        to { -webkit-transform: rotate(360deg); }
    }
    #toolOutput {
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: monospace;
        font-size: 0.9rem;
    }
</style>
{% endblock extrastyle %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        var toolClassSelect = document.getElementById('{{ form.tool_class.id_for_label }}');
        var toolSubclassSelect = document.getElementById('{{ form.tool_subclass.id_for_label }}');
        var toolDescriptionInput = document.getElementById('tool_description');
        var submitButton = document.getElementById('submitButton');
        var errorMessageDiv = document.getElementById('errorMessage');
        var outputTableContainer = document.getElementById('outputTableContainer');
        var outputTables = [];

        function setLoading(isLoading) {
            if (isLoading) {
                toolSubclassSelect.innerHTML = '<option value="">Loading...</option>';
                toolDescriptionInput.value = 'Loading...';
                submitButton.innerHTML = '<span class="loading"></span> Loading';
            } else {
                submitButton.innerHTML = 'Save';
            }
            submitButton.disabled = isLoading;
        }

        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
        }

        function hideError() {
            errorMessageDiv.style.display = 'none';
        }

        toolClassSelect.addEventListener('change', function() {
            var selectedTool = this.value;
            if (selectedTool) {
                setLoading(true);
                hideError();
                fetch(`/agents/get_tool_info/?tool_class=${selectedTool}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        toolSubclassSelect.innerHTML = '';
                        data.classes.forEach(cls => {
                            var option = document.createElement('option');
                            option.value = cls.name;
                            option.textContent = cls.name;
                            option.setAttribute('data-description', cls.description);
                            toolSubclassSelect.appendChild(option);
                        });
                        toolSubclassSelect.dispatchEvent(new Event('change'));
                        submitButton.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showError(`Failed to load tool information: ${error.message}`);
                        toolSubclassSelect.innerHTML = '';
                        toolDescriptionInput.value = '';
                        submitButton.disabled = true;
                    })
                    .finally(() => {
                        setLoading(false);
                    });
            } else {
                toolSubclassSelect.innerHTML = '';
                toolDescriptionInput.value = '';
                submitButton.disabled = true;
                hideError();
            }
        });

        toolSubclassSelect.addEventListener('change', function() {
            var selectedOption = this.options[this.selectedIndex];
            if (selectedOption) {
                toolDescriptionInput.value = selectedOption.getAttribute('data-description') || '';
            } else {
                toolDescriptionInput.value = '';
            }
        });

        // Trigger the change event on page load if a tool is already selected (for edit mode)
        if (toolClassSelect.value) {
            toolClassSelect.dispatchEvent(new Event('change'));
        }

        {% if tool %}
        // Tool testing functionality
        const toolInputs = document.getElementById('toolInputs');
        const testToolBtn = document.getElementById('testToolBtn');
        const toolOutput = document.getElementById('toolOutput');
        const copyOutputBtn = document.getElementById('copyOutputBtn');
        const tokenCountSpan = document.getElementById('tokenCount');

        // Function to fetch tool schema and create input fields
        function fetchToolSchema() {
            fetch(`/agents/get_tool_schema/{{ tool.id }}/`)
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw err; });
                    }
                    return response.json();
                })
                .then(schema => {
                    toolInputs.innerHTML = '';
                    if (schema.error) {
                        throw new Error(schema.error);
                    } else if (schema.properties) {
                        for (const [key, value] of Object.entries(schema.properties)) {
                            const inputGroup = document.createElement('div');
                            inputGroup.className = 'mb-3';
                            
                            const label = document.createElement('label');
                            label.className = 'form-label';
                            label.textContent = value.title || key;
                            
                            const input = document.createElement('input');
                            input.className = 'form-control';
                            input.name = key;
                            input.type = value.type === 'number' ? 'number' : 'text';
                            if (value.description) {
                                input.placeholder = value.description;
                            }
                            
                            inputGroup.appendChild(label);
                            inputGroup.appendChild(input);
                            toolInputs.appendChild(inputGroup);
                        }
                    } else {
                        throw new Error('Invalid schema structure');
                    }
                })
                .catch(error => {
                    console.error('Error fetching tool schema:', error);
                    toolInputs.innerHTML = `<p class="text-danger">Error loading tool inputs: ${error.message}</p>`;
                });
        }

        // Fetch tool schema on page load
        fetchToolSchema();

        function isJSON(str) {
            try {
                JSON.parse(str);
                return true;
            } catch (e) {
                return false;
            }
        }

        function parseJSON(jsonStr) {
            return JSON.parse(jsonStr);
        }

        function createTable(data, tableName) {
            if (!Array.isArray(data) || data.length === 0) return null;
            
            const tableContainer = document.createElement('div');
            tableContainer.className = 'col-12 mt-4';
            
            // Get all unique keys from all objects
            const keys = [...new Set(data.flatMap(obj => Object.keys(obj)))];
            
            tableContainer.innerHTML = `
                <div class="card mb-4">
                    <div class="card-header pb-0">
                        <h6>${tableName}</h6>
                    </div>
                    <div class="card-body px-0 pt-0 pb-2">
                        <div class="table-responsive p-0">
                            <table class="table align-items-center mb-0" id="${tableName.replace(/\s+/g, '-').toLowerCase()}">
                                <thead>
                                    <tr>
                                        ${keys.map(key => `<th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">${key}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${data.map(row => `
                                        <tr>
                                            ${keys.map(key => {
                                                const value = row[key];
                                                let displayValue = '';
                                                if (value === undefined || value === null) {
                                                    displayValue = '';
                                                } else if (typeof value === 'object') {
                                                    displayValue = JSON.stringify(value, null, 2);
                                                } else {
                                                    displayValue = value.toString();
                                                }
                                                return `<td class="text-sm font-weight-normal"><pre style="white-space: pre-wrap;">${displayValue}</pre></td>`;
                                            }).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            return tableContainer;
        }

        function flattenObject(obj, prefix = '') {
            let tables = {};
            for (const [key, value] of Object.entries(obj)) {
                const newKey = prefix ? `${prefix}.${key}` : key;
                if (Array.isArray(value)) {
                    if (value.length > 0) {
                        if (typeof value[0] === 'object') {
                            // Handle array of objects that have nested arrays
                            const flattenedData = value.map(item => {
                                const flattened = {};
                                for (const [k, v] of Object.entries(item)) {
                                    if (Array.isArray(v)) {
                                        if (v.length > 0 && typeof v[0] === 'object') {
                                            flattened[k] = v.map(obj => JSON.stringify(obj, null, 2)).join('\n');
                                        } else {
                                            flattened[k] = v.join(', ');
                                        }
                                    } else {
                                        flattened[k] = v;
                                    }
                                }
                                return flattened;
                            });
                            tables[newKey] = flattenedData;
                        }
                    }
                } else if (typeof value === 'object' && value !== null) {
                    Object.assign(tables, flattenObject(value, newKey));
                }
            }
            return tables;
        }

        function displayMultipleTables(data) {
            console.log('Displaying multiple tables. Data:', data);
            if (!outputTableContainer) {
                outputTableContainer = document.getElementById('outputTableContainer');
                if (!outputTableContainer) {
                    console.error('Output table container not found');
                    return;
                }
            }
            outputTableContainer.innerHTML = '';

            // Get all possible tables from the nested structure
            const tables = flattenObject(data);
            
            for (const [key, value] of Object.entries(tables)) {
                if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                    const table = createTable(value, key);
                    if (table) {
                        outputTableContainer.appendChild(table);

                        const tableId = `#${key.replace(/\s+/g, '-').toLowerCase()}`;
                        try {
                            const tableElement = document.querySelector(tableId);
                            if (tableElement) {
                                outputTables.push(new simpleDatatables.DataTable(tableId, {
                                    searchable: true,
                                    fixedHeight: false,
                                    perPage: 10
                                }));
                            }
                        } catch (error) {
                            console.warn(`Failed to initialize DataTable for ${tableId}:`, error);
                        }
                    }
                }
            }

            outputTableContainer.style.display = 'block';
        }

        function isCSV(str) {
            const lines = str.trim().split('\n');
            return lines.length > 1 && lines[0].includes(',') && lines[1].includes(',');
        }

        function parseCSV(csv) {
            const lines = csv.trim().split('\n');
            return lines.map(line => line.split(',').map(cell => cell.trim()));
        }

        function displayTable(data, tableName = 'CSV Data') {
            if (!outputTableContainer) {
                console.error('Output table container not found');
                return;
            }
            outputTableContainer.innerHTML = '';

            const tableData = data.slice(1).map(row => {
                const obj = {};
                data[0].forEach((header, index) => {
                    obj[header] = row[index];
                });
                return obj;
            });

            const table = createTable(tableData, tableName);
            outputTableContainer.appendChild(table);

            outputTables.push(new simpleDatatables.DataTable(`#${tableName.replace(/\s+/g, '-').toLowerCase()}`, {
                searchable: true,
                fixedHeight: false,
                perPage: 10
            }));

            outputTableContainer.style.display = 'block';
        }

        testToolBtn.addEventListener('click', function() {
            console.log('Test button clicked');
            const formData = new FormData(document.getElementById('toolTestForm'));
            
            // Show loading state
            toolOutput.innerHTML = `
                <div class="d-flex align-items-center">
                    <div class="spinner-border text-primary me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span>Testing tool...</span>
                </div>
            `;
            
            fetch(`/agents/test_tool/{{ tool.id }}/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Tool execution started successfully
                console.log('Tool execution started:', data);
                const taskId = data.task_id;
                
                // Function to check task status
                function checkStatus() {
                    fetch(`/agents/tool-status/${taskId}/`)
                        .then(response => response.json())
                        .then(statusData => {
                            console.log('Task status:', statusData);
                            
                            if (statusData.error) {
                                throw new Error(statusData.error);
                            }
                            
                            if (statusData.status === 'PENDING' || statusData.status === 'STARTED') {
                                // Still running, update UI and check again in 1 second
                                toolOutput.innerHTML = `
                                    <div class="d-flex align-items-center">
                                        <div class="spinner-border text-primary me-2" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span>Tool is running...</span>
                                    </div>
                                `;
                                setTimeout(checkStatus, 1000);
                            } else if (statusData.status === 'SUCCESS') {
                                // Task completed successfully
                                const result = statusData.result;
                                
                                // Clear any previous output
                                toolOutput.innerHTML = '';
                                
                                // Handle different types of output
                                if (typeof result === 'string') {
                                    if (isJSON(result)) {
                                        const jsonData = parseJSON(result);
                                        displayMultipleTables(jsonData);
                                        toolOutput.textContent = result;
                                    } else if (isCSV(result)) {
                                        const csvData = parseCSV(result);
                                        displayTable(csvData);
                                        toolOutput.textContent = result;
                                    } else {
                                        toolOutput.textContent = result;
                                    }
                                } else if (result && typeof result === 'object') {
                                    displayMultipleTables(result);
                                    toolOutput.textContent = JSON.stringify(result, null, 2);
                                } else {
                                    toolOutput.textContent = 'Task completed successfully';
                                }
                            } else if (statusData.status === 'FAILURE') {
                                throw new Error(statusData.error || 'Task failed');
                            }
                        })
                        .catch(error => {
                            toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                        });
                }
                
                // Start checking status
                checkStatus();
            })
            .catch(error => {
                toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
            });
        });

        // Copy output to clipboard
        copyOutputBtn.addEventListener('click', function() {
            navigator.clipboard.writeText(toolOutput.textContent)
                .then(() => {
                    alert('Output copied to clipboard!');
                })
                .catch(err => {
                    console.error('Failed to copy text: ', err);
                });
        });

        {% endif %}
    });
</script>
{% endblock extra_js %}

================
File: agents/templatetags/__init__.py
================
# Empty file to make the directory a Python package

================
File: agents/templatetags/agent_filters.py
================
from django import template

register = template.Library()

@register.filter
def has_force_output_enabled(agent, tool):
    """Template filter to check if force output is enabled for a tool."""
    if not agent:
        return False
    tool_setting = agent.tool_settings.filter(tool=tool).first()
    return tool_setting.force_output_as_result if tool_setting else False

================
File: agents/templatetags/agent_tags.py
================
from django import template

register = template.Library()

@register.filter
def get_item(dictionary, key):
    return dictionary.get(key)

================
File: agents/tests/integration/test_callback_flow.py
================


================
File: agents/utils/error_handling.py
================
from functools import wraps
import logging
import json
from typing import Optional, Any, Callable
from django.core.exceptions import ValidationError

logger = logging.getLogger(__name__)

class ChatError(Exception):
    """Base class for chat-related errors"""
    def __init__(self, message: str, code: Optional[str] = None):
        super().__init__(message)
        self.code = code

def handle_chat_errors(func: Callable) -> Callable:
    """Decorator to handle chat-related errors"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ChatError as e:
            logger.warning(f"Chat error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': e.code
            }
        except ValidationError as e:
            logger.warning(f"Validation error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': 'validation_error'
            }
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': 'An unexpected error occurred',
                'code': 'internal_error'
            }
    return wrapper

================
File: agents/utils/formatters.py
================
import json
from typing import Any
from logger import logger

class TableFormatter:
    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data appears to be tabular"""
        try:
            # Handle string input
            if isinstance(data, str):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return False

            # Handle dictionary with nested data
            if isinstance(data, dict):
                # Look for common response patterns and nested data
                for key in ['data', 'results', 'search_console_data', 'analytics_data', 
                           'records', 'rows', 'items', 'response']:
                    if key in data and isinstance(data[key], list):
                        data = data[key]
                        break
                # If no list found in known keys, check all values
                if isinstance(data, dict):
                    for value in data.values():
                        if isinstance(value, list) and len(value) > 0:
                            data = value
                            break

            # Check if it's a list of dictionaries with consistent structure
            if isinstance(data, list) and len(data) > 0:
                if all(isinstance(item, dict) for item in data):
                    # Get keys from first item
                    keys = set(data[0].keys())
                    # Check if all items have same keys and at least one key
                    return len(keys) > 0 and all(set(item.keys()) == keys for item in data)

            return False
            
        except Exception as e:
            logger.error(f"Error detecting tabular data: {str(e)}")
            return False

================
File: agents/websockets/handlers/agent_handler.py
================
import logging
from apps.common.utils import format_message
from apps.agents.models import Agent
from channels.db import database_sync_to_async
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler
from apps.agents.websockets.services.chat_service import ChatService

logger = logging.getLogger(__name__)

class AgentHandler:
    def __init__(self, consumer):
        self.consumer = consumer
        self.chat_service = None

    async def process_response(self, message, agent_id, model_name, client_id):
        """Manages agent and chat service lifecycle"""
        try:
            # Get agent data
            agent = await self.get_agent(agent_id)
            if not agent:
                raise ValueError("Agent not found")

            # Get client data
            client_data = await self.consumer.client_manager.get_client_data(client_id)

            # Initialize or reset chat service
            if not self.chat_service:
                callback_handler = WebSocketCallbackHandler(self.consumer)
                self.chat_service = ChatService(
                    agent=agent,
                    model_name=model_name,
                    client_data=client_data,
                    callback_handler=callback_handler,
                    session_id=self.consumer.session_id
                )
                await self.chat_service.initialize()
            else:
                # Reset token counter if service exists
                if hasattr(self.chat_service, 'token_counter'):
                    self.chat_service.token_counter.input_tokens = 0
                    self.chat_service.token_counter.output_tokens = 0

            # Process message - no return value needed as everything goes through callbacks
            await self.chat_service.process_message(message)

        except Exception as e:
            logger.error(f"Error in agent handler: {str(e)}")
            raise

    @database_sync_to_async
    def get_agent(self, agent_id):
        """Get agent from database"""
        try:
            return Agent.objects.get(id=agent_id)
        except Exception as e:
            logger.error(f"Error getting agent: {str(e)}")
            raise

================
File: agents/websockets/handlers/callback_handler.py
================
from langchain_core.callbacks import BaseCallbackHandler
import logging
import json
from typing import Any, Dict, List
from datetime import datetime
from langchain_core.agents import  AgentFinish
import asyncio
import textwrap
import uuid
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.table_formatter import TableFormatter
from apps.agents.chat.formatters.output_formatter import OutputFormatter
from langchain.schema import SystemMessage, AIMessage

logger = logging.getLogger(__name__)

class UUIDEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, uuid.UUID):
            return str(obj)
        return super().default(obj)

def create_box(title: str, content: str) -> str:
    """Create a boxed debug message with wrapped content using Unicode box characters."""
    # Box drawing characters
    TOP_LEFT = "┌"
    TOP_RIGHT = "┐"
    BOTTOM_LEFT = "└"
    BOTTOM_RIGHT = "┘"
    HORIZONTAL = "─"
    VERTICAL = "│"
    
    # Wrap content to 80 chars
    wrapped_content = textwrap.fill(str(content), width=80)
    width = max(max(len(line) for line in wrapped_content.split('\n')), len(title)) + 4
    
    # Create box components
    top = f"{TOP_LEFT}{HORIZONTAL * (width-2)}{TOP_RIGHT}"
    title_line = f"{VERTICAL} {title.center(width-4)} {VERTICAL}"
    separator = f"{HORIZONTAL * width}"
    content_lines = [f"{VERTICAL} {line:<{width-4}} {VERTICAL}" for line in wrapped_content.split('\n')]
    bottom = f"{BOTTOM_LEFT}{HORIZONTAL * (width-2)}{BOTTOM_RIGHT}"
    
    return f"\n{top}\n{title_line}\n{separator}\n{chr(10).join(content_lines)}\n{bottom}\n"

class WebSocketCallbackHandler(BaseCallbackHandler):
    """Callback handler that sends only essential messages to the WebSocket."""
    
    def __init__(self, consumer, message_manager=None, token_manager=None):
        """Initialize the handler with a WebSocket consumer and managers"""
        super().__init__()
        self.consumer = consumer
        self.logger = logging.getLogger(__name__)
        self._message_lock = asyncio.Lock()
        self.message_history = []
        self._last_agent_finish = None  # Track last agent finish message
        self.message_manager = message_manager
        self.token_manager = token_manager

    def _log_message(self, title: str, content: Any):
        """Log a message with proper JSON serialization."""
        try:
            if isinstance(content, dict):
                content_str = json.dumps(content, indent=2, cls=UUIDEncoder)
            else:
                content_str = str(content)
            self.logger.debug(create_box(title, content_str))
        except Exception as e:
            self.logger.error(f"Error logging message: {str(e)}")

    async def _send_message(self, message_data):
        """Send message to WebSocket and store in history."""
        try:
            # Store message in history
            self.message_history.append({
                'timestamp': datetime.now().isoformat(),
                'type': message_data.get('type'),
                'content': message_data
            })
            
            # Format message if it's a tool message
            if message_data.get('type', '').startswith('tool_') and self.message_manager:
                message_data['message'] = self.message_manager.format_message(
                    message_data['message'],
                    message_data['type']
                )
            
            async with self._message_lock:
                await self.consumer.send_json(message_data)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN SEND MESSAGE", str(e)), exc_info=True)

    async def on_agent_finish(self, finish: AgentFinish, **kwargs: Any):
        """Handle agent completion - send final answer and save to database."""
        try:
            # Get token usage and track it
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
                await self.token_manager.track_conversation_tokens()
            
            if hasattr(finish, 'return_values'):
                output = finish.return_values.get('output', '')
                
                # Check if this is a duplicate message
                if self._last_agent_finish == output:
                    self.logger.debug("Skipping duplicate agent finish message")
                    return
                
                self._last_agent_finish = output
                
                debug_info = {
                    'output': output,
                    'token_usage': token_usage
                }
                self._log_message("AGENT FINISH EVENT RECEIVED", debug_info)
                
                message = {
                    'type': 'agent_finish',
                    'message': output,
                    'timestamp': datetime.now().isoformat(),
                    'token_usage': token_usage
                }
                
                # Store message using message manager
                if self.message_manager:
                    await self.message_manager.add_message(
                        AIMessage(content=output),
                        token_usage=token_usage
                    )
                
                # Send message to websocket
                await self._send_message(message)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN AGENT FINISH", str(e)), exc_info=True)

    def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any) -> None:
        """Synchronous handler for tool start - required by LangChain."""
        self._log_message("TOOL START (SYNC)", {
            'tool': serialized.get('name', 'Unknown Tool'),
            'input': input_str,
            'kwargs': kwargs
        })

    def on_tool_end(self, output: str, **kwargs: Any) -> None:
        """Synchronous handler for tool end - required by LangChain."""
        self._log_message("TOOL END (SYNC)", {
            'output': output,
            'kwargs': kwargs
        })

    async def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any):
        """Handle tool start - send tool name and input."""
        try:
            # Skip internal exceptions
            if serialized.get('name') == '_Exception':
                return
                
            # Get token usage and track it
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            debug_info = {
                'tool': serialized.get('name', 'Unknown Tool'),
                'input': input_str,
                'token_usage': token_usage
            }
            self._log_message("TOOL START EVENT RECEIVED", debug_info)
            
            # Store tool start in message history if manager available
            tool_message = f"Tool Start: {serialized.get('name')} - {input_str}"
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=tool_message),
                    token_usage=token_usage
                )
            
            # Then send message to websocket
            message = {
                'type': 'agent_message',
                'message': tool_message,
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage
            }
            await self._send_message(message)
                
        except Exception as e:
            logger.error(create_box("ERROR IN TOOL START", str(e)), exc_info=True)
            await self.on_tool_error(str(e), **kwargs)

    async def on_tool_end(self, output: str, **kwargs: Any):
        """Handle tool completion - send formatted output."""
        try:
            # Check if this is an error response
            if isinstance(output, dict) and output.get('error'):
                await self.on_tool_error(output['error'], **kwargs)
                return
            
            # Format the output using message manager if available
            formatted_output = output
            if self.message_manager:
                formatted_output = self.message_manager.format_message(output, 'tool_end')
            
            debug_info = {
                'output': formatted_output,
                'token_usage': {}  # Tools don't typically use tokens
            }
            self._log_message("TOOL END EVENT RECEIVED", debug_info)
            
            tool_result = f"Tool Result: {formatted_output}"
            message = {
                'type': 'agent_message',
                'message': tool_result,
                'timestamp': datetime.now().isoformat(),
                'token_usage': {}  # Tools don't typically use tokens
            }
            await self._send_message(message)
            
            # Store tool end in message history if manager available
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=tool_result),
                    token_usage={}  # Tools don't typically use tokens
                )
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL END", str(e)), exc_info=True)
            await self.on_tool_error(str(e), **kwargs)

    async def on_tool_error(self, error: str, **kwargs: Any):
        """Handle tool errors"""
        try:
            # Get token usage from kwargs if available
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            error_info = {
                'error': error,
                'token_usage': token_usage
            }
            self._log_message("TOOL ERROR EVENT RECEIVED", error_info)
            
            error_message = f"Tool Error: {error}"
            message = {
                'type': 'agent_message',
                'message': error_message,
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage
            }
            await self._send_message(message)
            
            # Store error in message history if manager available
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=error_message),
                    token_usage=token_usage
                )
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL ERROR HANDLER", str(e)), exc_info=True)

================
File: agents/websockets/services/chat_service.py
================
from langchain.agents import AgentExecutor, create_structured_chat_agent
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.memory import ConversationBufferMemory
from langchain_core.messages import (
    BaseMessage,
    HumanMessage, 
    AIMessage,

    SystemMessage
)
from channels.db import database_sync_to_async
import json
import logging
from django.utils import timezone
from apps.common.utils import get_llm
from django.core.cache import cache
from typing import Optional, List, Any, Dict
import asyncio
from apps.seo_manager.models import Client
from django.db import models
from pydantic import ValidationError
from langchain_core.agents import AgentFinish
import re

# Import our new managers
from apps.agents.chat.managers.token_manager import TokenManager
from apps.agents.chat.managers.tool_manager import ToolManager
from apps.agents.chat.managers.prompt_manager import PromptManager
from apps.agents.chat.managers.message_manager import MessageManager
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler

logger = logging.getLogger(__name__)

class ChatServiceError(Exception):
    """Base exception for chat service errors"""
    pass

class ToolExecutionError(ChatServiceError):
    """Raised when a tool execution fails"""
    pass

class TokenLimitError(ChatServiceError):
    """Raised when token limit is exceeded"""
    pass

class ChatService:
    def __init__(self, agent, model_name, client_data, callback_handler, session_id=None):
        self.agent = agent
        self.model_name = model_name
        self.client_data = client_data
        self.callback_handler = callback_handler
        self.llm = None
        self.agent_executor = None
        self.processing = False
        self.tool_cache = {}  # Cache for tool results
        self.session_id = session_id or f"{agent.id}_{client_data['client_id'] if client_data else 'no_client'}"
        self.processing_lock = asyncio.Lock()
        
        # Create conversation ID from session ID if not provided
        self.conversation_id = f"conv_{self.session_id}"
        
        # Initialize managers with conversation ID
        self.token_manager = TokenManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id,
            max_token_limit=64000,
            model_name=model_name
        )
        
        self.message_manager = MessageManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id
        )
        
        self.tool_manager = ToolManager()
        self.prompt_manager = PromptManager()
        
        # Set up message history with token management
        self.message_history = self.message_manager
        
        # Update callback handler with managers
        if isinstance(self.callback_handler, WebSocketCallbackHandler):
            self.callback_handler.message_manager = self.message_manager
            self.callback_handler.token_manager = self.token_manager

    async def initialize(self) -> Optional[AgentExecutor]:
        """Initialize the chat service with LLM and agent"""
        try:
            # Validate and get client if present
            client_data = None
            if self.client_data and self.client_data.get('client_id'):
                try:
                    client = await database_sync_to_async(Client.objects.get)(id=self.client_data['client_id'])
                    client_data = {'client': client}
                except Client.DoesNotExist:
                    logger.error(f"Client not found with ID: {self.client_data['client_id']}")
                    raise ValueError(f"Client not found with ID: {self.client_data['client_id']}")

            # Create or get conversation
            conversation = await self._create_or_get_conversation(client_data['client'] if client_data else None)
            
            # Update managers with conversation ID
            self.conversation_id = str(conversation.id)
            self.token_manager.conversation_id = self.conversation_id
            self.message_manager.conversation_id = self.conversation_id

            # Get LLM with token tracking
            self.llm, token_callback = get_llm(
                model_name=self.model_name,
                temperature=0.7,
            )
            
            # Set up token tracking
            self.llm.callbacks = [token_callback]
            self.token_manager.set_token_callback(token_callback)

            # Initialize memory with proper message handling
            memory = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                chat_memory=self.message_manager,
                output_key="output",
                input_key="input"
            )

            # Load tools using tool manager
            tools = await self.tool_manager.load_tools(self.agent)

            # Get tool names and descriptions
            tool_names = [tool.name for tool in tools]
            tool_descriptions = [f"{tool.name}: {tool.description}" for tool in tools]

            # Get chat history and ensure it's a list of BaseMessage objects
            chat_history = await self.message_manager.get_messages()
            if not isinstance(chat_history, list):
                chat_history = []
            
            # Create the agent-specific system prompt with client context using prompt manager
            system_prompt = self.prompt_manager.create_agent_prompt(self.agent, client_data)
            
            # Create prompt using prompt manager
            prompt = self.prompt_manager.create_chat_prompt(
                system_prompt=system_prompt,
                additional_context={
                    "tools": "\n".join(tool_descriptions),
                    "tool_names": ", ".join(tool_names),
                    "agent_scratchpad": "{agent_scratchpad}",
                    "chat_history": chat_history,  # Pass the raw messages, let prompt manager format them
                    "client_data": client_data
                }
            )

            # Create the agent
            agent = create_structured_chat_agent(
                llm=self.llm,
                tools=tools,
                prompt=prompt
            )

            # Create agent executor with memory
            self.agent_executor = AgentExecutor(
                agent=agent,
                tools=tools,
                memory=memory,
                verbose=True,
                max_iterations=25,  
                handle_parsing_errors=True,
            )

            # Reset session token totals
            await self.token_manager._reset_session_token_totals()

            return self.agent_executor

        except Exception as e:
            logger.error(f"Error initializing chat service: {str(e)}", exc_info=True)
            raise

    @database_sync_to_async
    def _create_or_get_conversation(self, client=None) -> Any:
        """Create or get a conversation record."""
        try:
            from apps.agents.models import Conversation
            
            # Try to get existing conversation
            conversation = Conversation.objects.filter(
                session_id=self.session_id
            ).first()
            
            if not conversation:
                # Create new conversation
                conversation = Conversation.objects.create(
                    session_id=self.session_id,
                    agent_id=self.agent.id,
                    client=client,
                    user_id=self.client_data.get('user_id') if self.client_data else None
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error creating/getting conversation: {str(e)}", exc_info=True)
            raise

    def _create_token_aware_memory(self) -> ConversationBufferMemory:
        """Create memory with token limit enforcement"""
        memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True,
            chat_memory=self.message_manager,
            output_key="output",
            input_key="input"
        )

        # Wrap the add_message methods to check token counts
        original_add_message = self.message_manager.add_message

        async def wrapped_add_message(message: BaseMessage, **kwargs) -> None:
            """Async wrapper for add_message that handles token usage"""
            try:
                # Check token limit before adding message
                if not await self.token_manager.check_token_limit([message]):
                    raise TokenLimitError("Message would exceed token limit")
                    
                # Pass through any additional kwargs (including token_usage)
                await original_add_message(message, **kwargs)
            except Exception as e:
                logger.error(f"Error in wrapped_add_message: {str(e)}")
                raise

        # Replace the add_message method with our wrapped version
        self.message_manager.add_message = wrapped_add_message

        return memory

    def _create_box(self, content: str, title: str = "", width: int = 80) -> str:
        """Create a pretty ASCII box with content for logging"""
        lines = []
        
        # Top border with title
        if title:
            title = f" {title} "
            padding = (width - len(title)) // 2
            lines.append("╔" + "═" * padding + title + "═" * (width - padding - len(title)) + "╗")
        else:
            lines.append("╔" + "═" * width + "╗")
            
        # Content
        for line in content.split('\n'):
            # Split long lines
            while len(line) > width:
                split_at = line[:width].rfind(' ')
                if split_at == -1:
                    split_at = width
                lines.append("║ " + line[:split_at].ljust(width-2) + " ║")
                line = line[split_at:].lstrip()
            lines.append("║ " + line.ljust(width-2) + " ║")
            
        # Bottom border
        lines.append("╚" + "═" * width + "╝")
        
        return "\n".join(lines)

    async def process_message(self, message: str, is_edit: bool = False) -> None:
        """Handles all LLM/tool interactions"""
        async with self.processing_lock:
            try:
                # Reset token tracking
                self.token_manager.reset_tracking()

                # Log user input
                logger.info(f"Processing message: {message}")
                
                # Get agent response with preprocessing - just like testagent.py main()
                response = await self.agent_executor.ainvoke(
                    {
                        "input": message,
                        "chat_history": await self.message_manager.get_messages()
                    },
                    {"callbacks": [self.callback_handler, self.llm.callbacks[0]]}  # Use the token_callback from llm
                )

                # Save the agent's response to the database
                if isinstance(response, dict) and 'output' in response:
                    await self._handle_response(response['output'])

            except Exception as e:
                logger.error(f"Error in process_message: {str(e)}")
                # Pass run_id=None since we're in an error state
                await self._handle_error(str(e), e, unexpected=True)

    async def _handle_response(self, response: str) -> None:
        """Handle successful response"""
        try:
            # Get current token usage
            token_usage = self.token_manager.get_current_usage()
            
            # Send through callback handler for WebSocket communication
            await self.callback_handler.on_agent_finish(
                AgentFinish(
                    return_values={'output': response},
                    log='',
                ),
                token_usage=token_usage
            )
        except Exception as e:
            logger.error(f"Error handling response: {str(e)}", exc_info=True)
            await self._handle_error("Failed to handle response", e)

    async def _handle_error(self, error_msg: str, exception: Exception, unexpected: bool = False) -> None:
        """Handle errors consistently"""
        try:
            # Log the error
            logger.error(f"Error in chat service: {error_msg}", exc_info=True)
            
            # Store error message in message history
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=f"Error: {error_msg}"),
                    token_usage=self.token_manager.get_current_usage()
                )
            
            # Send error through callback handler
            await self.callback_handler.on_llm_error(error_msg)
            
            if unexpected:
                raise ChatServiceError(str(exception))
            else:
                raise exception
                
        except Exception as e:
            logger.error(f"Error in error handler: {str(e)}", exc_info=True)
            raise ChatServiceError(str(e))

    async def handle_edit(self) -> None:
        """Handle message editing"""
        try:
            await self.message_manager.handle_edit()
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise ChatServiceError("Failed to handle message edit")

    async def get_conversation_token_usage(self) -> Dict:
        """Get total token usage for the conversation"""
        return await self.token_manager.get_conversation_token_usage()

    async def track_tool_token_usage(self, token_usage: Dict, tool_name: str) -> None:
        """Track token usage for tool execution"""
        await self.token_manager.store_token_usage(
            message_id=f"tool_{tool_name}_{timezone.now().timestamp()}",
            token_usage={
                **token_usage,
                'metadata': {'tool_name': tool_name, 'type': 'tool_execution'}
            }
        )

================
File: agents/websockets/__init__.py
================
from .chat_consumer import ChatConsumer
from .base import BaseWebSocketConsumer

__all__ = ['ChatConsumer', 'BaseWebSocketConsumer']

================
File: agents/websockets/base.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class BaseWebSocketConsumer(AsyncWebsocketConsumer):
    async def send_json(self, data):
        """Send JSON data as text"""
        try:
            await self.send(text_data=json.dumps(data))
        except Exception as e:
            logger.error(f"Error sending JSON: {str(e)}")
            await self.send(text_data=json.dumps({
                'error': True,
                'message': 'Error sending message'
            }))

    async def handle_binary_message(self, message):
        """Handle binary message data"""
        try:
            if isinstance(message, bytes):
                message = message.decode('utf-8')
            return json.loads(message)
        except Exception as e:
            logger.error(f"Error handling binary message: {str(e)}")
            return None

================
File: agents/websockets/chat_consumer.py
================
from .base import BaseWebSocketConsumer
from .handlers.agent_handler import AgentHandler
from ..tools.manager import AgentToolManager
from ..clients.manager import ClientDataManager
from ..chat.history import DjangoCacheMessageHistory
from ..models import Conversation
import logging
import uuid
import json
from datetime import datetime
from urllib.parse import parse_qs
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import (
    BaseMessage, 
    HumanMessage, 
    AIMessage,
    messages_from_dict, 
    messages_to_dict
)

logger = logging.getLogger(__name__)

class ChatConsumer(BaseWebSocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.tool_manager = AgentToolManager()
        self.client_manager = ClientDataManager()
        self.session_id = None
        self.group_name = None
        self.agent_handler = AgentHandler(self)
        self.is_connected = False
        self.message_history = None

    async def send_json(self, content):
        """Override to add logging"""
        #logger.debug(f"Sending message: {content}")
        await super().send_json(content)

    async def connect(self):
        if self.is_connected:
            return

        try:
            # Get session ID from query parameters
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if param)
            self.session_id = params.get('session')
            
            if not self.session_id:
                logger.error("No session ID provided")
                await self.close()
                return
                
            self.user = self.scope.get("user")
            if not self.user or not self.user.is_authenticated:
                logger.error("User not authenticated")
                await self.close()
                return
        
            logger.debug(f"Connecting websocket for user {self.user.id} with session {self.session_id}")
                
            # Get or create conversation first to get agent_id
            conversation = await self.get_or_create_conversation()
            if not conversation:
                logger.error("Failed to get/create conversation")
                await self.close()
                return
            
            logger.debug(f"Found conversation {conversation.id} with title: {conversation.title}")
                
            self.group_name = f"chat_{self.session_id}"
            # Pass agent_id from conversation
            self.message_history = DjangoCacheMessageHistory(
                session_id=self.session_id,
                agent_id=conversation.agent_id if conversation.agent_id else None,
                conversation_id=conversation.id
            )
            
            await self.channel_layer.group_add(self.group_name, self.channel_name)
            await self.accept()
            self.is_connected = True
            
            # Send historical messages
            messages = await self.message_history.aget_messages()
            logger.debug(f"Retrieved {len(messages)} historical messages")
            
            for msg in messages:
                logger.debug(f"Processing message: {type(msg)} | content: {msg.content[:50]}...")
                message_type = 'agent_message' if isinstance(msg, AIMessage) else 'user_message'
                message_content = msg.content
                
                logger.debug(f"Sending historical message: type={message_type}, content={message_content[:50]}...")
                
                await self.send_json({
                    'type': message_type,
                    'message': message_content,
                    'timestamp': conversation.updated_at.isoformat()
                })
            
            await self.send_json({
                'type': 'system_message',
                'message': 'Connected to chat server',
                'connection_status': 'connected',
                'session_id': self.session_id
            })
            
        except Exception as e:
            logger.error(f"Error in connect: {str(e)}", exc_info=True)
            await self.close()
            return

    async def get_or_create_conversation(self):
        try:
            # Get existing conversation
            conversation = await Conversation.objects.filter(
                session_id=self.session_id,
                user=self.user
            ).afirst()
            
            if not conversation:
                # Create new conversation with placeholder title
                conversation = await Conversation.objects.acreate(
                    session_id=self.session_id,
                    user=self.user,
                    title="..."  # Will be updated with first message
                )
                #logger.info(f"Created new conversation: {conversation.id}")
            else:
                #logger.info(f"Found existing conversation: {conversation.id}")
                pass
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error getting/creating conversation: {str(e)}")
            return None

    async def update_conversation(self, message, agent_id=None, client_id=None):
        try:
            conversation = await Conversation.objects.filter(
                session_id=self.session_id
            ).afirst()
            
            if conversation:
                # Update title if it's still the default
                if conversation.title == "...":
                    # Clean and truncate the message for the title
                    title = message.strip().replace('\n', ' ')[:50]
                    # Add ellipsis if truncated
                    if len(message) > 50:
                        title += "..."
                    conversation.title = title
                
                # Update agent and client if provided
                if agent_id:
                    conversation.agent_id = agent_id
                if client_id:
                    conversation.client_id = client_id
                    
                await conversation.asave()
                #logger.info(f"Updated conversation: {conversation.id} with title: {conversation.title}")
                
        except Exception as e:
            logger.error(f"Error updating conversation: {str(e)}")

    async def receive(self, text_data=None, bytes_data=None):
        try:
            # Handle binary data if present
            if bytes_data:
                data = await self.handle_binary_message(bytes_data)
            else:
                data = json.loads(text_data)

            # Process keep-alive messages
            if data.get('type') == 'keep_alive':
                await self.message_handler.handle_keep_alive()
                return

            # Process message - responses come via callback_handler
            await self.process_message(data)

        except json.JSONDecodeError as e:
            logger.error(f"❌ JSON decode error: {str(e)}")
            await self.message_handler.handle_message(
                'Invalid message format', is_agent=True, error=True
            )
        except Exception as e:
            logger.error(f"❌ Error: {str(e)}")
            await self.message_handler.handle_message(
                'Internal server error', is_agent=True, error=True)

    async def process_message(self, data):
        """Primary entry point for all messages"""
        try:
            # Extract message data
            message = data.get('message', '').strip()
            agent_id = data.get('agent_id')
            model_name = data.get('model')
            client_id = data.get('client_id')
            is_edit = data.get('is_edit', False)

            if not message or not agent_id:
                raise ValueError('Missing required fields')

            # Handle message editing if needed
            if is_edit:
                await self.message_history.handle_edit()

            # Update conversation state
            await self.update_conversation(message, agent_id, client_id)
            
            # Ensure message history has correct agent_id
            if not self.message_history or self.message_history.agent_id != agent_id:
                conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
                self.message_history = DjangoCacheMessageHistory(
                    session_id=self.session_id,
                    agent_id=agent_id,
                    conversation_id=conversation.id if conversation else None
                )
            
            # Store user message and let frontend handle display
            await self.message_history.add_message(
                HumanMessage(content=message)
            )

            # Process with agent - responses come via callback_handler
            await self.agent_handler.process_response(
                message, agent_id, model_name, client_id
            )

        except Exception as e:
            logger.error(f"Error processing message: {str(e)}")
            await self.send_json({
                'type': 'error',
                'message': str(e),
                'timestamp': datetime.now().isoformat()
            })

    async def receive_json(self, content):
        """Disabled in favor of receive() to prevent duplicate message processing"""
        pass

================
File: agents/websockets/consumers.py
================
import json
from django.db import models
from django.db.models import Q
from asgiref.sync import sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.agents.models import Agent
from apps.agents.services import ChatService

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        session_id = self.scope['url_route']['kwargs']['session_id']
        agent_id = self.scope['url_route']['kwargs'].get('agent_id')
        
        # Get the agent from the database
        agent = await database_sync_to_async(Agent.objects.get)(id=agent_id)
        
        # Initialize chat service with the specified agent
        self.chat_service = ChatService(
            agent=agent,
            model_name=self.model_name,
            client_data=self.client_data,
            callback_handler=self,
            session_id=session_id
        )
        
        await self.chat_service.initialize()
        await self.accept()

    async def receive(self, text_data):
        data = json.loads(text_data)
        if data.get('type') == 'agent_change':
            # Handle agent change
            new_agent = await database_sync_to_async(Agent.objects.get)(id=data['agent_id'])
            self.chat_service.update_agent(new_agent)
            return
            
        # ... rest of receive code ...

================
File: agents/websockets/crew_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
# ... other imports ...

class CrewExecutionConsumer(AsyncWebsocketConsumer):
    # ... existing implementation ...
    pass

================
File: agents/admin.py
================
from django.contrib import admin
from .models import Crew, CrewExecution, CrewMessage, Agent, Task, Tool, CrewTask, Pipeline, PipelineStage, PipelineRoute, PipelineExecution, PipelineRunResult
from .forms import AgentForm, TaskForm, CrewForm

class CrewTaskInline(admin.TabularInline):
    model = CrewTask
    extra = 1

@admin.register(Crew)
class CrewAdmin(admin.ModelAdmin):
    list_display = ('name', 'process', 'verbose')
    filter_horizontal = ('agents',)
    inlines = [CrewTaskInline]
    fieldsets = (
        (None, {
            'fields': ('name', 'agents', 'process', 'verbose', 'manager_llm', 'function_calling_llm', 'config', 'max_rpm', 'language', 'language_file', 'memory', 'cache', 'embedder', 'full_output', 'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks', 'prompt_file', 'planning', 'planning_llm')
        }),
    )

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        form.base_fields['agents'].widget.can_add_related = True
        form.base_fields['agents'].widget.can_change_related = True
        return form

@admin.register(CrewExecution)
class CrewExecutionAdmin(admin.ModelAdmin):
    list_display = ('crew', 'user', 'client', 'status', 'created_at', 'updated_at')
    list_filter = ('status', 'created_at', 'updated_at')
    search_fields = ('crew__name', 'user__username', 'client__name')
    readonly_fields = ('created_at', 'updated_at', 'human_input_request', 'human_input_response', 'error_message')
    fieldsets = (
        (None, {
            'fields': ('crew', 'user', 'client', 'status', 'inputs', 'crew_output')
        }),
        ('Human Input', {
            'fields': ('human_input_request', 'human_input_response')
        }),
        ('Error Information', {
            'fields': ('error_message',)
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at')
        }),
    )

@admin.register(CrewMessage)
class CrewMessageAdmin(admin.ModelAdmin):
    list_display = ('execution', 'timestamp')
    list_filter = ('timestamp',)
    search_fields = ('execution__crew__name', 'content')

@admin.register(Agent)
class AgentAdmin(admin.ModelAdmin):
    form = AgentForm
    list_display = ('name', 'role', 'llm', 'function_calling_llm', 'verbose', 'allow_delegation', 'allow_code_execution')
    list_filter = ('verbose', 'allow_delegation', 'allow_code_execution', 'use_system_prompt', 'respect_context_window')
    search_fields = ('name', 'role', 'goal', 'backstory')
    filter_horizontal = ('tools',)
    fieldsets = (
        (None, {
            'fields': ('name', 'role', 'goal', 'backstory', 'llm', 'tools')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('function_calling_llm', 'max_iter', 'max_rpm', 'max_execution_time', 'verbose', 'allow_delegation', 'step_callback', 'cache', 'system_template', 'prompt_template', 'response_template', 'allow_code_execution', 'max_retry_limit', 'use_system_prompt', 'respect_context_window'),
        }),
    )

@admin.register(Task)
class TaskAdmin(admin.ModelAdmin):
    form = TaskForm
    list_display = ('description', 'agent', 'async_execution', 'human_input', 'output_type')
    list_filter = ('async_execution', 'human_input')
    filter_horizontal = ('tools', 'context')
    search_fields = ('description', 'agent__name', 'expected_output')
    readonly_fields = ('output',)

    def output_type(self, obj):
        if obj.output_json:
            return 'JSON'
        elif obj.output_pydantic:
            return 'Pydantic'
        elif obj.output_file:
            return 'File'
        else:
            return 'Default'
    output_type.short_description = 'Output Type'

    fieldsets = (
        (None, {
            'fields': ('description', 'agent', 'expected_output', 'tools', 'async_execution', 'context')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls'),
        }),
        ('Output', {
            'fields': ('output',),
        }),
    )

@admin.register(Tool)
class ToolAdmin(admin.ModelAdmin):
    list_display = ('name', 'description')
    search_fields = ('name', 'description', 'function')

# Register other models
admin.site.register(Pipeline)
admin.site.register(PipelineStage)
admin.site.register(PipelineRoute)
admin.site.register(PipelineExecution)
admin.site.register(PipelineRunResult)

================
File: agents/apps.py
================
from django.apps import AppConfig


class AgentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.agents'
    verbose_name = 'CrewAI Agents'

    def ready(self):
        pass  # We'll add any necessary imports or setup here later if needed

================
File: agents/celery.py
================
from celery import Celery
import os
from django.conf import settings

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

app = Celery('core')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)

================
File: agents/consumers.py
================
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
from .models import CrewExecution, CrewMessage, ChatMessage, Agent
from django.core.cache import cache
from apps.common.utils import format_message, get_llm
from .utils import get_tool_classes
import logging
import uuid
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, FunctionMessage, BaseMessage, messages_from_dict, messages_to_dict
import asyncio
import tiktoken
from langchain_community.chat_models import ChatLiteLLM
from langchain_core.tools import Tool
from django.utils import timezone
from apps.seo_manager.models import Client
from langchain.prompts import ChatPromptTemplate
from langchain.agents import initialize_agent, AgentType, AgentExecutor, create_structured_chat_agent
from langchain.agents.format_scratchpad import format_to_openai_function_messages
from langchain.agents.output_parsers import JSONAgentOutputParser
from langchain_core.callbacks import BaseCallbackHandler
import datetime
from langchain.tools import StructuredTool
from typing import Dict, Any, List
from pydantic import create_model
from langchain.memory import ConversationBufferMemory
from langchain_core.chat_history import BaseChatMessageHistory
import re
import time

logger = logging.getLogger(__name__)

def count_tokens(text):
    """Count tokens in text using tiktoken"""
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

class ConnectionTestConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()
        await self.send(text_data=json.dumps({
            'message': 'Connected to server'
        }))

    async def disconnect(self, close_code):
        pass

    async def receive(self, text_data):
        try:
            text_data_json = json.loads(text_data)
            message = text_data_json['message']

            # Echo the received message back to the client
            await self.send(text_data=json.dumps({
                'message': f'Server received: {message}'
            }))
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'error': 'Invalid JSON format'
            }))
        except KeyError:
            await self.send(text_data=json.dumps({
                'error': 'Missing "message" key in JSON'
            }))

class CrewExecutionConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.execution_id = self.scope['url_route']['kwargs']['execution_id']
        self.execution_group_name = f'crew_execution_{self.execution_id}'

        # Join room group
        await self.channel_layer.group_add(
            self.execution_group_name,
            self.channel_name
        )

        await self.accept()

        # Send initial status
        await self.send_execution_status()

    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.execution_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message_type = text_data_json.get('type')

        if message_type == 'human_input':
            input_key = text_data_json.get('input_key')
            user_input = text_data_json.get('input')
            await self.handle_human_input(input_key, user_input)

    async def crew_execution_update(self, event):
        status = event.get('status', '')  # No formatting applied
        formatted_messages = [
            {
                'agent': msg.get('agent', 'System'),
                'content': format_message(msg.get('content', ''))
            } for msg in event.get('messages', []) if msg.get('content')
        ]
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
            'human_input_request': event.get('human_input_request')
        }))

    @database_sync_to_async
    def handle_human_input(self, input_key, user_input):
        cache.set(f"{input_key}_response", user_input, timeout=3600)
        execution = CrewExecution.objects.get(id=self.execution_id)
        CrewMessage.objects.create(
            execution=execution,
            agent='Human',
            content=f"Human input received: {user_input}"
        )

    @database_sync_to_async
    def get_execution_status(self):
        execution = CrewExecution.objects.get(id=self.execution_id)
        messages = CrewMessage.objects.filter(execution=execution).order_by('-timestamp')[:10]
        return {
            'status': execution.status,
            'messages': [{'agent': msg.agent, 'content': msg.content} for msg in messages],
        }

    async def send_execution_status(self):
        status_data = await self.get_execution_status()
        status = status_data['status']  # No formatting applied
        formatted_messages = [
            {
                'agent': msg['agent'],
                'content': format_message(msg['content'])
            } for msg in status_data['messages'] if msg.get('content')
        ]
        
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
        }))

================
File: agents/forms.py
================
import random
from django.conf import settings
from django import forms
from .models import CrewExecution, Agent, Task, Tool, Crew, get_available_tools, AVATAR_CHOICES
from apps.seo_manager.models import Client
from apps.common.utils import get_models
import json
import logging
from .utils import get_available_tools, get_tool_classes

logger = logging.getLogger(__name__)

class CrewExecutionForm(forms.ModelForm):
    inputs = forms.JSONField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = CrewExecution
        fields = ['inputs']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['inputs'].widget.attrs['class'] = 'form-control'
        self.fields['inputs'].help_text = 'Enter JSON formatted inputs for the crew execution.'

    def clean_inputs(self):
        inputs = self.cleaned_data.get('inputs')
        if inputs:
            try:
                return json.loads(inputs)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in inputs field")
        return {}

class HumanInputForm(forms.Form):
    response = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=True)

class AgentForm(forms.ModelForm):
    avatar = forms.ChoiceField(
        choices=[(choice, choice) for choice in AVATAR_CHOICES],
        widget=forms.RadioSelect(),
        required=False
    )
    llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=True
    )
    function_calling_llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=False
    )
    
    tools = forms.ModelMultipleChoiceField(
        queryset=Tool.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False
    )

    class Meta:
        model = Agent
        fields = '__all__'  # Include all fields from the model
        widgets = {
            'goal': forms.Textarea(attrs={'rows': 3}),
            'backstory': forms.Textarea(attrs={'rows': 3}),
            'system_template': forms.Textarea(attrs={'rows': 4}),
            'prompt_template': forms.Textarea(attrs={'rows': 4}),
            'response_template': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.SelectMultiple(attrs={'class': 'form-select'}),
            'llm': forms.Select(attrs={'class': 'form-select'}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for field in self.fields:
            if isinstance(self.fields[field].widget, forms.CheckboxInput):
                self.fields[field].widget.attrs['class'] = 'form-check-input'
            elif not isinstance(self.fields[field].widget, (forms.SelectMultiple, forms.RadioSelect)):
                self.fields[field].widget.attrs['class'] = 'form-control'

        # Ensure avatar choices are set
        self.fields['avatar'].choices = [(choice, choice) for choice in AVATAR_CHOICES]

        # Ensure the initial values are set correctly
        self.initial['llm'] = self.initial.get('llm', settings.GENERAL_MODEL)
        self.initial['function_calling_llm'] = self.initial.get('function_calling_llm', settings.GENERAL_MODEL)

    def clean(self):
        cleaned_data = super().clean()
        logger.debug(f"Cleaned form data: {cleaned_data}")
        return cleaned_data

    def save(self, commit=True):
        logger.debug(f"Saving form with data: {self.cleaned_data}")
        instance = super().save(commit=False)
        # Ensure LLM values are set on the instance
        instance.llm = self.cleaned_data.get('llm')
        instance.function_calling_llm = self.cleaned_data.get('function_calling_llm')
        if commit:
            instance.save()
            self.save_m2m()
        logger.debug(f"Saved instance: {instance.__dict__}")
        return instance

class TaskForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = Task
        fields = ['description', 'agent', 'expected_output', 'tools', 'async_execution', 'context', 'config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
            'expected_output': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.CheckboxSelectMultiple(),
            'context': forms.CheckboxSelectMultiple(),
            'output_json': forms.TextInput(),
            'output_pydantic': forms.TextInput(),
            'output_file': forms.TextInput(attrs={'placeholder': 'e.g., outputs/task_result.txt'}),
            'converter_cls': forms.TextInput(),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)

    def clean_config(self):
        config = self.cleaned_data.get('config')
        if config:
            try:
                return json.loads(config)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in config field")
        return None

    def clean_output_file(self):
        output_file = self.cleaned_data.get('output_file')
        if output_file:
            # You can add additional validation here if needed
            # For example, check if the path is within allowed directories
            pass
        return output_file

class ToolForm(forms.ModelForm):
    tool_class = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    tool_subclass = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    description = forms.CharField(widget=forms.Textarea(attrs={'readonly': 'readonly'}), required=False)

    class Meta:
        model = Tool
        fields = ['tool_class', 'tool_subclass', 'name', 'description']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_tools = get_available_tools()
        self.fields['tool_class'].choices = [(tool, tool) for tool in available_tools]
        self.fields['name'].widget = forms.HiddenInput()
        self.fields['name'].required = False
        
        if self.data.get('tool_class'):
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.data['tool_class'])
        elif self.instance.pk:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.instance.tool_class)

    def get_subclass_choices(self, tool_class):
        subclasses = get_tool_classes(tool_class)
        return [(cls.__name__, cls.__name__) for cls in subclasses]

    def clean(self):
        cleaned_data = super().clean()
        tool_class = cleaned_data.get('tool_class')
        tool_subclass = cleaned_data.get('tool_subclass')

        if tool_class:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(tool_class)

        if tool_class and tool_subclass:
            subclasses = dict(self.fields['tool_subclass'].choices)
            if tool_subclass not in subclasses:
                raise forms.ValidationError(f"Invalid tool subclass '{tool_subclass}' for tool class '{tool_class}'")

        # Set the name field to the value of tool_subclass
        cleaned_data['name'] = tool_subclass

        return cleaned_data

    def save(self, commit=True):
        instance = super().save(commit=False)
        instance.name = self.cleaned_data['tool_subclass']
        if commit:
            instance.save()
        return instance

class CrewForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    manager_callbacks = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    agents = forms.ModelMultipleChoiceField(
        queryset=Agent.objects.all(),
        required=False,
        widget=forms.SelectMultiple(attrs={'class': 'form-control form-select'})
    )

    class Meta:
        model = Crew
        fields = [
            'name', 'agents', 'tasks', 'process', 'verbose', 'manager_llm',
            'function_calling_llm', 'config', 'max_rpm', 'language',
            'language_file', 'memory', 'cache', 'embedder', 'full_output',
            'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks',
            'prompt_file', 'planning', 'planning_llm'
        ]
        # Note: input_variables is not included here as it's handled separately in the view

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_models = get_models()
        self.fields['manager_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['function_calling_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['planning_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['max_rpm'].widget.attrs['min'] = 0
        self.fields['max_rpm'].widget.attrs['step'] = 1

        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)
        if self.instance.manager_callbacks:
            self.initial['manager_callbacks'] = json.dumps(self.instance.manager_callbacks, indent=2)
        if self.instance.embedder:
            self.initial['embedder'] = json.dumps(self.instance.embedder, indent=2)

        # Remove the 'required' attribute from the agents field
        if 'agents' in self.fields:
            self.fields['agents'].required = False

        print(f"Initial manager_llm: {self.initial.get('manager_llm')}")  # Debugging line
        print(f"Initial function_calling_llm: {self.initial.get('function_calling_llm')}")  # Debugging line

    def clean_config(self):
        return self._clean_json_field('config')

    def clean_manager_callbacks(self):
        return self._clean_json_field('manager_callbacks')

    def clean_embedder(self):
        return self._clean_json_field('embedder')

    def _clean_json_field(self, field_name):
        data = self.cleaned_data.get(field_name)
        if data:
            try:
                return json.loads(data)
            except json.JSONDecodeError:
                raise forms.ValidationError(f"Invalid JSON format in {field_name} field")
        return None

================
File: agents/kanban_consumers.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
import logging

logger = logging.getLogger(__name__)
User = get_user_model()

class CrewKanbanConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        """
        Handle WebSocket connection setup
        """
        self.crew_id = self.scope['url_route']['kwargs']['crew_id']
        self.room_group_name = f'crew_{self.crew_id}_kanban'
        self.is_connected = False
        
        try:
            # Add to crew group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            await self.accept()
            self.is_connected = True
            logger.info(f"WebSocket connection established for crew {self.crew_id}")
        except Exception as e:
            logger.error(f"Error establishing WebSocket connection: {str(e)}")
            if not self.is_connected:
                await self.close()
    
    async def disconnect(self, close_code):
        """
        Handle WebSocket disconnection cleanup
        """
        try:
            self.is_connected = False
            await self.channel_layer.group_discard(
                self.room_group_name,
                self.channel_name
            )
            logger.info(f"WebSocket connection closed for crew {self.crew_id} with code {close_code}")
        except Exception as e:
            logger.error(f"Error during WebSocket disconnect: {str(e)}")
    
    async def receive(self, text_data):
        """
        Handle incoming WebSocket messages
        """
        if not self.is_connected:
            logger.warning("Received message but WebSocket is not connected")
            return
            
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            logger.debug(f"Received WebSocket message: {message_type}")
            
            # Handle ping messages immediately
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong'
                }))
                return
            
            handlers = {
                'execution_update': self.handle_execution_update,
                'agent_step': self.handle_agent_step,
                'human_input_request': self.handle_human_input_request,
                'task_complete': self.handle_task_complete
            }
            
            handler = handlers.get(message_type)
            if handler:
                await handler(data)
            else:
                logger.warning(f"Unknown message type received: {message_type}")
        
        except json.JSONDecodeError:
            logger.error(f"Failed to decode WebSocket message: {text_data}")
        except Exception as e:
            logger.error(f"Error processing WebSocket message: {str(e)}")
            if self.is_connected:
                await self.send(text_data=json.dumps({
                    'type': 'error',
                    'message': 'Internal server error occurred'
                }))
    
    async def handle_execution_update(self, data):
        """Handle execution status updates"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id from execution
            execution_id = data.get('execution_id')
            if execution_id:
                crewai_task_id = await self.get_task_id_for_execution(execution_id)
                data['crewai_task_id'] = crewai_task_id
            
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'execution_update',
                    **data
                }
            )
            logger.debug(f"Sent execution update for execution {execution_id}")
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            # Don't try to send error message if we already know connection is broken
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def handle_agent_step(self, data):
        """Handle individual agent step updates"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'agent_step',
                    'execution_id': data.get('execution_id'),
                    'agent': data.get('agent', ''),
                    'content': data.get('content', ''),
                    'step_type': data.get('step_type', ''),
                    'is_final_step': data.get('is_final_step', False)
                }
            )
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def handle_human_input_request(self, data):
        """Handle requests for human input"""
        if not self.is_connected:
            logger.warning("Cannot send human input request - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'human_input_request',
                    'execution_id': data.get('execution_id'),
                    'prompt': data.get('prompt', ''),
                    'context': data.get('context', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send human input request'
                    }))
                except:
                    pass

    async def handle_task_complete(self, data):
        """Handle task completion notifications"""
        if not self.is_connected:
            logger.warning("Cannot send task complete - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'task_complete',
                    'execution_id': data.get('execution_id'),
                    'message': data.get('message', ''),
                    'results': data.get('results', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending task complete: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send task complete'
                    }))
                except:
                    pass
    
    # WebSocket send handlers
    async def execution_update(self, event):
        """Send execution updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Ensure stage data has all required fields
            stage = event.get('stage', {})
            if stage:
                stage.setdefault('stage_type', 'processing')
                stage.setdefault('title', 'Processing...')
                stage.setdefault('content', '')
                stage.setdefault('status', 'in_progress')
                stage.setdefault('agent', 'System')
                stage.setdefault('completed', False)
                
                # Mark stage as completed if status is 'completed'
                if stage.get('status') == 'completed':
                    stage['completed'] = True
                
                # Ensure chat_message_prompts exists and has at least one item
                if 'chat_message_prompts' not in stage:
                    stage['chat_message_prompts'] = [{
                        'role': 'system',
                        'content': stage.get('content', 'Processing task...')
                    }]
            
            # Use the crewai_task_id directly from the event
            crewai_task_id = event.get('crewai_task_id')
            if not crewai_task_id:
                logger.debug(f"No CrewAI task ID provided in event for execution {event.get('execution_id')}")
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': event['execution_id'],  # Internal execution ID
                'status': event['status'],
                'crewai_task_id': crewai_task_id,  # Use task ID from event for kanban board placement
                'message': event.get('message'),
                'stage': stage
            }))
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def agent_step(self, event):
        """Send agent step updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id for this execution
            execution_id = event['execution_id']
            crewai_task_id = await self.get_task_id_for_execution(execution_id)
            
            # Format agent step as a stage update with chat_message_prompts
            stage_data = {
                'stage_type': event.get('step_type', 'agent_step'),
                'title': f"Agent: {event.get('agent', 'System')}",
                'content': event.get('content', ''),
                'status': 'in_progress',
                'agent': event.get('agent', 'System'),
                'completed': False,
                'chat_message_prompts': [{
                    'role': 'assistant',
                    'content': event.get('content', '')
                }]
            }
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': execution_id,
                'crewai_task_id': crewai_task_id,
                'stage': stage_data
            }))
            
            # Send a completion update for this stage if it's the final step
            if event.get('is_final_step', False):
                stage_data.update({
                    'status': 'completed',
                    'completed': True
                })
                await self.send(text_data=json.dumps({
                    'type': 'execution_update',
                    'execution_id': execution_id,
                    'crewai_task_id': crewai_task_id,
                    'stage': stage_data
                }))
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def human_input_request(self, event):
        """Send human input requests to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'human_input_request',
            'execution_id': event['execution_id'],
            'prompt': event['prompt'],
            'context': event['context']
        }))
    
    async def task_complete(self, event):
        """Send task completion notifications to WebSocket"""
        execution_id = event['execution_id']
        crewai_task_id = await self.get_task_id_for_execution(execution_id)
        
        await self.send(text_data=json.dumps({
            'type': 'task_complete',
            'execution_id': execution_id,
            'crewai_task_id': crewai_task_id,
            'message': event['message'],
            'results': event['results']
        }))

    @database_sync_to_async
    def get_task_id_for_execution(self, execution_id):
        """Get CrewAI task ID for a given execution"""
        from .models import CrewExecution
        try:
            execution = CrewExecution.objects.get(id=execution_id)
            # Get the latest execution stage for this execution
            latest_stage = execution.executionstage_set.order_by('-created_at').first()
            return latest_stage.crewai_task_id if latest_stage else None
        except CrewExecution.DoesNotExist:
            return None

================
File: agents/models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from apps.common.utils import get_models
from pydantic import BaseModel
import os
import importlib
import logging
import uuid
import random
import json
from django.contrib.postgres.fields import ArrayField
from django.conf import settings
from apps.agents.utils import load_tool, get_tool_description

logger = logging.getLogger(__name__)

User = get_user_model()

AVATAR_CHOICES = [
    'user.jpg', 'team-5.jpg', 'team-4.jpg', 'team-3.jpg', 'team-2.jpg', 'kal-visuals-square.jpg',
    'team-1.jpg', 'marie.jpg', 'ivana-squares.jpg', 'ivana-square.jpg'
]

def random_avatar():
    return random.choice(AVATAR_CHOICES)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for dir_name in dirs:
            if not dir_name.startswith('__'):  # Exclude directories like __pycache__
                tool_path = os.path.relpath(os.path.join(root, dir_name), tools_dir)
                available_tools.append(tool_path.replace(os.path.sep, '.'))

    return available_tools

def default_embedder():
    return {'provider': 'openai'}

def user_directory_path(instance, filename):
    # File will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    return f'user_{instance.crew_execution.user.id}/{filename}'

class Tool(models.Model):
    tool_class = models.CharField(max_length=255)
    tool_subclass = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    module_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.module_path:
            self.module_path = f"apps.agents.tools.{self.tool_class}"
        
        try:
            tool = load_tool(self)
            if tool:
                self.name = getattr(tool, 'name', self.tool_subclass)
                self.description = get_tool_description(tool.__class__)
            else:
                raise ValueError(f"Failed to load tool: {self.module_path}.{self.tool_subclass}. Check the logs for more details.")
        except Exception as e:
            logger.error(f"Error in Tool.save: {str(e)}")
            raise ValidationError(f"Error loading tool: {str(e)}")

        super().save(*args, **kwargs)

class ToolRun(models.Model):
    """Model to track tool executions"""
    TOOL_RUN_STATUS = (
        ('pending', 'Pending'),
        ('running', 'Running'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )
    
    tool = models.ForeignKey(Tool, on_delete=models.CASCADE)
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    message = models.ForeignKey('ChatMessage', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    status = models.CharField(max_length=20, choices=TOOL_RUN_STATUS, default='pending')
    inputs = models.JSONField()
    result = models.JSONField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.tool.name} - {self.status} ({self.created_at})"

class Agent(models.Model):
    name = models.CharField(max_length=255)
    role = models.CharField(max_length=100)
    goal = models.TextField()
    backstory = models.TextField()
    llm = models.CharField(max_length=100, default=settings.GENERAL_MODEL)
    tools = models.ManyToManyField(Tool, blank=True)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    max_iter = models.IntegerField(default=25)
    max_rpm = models.IntegerField(null=True, blank=True)
    max_execution_time = models.IntegerField(null=True, blank=True)
    verbose = models.BooleanField(default=False)
    allow_delegation = models.BooleanField(default=False)
    step_callback = models.CharField(max_length=255, null=True, blank=True)
    cache = models.BooleanField(default=True)
    system_template = models.TextField(null=True, blank=True)
    prompt_template = models.TextField(null=True, blank=True)
    response_template = models.TextField(null=True, blank=True)
    allow_code_execution = models.BooleanField(default=False)
    max_retry_limit = models.IntegerField(default=2)
    use_system_prompt = models.BooleanField(default=True)
    respect_context_window = models.BooleanField(default=True)
    avatar = models.CharField(max_length=100, default=random_avatar)

    def __str__(self):
        return self.name

    def clean(self):
        super().clean()
        available_models = get_models()
        if self.llm not in available_models:
            raise ValidationError({'llm': f"Selected LLM '{self.llm}' is not available. Please choose from: {', '.join(available_models)}"})

    def get_tool_settings(self, tool):
        """Get settings for a specific tool."""
        return self.tool_settings.filter(tool=tool).first()

    def get_forced_output_tools(self):
        """Get all tools that have force_output_as_result=True."""
        return self.tools.filter(
            id__in=self.tool_settings.filter(
                force_output_as_result=True
            ).values_list('tool_id', flat=True)
        )

    def has_force_output_enabled(self, tool):
        """Check if force output is enabled for a specific tool."""
        tool_setting = self.tool_settings.filter(tool=tool).first()
        return tool_setting.force_output_as_result if tool_setting else False

class Task(models.Model):
    description = models.TextField()
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    expected_output = models.TextField()
    tools = models.ManyToManyField(Tool, blank=True)
    async_execution = models.BooleanField(default=False)
    context = models.ManyToManyField('self', symmetrical=False, blank=True)
    config = models.JSONField(null=True, blank=True)
    output_json = models.CharField(max_length=255, null=True, blank=True)
    output_pydantic = models.CharField(max_length=255, null=True, blank=True)
    output_file = models.CharField(max_length=255, null=True, blank=True)
    output = models.TextField(null=True, blank=True)
    callback = models.CharField(max_length=255, null=True, blank=True)
    human_input = models.BooleanField(default=False)
    converter_cls = models.CharField(max_length=255, null=True, blank=True)
    crew_execution = models.ForeignKey('CrewExecution', on_delete=models.CASCADE, null=True, blank=True)

    def __str__(self):
        return self.description[:50]

    def save_output_file(self, content):
        if self.output_file:
            file_name = os.path.basename(self.output_file)
        else:
            file_name = f"task_{self.id}_output.txt"
        
        file_path = user_directory_path(self, file_name)
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        with open(full_path, 'w') as f:
            f.write(content)
        
        self.output_file = file_path
        self.save()

class Crew(models.Model):
    name = models.CharField(max_length=100)
    agents = models.ManyToManyField(Agent)
    tasks = models.ManyToManyField(Task, through='CrewTask')
    process = models.CharField(max_length=20, choices=[('sequential', 'Sequential'), ('hierarchical', 'Hierarchical')], default='sequential')
    verbose = models.BooleanField(default=False)
    manager_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    config = models.JSONField(null=True, blank=True)
    max_rpm = models.IntegerField(null=True, blank=True)
    language = models.CharField(max_length=50, default='English')
    language_file = models.CharField(max_length=255, null=True, blank=True)
    memory = models.BooleanField(default=False)
    cache = models.BooleanField(default=True)
    embedder = models.JSONField(default=default_embedder)
    full_output = models.BooleanField(default=False)
    share_crew = models.BooleanField(default=False)
    output_log_file = models.CharField(max_length=255, null=True, blank=True)
    manager_agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True, related_name='managed_crews')
    manager_callbacks = models.JSONField(null=True, blank=True)
    prompt_file = models.CharField(max_length=255, null=True, blank=True)
    planning = models.BooleanField(default=False)
    planning_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    input_variables = ArrayField(
        models.CharField(max_length=100),
        blank=True,
        null=True,
        default=list
    )

    def __str__(self):
        return self.name

class CrewExecution(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE)
    status = models.CharField(max_length=25, choices=[
        ('PENDING', 'Pending'),
        ('RUNNING', 'Running'),
        ('WAITING_FOR_HUMAN_INPUT', 'Waiting for Human Input'),
        ('COMPLETED', 'Completed'),
        ('FAILED', 'Failed')
    ], default='PENDING')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    inputs = models.JSONField(null=True, blank=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE, null=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)
    crew_output = models.OneToOneField('CrewOutput', on_delete=models.SET_NULL, null=True, blank=True, related_name='crew_execution')
    task_id = models.CharField(max_length=100, null=True, blank=True)
    human_input_request = models.JSONField(null=True, blank=True)
    human_input_response = models.JSONField(null=True, blank=True)
    error_message = models.TextField(blank=True, null=True)

    def __str__(self):
        return f"{self.crew.name} - {self.created_at}"

    def save_task_output_file(self, task, content):
        task.crew_execution = self
        task.save_output_file(content)

class CrewMessage(models.Model):
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='messages')
    content = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    agent = models.CharField(max_length=255, null=True, blank=True)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement

    def __str__(self):
        return f"{self.timestamp}: {self.content[:50]}"

class Pipeline(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    status = models.CharField(max_length=20, default='Idle')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

    def clean(self):
        # Validate that stages are properly structured
        stages = self.stages.all().order_by('order')
        for stage in stages:
            if stage.is_parallel:
                if stage.crew is not None:
                    raise ValidationError("Parallel stages should not have a single crew assigned.")
            else:
                if stage.crew is None:
                    raise ValidationError("Sequential stages must have a crew assigned.")

class PipelineStage(models.Model):
    pipeline = models.ForeignKey(Pipeline, related_name='stages', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    crew = models.ForeignKey('Crew', on_delete=models.SET_NULL, null=True, blank=True)
    order = models.PositiveIntegerField()
    is_parallel = models.BooleanField(default=False)
    is_router = models.BooleanField(default=False)

    class Meta:
        ordering = ['order']

    def __str__(self):
        return f"{self.pipeline.name} - {self.name}"

    def clean(self):
        if self.is_router and self.crew is not None:
            raise ValidationError("Router stages should not have a crew assigned.")

class PipelineRoute(models.Model):
    stage = models.ForeignKey(PipelineStage, related_name='routes', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    condition = models.TextField()  # This would store a serialized form of the condition
    target_pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.stage.name} - {self.name}"

class PipelineExecution(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, default='Pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.pipeline.name} Execution - {self.created_at}"

class PipelineRunResult(models.Model):
    execution = models.ForeignKey(PipelineExecution, related_name='run_results', on_delete=models.CASCADE)
    raw_output = models.TextField(blank=True)
    json_output = models.JSONField(null=True, blank=True)
    pydantic_output = models.TextField(null=True, blank=True)  # This would store a serialized form of the Pydantic model
    token_usage = models.JSONField(null=True, blank=True)
    trace = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"Run Result for {self.execution.pipeline.name}"

class CrewOutput(models.Model):
    raw = models.TextField()
    pydantic = models.JSONField(null=True, blank=True)
    json_dict = models.JSONField(null=True, blank=True)
    token_usage = models.JSONField(null=True, blank=True)

    @property
    def json(self):
        return json.dumps(self.json_dict) if self.json_dict else None

    def to_dict(self):
        return self.json_dict or (self.pydantic.dict() if self.pydantic else None) or {}

    def __str__(self):
        if self.pydantic:
            return str(self.pydantic)
        elif self.json_dict:
            return json.dumps(self.json_dict)
        else:
            return self.raw

    def save(self, *args, **kwargs):
        # Convert UsageMetrics to a dictionary if it's not already
        if self.token_usage and hasattr(self.token_usage, 'dict'):
            self.token_usage = self.token_usage.dict()
        super().save(*args, **kwargs)

class CrewTask(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE, related_name='crew_tasks')
    task = models.ForeignKey(Task, on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['order']
        unique_together = ('crew', 'task')

    def __str__(self):
        return f"{self.crew.name} - {self.task.description} (Order: {self.order})"

class AgentToolSettings(models.Model):
    agent = models.ForeignKey('Agent', on_delete=models.CASCADE, related_name='tool_settings')
    tool = models.ForeignKey('Tool', on_delete=models.CASCADE)
    force_output_as_result = models.BooleanField(default=False)

    class Meta:
        unique_together = ('agent', 'tool')

class ChatMessage(models.Model):
    session_id = models.UUIDField()
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='messages')
    agent = models.ForeignKey(Agent, on_delete=models.CASCADE)
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    content = models.TextField()
    is_agent = models.BooleanField()
    timestamp = models.DateTimeField(auto_now_add=True)
    model = models.CharField(max_length=100)

    class Meta:
        ordering = ['timestamp']

class ExecutionStage(models.Model):
    STAGE_TYPES = [
        ('task_start', 'Task Start'),
        ('thinking', 'Thinking'),
        ('tool_usage', 'Tool Usage'),
        ('tool_results', 'Tool Results'),
        ('human_input', 'Human Input'),
        ('completion', 'Completion')
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ]
    
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='stages')
    stage_type = models.CharField(max_length=20, choices=STAGE_TYPES)
    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    metadata = models.JSONField(default=dict)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'Execution Stage'
        verbose_name_plural = 'Execution Stages'
    
    def __str__(self):
        return f"{self.get_stage_type_display()} - {self.title}"

class Conversation(models.Model):
    session_id = models.UUIDField(unique=True)
    user = models.ForeignKey(get_user_model(), on_delete=models.CASCADE)
    agent = models.ForeignKey('Agent', on_delete=models.SET_NULL, null=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.SET_NULL, null=True)
    title = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ['-updated_at']

    def __str__(self):
        return f"{self.title} ({self.created_at.strftime('%Y-%m-%d %H:%M')})"

class TokenUsage(models.Model):
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='token_usage')
    message = models.ForeignKey('ChatMessage', on_delete=models.SET_NULL, null=True, blank=True)
    tool_run = models.ForeignKey('ToolRun', on_delete=models.SET_NULL, null=True, blank=True)
    prompt_tokens = models.IntegerField(default=0)
    completion_tokens = models.IntegerField(default=0)
    total_tokens = models.IntegerField(default=0)
    model = models.CharField(max_length=100)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)  # Changed from JSONField to models.JSONField

    class Meta:
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
        ]

    def __str__(self):
        return f"{self.conversation_id} - {self.total_tokens} tokens"

================
File: agents/routing.py
================
from django.urls import re_path
from .consumers import ConnectionTestConsumer, ChatConsumer, CrewExecutionConsumer
from .kanban_consumers import CrewKanbanConsumer

websocket_urlpatterns = [
    re_path(r'ws/chat/$', ChatConsumer.as_asgi()),
    re_path(r'ws/crew_execution/(?P<execution_id>\w+)/$', CrewExecutionConsumer.as_asgi()),
    re_path(r'ws/test-connection/$', ConnectionTestConsumer.as_asgi()),
]

================
File: agents/tasks.py
================
from celery import shared_task
import asyncio
import logging
from .utils import load_tool
from django.shortcuts import get_object_or_404
from .models import Tool, ToolRun
import inspect
import json
import traceback

logger = logging.getLogger(__name__)

@shared_task(bind=True)
def run_tool(self, tool_id: int, inputs: dict):
    """Generic Celery task to run any tool"""
    try:
        # Load the tool
        tool = get_object_or_404(Tool, id=tool_id)
        tool_instance = load_tool(tool)
        
        if tool_instance is None:
            raise ValueError('Failed to load tool')

        # Create a tool run record
        tool_run = ToolRun.objects.create(
            tool=tool,
            status='running',
            inputs=inputs
        )
        
        try:
            # Process inputs if tool has args_schema
            if hasattr(tool_instance, 'args_schema'):
                processed_inputs = {}
                for key, value in inputs.items():
                    if value != '':
                        try:
                            processed_inputs[key] = json.loads(value)
                        except json.JSONDecodeError:
                            processed_inputs[key] = value
                            
                validated_inputs = tool_instance.args_schema(**processed_inputs)
                inputs = validated_inputs.dict()
            
            # Run the tool
            if inspect.iscoroutinefunction(tool_instance._run):
                # Create event loop for async tools
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    result = loop.run_until_complete(tool_instance._run(**inputs))
                finally:
                    loop.close()
            else:
                # Run sync tools directly
                result = tool_instance._run(**inputs)
            
            # Update tool run record with success
            tool_run.status = 'completed'
            tool_run.result = result
            tool_run.save()
            
            return {
                'status': 'completed',
                'result': result,
                'tool_run_id': tool_run.id
            }
            
        except Exception as e:
            # Update tool run record with error
            tool_run.status = 'failed'
            tool_run.error = str(e)
            tool_run.save()
            raise
            
    except Exception as e:
        logger.error(f"Error running tool: {str(e)}\n{traceback.format_exc()}")
        return {
            'status': 'failed',
            'error': str(e)
        }

================
File: agents/tests.py
================
from django.test import TestCase
from django.contrib.auth import get_user_model
from .models import Crew, CrewExecution, CrewMessage
from .tasks import execute_crew, resume_crew_execution
from unittest.mock import patch

User = get_user_model()

class CrewExecutionTestCase(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testuser', password='12345')
        self.crew = Crew.objects.create(name='Test Crew', process='sequential')
        self.execution = CrewExecution.objects.create(
            crew=self.crew,
            user=self.user,
            inputs={'test_input': 'value'}
        )

    @patch('apps.agents.tasks.run_crew')
    def test_execute_crew(self, mock_run_crew):
        mock_run_crew.return_value = {'test_output': 'result'}
        
        execute_crew(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'COMPLETED')
        self.assertEqual(self.execution.outputs, {'test_output': 'result'})

    @patch('apps.agents.tasks.run_crew')
    def test_execute_crew_human_input_required(self, mock_run_crew):
        from .tasks import HumanInputRequired
        mock_run_crew.side_effect = HumanInputRequired('Test human input required')
        
        execute_crew(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'WAITING_FOR_HUMAN_INPUT')
        self.assertEqual(self.execution.human_input_request, 'Test human input required')

    @patch('apps.agents.tasks.run_crew')
    def test_resume_crew_execution(self, mock_run_crew):
        mock_run_crew.return_value = {'test_output': 'result after human input'}
        
        self.execution.status = 'WAITING_FOR_HUMAN_INPUT'
        self.execution.human_input_response = 'Test human input'
        self.execution.save()
        
        resume_crew_execution(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'COMPLETED')
        self.assertEqual(self.execution.outputs, {'test_output': 'result after human input'})

    def test_crew_message_creation(self):
        CrewMessage.objects.create(
            execution=self.execution,
            content='Test message'
        )
        
        self.assertEqual(CrewMessage.objects.count(), 1)
        self.assertEqual(CrewMessage.objects.first().content, 'Test message')

================
File: agents/tools.py
================


================
File: agents/urls.py
================
from django.urls import path
from . import views
from . import views_agents
from . import views_tasks
from . import views_tools
from . import views_crews
from . import views_kanban
from . import views_chat
from .views_chat import ChatView


app_name = 'agents'

urlpatterns = [
    path('', views.crewai_home, name='crewai_home'),
    path('crews/', views.crew_list, name='crew_list'),
    path('crew/<int:crew_id>/', views.crew_detail, name='crew_detail'),
    path('crew/<int:crew_id>/kanban/', views_kanban.crew_kanban, name='crew_kanban'),
    path('crew/<int:crew_id>/start-execution/', views_kanban.start_execution, name='start_execution'),
    path('crew/<int:crew_id>/active-executions/', views_kanban.get_active_executions, name='get_active_executions'),
    path('crew/execution/<int:execution_id>/input/', views_kanban.submit_human_input, name='submit_human_input'),
    path('executions/', views.execution_list, name='execution_list'),
    path('execution/<int:execution_id>/', views_kanban.execution_detail, name='execution_detail'),
    path('execution/<int:execution_id>/status/', views_kanban.get_active_executions, name='execution_status'),
    path('execution/<int:execution_id>/submit_human_input/', views.submit_human_input, name='submit_human_input'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    
    # Admin views
    path('manage/agents/', views_agents.manage_agents, name='manage_agents'),
    path('manage/agents/add/', views_agents.add_agent, name='add_agent'),
    path('manage/agents/edit/<int:agent_id>/', views_agents.edit_agent, name='edit_agent'),
    path('manage/agents/delete/<int:agent_id>/', views_agents.delete_agent, name='delete_agent'),
    
    path('manage/tasks/', views_tasks.manage_tasks, name='manage_tasks'),
    path('manage/tasks/add/', views_tasks.add_task, name='add_task'),
    path('manage/tasks/edit/<int:task_id>/', views_tasks.edit_task, name='edit_task'),
    path('manage/tasks/delete/<int:task_id>/', views_tasks.delete_task, name='delete_task'),
    
    path('manage/tools/', views_tools.manage_tools, name='manage_tools'),
    path('manage/tools/add/', views_tools.add_tool, name='add_tool'),
    path('manage/tools/edit/<int:tool_id>/', views_tools.edit_tool, name='edit_tool'),
    path('manage/tools/delete/<int:tool_id>/', views_tools.delete_tool, name='delete_tool'),
    path('tool-schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test-tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),
    path('tool-status/<str:task_id>/', views_tools.get_tool_status, name='get_tool_status'),
    path('get_tool_info/', views_tools.get_tool_info, name='get_tool_info'),
    path('get_tool_schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test_tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),  # Django 3.1+ automatically handles async views
    path('manage/crews/', views_crews.manage_crews, name='manage_crews'),
    path('manage/crews/add/', views_crews.crew_create_or_update, name='add_crew'),
    path('manage/crews/edit/<int:crew_id>/', views_crews.crew_create_or_update, name='edit_crew'),
    path('manage/crews/delete/<int:crew_id>/', views_crews.delete_crew, name='delete_crew'),
    path('manage/crews/update_agents/<int:crew_id>/', views_crews.update_crew_agents, name='update_crew_agents'),
    
    path('pipelines/', views.manage_pipelines, name='manage_pipelines'),
    path('manage/agents/card-view/', views_agents.manage_agents_card_view, name='manage_agents_card_view'),
    path('manage/crews/card-view/', views_crews.manage_crews_card_view, name='manage_crews_card_view'),
    
    path('connection-test/', views.connection_test, name='connection_test'),
    path('chat/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/delete/', views_chat.delete_conversation, name='delete_conversation'),
]

================
File: agents/utils.py
================
import os
import importlib
from crewai_tools import BaseTool as CrewAIBaseTool
from langchain.tools import BaseTool as LangChainBaseTool
import logging
import crewai_tools
from typing import Optional
from django.core.cache import cache
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import re

logger = logging.getLogger(__name__)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for item in dirs + files:
            if item.endswith('.py') and not item.startswith('__'):
                rel_path = os.path.relpath(os.path.join(root, item), tools_dir)
                module_path = os.path.splitext(rel_path)[0].replace(os.path.sep, '.')
                available_tools.append(module_path)

    return available_tools

def get_tool_classes(tool_path):
    module_path = f"apps.agents.tools.{tool_path}"
    if module_path.endswith('.py'):
        module_path = module_path[:-3]
    try:
        module = importlib.import_module(module_path)
    except ImportError as e:
        logger.error(f"Failed to import module {module_path}: {e}")
        return []
    
    tool_classes = []
    for name, obj in module.__dict__.items():
        if isinstance(obj, type) and name.endswith('Tool'):
            try:
                if issubclass(obj, (CrewAIBaseTool, LangChainBaseTool)) or (hasattr(obj, '_run') and callable(getattr(obj, '_run'))):
                    if not any(issubclass(other, obj) and other != obj for other in module.__dict__.values() if isinstance(other, type)):
                        tool_classes.append(obj)
            except TypeError:
                # This can happen if obj is not a class or doesn't inherit from the expected base classes
                logger.warning(f"Skipping {name} as it's not a valid tool class")
    
    logger.debug(f"Found tool classes for {tool_path}: {[cls.__name__ for cls in tool_classes]}")
    return tool_classes

def get_tool_description(tool_class_obj):
    logger.debug(f"Attempting to get description for {tool_class_obj}")

    if hasattr(tool_class_obj, 'description'):
        description = getattr(tool_class_obj, 'description')
        if isinstance(description, str):
            logger.debug(f"Found description class attribute: {description}")
            return description

    if hasattr(tool_class_obj, 'name'):
        name = getattr(tool_class_obj, 'name')
        if isinstance(name, str):
            logger.debug(f"Found name class attribute: {name}")
            return name

    if hasattr(tool_class_obj, '__annotations__') and 'description' in tool_class_obj.__annotations__:
        description = tool_class_obj.__annotations__['description']
        if isinstance(description, str):
            logger.debug(f"Found description in class annotations: {description}")
            return description

    if hasattr(tool_class_obj, 'model_fields') and 'description' in tool_class_obj.model_fields:
        description = tool_class_obj.model_fields['description'].default
        if isinstance(description, str):
            logger.debug(f"Found description in model_fields: {description}")
            return description

    if tool_class_obj.__doc__:
        docstring = tool_class_obj.__doc__.strip()
        logger.debug(f"Found docstring: {docstring}")
        return docstring

    #  Corrected schema handling: Access the description directly if it exists.
    if hasattr(tool_class_obj, 'schema') and callable(tool_class_obj.schema):
        try:
            schema = tool_class_obj.schema()
            if isinstance(schema, dict) and 'description' in schema and isinstance(schema['description'], str):
                 logger.debug(f"Found description in schema: {schema['description']}")
                 return schema['description']
        except Exception as e:
            logger.warning(f"Error getting schema for {tool_class_obj.__name__}: {str(e)}")


    default_description = f"A tool of type {tool_class_obj.__name__}"
    logger.debug(f"Using default description: {default_description}")
    return default_description

def get_tool_class_obj(tool_class, tool_subclass):
    try:
        module = importlib.import_module(f"apps.agents.tools.{tool_class}")  # Ensure correct module path
        return getattr(module, tool_subclass)
    except (ImportError, AttributeError) as e:
        logger.error(f"Error importing tool class: {e}")
        return None

def load_tool(tool_model) -> Optional[CrewAIBaseTool]:
    logger.info(f"Attempting to load tool: {tool_model.tool_class}.{tool_model.tool_subclass}")
    
    try:
        # Check if it's a pre-built CrewAI tool
        if hasattr(crewai_tools, tool_model.tool_class):
            logger.info(f"Loading pre-built CrewAI tool: {tool_model.tool_class}")
            tool_class = getattr(crewai_tools, tool_model.tool_class)
            return tool_class()

        # If not, try to import a custom tool
        full_module_path = f"apps.agents.tools.{tool_model.tool_class}"
        logger.info(f"Attempting to import custom tool module: {full_module_path}")
        module = importlib.import_module(full_module_path)
        tool_class = getattr(module, tool_model.tool_subclass)
        
        if issubclass(tool_class, CrewAIBaseTool):
            logger.info(f"Loaded custom CrewAI tool: {tool_model.tool_subclass}")
            return tool_class()
        elif issubclass(tool_class, LangChainBaseTool):
            logger.info(f"Loaded and wrapped LangChain tool: {tool_model.tool_subclass}")
            # Wrap LangChain tool in CrewAI compatible class
            class WrappedLangChainTool(CrewAIBaseTool):
                name = tool_class.name
                description = get_tool_description(tool_class)

                def _run(self, *args, **kwargs):
                    return tool_class()(*args, **kwargs)

            return WrappedLangChainTool()
        else:
            raise ValueError(f"Unsupported tool class: {tool_class}")

    except ImportError as e:
        logger.error(f"Error importing tool module {full_module_path}: {str(e)}")
    except AttributeError as e:
        logger.error(f"Error finding tool class {tool_model.tool_subclass} in module {full_module_path}: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error loading tool {full_module_path}.{tool_model.tool_subclass}: {str(e)}")
    
    return None

def get_tool_info(tool_model):
    logger.info(f"Getting tool info for: {tool_model.tool_class}.{tool_model.tool_subclass}")
    
    full_module_path = f"apps.agents.tools.{tool_model.tool_class}"
    
    return {
        'module_path': full_module_path,
        'class_name': tool_model.tool_subclass
    }

class URLDeduplicator:
    def __init__(self):
        # Common CMS page identifiers
        self.cms_patterns = {
            'wordpress': [
                r'(?:page_id|p|post)=\d+',
                r'\d{4}/\d{2}/\d{2}',  # Date-based permalinks
                r'(?:category|tag)/[\w-]+',
            ],
            'woocommerce': [
                r'product=\d+',
                r'product-category/[\w-]+',
            ],
        }
        
        # Patterns that indicate filter/sort URLs
        self.filter_patterns = [
            # E-commerce filters
            r'product_type=\d+',
            r'prefilter=',
            r'filter\[.*?\]=',
            r'sort(?:by)?=',
            r'order=',
            r'view=',
            r'display=',
            # Pagination
            r'page=\d+',
            r'per_page=\d+',
            # Common parameters
            r'utm_.*?=',
        ]
        
        # Initialize sets for tracking seen URLs and content hashes
        self._seen_urls = set()
        self._seen_hashes = set()
        self._content_hashes = {}
        
    def should_process_url(self, url: str) -> bool:
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        
        # First check if it's a CMS page
        if self._is_cms_page(parsed.query):
            return True
            
        # For filter URLs, check both the filtered URL and the base URL
        if self._is_filter_url(parsed.query):
            # Create base URL without query parameters
            base_url = urlunparse((
                parsed.scheme,
                parsed.netloc,
                parsed.path,
                '',
                '',
                ''
            ))
            # Add base URL to seen URLs to avoid duplicate processing
            normalized_base = self._normalize_url(base_url)
            if normalized_base not in self._seen_urls:
                self._seen_urls.add(normalized_base)
                return True
            return False
            
        # If unclear, normalize and check if we've seen it
        normalized = self._normalize_url(url)
        return normalized not in self._seen_urls
        
    def _is_cms_page(self, query: str) -> bool:
        return any(
            re.search(pattern, query)
            for patterns in self.cms_patterns.values()
            for pattern in patterns
        )
        
    def _is_filter_url(self, query: str) -> bool:
        return any(
            re.search(pattern, query)
            for pattern in self.filter_patterns
        )
        
    def _normalize_url(self, url: str) -> str:
        parsed = urlparse(url)
        # Keep only essential query parameters
        query_params = parse_qs(parsed.query)
        essential_params = {
            k: v for k, v in query_params.items()
            if not any(re.search(pattern, f"{k}={v[0]}") 
                      for pattern in self.filter_patterns)
        }
        query = urlencode(essential_params, doseq=True) if essential_params else ''
        
        return urlunparse((
            parsed.scheme,
            parsed.netloc.lower(),
            parsed.path.rstrip('/'),
            '',
            query,
            ''
        ))
        
    def _hash_main_content(self, content: str) -> int:
        """Hash the main content, ignoring common dynamic elements"""
        # TODO: Implement content cleaning/normalization if needed
        return hash(content)
        
    def fallback_content_check(self, url: str, content: str) -> bool:
        """Use content hash as fallback for ambiguous cases"""
        if url not in self._content_hashes:
            content_hash = self._hash_main_content(content)
            if content_hash in self._seen_hashes:
                return False
            self._content_hashes[url] = content_hash
            self._seen_hashes.add(content_hash)
        return True

================
File: agents/views_agents.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Agent, AgentToolSettings
from .forms import AgentForm
import traceback
from django.conf import settings

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_agents(request):
    agents = Agent.objects.all().order_by('name')
    return render(request, 'agents/manage_agents.html', {'agents': agents})
@login_required
def manage_agents_card_view(request):
    agents = Agent.objects.prefetch_related('crew_set', 'task_set', 'tools').all().order_by('name')
    form = AgentForm()  # Now AgentForm is defined
    context = {
        'page_title': 'Manage Agents',
        'agents': agents,
        'form': form,
    }
    return render(request, 'agents/manage_agents_card_view.html', context)

@login_required
@user_passes_test(is_admin)
def add_agent(request):
    if request.method == 'POST':
        form = AgentForm(request.POST)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                
                # Save many-to-many fields
                form.save_m2m()
                
                # Handle tool settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent added successfully.')
                return redirect('agents:manage_agents')
            except Exception as e:
                messages.error(request, f"Error adding agent: {str(e)}")
    else:
        form = AgentForm()

    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Agent',
    }
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        form = AgentForm(request.POST, instance=agent)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                form.save_m2m()
                
                # Update tool settings
                agent.tool_settings.all().delete()  # Remove existing settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent updated successfully.')
                return redirect('agents:manage_agents_card_view')
            except Exception as e:
                messages.error(request, f"Error updating agent: {str(e)}")
    else:
        form = AgentForm(instance=agent)
    
    # Add page_title to the context
    context = {
        'form': form,
        'agent': agent,
        'page_title': 'Edit Agent',
    }
    
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        agent.delete()
        messages.success(request, 'Agent deleted successfully.')
        return redirect('agents:manage_agents')
    # Add page_title to the context
    context = {
        'object': agent,
        'type': 'agent',
        'page_title': 'Delete Agent',
    }
    return render(request, 'agents/confirm_delete.html', context)

================
File: agents/views_chat.py
================
from django.views.generic import TemplateView
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from apps.agents.models import Agent, Conversation
from apps.common.utils import get_models
from django.conf import settings
from apps.seo_manager.models import Client
import logging
import uuid

logger = logging.getLogger(__name__)

@login_required
@require_POST
def delete_conversation(request, session_id):
    try:
        conversation = get_object_or_404(Conversation, session_id=session_id, user=request.user)
        conversation.delete()
        logger.info(f"Deleted conversation: {conversation.id}")
        return JsonResponse({'status': 'success'})
    except Exception as e:
        logger.error(f"Error deleting conversation: {str(e)}")
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

class ChatView(LoginRequiredMixin, TemplateView):
    template_name = 'agents/chat.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        try:
            # Get session_id from URL parameters or generate new one
            session_id = self.kwargs.get('session_id', str(uuid.uuid4()))
            logger.info(f"Using chat session ID: {session_id}")
            
            # Get base queryset for conversations
            conversations_qs = Conversation.objects.filter(
                user=self.request.user,
                is_active=True
            ).select_related('agent', 'client').order_by('-updated_at')
            
            # Get current conversation if exists
            current_conversation = None
            if 'session_id' in self.kwargs:
                try:
                    current_conversation = conversations_qs.get(session_id=session_id)
                    logger.info(f"Found existing conversation: {current_conversation}")
                except Conversation.DoesNotExist:
                    logger.warning(f"No conversation found for session_id: {session_id}")
            
            # Get recent conversations (limited to 50)
            conversations = conversations_qs[:50]
            logger.info(f"Found {conversations.count()} conversations")
            
            # Get all agents
            agents = Agent.objects.all().order_by('name')
            logger.info(f"Found {agents.count()} agents")
            
            # Get all clients
            clients = Client.objects.all().order_by('name')
            logger.info(f"Found {clients.count()} clients")
            
            # Get models list
            models = get_models()
            logger.info(f"Found {len(models)} models")
            
            # Get default model
            default_model = settings.GENERAL_MODEL
            logger.info(f"Using default model: {default_model}")
            
            context.update({
                'page_title': 'Chat',
                'agents': agents,
                'clients': clients,
                'models': models,
                'conversations': conversations,
                'current_conversation': current_conversation,
                'add_agent_url': reverse('agents:add_agent'),
                'segment': 'chat',
                'default_model': default_model,
                'session_id': session_id,
            })
            logger.info("Context prepared successfully")
            
        except Exception as e:
            logger.error(f"Error preparing chat view context: {str(e)}", exc_info=True)
            raise
            
        return context

================
File: agents/views_crews.py
================
# This file was previously named views_admin.py
# The content remains the same, but you might want to remove any unused imports

import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Crew, CrewTask
from .forms import CrewForm
import json
from apps.seo_manager.models import Client
from django.conf import settings

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_crews(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews.html', context)

@login_required
@user_passes_test(is_admin)
def add_crew(request):
    if request.method == 'POST':
        form = CrewForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew added successfully.')
            return redirect('agents:manage_crews')
    else:
        initial_data = {
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        }
        logger.debug(f"Initial data for form: {initial_data}")
        form = CrewForm(initial=initial_data)
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew updated successfully.')
            return redirect('agents:manage_crews')
    else:
        form = CrewForm(instance=crew, initial={
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        })
    # Add page_title to the context
    context = {
        'form': form,
        'crew': crew,
        'page_title': 'Edit Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        crew.delete()
        messages.success(request, 'Crew deleted successfully.')
        return redirect('agents:manage_crews')
    # Add page_title to the context
    context = {
        'object': crew,
        'type': 'crew',
        'page_title': 'Delete Crew',
    }
    return render(request, 'agents/confirm_delete.html', context)

@login_required
@user_passes_test(is_admin)
def update_crew_agents(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        agent_ids = request.POST.getlist('agents')
        crew.agents.set(agent_ids)
        
        # Update manager_agent if it's in the POST data
        manager_agent_id = request.POST.get('manager_agent')
        if manager_agent_id:
            crew.manager_agent_id = manager_agent_id
        else:
            crew.manager_agent = None
        
        crew.save()
        messages.success(request, 'Crew agents updated successfully.')
    return redirect('agents:manage_crews')

@login_required
@user_passes_test(is_admin)
def manage_crews_card_view(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews_card_view.html', context)

@login_required
def crew_create_or_update(request, crew_id=None):
    if crew_id:
        crew = get_object_or_404(Crew, id=crew_id)
    else:
        crew = None

    next_url = request.GET.get('next') or request.POST.get('next')

    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            crew = form.save(commit=False)
            
            # Handle input variables
            input_variables = request.POST.getlist('input_variables[]')
            crew.input_variables = input_variables
            
            crew.save()
            form.save_m2m()  # This is important for saving many-to-many relationships
            
            # Handle task order
            task_order = request.POST.getlist('task_order[]')
            CrewTask.objects.filter(crew=crew).delete()
            for index, task_id in enumerate(task_order):
                CrewTask.objects.create(crew=crew, task_id=task_id, order=index)
            
            messages.success(request, f'Crew {"updated" if crew_id else "created"} successfully.')
            
            if next_url:
                return redirect(next_url)
            else:
                return redirect('agents:manage_crews')
        else:
            messages.error(request, f'Error {"updating" if crew_id else "creating"} crew. Please check the form.')
    else:
        form = CrewForm(instance=crew)
        input_variables = crew.input_variables if crew else []

    context = {
        'page_title': 'Create or Update Crew',
        'form': form,
        'crew': crew,
        'input_variables_json': json.dumps(input_variables),
        'next': next_url,
    }

    return render(request, 'agents/crew_form.html', context)

================
File: agents/views_kanban.py
================
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_protect
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.utils import timezone
import json

from .models import Crew, CrewExecution, ExecutionStage, Task, Agent, CrewTask
from apps.seo_manager.models import Client
from django.core.cache import cache

@login_required
def crew_kanban(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    client_id = request.GET.get('client_id')
    client = get_object_or_404(Client, id=client_id) if client_id else None
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        # Get executions that are associated with this task
        executions = CrewExecution.objects.filter(
            crew=crew,
            task=task
        ).prefetch_related('stages')
        
        execution_data = []
        for execution in executions:
            stages = execution.stages.all()
            stage_data = {}
            
            for stage in stages:
                stage_data[stage.stage_type] = {
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None
                }
                
                # Add stage-specific metadata
                if stage.metadata:
                    stage_data[stage.stage_type].update(stage.metadata)
            
            execution_data.append({
                'id': execution.id,
                'name': f'Execution #{execution.id}',
                'status': execution.status,
                'stages': stage_data
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'executions': execution_data
        })
    
    # Add page_title to the context
    context = {
        'crew': crew,
        'client': client,
        'tasks': kanban_tasks,
        'page_title': 'Crew Run',
    }
    return render(request, 'agents/crew_kanban.html', context)

@login_required
@require_http_methods(['POST'])
@csrf_protect
def start_execution(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    
    try:
        data = json.loads(request.body)
        client_id = data.get('client_id')
            
        if not client_id:
            return JsonResponse({
                'status': 'error',
                'message': 'Client ID is required'
            }, status=400)
            
        client = get_object_or_404(Client, id=client_id)
        
        # Get the first task for this crew
        crew_task = CrewTask.objects.filter(crew=crew).order_by('order').first()
        if not crew_task:
            return JsonResponse({
                'status': 'error',
                'message': 'No tasks found for this crew'
            }, status=400)
        
        # Create new execution
        execution = CrewExecution.objects.create(
            crew=crew,
            status='PENDING',
            inputs={
                'client_id': client_id
            },
            user=request.user,
            client=client
        )
        
        # Create initial stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_start',
            title='Starting New Execution',
            content='Initializing crew execution workflow',
            status='pending'
        )
        
        # Start the Celery task
        from .tasks import execute_crew
        task = execute_crew.delay(execution.id)
        
        # Update execution with task_id immediately
        execution.task_id = task.id
        execution.save()
        
        # Notify WebSocket clients
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'crew_{crew_id}_kanban',
            {
                'type': 'execution_update',
                'execution_id': execution.id,
                'task_id': crew_task.task.id,  # Send the task ID for proper board placement
                'status': 'PENDING',
                'message': 'New execution started',
                'stage': {
                    'stage_type': 'task_start',
                    'title': 'Starting New Execution',
                    'content': 'Initializing crew execution workflow',
                    'status': 'pending'
                }
            }
        )
        
        return JsonResponse({
            'status': 'success',
            'execution_id': execution.id,
            'task_id': crew_task.task.id
        })
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Error starting execution: {str(e)}', exc_info=True)
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(['GET'])
def get_active_executions(request, crew_id):
    """Get all active executions for a crew"""
    crew = get_object_or_404(Crew, id=crew_id)
    
    # Get all in-progress executions for this crew
    executions = CrewExecution.objects.filter(
        crew=crew,
        status__in=['pending', 'in_progress']
    ).prefetch_related('stages')
    
    execution_data = []
    for execution in executions:
        stages = execution.stages.all()
        stage_data = {}
        
        for stage in stages:
            stage_data[stage.stage_type] = {
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None
            }
            
            if stage.metadata:
                stage_data[stage.stage_type].update(stage.metadata)
        
        execution_data.append({
            'execution_id': execution.id,
            'task_id': execution.task_id if hasattr(execution, 'task_id') else None,
            'name': f'Execution #{execution.id}',
            'status': execution.status,
            'stages': stage_data
        })
    
    return JsonResponse({'executions': execution_data})

@login_required
@require_http_methods(['POST'])
@csrf_protect
def submit_human_input(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    try:
        data = json.loads(request.body)
        input_text = data.get('input')
        
        if not input_text:
            return JsonResponse({
                'status': 'error',
                'message': 'Input text is required'
            }, status=400)
        
        # Update execution with human input
        execution.human_input_response = {'input': input_text}
        execution.status = 'RUNNING'
        execution.save()
        
        # Create human input stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='human_input',
            title='Human Input Received',
            content=input_text,
            status='completed',
            metadata={
                'input_timestamp': timezone.now().isoformat()
            }
        )
        
        # Notify WebSocket clients
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'crew_{execution.crew.id}_kanban',
            {
                'type': 'stage_update',
                'execution_id': execution.id,
                'stage_type': 'human_input',
                'stage_data': {
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'completed': True
                }
            }
        )
        
        return JsonResponse({'status': 'success'})
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(["POST"])
def cancel_execution(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    if execution.task_id:
        # Revoke the Celery task
        from celery import current_app
        revoke = current_app.control.revoke(task_id=execution.task_id, terminate=True)
        
        # Update execution status
        execution.status = 'cancelled'
        execution.save()
        
        return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error', 'message': 'No task ID found'}, status=404)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution.objects.select_related('crew', 'crew_output'), id=execution_id)
    crew = execution.crew
    
    # Define the columns we want to show
    columns = [
        {'id': 'task_start', 'name': 'Task Start'},
        {'id': 'thinking', 'name': 'Thinking'},
        {'id': 'tool_usage', 'name': 'Tool Usage'},
        {'id': 'tool_results', 'name': 'Tool Results'},
        {'id': 'human_input', 'name': 'Human Input'},
        {'id': 'completion', 'name': 'Completion'}
    ]
    
    # Get all stages for this execution
    stages = execution.stages.all().select_related('agent').order_by('created_at')
    
    # Get all messages for this execution
    messages = execution.messages.all().order_by('timestamp')
    
    # Organize stages by stage_type
    kanban_columns = []
    for column in columns:
        column_stages = []
        
        # Add stages for this column
        for stage in stages:
            if stage.stage_type == column['id']:
                stage_data = {
                    'id': stage.id,
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None,
                    'created_at': stage.created_at,
                    'metadata': stage.metadata or {},
                    'type': 'stage'
                }
                column_stages.append(stage_data)
        
        # Add messages that might be related to this stage type
        if column['id'] == 'thinking':
            for message in messages:
                column_stages.append({
                    'id': f'msg_{message.id}',
                    'title': f'Message from {message.agent}',
                    'content': message.content,
                    'status': 'completed',
                    'agent': message.agent,
                    'created_at': message.timestamp,
                    'type': 'message'
                })
        
        # Add crew output to completion column
        if column['id'] == 'completion' and execution.crew_output:
            output_data = {
                'id': 'output',
                'title': 'Final Output',
                'content': execution.crew_output.raw,
                'status': 'completed',
                'created_at': execution.updated_at,
                'type': 'output',
                'metadata': {
                    'json_output': execution.crew_output.json_dict,
                    'token_usage': execution.crew_output.token_usage
                }
            }
            column_stages.append(output_data)
        
        kanban_columns.append({
            'id': column['id'],
            'name': column['name'],
            'stages': sorted(column_stages, key=lambda x: x['created_at'])
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': crew,
        'columns': kanban_columns
    }
    
    return render(request, 'agents/execution_detail.html', context)

================
File: agents/views_tasks.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Task
from .forms import TaskForm

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_tasks(request):
    tasks = Task.objects.all().order_by('description')
    # Add page_title to the context
    context = {
        'tasks': tasks,
        'page_title': 'Manage Tasks',
    }
    return render(request, 'agents/manage_tasks.html', context)

@login_required
@user_passes_test(is_admin)
def add_task(request):
    if request.method == 'POST':
        form = TaskForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task added successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        form = TaskForm(request.POST, instance=task)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task updated successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm(instance=task)
    # Add page_title to the context
    context = {
        'form': form,
        'task': task,
        'page_title': 'Edit Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        task.delete()
        messages.success(request, 'Task deleted successfully.')
        return redirect('agents:manage_tasks')
    # Add page_title to the context
    context = {
        'object': task,
        'type': 'task',
        'page_title': 'Delete Task',
    }
    return render(request, 'agents/confirm_delete.html', context)

================
File: agents/views_tools.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
import traceback
from .models import Tool
from .forms import ToolForm
from .utils import get_available_tools, get_tool_classes, get_tool_description, get_tool_class_obj, load_tool
from pydantic import BaseModel
import inspect
import json
import tiktoken
import csv
from io import StringIO
import asyncio
from asgiref.sync import sync_to_async

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

def count_tokens(text):
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

@login_required
@user_passes_test(is_admin)
def manage_tools(request):
    tools = Tool.objects.all().order_by('name')
    return render(request, 'agents/manage_tools.html', {'tools': tools, 'page_title': 'Manage Tools'})

@login_required
@user_passes_test(is_admin)
def add_tool(request):
    if request.method == 'POST':
        form = ToolForm(request.POST)
        logger.debug(f"POST data: {request.POST}")
        if form.is_valid():
            tool = form.save(commit=False)
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            logger.debug(f"Adding tool: class={tool_class}, subclass={tool_subclass}")
            
            # Get the tool class object and its description
            tool_classes = get_tool_classes(tool_class)
            logger.debug(f"Available tool classes: {[cls.__name__ for cls in tool_classes]}")
            if tool_classes:
                tool_class_obj = next((cls for cls in tool_classes if cls.__name__ == tool_subclass), None)
                if tool_class_obj:
                    logger.debug(f"Tool class object: {tool_class_obj}")
                    
                    tool.description = get_tool_description(tool_class_obj)
                    logger.debug(f"Tool description: {tool.description}")
                    
                    # Save the tool
                    tool.save()
                    
                    messages.success(request, 'Tool added successfully.')
                    return redirect('agents:manage_tools')
                else:
                    messages.error(request, f'Tool subclass {tool_subclass} not found.')
            else:
                messages.error(request, 'Tool class not found.')
        else:
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
            logger.error(f"Form errors: {form.errors}")
    else:
        form = ToolForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Tool',
    }
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        form = ToolForm(request.POST, instance=tool)
        if form.is_valid():
            tool = form.save(commit=False)
            tool.name = form.cleaned_data['tool_subclass']
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            tool_class_obj = get_tool_class_obj(tool_class, tool_subclass)
            tool.description = get_tool_description(tool_class_obj)
            tool.save()
            messages.success(request, 'Tool updated successfully.')
            return redirect('agents:manage_tools')
    else:
        form = ToolForm(instance=tool)
    # Add page_title to the context
    context = {
        'form': form,
        'tool': tool,
        'page_title': 'Edit Tool',
    }
    
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        tool.delete()
        messages.success(request, 'Tool deleted successfully.')
        return redirect('agents:manage_tools')
    return render(request, 'agents/confirm_delete.html', {'object': tool, 'type': 'tool', 'page_title': 'Delete Tool'})

@login_required
@user_passes_test(is_admin)
def get_tool_info(request):
    tool_class = request.GET.get('tool_class')
    logger.info(f"Received request for tool_class: {tool_class}")
    
    if tool_class:
        try:
            tool_objects = get_tool_classes(tool_class)
            logger.debug(f"Found tool objects: {[obj.__name__ for obj in tool_objects]}")
            
            class_info = []
            for obj in tool_objects:
                description = get_tool_description(obj)
                logger.debug(f"Tool: {obj.__name__}, Description: {description}")
                class_info.append({
                    'name': obj.__name__,
                    'description': description
                })
            
            logger.debug(f"Returning class_info: {class_info}")
            return JsonResponse({
                'classes': class_info
            })
        except ImportError as e:
            logger.error(f"ImportError: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"Failed to import tool module: {str(e)}"}, status=500)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"An unexpected error occurred: {str(e)}"}, status=500)
    
    logger.warning("Invalid request: tool_class parameter is missing")
    return JsonResponse({'error': 'Invalid request: tool_class parameter is missing'}, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_schema(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    try:
        tool_class = get_tool_class_obj(tool.tool_class, tool.tool_subclass)

        if tool_class is None:
            return JsonResponse({'error': 'Failed to load tool class'}, status=400)

        manual_schema = {
            "type": "object",
            "properties": {}
        }

        if hasattr(tool_class, 'args_schema') and issubclass(tool_class.args_schema, BaseModel):
            # Use Pydantic v2 method if available
            if hasattr(tool_class.args_schema, 'model_json_schema'):
                schema = tool_class.args_schema.model_json_schema()
            else:
                # Fallback for Pydantic v1
                schema = tool_class.args_schema.schema()

            for field_name, field_schema in schema.get('properties', {}).items():
                manual_schema['properties'][field_name] = {
                    "type": field_schema.get('type', 'string'),
                    "title": field_schema.get('title', field_name.capitalize()),
                    "description": field_schema.get('description', '')
                }
        else:
            # Fallback for tools without args_schema
            for param_name, param in inspect.signature(tool_class._run).parameters.items():
                if param_name not in ['self', 'kwargs']:
                    manual_schema['properties'][param_name] = {
                        "type": "string",
                        "title": param_name.capitalize(),
                        "description": ""
                    }

        if not manual_schema["properties"]:
            logger.error(f"No input fields found for tool: {tool_class}")
            return JsonResponse({'error': 'No input fields found for this tool'}, status=400)

        logger.debug(f"Generated schema for tool {tool_id}: {manual_schema}")
        return JsonResponse(manual_schema)
    except Exception as e:
        logger.error(f"Error getting tool schema: {str(e)}")
        return JsonResponse({'error': f'Error getting tool schema: {str(e)}'}, status=500)

@login_required
@user_passes_test(is_admin)
@require_http_methods(["POST"])
def test_tool(request, tool_id):
    """Run a tool test using Celery for both sync and async tools"""
    tool = get_object_or_404(Tool, id=tool_id)
    
    # Get inputs from request
    inputs = {key: value for key, value in request.POST.items() if key != 'csrfmiddlewaretoken'}
    
    try:
        # Start Celery task
        from .tasks.tools import run_tool
        task = run_tool.delay(tool_id, inputs)
        
        return JsonResponse({
            'status': 'started',
            'task_id': task.id,
            'message': f'Tool execution started. Task ID: {task.id}'
        })
        
    except Exception as e:
        logger.error(f"Error starting tool execution: {str(e)}\n{traceback.format_exc()}")
        return JsonResponse({
            'error': str(e)
        }, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_status(request, task_id):
    """Get the status of a tool execution"""
    from celery.result import AsyncResult
    
    task = AsyncResult(task_id)
    
    response = {
        'status': task.status,  # This will be one of: PENDING, STARTED, SUCCESS, FAILURE
    }
    
    if task.ready():
        if task.successful():
            try:
                result = task.get()
                if isinstance(result, dict):
                    response.update({
                        'result': result.get('result', ''),
                        'error': result.get('error')
                    })
                else:
                    response['result'] = str(result)
            except Exception as e:
                response.update({
                    'status': 'FAILURE',
                    'error': str(e)
                })
        else:
            response.update({
                'error': str(task.result)
            })
    
    return JsonResponse(response)

================
File: agents/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.paginator import Paginator
from django.http import JsonResponse
from django.views.decorators.http import require_POST, require_http_methods
from django.views.decorators.csrf import csrf_exempt, csrf_protect
from .models import Crew, CrewExecution, CrewMessage, Pipeline, Agent, CrewTask, Task
from .forms import CrewExecutionForm, HumanInputForm, AgentForm
from .tasks import execute_crew
from django.core.exceptions import ValidationError
import logging
import json
from django.urls import reverse
from django.core.cache import cache
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from django.conf import settings
import os
from apps.seo_manager.models import Client  # Import the Client model
from markdown_it import MarkdownIt  # Import markdown-it
from apps.common.utils import get_models

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

# Initialize the MarkdownIt instance
md = MarkdownIt()

@login_required
@csrf_exempt
def connection_test(request):
    return render(request, 'agents/connection_test.html')

@login_required
def crewai_home(request):
    crews = Crew.objects.all()  # Get the first 3 crews for the summary
    recent_executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')[:10]
    clients = Client.objects.all()  # Get all clients
    
    # Get the selected client_id from the request, fallback to session
    selected_client_id = request.GET.get('client_id') or request.session.get('selected_client_id')
    
    if selected_client_id:
        request.session['selected_client_id'] = selected_client_id
    else:
        # If no client is selected, remove it from the session
        request.session.pop('selected_client_id', None)
    
    context = {
        'page_title': 'Crews Home',
        'crews': crews,
        'recent_executions': recent_executions,
        'clients': clients,
        'selected_client_id': selected_client_id,
    }
    return render(request, 'agents/crewai_home.html', context)

@login_required
def crew_list(request):
    logger.debug("Entering crew_list view")
    crews = Crew.objects.all()
    # Add page_title to the context
    context = {
        'crews': crews,
        'page_title': 'Crew List',
    }
    return render(request, 'agents/crew_list.html', context)

@login_required
def crew_detail(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    recent_executions = CrewExecution.objects.filter(crew=crew).order_by('-created_at')[:5]
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
    
    if request.method == 'POST':
        form = CrewExecutionForm(request.POST)
        if form.is_valid():
            execution = form.save(commit=False)
            execution.crew = crew
            execution.user = request.user
            execution.client = selected_client  # Associate the selected client with the execution
            
            # Handle input variables
            input_variables = json.loads(request.POST.get('input_variables', '{}'))
            execution.inputs = input_variables
            
            execution.save()
            
            # Start the execution
            execute_crew.delay(execution.id)
            
            messages.success(request, 'Crew execution started.')
            return JsonResponse({'status': 'success', 'execution_id': execution.id})
    else:
        form = CrewExecutionForm()
    
    context = {
        'page_title': 'Crew Detail',
        'crew': crew,
        'form': form,
        'recent_executions': recent_executions,
        'selected_client': selected_client,
    }
    return render(request, 'agents/crew_detail.html', context)

@login_required
def execution_list(request):
    logger.debug("Entering execution_list view")
    executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')
    crews = Crew.objects.all()

    # Apply filters
    crew_id = request.GET.get('crew')
    status = request.GET.get('status')

    if crew_id:
        executions = executions.filter(crew_id=crew_id)
    if status:
        executions = executions.filter(status=status)

    # Pagination
    paginator = Paginator(executions, 10)  # Show 10 executions per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_title': 'Execution List',
        'executions': page_obj,
        'crews': crews,
    }
    return render(request, 'agents/execution_list.html', context)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=execution.crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        stages = execution.stages.filter(task=task).order_by('created_at')
        
        stage_data = []
        for stage in stages:
            stage_data.append({
                'id': stage.id,
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None,
                'created_at': stage.created_at,
                'metadata': stage.metadata or {}
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'stages': stage_data
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': execution.crew,
        'tasks': kanban_tasks
    }
    
    return render(request, 'agents/execution_detail.html', context)

@login_required
def execution_status(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        
        # Get the last message ID from the request
        last_message_id = request.GET.get('last_message_id')
        
        # Only fetch new messages if there are any
        if last_message_id:
            messages = CrewMessage.objects.filter(
                execution=execution,
                id__gt=last_message_id
            ).order_by('timestamp')
        else:
            messages = CrewMessage.objects.filter(
                execution=execution
            ).order_by('timestamp')
        
        # Get status badge class
        status_classes = {
            'PENDING': 'info',
            'RUNNING': 'primary',
            'WAITING_FOR_HUMAN_INPUT': 'warning',
            'COMPLETED': 'success',
            'FAILED': 'danger'
        }
        status_class = status_classes.get(execution.status, 'secondary')
        
        response_data = {
            'status': execution.get_status_display(),
            'status_class': status_class,
            'updated_at': execution.updated_at.isoformat(),
            'outputs': execution.outputs,
            'human_input_request': execution.human_input_request,
            'messages': [{
                'id': msg.id,
                'agent': msg.agent,
                'content': msg.content,
                'timestamp': msg.timestamp.strftime("%d %b %H:%M")
            } for msg in messages],
        }
        return JsonResponse(response_data)
    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)

@login_required
@csrf_protect
@require_POST
def provide_human_input(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        if execution.status != 'WAITING_FOR_HUMAN_INPUT':
            return JsonResponse({'error': 'Execution is not waiting for human input'}, status=400)

        data = json.loads(request.body)
        user_input = data.get('input')

        if user_input is None:
            return JsonResponse({'error': 'No input provided'}, status=400)

        # Store the user input in the cache
        cache.set(f'human_input_response_{execution_id}', user_input, timeout=3600)

        logger.info(f"Stored user input for execution {execution_id}: {user_input}")

        # Update execution status
        execution.status = 'RUNNING'
        execution.save()

        # Send a WebSocket message to update the frontend
        async_to_sync(channel_layer.group_send)(
            f'crew_execution_{execution_id}',
            {
                'type': 'crew_execution_update',
                'status': 'RUNNING',
                'messages': [{'agent': 'Human', 'content': f'Input provided: {user_input}'}],
            }
        )

        # Return the actual user input
        return JsonResponse({'message': 'Human input received and processing resumed', 'input': user_input})
    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f"Error in provide_human_input: {str(e)}")
        return JsonResponse({'error': 'An unexpected error occurred'}, status=500)

@login_required
def manage_pipelines(request):
    pipelines = Pipeline.objects.all()
    context = {
        'page_title': 'Manage Pipelines',
        'pipelines': pipelines,
    }
    return render(request, 'agents/manage_pipelines.html', context)

@login_required
@require_POST
def submit_human_input(request, execution_id):
    input_key = request.POST.get('input_key')
    response = request.POST.get('response')
    
    if not input_key or not response:
        return JsonResponse({'error': 'Missing input_key or response'}, status=400)
    
    execution = get_object_or_404(CrewExecution, id=execution_id, user=request.user)
    
    # Store the response in the cache
    cache_key = f"{input_key}_response"
    cache.set(cache_key, response, timeout=3600)
    
    # Verify that the input was stored correctly
    stored_value = cache.get(cache_key)
    logger.info(f"Stored human input in cache for execution {execution_id}: key={cache_key}, value={response}")
    
    # Update execution status
    execution.status = 'RUNNING'
    execution.save()
    
    return JsonResponse({'message': 'Human input received and processed'})

@login_required
def chat_view(request):
    clients = Client.objects.all().order_by('name')
    print(f"Found {clients.count()} clients")  # Debug print
    
    context = {
        'agents': Agent.objects.all(),
        'models': get_models(),
        'default_model': settings.GENERAL_MODEL,
        'clients': clients,
    }
    return render(request, 'agents/chat.html', context)
