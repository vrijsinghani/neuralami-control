This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-24T22:53:44.663Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
agents/
  chat/
    formatters/
      __init__.py
      output_formatter.py
      table_formatter.py
      tool_formatter.py
    managers/
      message_manager.py
      prompt_manager.py
      token_manager.py
      tool_manager.py
    history.py
  clients/
    manager.py
  utils/
    error_handling.py
    formatters.py
  websockets/
    handlers/
      agent_handler.py
      callback_handler.py
    services/
      chat_service.py
    __init__.py
    base.py
    chat_consumer.py
    consumers.py
    crew_consumer.py
  admin.py
  apps.py
  celery.py
  consumers.py
  forms.py
  kanban_consumers.py
  models.py
  routing.py
  tasks.py
  tests.py
  tools.py
  urls.py
  utils.py
  views_agents.py
  views_chat.py
  views_crews.py
  views_kanban.py
  views_tasks.py
  views_tools.py
  views.py

================================================================
Repository Files
================================================================

================
File: agents/chat/formatters/__init__.py
================
from .table_formatter import TableFormatter
from .tool_formatter import ToolFormatter
from .output_formatter import OutputFormatter

__all__ = ['TableFormatter', 'ToolFormatter', 'OutputFormatter']

================
File: agents/chat/formatters/output_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class OutputFormatter:
    """Handles general output formatting"""
    
    @staticmethod
    def format_response(response: Dict) -> str:
        """Format agent response"""
        try:
            output = response.get("output")
            if not output:
                return "No response generated"
                
            # If output is a dict, check for tabular data
            if isinstance(output, dict):
                if "formatted_table" in output:
                    return output["formatted_table"]
                if TableFormatter.detect_tabular_data(output):
                    return TableFormatter.format_table(output)
                return json.dumps(output, indent=2)
                
            # If output is a string but contains JSON, try to parse and format
            if isinstance(output, str) and (output.startswith('{') or output.startswith('[')):
                try:
                    json_data = json.loads(output)
                    if "formatted_table" in json_data:
                        return json_data["formatted_table"]
                    if TableFormatter.detect_tabular_data(json_data):
                        return TableFormatter.format_table(json_data)
                    return json.dumps(json_data, indent=2)
                except json.JSONDecodeError:
                    pass
                    
            return output

        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}", exc_info=True)
            return "Error formatting response"

    @staticmethod
    def format_final_answer(content: Any) -> str:
        """Format the final agent response"""
        try:
            # Format as table if possible
            if TableFormatter.detect_tabular_data(content):
                content = TableFormatter.format_table(content)
            return f'<div class="agent-response">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting final answer: {str(e)}")
            return str(content)

================
File: agents/chat/formatters/table_formatter.py
================
from typing import Any, Dict, List, Union
import json
import logging

logger = logging.getLogger(__name__)

class TableFormatter:
    """Generic table formatter for structured data"""
    
    @staticmethod
    def _is_json(data: str) -> bool:
        """Check if string is valid JSON"""
        try:
            json.loads(data)
            return True
        except (json.JSONDecodeError, TypeError):
            return False

    @staticmethod
    def _is_csv(data: str) -> bool:
        """Check if string appears to be CSV data"""
        if not isinstance(data, str):
            return False
        return (',' in data and 
                '\n' in data and 
                '{' not in data and 
                '[' not in data)

    @staticmethod
    def _parse_csv(csv_data: str) -> List[Dict]:
        """Convert CSV string to list of dictionaries"""
        try:
            lines = csv_data.strip().split('\n')
            headers = [h.strip() for h in lines[0].split(',')]
            
            return [
                {
                    headers[i]: value.strip() 
                    for i, value in enumerate(line.split(','))
                    if i < len(headers)
                }
                for line in lines[1:]
            ]
        except Exception as e:
            logger.error(f"Error parsing CSV: {str(e)}", exc_info=True)
            return []

    @staticmethod
    def _find_tabular_data(data: Any) -> Union[List[Dict], None]:
        """
        Recursively search for tabular data in the structure.
        Returns the first found list of dictionaries with consistent keys.
        """
        # Handle string input
        if isinstance(data, str):
            if TableFormatter._is_json(data):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return None
            elif TableFormatter._is_csv(data):
                return TableFormatter._parse_csv(data)
            else:
                return None

        # Handle list of dictionaries
        if isinstance(data, list) and data:
            if all(isinstance(item, dict) for item in data):
                # Get all unique keys from all objects
                keys = set().union(*(item.keys() for item in data))
                if keys:  # If we have keys, it's tabular
                    return data
            
            # Check each list item for nested tabular data
            for item in data:
                result = TableFormatter._find_tabular_data(item)
                if result:
                    return result

        # Handle dictionary
        if isinstance(data, dict):
            # First check direct values
            for value in data.values():
                if isinstance(value, list) and value:
                    if all(isinstance(item, dict) for item in value):
                        return value
            
            # Then check nested structures
            for value in data.values():
                result = TableFormatter._find_tabular_data(value)
                if result:
                    return result

        return None

    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data contains tabular structure anywhere in the hierarchy"""
        try:
            return TableFormatter._find_tabular_data(data) is not None
        except Exception:
            logger.error("Error detecting tabular data", exc_info=True)
            return False

    @staticmethod
    def format_table(data: Any) -> str:
        """Format tabular data into a markdown table"""
        try:
            tabular_data = TableFormatter._find_tabular_data(data)
            if not tabular_data:
                return str(data)

            # Get all unique keys from all objects
            keys = list(set().union(*(item.keys() for item in tabular_data)))
            
            # Calculate column widths
            col_widths = {key: len(str(key)) for key in keys}
            for row in tabular_data:
                for key in keys:
                    value = row.get(key)
                    if value is None:
                        continue
                    elif isinstance(value, (dict, list)):
                        str_value = json.dumps(value)
                    else:
                        str_value = str(value)
                    col_widths[key] = max(col_widths[key], len(str_value))

            # Build table
            # Header row
            table = "| " + " | ".join(
                str(key).ljust(col_widths[key]) 
                for key in keys
            ) + " |\n"
            
            # Separator row
            table += "|" + "|".join(
                "-" * (col_widths[key] + 2) 
                for key in keys
            ) + "|\n"
            
            # Data rows
            for row in tabular_data:
                table += "| " + " | ".join(
                    str(row.get(key, '')).ljust(col_widths[key]) 
                    for key in keys
                ) + " |\n"

            return table

        except Exception as e:
            logger.error(f"Error formatting table: {str(e)}", exc_info=True)
            return str(data)  # Return original data if formatting fails

================
File: agents/chat/formatters/tool_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class ToolFormatter:
    """Handles formatting of tool outputs and usage messages"""
    
    @staticmethod
    def format_tool_output(content: Any) -> str:
        """Format tool output with proper styling"""
        try:
            if isinstance(content, dict):
                return f'<div class="json-output">{json.dumps(content, indent=2)}</div>'
            elif isinstance(content, str):
                # Try to parse as JSON first
                try:
                    json_content = json.loads(content)
                    return f'<div class="json-output">{json.dumps(json_content, indent=2)}</div>'
                except json.JSONDecodeError:
                    pass
                
                # Format as table if possible
                if TableFormatter.detect_tabular_data(content):
                    content = TableFormatter.format_table(content)
            
            return f'<div class="tool-output">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting tool output: {str(e)}")
            return str(content)

    @staticmethod
    def format_tool_usage(content: str, message_type: str = None) -> str:
        """Format tool usage messages"""
        if message_type == "tool_start" and content.startswith('Using tool:'):
            tool_info = content.split('\n')
            formatted = f'''
            <div class="tool-usage">
                <i class="fas fa-tools"></i>
                <div>
                    <strong>{tool_info[0]}</strong>
                    <div class="tool-input">{tool_info[1] if len(tool_info) > 1 else ''}</div>
                </div>
            </div>
            '''
            return formatted
        elif message_type == "tool_error":
            return f'''
            <div class="tool-error">
                <i class="fas fa-exclamation-triangle"></i>
                <div>{content}</div>
            </div>
            '''
        return content

    @staticmethod
    def format_tool_result(observation: Any) -> Dict:
        """Format tool output into a standardized structure"""
        try:
            result_data = {
                'tool_type': None,
                'format': None,
                'data': None,
                'metadata': {}
            }

            if isinstance(observation, dict):
                # Handle tabular data
                if TableFormatter.detect_tabular_data(observation):
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'table',
                        'data': TableFormatter.format_table(observation),
                        'metadata': {
                            'raw_data': observation.get('raw_data', {}),
                            'tool': observation.get('tool')
                        }
                    })
                
                # Handle validation errors
                elif observation.get('type') == 'error':
                    result_data.update({
                        'tool_type': 'error',
                        'format': 'error',
                        'data': {
                            'message': observation.get('message'),
                            'error_type': observation.get('error'),
                            'suggestion': observation.get('suggestion')
                        }
                    })
                
                # Handle other structured data
                else:
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'json',
                        'data': json.dumps(observation, indent=2),
                        'metadata': {
                            'tool': observation.get('tool')
                        }
                    })

            return result_data

        except Exception as e:
            logger.error(f"Error formatting tool result: {str(e)}", exc_info=True)
            return {
                'tool_type': 'error',
                'format': 'error',
                'data': {
                    'message': str(e),
                    'error_type': 'formatting_error'
                }
            }

================
File: agents/chat/managers/message_manager.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage, SystemMessage
from django.core.cache import cache
from typing import List, Optional, Dict, Any
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter
from apps.agents.chat.formatters.table_formatter import TableFormatter
from apps.agents.models import ChatMessage
import logging
import json

logger = logging.getLogger(__name__)

def messages_to_dict(messages: List[BaseMessage]) -> List[Dict]:
    """Convert message objects to dictionary format for storage."""
    return [{
        'type': message.__class__.__name__,
        'content': message.content,
        'additional_kwargs': message.additional_kwargs
    } for message in messages]

def dict_to_messages(messages_dict: List[Dict]) -> List[BaseMessage]:
    """Convert dictionary format back to message objects."""
    message_types = {
        'HumanMessage': HumanMessage,
        'AIMessage': AIMessage,
        'SystemMessage': SystemMessage
    }
    
    return [
        message_types[msg['type']](
            content=msg['content'],
            additional_kwargs=msg.get('additional_kwargs', {})
        ) for msg in messages_dict
    ]

class MessageManager(BaseChatMessageHistory):
    """
    Manages chat message history, storage, and formatting.
    Consolidates message-related functionality from across the codebase.
    """
    
    def __init__(self, 
                 conversation_id: Optional[str] = None,
                 session_id: Optional[str] = None,
                 agent_id: Optional[int] = None,
                 ttl: int = 3600):
        """
        Initialize the MessageManager.
        
        Args:
            conversation_id: Unique identifier for the conversation
            session_id: Unique identifier for the current session
            agent_id: ID of the agent associated with this conversation
            ttl: Time-to-live for cached messages in seconds
        """
        super().__init__()
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.agent_id = agent_id
        self.ttl = ttl
        self.tool_formatter = ToolFormatter()
        self.messages_cache_key = f"messages_{self.session_id}"
        self._messages = []

    @property
    def messages(self) -> List[BaseMessage]:
        """Get all messages in the history. Required by BaseChatMessageHistory."""
        if self.messages_cache_key:
            messages_dict = cache.get(self.messages_cache_key, [])
            return dict_to_messages(messages_dict)
        return self._messages.copy()

    @messages.setter
    def messages(self, messages: List[BaseMessage]) -> None:
        """Set messages in the history. Required by BaseChatMessageHistory."""
        self._messages = messages.copy()
        if self.messages_cache_key:
            messages_dict = messages_to_dict(messages)
            cache.set(self.messages_cache_key, messages_dict, self.ttl)

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Add a message to the history and persist it.
        This is the central function for all message persistence.
        
        Args:
            message: The message to add
            token_usage: Optional token usage stats
            
        Returns:
            ChatMessage: The created message object, or None if creation failed
        """
        try:
            # For agent finish messages, extract JSON data if present
            if isinstance(message, AIMessage) and message.content:
                # Look for JSON code blocks
                if '```json' in message.content:
                    parts = message.content.split('```json')
                    if len(parts) > 1:
                        text_content = parts[0].strip()
                        json_str = parts[1].split('```')[0].strip()
                        try:
                            # Validate JSON
                            json_data = json.loads(json_str)
                            # Store as separate messages
                            if text_content:
                                await self._store_message_in_db(AIMessage(content=text_content), token_usage)
                            message.content = json.dumps(json_data)
                        except json.JSONDecodeError:
                            # If JSON is invalid, keep original message
                            pass

            # Store in database only if we have a conversation ID
            if self.conversation_id:
                return await self._store_message_in_db(message, token_usage)
            return None
                
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    async def get_messages(self) -> List[BaseMessage]:
        """Get all non-deleted messages in the history."""
        try:
            if self.conversation_id:
                from apps.agents.models import ChatMessage, ToolRun
                query = {
                    'conversation_id': self.conversation_id,
                    'is_deleted': False  # Only get non-deleted messages
                }
                    
                messages = await database_sync_to_async(
                    lambda: list(
                        ChatMessage.objects.filter(**query)
                        .prefetch_related('tool_runs')
                        .order_by('timestamp')
                    )
                )()

                result = []
                for msg in messages:
                    if not msg.is_agent:
                        # Human messages
                        result.append(HumanMessage(
                            content=msg.content,
                            additional_kwargs={'id': str(msg.id)}
                        ))
                    else:
                        # AI messages - check for tool runs
                        tool_runs = list(msg.tool_runs.all())
                        if tool_runs and len(tool_runs) > 0:
                            # Get the first tool run (original format had one per message)
                            run = tool_runs[0]
                            
                            # Format tool start message
                            result.append(AIMessage(
                                content=f"Tool Start: {run.tool.name if run.tool else 'unknown'} - {run.inputs}",
                                additional_kwargs={'id': f"{msg.id}_start"}
                            ))
                            
                            # Format tool result message
                            if run.result:
                                try:
                                    # Check if the message content is a JSON-formatted tool result
                                    try:
                                        content = json.loads(msg.content)
                                        if isinstance(content, dict) and content.get('type') == 'tool_result':
                                            result.append(AIMessage(
                                                content=json.dumps(content['content']),
                                                additional_kwargs={'id': f"{msg.id}_result"}
                                            ))
                                        else:
                                            result.append(AIMessage(
                                                content=msg.content,
                                                additional_kwargs={'id': str(msg.id)}
                                            ))
                                    except json.JSONDecodeError:
                                        # If not JSON, use the original format
                                        result.append(AIMessage(
                                            content=f"Tool Result: {run.result}",
                                            additional_kwargs={'id': f"{msg.id}_result"}
                                        ))
                                except Exception as e:
                                    logger.error(f"Error formatting tool result: {str(e)}")
                                    result.append(AIMessage(
                                        content=f"Tool Error: {str(e)}",
                                        additional_kwargs={'id': f"{msg.id}_result"}
                                    ))
                        else:
                            # Regular AI message
                            result.append(AIMessage(
                                content=msg.content,
                                additional_kwargs={'id': str(msg.id)}
                            ))
                
                return result
            return []
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}")
            return []

    def add_messages(self, messages: List[BaseMessage]) -> None:
        """Add multiple messages to the history."""
        for message in messages:
            self.add_message(message)

    def clear(self) -> None:
        """Required abstract method: Clear all messages."""
        pass  # No cache to clear anymore

    async def clear_messages(self) -> None:
        """Clear all messages from the history."""
        try:
            if self.conversation_id:
                await database_sync_to_async(ChatMessage.objects.filter(
                    conversation_id=self.conversation_id
                ).delete)()
                
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    @database_sync_to_async
    def _store_message_in_db(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Store a message in the database.
        Centralized database persistence function.
        
        Returns:
            ChatMessage: The created message object, or None if creation failed
        """
        try:
            from apps.agents.models import ChatMessage, Conversation, TokenUsage, ToolRun, Tool
            
            # Get the conversation by session_id
            conversation = Conversation.objects.filter(
                session_id=self.session_id
            ).select_related('user', 'agent').first()
            
            if not conversation:
                logger.error(f"No conversation found with session ID: {self.session_id}")
                return None
                
            # Determine if message is from agent or user
            is_agent = not isinstance(message, HumanMessage)
            
            # Create the message
            chat_message = ChatMessage.objects.create(
                session_id=self.session_id,
                conversation=conversation,
                agent=conversation.agent,
                user=conversation.user,
                content=message.content,
                is_agent=is_agent,
                model=token_usage.get('model', 'unknown') if token_usage else 'unknown'
            )
            
            # Store token usage if provided
            if token_usage:
                TokenUsage.objects.create(
                    conversation=conversation,
                    message=chat_message,
                    prompt_tokens=token_usage.get('prompt_tokens', 0),
                    completion_tokens=token_usage.get('completion_tokens', 0),
                    total_tokens=token_usage.get('total_tokens', 0),
                    model=token_usage.get('model', 'unknown'),
                    metadata={'message_type': message.__class__.__name__}
                )
            
            # Store tool runs if this is a tool-related message
            if message.additional_kwargs.get('tool_call'):
                tool_call = message.additional_kwargs['tool_call']
                tool_name = tool_call.get('name')
                tool_input = tool_call.get('input', {})
                tool_output = tool_call.get('output')
                
                if tool_name:
                    tool = Tool.objects.filter(name=tool_name).first()
                    if tool:
                        # Ensure tool_output is proper JSON
                        try:
                            if isinstance(tool_output, str):
                                # If it's a string, try to parse it to ensure valid JSON
                                output_json = json.loads(tool_output)
                            else:
                                output_json = tool_output
                            # Store as JSON string
                            tool_output = json.dumps(output_json)
                        except:
                            # If not valid JSON, store as string
                            tool_output = str(tool_output)
                            
                        ToolRun.objects.create(
                            tool=tool,
                            conversation=conversation,
                            message=chat_message,
                            status='completed',
                            inputs=tool_input,
                            result=tool_output
                        )
            
            return chat_message
                
        except Exception as e:
            logger.error(f"Error storing message in database: {str(e)}", exc_info=True)
            raise


    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing by marking the message and subsequent messages as deleted."""
        try:
            # Get the message's timestamp
            message = await database_sync_to_async(
                ChatMessage.objects.get
            )(id=message_id)
            
            # Mark this message and all subsequent messages as deleted
            deleted_count = await database_sync_to_async(
                ChatMessage.objects.filter(
                    conversation_id=self.conversation_id,
                    timestamp__gte=message.timestamp
                ).update
            )(is_deleted=True)
            
            logger.debug(f"Message timestamp: {message.timestamp}. {deleted_count} messages marked as deleted.")
                    
        except Exception as e:
            logger.error(f"Error handling message edit: {str(e)}")
            raise

    def format_message(self, content: Any, message_type: Optional[str] = None) -> str:
        """Format a message for display."""
        try:
            # If content is a dict, convert to string representation
            if isinstance(content, dict):
                return json.dumps(content, indent=2)
                
            # Handle tool messages
            if message_type and message_type.startswith('tool_'):
                return self.tool_formatter.format_tool_usage(str(content), message_type)
                
            return str(content)
        except Exception as e:
            logger.error(f"Error formatting message: {str(e)}")
            return str(content)

    async def get_conversation_summary(self) -> str:
        """Get a summary of the conversation."""
        messages = await self.get_messages()
        if not messages:
            return "No messages in conversation"
        
        summary_parts = []
        for msg in messages:
            msg_type = msg.__class__.__name__.replace('Message', '')
            summary_parts.append(f"{msg_type}: {msg.content[:100]}...")
        
        return "\n".join(summary_parts) 

    async def get_message_ids(self) -> Dict[str, str]:
        """Get a mapping of message content to message IDs."""
        messages = await ChatMessage.objects.filter(
            conversation_id=self.conversation_id
        ).values('id', 'content')
        return {msg['content']: str(msg['id']) for msg in messages}

================
File: agents/chat/managers/prompt_manager.py
================
import logging
from typing import Dict, List, Optional, Any, Union
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import SystemMessage, HumanMessage, AIMessage
from langchain_core.messages import BaseMessage
from django.utils import timezone
import json
from apps.common.utils import create_box

logger = logging.getLogger(__name__)

class PromptManager:
    """
    Manages prompt generation, formatting, and template management for chat agents.
    Consolidates prompt-related functionality from across the codebase.
    """
    
    def __init__(self, system_prompt: Optional[str] = None):
        """
        Initialize the PromptManager.
        
        Args:
            system_prompt: Optional system prompt to use as default
        """
        self.system_prompt = system_prompt or self._get_default_system_prompt()
        self.prompt_templates = {}
        self._box_width = 80

    def _get_default_system_prompt(self) -> str:
        """Get the default system prompt."""
        return """You are a helpful AI assistant. You aim to provide accurate, helpful responses
        while maintaining a professional and friendly tone. You will:
        1. Answer questions clearly and concisely
        2. Use appropriate tools when needed
        3. Admit when you don't know something
        4. Ask for clarification when needed"""

    def create_chat_prompt(self, 
                        system_prompt: Optional[str] = None,
                        tools: Optional[List] = None,
                        chat_history: Optional[List] = None,
                        client_data: Optional[Dict] = None) -> ChatPromptTemplate:
        """
        Create a chat prompt template with system message and message history.
        """
        # Debug logging for message template creation
        logger.debug("Creating chat prompt template")
        logger.debug(f"Chat history type: {type(chat_history)}")

        # Create the system prompt with explicit JSON format instructions
        system_template = '''{system_prompt}

    You have access to the following tools:

    {tools}

    Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

    Valid "action" values: "Final Answer" or {tool_names}

    Provide only ONE action per $JSON_BLOB, as shown:

    ```
{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}
```


    Follow this format:

    Question: input question to answer
    Thought: consider previous and subsequent steps
    Action:
    $JSON_BLOB

    Observation: action result
    ... (repeat Thought/Action/Observation N times)
    Thought: I know what to respond
    Action:
    {{
    "action": "Final Answer",
    "action_input": "Final response to human"
    }}


    Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate.'''

        # Format tools and descriptions
        tool_descriptions = [f"{tool.name}: {tool.description}" for tool in (tools or [])]
        tool_names = [tool.name for tool in (tools or [])]

        # Create the prompt template with proper message structure
        messages = [
            ("system", system_template),
            MessagesPlaceholder(variable_name="chat_history", optional=True),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad")
        ]

        logger.debug(f"Message template structure: {[m[0] if isinstance(m, tuple) else m.variable_name for m in messages]}")
        
        prompt = ChatPromptTemplate.from_messages(messages)

        # Create the partial with the provided values
        partial = prompt.partial(
            system_prompt=system_prompt or self.system_prompt,
            tools="\n".join(tool_descriptions),
            tool_names=", ".join(tool_names)
        )

        # Debug logging for partial variables
        logger.debug(f"Partial input variables: {partial.input_variables}")
        logger.debug(f"Input variables before modification: {prompt.input_variables}")

        # Ensure agent_scratchpad remains as input variable but don't try to set it
        if 'agent_scratchpad' not in partial.input_variables:
            logger.debug("Recreating prompt template to preserve agent_scratchpad")
            # Create a new prompt with agent_scratchpad as a required input
            messages = [
                ("system", system_template),
                MessagesPlaceholder(variable_name="chat_history", optional=True),
                ("human", "{input}"),
                MessagesPlaceholder(variable_name="agent_scratchpad")
            ]
            partial = ChatPromptTemplate.from_messages(messages)
            # Only partially fill the system-level variables
            partial = partial.partial(
                system_prompt=system_prompt or self.system_prompt,
                tools="\n".join(tool_descriptions),
                tool_names=", ".join(tool_names)
            )
            logger.debug(f"Modified partial input variables: {partial.input_variables}")

        return partial

    def format_chat_history(self, messages: Union[str, List[BaseMessage], List[Dict]]) -> List[BaseMessage]:
        """
        Format chat history for prompt inclusion.
        Handles string, dict, and BaseMessage formats.
        Escapes any template variables in message content.
        """
        if isinstance(messages, str):
            # Try to parse string as JSON list of messages
            try:
                messages = json.loads(messages)
            except:
                return []
        
        formatted_messages = []
        for msg in messages:
            if isinstance(msg, BaseMessage):
                # Escape any template variables in content
                content = msg.content.replace("{", "{{").replace("}", "}}")
                if isinstance(msg, HumanMessage):
                    formatted_messages.append(HumanMessage(content=content))
                elif isinstance(msg, AIMessage):
                    formatted_messages.append(AIMessage(content=content))
                else:
                    formatted_messages.append(msg.__class__(content=content))
            elif isinstance(msg, dict):
                # Convert dict to appropriate message type and escape content
                content = msg.get('content', '').replace("{", "{{").replace("}", "}}")
                if msg.get('type') == 'human' or msg.get('is_user', False):
                    formatted_messages.append(HumanMessage(content=content))
                else:
                    formatted_messages.append(AIMessage(content=content))
            else:
                logger.warning(f"Unhandled message format: {type(msg)}")
                
        return formatted_messages

    def _format_context(self, context: Dict) -> str:
        """Format additional context into a string."""
        context_parts = []
        for key, value in context.items():
            if isinstance(value, (list, dict)):
                context_parts.append(f"{key}:\n{self._format_structured_value(value)}")
            else:
                context_parts.append(f"{key}: {value}")
        return "\n".join(context_parts)

    def _format_structured_value(self, value: Any, indent: int = 2) -> str:
        """Format structured values (lists/dicts) with proper indentation."""
        if isinstance(value, list):
            return "\n".join(" " * indent + f"- {item}" for item in value)
        elif isinstance(value, dict):
            return "\n".join(" " * indent + f"{k}: {v}" for k, v in value.items())
        return str(value)

    def create_tool_prompt(self, tool_name: str, tool_args: Dict) -> str:
        """Create a prompt for tool execution."""
        return f"Using tool: {tool_name}\nInput: {tool_args}"

    def create_error_prompt(self, error: str) -> str:
        """Create a prompt for error messages."""
        return f"Error occurred: {error}\nPlease try again or use a different approach."

    def register_prompt_template(self, name: str, template: str) -> None:
        """Register a new prompt template."""
        self.prompt_templates[name] = template

    def get_prompt_template(self, name: str) -> Optional[str]:
        """Get a registered prompt template."""
        return self.prompt_templates.get(name)

    def format_prompt(self, template_name: str, **kwargs) -> Optional[str]:
        """Format a registered prompt template with provided arguments."""
        template = self.get_prompt_template(template_name)
        if template:
            try:
                return template.format(**kwargs)
            except KeyError as e:
                logger.error(f"Missing required argument in prompt template: {str(e)}")
            except Exception as e:
                logger.error(f"Error formatting prompt template: {str(e)}")
        return None 

    def create_agent_prompt(self, agent, client_data: Optional[Dict] = None) -> str:
        """
        Create the system prompt for the agent with client context.
        
        Args:
            agent: The agent instance
            client_data: Optional dictionary containing client information
        """
        try:
            # Base agent prompt with escaped variables
            prompt = f"""You are {agent.name}, an AI assistant.

Role: {agent.role}

Goal: {{{{goal}}}}

Backstory: {agent.backstory if hasattr(agent, 'backstory') else ''}
"""
            # Add client context if available
            if client_data:
                client_context = self._create_client_context(client_data)
                prompt += f"\n{client_context}"
            else:
                prompt += f"\nCurrent Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

            # Replace the goal placeholder with actual goal if available
            if hasattr(agent, 'goal'):
                prompt = prompt.replace('{{goal}}', agent.goal)
            else:
                prompt = prompt.replace('{{goal}}', 'Help users accomplish their tasks effectively.')

            return prompt

        except Exception as e:
            logger.error(f"Error creating agent prompt: {str(e)}", exc_info=True)
            return self._get_default_system_prompt()

    def _create_client_context(self, client_data: Dict) -> str:
        """Create formatted client context string."""
        try:
            client = client_data.get('client')
            if not client:
                return f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

            context = f"""Current Context:
- Client ID: {client.id}
- Client Name: {client.name}
- Website URL: {client.website_url}
- Target Audience: {client.target_audience or 'N/A'}
- Current Date: {timezone.now().strftime('%Y-%m-%d')}
"""
            # Add business objectives if present
            if client.business_objectives:
                objectives_text = "\n".join([f"- {obj}" for obj in client.business_objectives])
                context += f"\n\nBusiness Objectives:\n{objectives_text}"

            # Add client profile if available
            if client.client_profile:
                context += f"\n\nClient Profile:\n{client.client_profile}"

            return context

        except Exception as e:
            logger.error(f"Error creating client context: {str(e)}", exc_info=True)
            return f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

================
File: agents/chat/managers/token_manager.py
================
import logging
import tiktoken
from django.core.cache import cache
from django.db import models
from typing import Dict, Optional, Any
from channels.db import database_sync_to_async
from apps.agents.models import TokenUsage
from apps.common.utils import get_llm
from datetime import datetime
import uuid

logger = logging.getLogger(__name__)

class TokenManager:
    """
    Manages token counting, tracking, and limits for chat conversations.
    Consolidates token-related functionality from across the codebase.
    """
    
    def __init__(self, 
                 conversation_id: Optional[str] = None,
                 session_id: Optional[str] = None,
                 max_token_limit: int = 16384,
                 model_name: str = "gpt-3.5-turbo"):
        """
        Initialize the TokenManager.
        
        Args:
            conversation_id: Unique identifier for the conversation
            session_id: Unique identifier for the current session
            max_token_limit: Maximum number of tokens allowed in conversation history
            model_name: Name of the model to use for tokenization
        """
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.max_token_limit = max_token_limit
        self.model_name = model_name
        # Use the same tokenizer setup as utils.py
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
        self.input_tokens = 0
        self.output_tokens = 0
        self.token_callback = None

    def count_tokens(self, text: str) -> int:
        """Count tokens in text using the initialized tokenizer."""
        try:
            return len(self.tokenizer.encode(text, disallowed_special=()))
        except Exception as e:
            logger.error(f"Error counting tokens: {str(e)}")
            return 0

    def set_token_callback(self, callback):
        """Set the token callback from the LLM."""
        self.token_callback = callback

    def track_token_usage(self, prompt_tokens: int, completion_tokens: int) -> None:
        """Track token usage for the current session."""
        self.input_tokens += prompt_tokens
        self.output_tokens += completion_tokens
        
        if self.session_id:
            session_cache_key = f"token_totals_{self.session_id}"
            session_totals = cache.get(session_cache_key, {
                'prompt_tokens': 0,
                'completion_tokens': 0,
                'total_tokens': 0
            })
            
            session_totals['prompt_tokens'] += prompt_tokens
            session_totals['completion_tokens'] += completion_tokens
            session_totals['total_tokens'] += (prompt_tokens + completion_tokens)
            
            cache.set(session_cache_key, session_totals, 3600)  # 1 hour expiry

    def get_current_usage(self) -> Dict[str, int]:
        """Get current token usage for the session."""
        if self.token_callback:
            input_tokens = getattr(self.token_callback, 'input_tokens', 0) or 0
            output_tokens = getattr(self.token_callback, 'output_tokens', 0) or 0
            return {
                'prompt_tokens': input_tokens,
                'completion_tokens': output_tokens,
                'total_tokens': input_tokens + output_tokens,
                'model': self.model_name
            }
        return {
            'prompt_tokens': self.input_tokens or 0,
            'completion_tokens': self.output_tokens or 0,
            'total_tokens': (self.input_tokens or 0) + (self.output_tokens or 0),
            'model': self.model_name
        }

    def reset_tracking(self):
        """Reset token tracking for the current session."""
        self.input_tokens = 0
        self.output_tokens = 0
        if self.token_callback:
            self.token_callback.input_tokens = 0
            self.token_callback.output_tokens = 0

    async def _reset_session_token_totals(self):
        """Reset token totals for the session."""
        if self.session_id:
            cache.delete(f"token_totals_{self.session_id}")

    @database_sync_to_async
    def store_token_usage(self, message_id: str, token_usage: Dict[str, Any]):
        """Store token usage in the database."""
        if not self.conversation_id:
            return

        try:
            TokenUsage.objects.create(
                conversation_id=self.conversation_id,
                message_id=message_id,
                prompt_tokens=token_usage.get('prompt_tokens', 0),
                completion_tokens=token_usage.get('completion_tokens', 0),
                total_tokens=token_usage.get('total_tokens', 0),
                model=token_usage.get('model', ''),
                metadata=token_usage.get('metadata', {})
            )
        except Exception as e:
            logger.error(f"Error storing token usage: {str(e)}")

    @database_sync_to_async
    def get_conversation_token_usage(self) -> Dict[str, int]:
        """Get total token usage for the conversation."""
        if not self.conversation_id:
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

        try:
            usage = TokenUsage.objects.filter(conversation_id=self.conversation_id).aggregate(
                total_tokens=models.Sum('total_tokens'),
                prompt_tokens=models.Sum('prompt_tokens'),
                completion_tokens=models.Sum('completion_tokens')
            )
            return {
                'total_tokens': usage['total_tokens'] or 0,
                'prompt_tokens': usage['prompt_tokens'] or 0,
                'completion_tokens': usage['completion_tokens'] or 0
            }
        except Exception as e:
            logger.error(f"Error getting conversation token usage: {str(e)}")
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

    async def track_conversation_tokens(self):
        """Track token usage for the entire conversation."""
        if not self.conversation_id:
            return

        current_usage = self.get_current_usage()
        if current_usage['total_tokens'] > 0:
            await self.store_token_usage(
                message_id=None,  # Set to None since we're tracking conversation-level usage
                token_usage={
                    **current_usage,
                    'metadata': {'type': 'conversation_tracking'}
                }
            )

================
File: agents/chat/managers/tool_manager.py
================
import logging
from typing import List, Dict, Any, Optional
from langchain.tools import Tool, StructuredTool
from apps.agents.utils import get_tool_classes
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter

logger = logging.getLogger(__name__)

class ToolManager:
    """
    Manages tool loading, execution, and formatting.
    Consolidates tool-related functionality from across the codebase.
    """
    
    def __init__(self):
        """Initialize the ToolManager."""
        self.tools = []
        self.tool_formatter = ToolFormatter()

    async def load_tools(self, agent) -> List[Tool]:
        """Load and initialize agent tools."""
        try:
            tools = []
            seen_tools = set()
            
            # Get tools using database_sync_to_async
            agent_tools = await self._get_agent_tools(agent)
            
            for tool_model in agent_tools:
                try:
                    tool_key = f"{tool_model.tool_class}_{tool_model.tool_subclass}"
                    if tool_key in seen_tools:
                        continue
                    seen_tools.add(tool_key)

                    tool_classes = get_tool_classes(tool_model.tool_class)
                    tool_class = next((cls for cls in tool_classes 
                                   if cls.__name__ == tool_model.tool_subclass), None)
                    
                    if tool_class:
                        logger.info(f"Initializing tool: {tool_class.__name__}")
                        tool_instance = tool_class()
                        
                        # Convert to Langchain format
                        langchain_tool = self._create_langchain_tool(tool_instance)
                        if langchain_tool:
                            tools.append(langchain_tool)
                            
                except Exception as e:
                    logger.error(f"Error initializing tool {tool_model.tool_subclass}: {str(e)}")
                    continue

            self.tools = tools
            return tools
            
        except Exception as e:
            logger.error(f"Error loading tools: {str(e)}")
            raise

    @database_sync_to_async
    def _get_agent_tools(self, agent):
        """Get agent tools from database."""
        return list(agent.tools.all())

    def _create_langchain_tool(self, tool_instance) -> Optional[Tool]:
        """Create a Langchain tool from a tool instance."""
        try:
            # Use StructuredTool if args_schema is present
            if hasattr(tool_instance, 'args_schema'):
                return StructuredTool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None,
                    args_schema=tool_instance.args_schema
                )
            else:
                return Tool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None
                )
        except Exception as e:
            logger.error(f"Error creating Langchain tool: {str(e)}")
            return None

    def _create_tool_description(self, tool_instance) -> str:
        """Create a description for the tool."""
        description = tool_instance.description
        if hasattr(tool_instance, 'args_schema'):
            schema = tool_instance.args_schema.schema()
            if 'properties' in schema:
                args_desc = []
                for name, details in schema['properties'].items():
                    arg_desc = f"- {name}: {details.get('description', 'No description')}"
                    if details.get('type'):
                        arg_desc += f" (type: {details['type']})"
                    args_desc.append(arg_desc)
                if args_desc:
                    description += "\nArguments:\n" + "\n".join(args_desc)
        return description

    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute a tool with given arguments."""
        try:
            tool = next((t for t in self.tools if t.name == tool_name), None)
            if not tool:
                raise ValueError(f"Tool not found: {tool_name}")
            
            if tool.coroutine:
                result = await tool.coroutine(**kwargs)
            else:
                result = tool.func(**kwargs)
                
            return result
            
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {str(e)}")
            raise

    def format_tool_output(self, content: Any) -> str:
        """Format tool output for display."""
        return self.tool_formatter.format_tool_output(content)

    def format_tool_usage(self, content: str, message_type: str = None) -> str:
        """Format tool usage messages."""
        return self.tool_formatter.format_tool_usage(content, message_type)

================
File: agents/chat/history.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage
from typing import List, Optional, Dict
import logging
from apps.agents.models import ChatMessage

logger = logging.getLogger(__name__)

class DjangoCacheMessageHistory(BaseChatMessageHistory):
    """Message history that uses Django's cache and database for storage."""
    
    def __init__(self, session_id: str, conversation_id: Optional[str] = None, agent_id: Optional[int] = None, ttl: int = 3600):
        """Initialize with session ID and optional conversation ID."""
        # Store these as instance variables since they're used by other parts of the system
        self.session_id = session_id
        self.conversation_id = conversation_id
        self.agent_id = agent_id
        self.ttl = ttl
        
        # Initialize the message manager for all operations
        from apps.agents.chat.managers.message_manager import MessageManager
        self.message_manager = MessageManager(
            conversation_id=conversation_id,
            session_id=session_id,
            agent_id=agent_id,
            ttl=ttl
        )

    async def aget_messages(self) -> List[BaseMessage]:
        """Get messages from the message manager."""
        try:
            return await self.message_manager.get_messages()
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}")
            return []

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Add message using the message manager.
        
        Returns:
            ChatMessage: The stored message object, or None if storage failed
        """
        try:
            return await self.message_manager.add_message(message, token_usage)
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    def clear(self) -> None:
        """Clear message history."""
        try:
            self.message_manager.clear()
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing by marking messages as deleted."""
        try:
            if self.conversation_id:
                await self.message_manager.handle_edit(message_id)
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise

================
File: agents/clients/manager.py
================
import logging
from django.utils import timezone
from apps.seo_manager.models import Client
from channels.db import database_sync_to_async

logger = logging.getLogger(__name__)

class ClientDataManager:
    def __init__(self):
        pass

    @database_sync_to_async
    def get_client_data(self, client_id):
        """Get and format client data"""
        if not client_id:
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
            
        try:
            client = Client.objects.get(id=client_id)
            current_date = timezone.now().date()
            
            return {
                'client_id': client.id,
                'current_date': current_date.isoformat(),
            }
        except Client.DoesNotExist:
            logger.info(f"No client found with ID {client_id}, returning default data")
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
        except Exception as e:
            logger.error(f"Error getting client data: {str(e)}", exc_info=True)
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }

================
File: agents/utils/error_handling.py
================
from functools import wraps
import logging
import json
from typing import Optional, Any, Callable
from django.core.exceptions import ValidationError

logger = logging.getLogger(__name__)

class ChatError(Exception):
    """Base class for chat-related errors"""
    def __init__(self, message: str, code: Optional[str] = None):
        super().__init__(message)
        self.code = code

def handle_chat_errors(func: Callable) -> Callable:
    """Decorator to handle chat-related errors"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ChatError as e:
            logger.warning(f"Chat error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': e.code
            }
        except ValidationError as e:
            logger.warning(f"Validation error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': 'validation_error'
            }
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': 'An unexpected error occurred',
                'code': 'internal_error'
            }
    return wrapper

================
File: agents/utils/formatters.py
================
import json
from typing import Any
from logger import logger

class TableFormatter:
    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data appears to be tabular"""
        try:
            # Handle string input
            if isinstance(data, str):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return False

            # Handle dictionary with nested data
            if isinstance(data, dict):
                # Look for common response patterns and nested data
                for key in ['data', 'results', 'search_console_data', 'analytics_data', 
                           'records', 'rows', 'items', 'response']:
                    if key in data and isinstance(data[key], list):
                        data = data[key]
                        break
                # If no list found in known keys, check all values
                if isinstance(data, dict):
                    for value in data.values():
                        if isinstance(value, list) and len(value) > 0:
                            data = value
                            break

            # Check if it's a list of dictionaries with consistent structure
            if isinstance(data, list) and len(data) > 0:
                if all(isinstance(item, dict) for item in data):
                    # Get keys from first item
                    keys = set(data[0].keys())
                    # Check if all items have same keys and at least one key
                    return len(keys) > 0 and all(set(item.keys()) == keys for item in data)

            return False
            
        except Exception as e:
            logger.error(f"Error detecting tabular data: {str(e)}")
            return False

================
File: agents/websockets/handlers/agent_handler.py
================
import logging
from apps.common.utils import create_box
from apps.agents.models import Agent
from channels.db import database_sync_to_async
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler
from apps.agents.websockets.services.chat_service import ChatService

logger = logging.getLogger(__name__)

class AgentHandler:
    def __init__(self, consumer):
        self.consumer = consumer
        self.chat_service = None

    async def process_response(self, message, agent_id, model_name, client_id):
        """Manages agent and chat service lifecycle"""
        try:
            # Get agent data
            agent = await self.get_agent(agent_id)
            if not agent:
                raise ValueError("Agent not found")

            # Get client data
            client_data = await self.consumer.client_manager.get_client_data(client_id)

            # Check if we need to reinitialize the chat service (agent or model changed)
            should_reinitialize = (
                not self.chat_service or
                str(self.chat_service.agent.id) != str(agent_id) or
                self.chat_service.model_name != model_name
            )

            if should_reinitialize:
                # Create new chat service with new agent/model but preserve message manager
                logger.info(create_box("AGENT HANDLER", f"Reinitializing chat service for agent {agent_id} with model {model_name}"))
                callback_handler = WebSocketCallbackHandler(self.consumer)
                
                # Preserve the existing message manager if it exists
                message_manager = self.chat_service.message_manager if self.chat_service else None
                
                self.chat_service = ChatService(
                    agent=agent,
                    model_name=model_name,
                    client_data=client_data,
                    callback_handler=callback_handler,
                    session_id=self.consumer.session_id
                )
                
                # Set the preserved message manager if it exists
                if message_manager:
                    self.chat_service.message_manager = message_manager
                    
                await self.chat_service.initialize()
            else:
                # Just update client data if it changed
                self.chat_service.client_data = client_data

            # Process message - no return value needed as everything goes through callbacks
            await self.chat_service.process_message(message)

        except Exception as e:
            logger.error(f"Error in agent handler: {str(e)}")
            raise

    @database_sync_to_async
    def get_agent(self, agent_id):
        """Get agent from database"""
        try:
            return Agent.objects.get(id=agent_id)
        except Exception as e:
            logger.error(f"Error getting agent: {str(e)}")
            raise

================
File: agents/websockets/handlers/callback_handler.py
================
from langchain_core.callbacks import BaseCallbackHandler
import logging
import json
from typing import Any, Dict, List
from datetime import datetime
from langchain_core.agents import  AgentFinish
import asyncio
import textwrap
import uuid
from channels.db import database_sync_to_async
from apps.common.utils import create_box
from langchain.schema import SystemMessage, AIMessage

logger = logging.getLogger(__name__)

class UUIDEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, uuid.UUID):
            return str(obj)
        return super().default(obj)


class WebSocketCallbackHandler(BaseCallbackHandler):
    """Callback handler that sends only essential messages to the WebSocket."""
    
    def __init__(self, consumer, message_manager=None, token_manager=None):
        """Initialize the handler with a WebSocket consumer and managers"""
        super().__init__()
        self.consumer = consumer
        self.logger = logging.getLogger(__name__)
        self._message_lock = asyncio.Lock()
        self.message_history = []
        self._last_agent_finish = None  # Track last agent finish message
        self.message_manager = message_manager
        self.token_manager = token_manager

    def _log_message(self, title: str, content: Any):
        """Log a message with proper JSON serialization."""
        try:
            if isinstance(content, dict):
                content_str = json.dumps(content, indent=2, cls=UUIDEncoder)
            else:
                content_str = str(content)
            self.logger.debug(create_box(title, content_str))
        except Exception as e:
            self.logger.error(f"Error logging message: {str(e)}")

    async def _send_message(self, message_data):
        """Send message to WebSocket and store in history."""
        try:
            # Store message in history
            self.message_history.append({
                'timestamp': datetime.now().isoformat(),
                'type': message_data.get('type'),
                'content': message_data
            })
            
            # Format message if it's a tool message
            if message_data.get('type', '').startswith('tool_') and self.message_manager:
                message_data['message'] = self.message_manager.format_message(
                    message_data['message'],
                    message_data['type']
                )
            
            # Add message ID if this is a message that was stored in DB
            if hasattr(self, '_last_message_id') and self._last_message_id:
                message_data['id'] = self._last_message_id
                self._last_message_id = None  # Clear it after use
            
            async with self._message_lock:
                await self.consumer.send_json(message_data)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN SEND MESSAGE", str(e)), exc_info=True)

    async def on_agent_finish(self, finish: AgentFinish, **kwargs: Any):
        """Handle agent completion - send final answer and save to database."""
        try:
            # Get token usage and track it
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
                await self.token_manager.track_conversation_tokens()
            
            if hasattr(finish, 'return_values'):
                output = finish.return_values.get('output', '')
                
                # Check if this is a duplicate message
                if self._last_agent_finish == output:
                    self.logger.debug("Skipping duplicate agent finish message")
                    return
                
                self._last_agent_finish = output
                
                debug_info = {
                    'output': output,
                    'token_usage': token_usage
                }
                self._log_message("AGENT FINISH EVENT RECEIVED", debug_info)
                
                # Store message using message manager and get the message ID
                stored_message = None
                if self.message_manager:
                    stored_message = await self.message_manager.add_message(
                        AIMessage(content=output),
                        token_usage=token_usage
                    )
                
                message = {
                    'type': 'agent_finish',
                    'message': output,
                    'timestamp': datetime.now().isoformat(),
                    'token_usage': token_usage,
                    'id': str(stored_message.id) if stored_message else None
                }
                
                # Send message to websocket
                await self._send_message(message)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN AGENT FINISH", str(e)), exc_info=True)

    def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any) -> None:
        """Synchronous handler for tool start - required by LangChain."""
        self._log_message("TOOL START (SYNC)", {
            'tool': serialized.get('name', 'Unknown Tool'),
            'input': input_str,
            'kwargs': kwargs
        })

    def on_tool_end(self, output: str, **kwargs: Any) -> None:
        """Synchronous handler for tool end - required by LangChain."""
        self._log_message("TOOL END (SYNC)", {
            'output': output,
            'kwargs': kwargs
        })

    async def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any):
        """Handle tool start - send tool name and input."""
        try:
            # Skip internal exceptions
            if serialized.get('name') == '_Exception':
                return
                
            # Get token usage and track it
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            debug_info = {
                'tool': serialized.get('name', 'Unknown Tool'),
                'input': input_str,
                'token_usage': token_usage
            }
            self._log_message("TOOL START EVENT RECEIVED", debug_info)
            
            # Store tool start in message history if manager available
            tool_message = f"Tool Start: {serialized.get('name')} - {input_str}"
            stored_message = None
            if self.message_manager:
                stored_message = await self.message_manager.add_message(
                    SystemMessage(content=tool_message),
                    token_usage=token_usage
                )
            
            # Then send message to websocket
            message = {
                'type': 'agent_message',
                'message': tool_message,
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage,
                'id': str(stored_message.id) if stored_message else None
            }
            await self._send_message(message)
                
        except Exception as e:
            logger.error(create_box("ERROR IN TOOL START", str(e)), exc_info=True)
            await self.on_tool_error(str(e), **kwargs)

    async def on_tool_end(self, output: str, **kwargs: Any):
        """Handle tool completion - send formatted output."""
        try:
            # Check if this is an error response
            if isinstance(output, dict) and output.get('error'):
                await self.on_tool_error(output['error'], **kwargs)
                return
            
            # Format the output using message manager if available
            formatted_output = output
            if self.message_manager:
                formatted_output = self.message_manager.format_message(output, 'tool_end')
            
            debug_info = {
                'output': formatted_output,
                'token_usage': {}  # Tools don't typically use tokens
            }
            self._log_message("TOOL END EVENT RECEIVED", debug_info)
            
            # Store tool end in message history if manager available
            stored_message = None
            if self.message_manager:
                stored_message = await self.message_manager.add_message(
                    SystemMessage(content=formatted_output),
                    token_usage={}  # Tools don't typically use tokens
                )
            
            # Try to parse the output as JSON
            try:
                if isinstance(formatted_output, str):
                    data = json.loads(formatted_output)
                else:
                    data = formatted_output
                
                # If it's analytics data, send as table type
                if isinstance(data, dict) and data.get('analytics_data'):
                    result_type = 'table'
                    result_data = data['analytics_data']
                else:
                    result_type = 'json'
                    result_data = data
            except json.JSONDecodeError:
                # If not valid JSON, send as text
                result_type = 'text'
                result_data = formatted_output
            
            message = {
                'type': 'tool_end',
                'message': {
                    'type': result_type,
                    'data': result_data
                },
                'timestamp': datetime.now().isoformat(),
                'token_usage': {},
                'id': str(stored_message.id) if stored_message else None
            }
            await self._send_message(message)
            
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL END", str(e)), exc_info=True)
            await self.on_tool_error(str(e), **kwargs)

    async def on_tool_error(self, error: str, **kwargs: Any):
        """Handle tool errors"""
        try:
            # Get token usage from kwargs if available
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            error_info = {
                'error': error,
                'token_usage': token_usage
            }
            self._log_message("TOOL ERROR EVENT RECEIVED", error_info)
            
            error_message = f"Tool Error: {error}"
            message = {
                'type': 'agent_message',
                'message': error_message,
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage
            }
            await self._send_message(message)
            
            # Store error in message history if manager available
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=error_message),
                    token_usage=token_usage
                )
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL ERROR HANDLER", str(e)), exc_info=True)

================
File: agents/websockets/services/chat_service.py
================
from langchain.agents import AgentExecutor, create_structured_chat_agent
from langchain.memory import ConversationBufferMemory
from langchain_core.messages import (
    BaseMessage,
    SystemMessage,
    AIMessage,
    HumanMessage
)
from channels.db import database_sync_to_async
from apps.common.utils import create_box
import logging
from django.utils import timezone
from apps.common.utils import get_llm
from django.core.cache import cache
from typing import Optional, List, Any, Dict
import asyncio
from apps.seo_manager.models import Client
from django.db import models
from pydantic import ValidationError
from langchain_core.agents import AgentFinish
import re

# Import our new managers
from apps.agents.chat.managers.token_manager import TokenManager
from apps.agents.chat.managers.tool_manager import ToolManager
from apps.agents.chat.managers.prompt_manager import PromptManager
from apps.agents.chat.managers.message_manager import MessageManager
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler

logger = logging.getLogger(__name__)

class ChatServiceError(Exception):
    """Base exception for chat service errors"""
    pass

class ToolExecutionError(ChatServiceError):
    """Raised when a tool execution fails"""
    pass

class TokenLimitError(ChatServiceError):
    """Raised when token limit is exceeded"""
    pass

class ChatService:
    def __init__(self, agent, model_name, client_data, callback_handler, session_id=None):
        self.agent = agent
        self.model_name = model_name
        self.client_data = client_data
        self.callback_handler = callback_handler
        self.llm = None
        self.agent_executor = None
        self.processing = False
        self.tool_cache = {}  # Cache for tool results
        self.session_id = session_id or f"{agent.id}_{client_data['client_id'] if client_data else 'no_client'}"
        self.processing_lock = asyncio.Lock()
        
        # Create conversation ID from session ID if not provided
        self.conversation_id = f"conv_{self.session_id}"
        
        # Initialize managers with conversation ID
        self.token_manager = TokenManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id,
            max_token_limit=64000,
            model_name=model_name
        )
        
        self.message_manager = MessageManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id
        )
        
        self.tool_manager = ToolManager()
        self.prompt_manager = PromptManager()
        
        # Set up message history with token management
        self.message_history = self.message_manager
        
        # Update callback handler with managers
        if isinstance(self.callback_handler, WebSocketCallbackHandler):
            self.callback_handler.message_manager = self.message_manager
            self.callback_handler.token_manager = self.token_manager

    async def initialize(self) -> Optional[AgentExecutor]:
        """Initialize the chat service with LLM and agent"""
        try:
            # Validate and get client if present
            client_data = None
            if self.client_data and self.client_data.get('client_id'):
                try:
                    client = await database_sync_to_async(Client.objects.get)(id=self.client_data['client_id'])
                    client_data = {'client': client}
                except Client.DoesNotExist:
                    logger.error(f"Client not found with ID: {self.client_data['client_id']}")
                    raise ValueError(f"Client not found with ID: {self.client_data['client_id']}")

            # Create or get conversation
            conversation = await self._create_or_get_conversation(client_data['client'] if client_data else None)
            
            # Update managers with conversation ID
            self.conversation_id = str(conversation.id)
            self.token_manager.conversation_id = self.conversation_id
            self.message_manager.conversation_id = self.conversation_id

            # Get LLM with token tracking
            self.llm, token_callback = get_llm(
                model_name=self.model_name,
                temperature=0.7,
            )
            
            # Set up token tracking
            self.llm.callbacks = [token_callback]
            self.token_manager.set_token_callback(token_callback)

            # Initialize memory with proper message handling
            memory = ConversationBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                chat_memory=self.message_manager,
                output_key="output",
                input_key="input"
            )

            # Load tools using tool manager
            tools = await self.tool_manager.load_tools(self.agent)

            # Get chat history and ensure it's a list of BaseMessage objects
            chat_history = await self.message_manager.get_messages()
            if not isinstance(chat_history, list):
                chat_history = []
            
            # Create the agent-specific system prompt with client context using prompt manager
            system_prompt = self.prompt_manager.create_agent_prompt(self.agent, client_data)
            
            # Create prompt using prompt manager - pass raw data
            prompt = self.prompt_manager.create_chat_prompt(
                system_prompt=system_prompt,
                tools=tools,
                chat_history=chat_history,
                client_data=client_data
            )

            # Create the agent
            agent = create_structured_chat_agent(
                llm=self.llm,
                tools=tools,
                prompt=prompt
            )

            # Create agent executor with memory
            self.agent_executor = AgentExecutor.from_agent_and_tools(
                agent=agent,
                tools=tools,
                memory=memory,
                verbose=True,
                max_iterations=25,
                handle_parsing_errors=True,
                return_intermediate_steps=True
            )

            # Reset session token totals
            await self.token_manager._reset_session_token_totals()

            return self.agent_executor

        except Exception as e:
            logger.error(f"Error initializing chat service: {str(e)}", exc_info=True)
            raise

    @database_sync_to_async
    def _create_or_get_conversation(self, client=None) -> Any:
        """Create or get a conversation record."""
        try:
            from apps.agents.models import Conversation
            
            # Try to get existing conversation
            conversation = Conversation.objects.filter(
                session_id=self.session_id
            ).first()
            
            if not conversation:
                # Create new conversation
                conversation = Conversation.objects.create(
                    session_id=self.session_id,
                    agent_id=self.agent.id,
                    client=client,
                    user_id=self.client_data.get('user_id') if self.client_data else None
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error creating/getting conversation: {str(e)}", exc_info=True)
            raise

    def _create_token_aware_memory(self) -> ConversationBufferMemory:
        """Create memory with token limit enforcement"""
        memory = ConversationBufferMemory(
            memory_key="chat_history",
            return_messages=True,
            chat_memory=self.message_manager,
            output_key="output",
            input_key="input"
        )

        # Wrap the add_message methods to check token counts
        original_add_message = self.message_manager.add_message

        async def wrapped_add_message(message: BaseMessage, **kwargs) -> None:
            """Async wrapper for add_message that handles token usage"""
            try:
                # Check token limit before adding message
                if not await self.token_manager.check_token_limit([message]):
                    raise TokenLimitError("Message would exceed token limit")
                    
                # Pass through any additional kwargs (including token_usage)
                await original_add_message(message, **kwargs)
            except Exception as e:
                logger.error(f"Error in wrapped_add_message: {str(e)}")
                raise

        # Replace the add_message method with our wrapped version
        self.message_manager.add_message = wrapped_add_message

        return memory
    
    async def process_message(self, message: str, is_edit: bool = False) -> None:
        async with self.processing_lock:
            try:
                # Reset token tracking
                self.token_manager.reset_tracking()

                # Get chat history
                chat_history = await self.message_manager.get_messages()

                # Ensure chat history is a list of BaseMessage objects
                if not all(isinstance(msg, BaseMessage) for msg in chat_history):
                    logger.warning("Chat history contains non-BaseMessage objects")
                    chat_history = []

                # Initialize empty agent_scratchpad with proper BaseMessage type
                inputs = {
                    "input": message,
                    "chat_history": chat_history,
                    "agent_scratchpad": []  # Initialize as empty list, let agent handle the messages
                }

                # Debug logging for agent_scratchpad
                logger.debug(f"Agent scratchpad type: {type(inputs['agent_scratchpad'])}")
                logger.debug(f"Agent scratchpad contents: {inputs['agent_scratchpad']}")

                # Get agent response
                response = await self.agent_executor.ainvoke(
                    inputs,
                    {"callbacks": [self.callback_handler, self.llm.callbacks[0]]}
                )

                # Save the agent's response
                if isinstance(response, dict) and 'output' in response:
                    await self._handle_response(response['output'])

            except Exception as e:
                logger.error(f"Error in process_message: {str(e)}")
                await self._handle_error(str(e), e, unexpected=True)

    async def _handle_response(self, response: str) -> None:
        """Handle successful response"""
        try:
            # Get current token usage
            token_usage = self.token_manager.get_current_usage()
            
            # Send through callback handler for WebSocket communication
            await self.callback_handler.on_agent_finish(
                AgentFinish(
                    return_values={'output': response},
                    log='',
                ),
                token_usage=token_usage
            )
        except Exception as e:
            logger.error(f"Error handling response: {str(e)}", exc_info=True)
            await self._handle_error("Failed to handle response", e)

    async def _handle_error(self, error_msg: str, exception: Exception, unexpected: bool = False) -> None:
        """Handle errors consistently"""
        try:
            # Log the error
            logger.error(f"Error in chat service: {error_msg}", exc_info=True)
            
            # Store error message in message history
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=f"Error: {error_msg}"),
                    token_usage=self.token_manager.get_current_usage()
                )
            
            # Send error through callback handler with run_id
            await self.callback_handler.on_llm_error(error_msg, run_id=None)
            
            if unexpected:
                raise ChatServiceError(str(exception))
            else:
                raise exception
                
        except Exception as e:
            logger.error(f"Error in error handler: {str(e)}", exc_info=True)
            raise ChatServiceError(str(e))

    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing"""
        try:
            logger.debug(f"Chat service handling edit request for message {message_id}")
            await self.message_manager.handle_edit(message_id)
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise ChatServiceError("Failed to handle message edit")

    async def get_conversation_token_usage(self) -> Dict:
        """Get total token usage for the conversation"""
        return await self.token_manager.get_conversation_token_usage()

    async def track_tool_token_usage(self, token_usage: Dict, tool_name: str) -> None:
        """Track token usage for tool execution"""
        await self.token_manager.store_token_usage(
            message_id=f"tool_{tool_name}_{timezone.now().timestamp()}",
            token_usage={
                **token_usage,
                'metadata': {'tool_name': tool_name, 'type': 'tool_execution'}
            }
        )

================
File: agents/websockets/__init__.py
================
from .chat_consumer import ChatConsumer
from .base import BaseWebSocketConsumer

__all__ = ['ChatConsumer', 'BaseWebSocketConsumer']

================
File: agents/websockets/base.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class BaseWebSocketConsumer(AsyncWebsocketConsumer):
    async def send_json(self, data):
        """Send JSON data as text"""
        try:
            await self.send(text_data=json.dumps(data))
        except Exception as e:
            logger.error(f"Error sending JSON: {str(e)}")
            await self.send(text_data=json.dumps({
                'error': True,
                'message': 'Error sending message'
            }))

    async def handle_binary_message(self, message):
        """Handle binary message data"""
        try:
            if isinstance(message, bytes):
                message = message.decode('utf-8')
            return json.loads(message)
        except Exception as e:
            logger.error(f"Error handling binary message: {str(e)}")
            return None

================
File: agents/websockets/chat_consumer.py
================
from .base import BaseWebSocketConsumer
from .handlers.agent_handler import AgentHandler
from ..tools.manager import AgentToolManager
from ..clients.manager import ClientDataManager
from ..chat.history import DjangoCacheMessageHistory
from ..models import Conversation
import logging
import uuid
import json
from datetime import datetime
from urllib.parse import parse_qs
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import (
    BaseMessage, 
    HumanMessage, 
    AIMessage,
    messages_from_dict, 
    messages_to_dict
)

logger = logging.getLogger(__name__)

class ChatConsumer(BaseWebSocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.tool_manager = AgentToolManager()
        self.client_manager = ClientDataManager()
        self.session_id = None
        self.group_name = None
        self.agent_handler = AgentHandler(self)
        self.is_connected = False
        self.message_history = None

    async def send_json(self, content):
        """Override to add logging"""
        #logger.debug(f"Sending message: {content}")
        await super().send_json(content)

    async def connect(self):
        if self.is_connected:
            return

        try:
            # Get session ID from query parameters
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if param)
            self.session_id = params.get('session')
            
            if not self.session_id:
                logger.error("No session ID provided")
                await self.close()
                return
                
            self.user = self.scope.get("user")
            if not self.user or not self.user.is_authenticated:
                logger.error("User not authenticated")
                await self.close()
                return
        
            logger.debug(f"Connecting websocket for user {self.user.id} with session {self.session_id}")
                
            # Get or create conversation first to get agent_id
            conversation = await self.get_or_create_conversation()
            if not conversation:
                logger.error("Failed to get/create conversation")
                await self.close()
                return
            
            logger.debug(f"Found conversation {conversation.id} with title: {conversation.title}")
                
            self.group_name = f"chat_{self.session_id}"
            # Pass agent_id from conversation
            self.message_history = DjangoCacheMessageHistory(
                session_id=self.session_id,
                agent_id=conversation.agent_id if conversation.agent_id else None,
                conversation_id=conversation.id
            )
            
            await self.channel_layer.group_add(self.group_name, self.channel_name)
            await self.accept()
            self.is_connected = True
            
            # Send historical messages
            messages = await self.message_history.aget_messages()
            logger.debug(f"Retrieved {len(messages)} historical messages")
            
            for msg in messages:
                message_type = 'agent_message' if isinstance(msg, AIMessage) else 'user_message'
                message_content = msg.content
                             
                await self.send_json({
                    'type': message_type,
                    'message': message_content,
                    'timestamp': conversation.updated_at.isoformat(),
                    'id': msg.additional_kwargs.get('id')  # Get ID from additional_kwargs
                })
            
            await self.send_json({
                'type': 'system_message',
                'message': 'Connected to chat server',
                'connection_status': 'connected',
                'session_id': self.session_id
            })
            
        except Exception as e:
            logger.error(f"Error in connect: {str(e)}", exc_info=True)
            await self.close()
            return

    async def get_or_create_conversation(self):
        try:
            # Get existing conversation
            conversation = await Conversation.objects.filter(
                session_id=self.session_id,
                user=self.user
            ).afirst()
            
            if not conversation:
                # Create new conversation with placeholder title
                conversation = await Conversation.objects.acreate(
                    session_id=self.session_id,
                    user=self.user,
                    title="..."  # Will be updated with first message
                )
                #logger.info(f"Created new conversation: {conversation.id}")
            else:
                #logger.info(f"Found existing conversation: {conversation.id}")
                pass
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error getting/creating conversation: {str(e)}")
            return None

    async def update_conversation(self, message, agent_id=None, client_id=None):
        try:
            conversation = await Conversation.objects.filter(
                session_id=self.session_id
            ).afirst()
            
            if conversation:
                # Update title if it's still the default
                if conversation.title == "...":
                    # Clean and truncate the message for the title
                    title = message.strip().replace('\n', ' ')[:50]
                    # Add ellipsis if truncated
                    if len(message) > 50:
                        title += "..."
                    conversation.title = title
                
                # Update agent and client if provided
                if agent_id:
                    conversation.agent_id = agent_id
                if client_id:
                    conversation.client_id = client_id
                    
                await conversation.asave()
                #logger.info(f"Updated conversation: {conversation.id} with title: {conversation.title}")
                
        except Exception as e:
            logger.error(f"Error updating conversation: {str(e)}")

    async def receive(self, text_data=None, bytes_data=None):
        try:
            # Handle binary data if present
            if bytes_data:
                data = await self.handle_binary_message(bytes_data)
            else:
                data = json.loads(text_data)

            # Process keep-alive messages
            if data.get('type') == 'keep_alive':
                await self.message_handler.handle_keep_alive()
                return

            # Process message - responses come via callback_handler
            await self.process_message(data)

        except json.JSONDecodeError as e:
            logger.error(f"❌ JSON decode error: {str(e)}")
            await self.message_handler.handle_message(
                'Invalid message format', is_agent=True, error=True
            )
        except Exception as e:
            logger.error(f"❌ Error: {str(e)}")
            await self.message_handler.handle_message(
                'Internal server error', is_agent=True, error=True)

    async def process_message(self, data):
        """Primary entry point for all messages"""
        try:
            # Extract message data
            message = data.get('message', '').strip()
            agent_id = data.get('agent_id')
            model_name = data.get('model')
            client_id = data.get('client_id')
            is_edit = data.get('type') == 'edit'  # Check for edit type
            message_id = data.get('message_id')  # Get message ID for edits

            logger.debug(f"Processing message: type={data.get('type')}, message_id={message_id}, is_edit={is_edit}")

            if not message and not is_edit:  # Allow empty message for edit
                raise ValueError('Missing required fields')

            # Handle message editing if needed
            if is_edit:
                if not message_id:
                    raise ValueError('Missing message ID for edit')
                logger.debug(f"Handling edit for message {message_id}")
                await self.message_history.handle_edit(message_id)
                return  # Return early for edit messages

            # Update conversation state
            await self.update_conversation(message, agent_id, client_id)
            
            # Ensure message history has correct agent_id
            if not self.message_history or self.message_history.agent_id != agent_id:
                conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
                self.message_history = DjangoCacheMessageHistory(
                    session_id=self.session_id,
                    agent_id=agent_id,
                    conversation_id=conversation.id if conversation else None
                )
            
            # Store user message and get the stored message object
            stored_message = await self.message_history.add_message(
                HumanMessage(content=message)
            )

            # Send user message with ID
            await self.send_json({
                'type': 'user_message',
                'message': message,
                'timestamp': datetime.now().isoformat(),
                'id': str(stored_message.id) if stored_message else None
            })

            # Process with agent - responses come via callback_handler
            await self.agent_handler.process_response(
                message, agent_id, model_name, client_id
            )

        except Exception as e:
            logger.error(f"Error processing message: {str(e)}")
            await self.send_json({
                'type': 'error',
                'message': str(e),
                'timestamp': datetime.now().isoformat()
            })

    async def receive_json(self, content):
        """Disabled in favor of receive() to prevent duplicate message processing"""
        pass

================
File: agents/websockets/consumers.py
================
import json
from django.db import models
from django.db.models import Q
from asgiref.sync import sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.agents.models import Agent
from apps.agents.services import ChatService

class ChatConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        session_id = self.scope['url_route']['kwargs']['session_id']
        agent_id = self.scope['url_route']['kwargs'].get('agent_id')
        
        # Get the agent from the database
        agent = await database_sync_to_async(Agent.objects.get)(id=agent_id)
        
        # Initialize chat service with the specified agent
        self.chat_service = ChatService(
            agent=agent,
            model_name=self.model_name,
            client_data=self.client_data,
            callback_handler=self,
            session_id=session_id
        )
        
        await self.chat_service.initialize()
        await self.accept()

    async def receive(self, text_data):
        data = json.loads(text_data)
        if data.get('type') == 'agent_change':
            # Handle agent change
            new_agent = await database_sync_to_async(Agent.objects.get)(id=data['agent_id'])
            self.chat_service.update_agent(new_agent)
            return
            
        # ... rest of receive code ...

================
File: agents/websockets/crew_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
# ... other imports ...

class CrewExecutionConsumer(AsyncWebsocketConsumer):
    # ... existing implementation ...
    pass

================
File: agents/admin.py
================
from django.contrib import admin
from .models import Crew, CrewExecution, CrewMessage, Agent, Task, Tool, CrewTask, Pipeline, PipelineStage, PipelineRoute, PipelineExecution, PipelineRunResult
from .forms import AgentForm, TaskForm, CrewForm

class CrewTaskInline(admin.TabularInline):
    model = CrewTask
    extra = 1

@admin.register(Crew)
class CrewAdmin(admin.ModelAdmin):
    list_display = ('name', 'process', 'verbose')
    filter_horizontal = ('agents',)
    inlines = [CrewTaskInline]
    fieldsets = (
        (None, {
            'fields': ('name', 'agents', 'process', 'verbose', 'manager_llm', 'function_calling_llm', 'config', 'max_rpm', 'language', 'language_file', 'memory', 'cache', 'embedder', 'full_output', 'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks', 'prompt_file', 'planning', 'planning_llm')
        }),
    )

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        form.base_fields['agents'].widget.can_add_related = True
        form.base_fields['agents'].widget.can_change_related = True
        return form

@admin.register(CrewExecution)
class CrewExecutionAdmin(admin.ModelAdmin):
    list_display = ('crew', 'user', 'client', 'status', 'created_at', 'updated_at')
    list_filter = ('status', 'created_at', 'updated_at')
    search_fields = ('crew__name', 'user__username', 'client__name')
    readonly_fields = ('created_at', 'updated_at', 'human_input_request', 'human_input_response', 'error_message')
    fieldsets = (
        (None, {
            'fields': ('crew', 'user', 'client', 'status', 'inputs', 'crew_output')
        }),
        ('Human Input', {
            'fields': ('human_input_request', 'human_input_response')
        }),
        ('Error Information', {
            'fields': ('error_message',)
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at')
        }),
    )

@admin.register(CrewMessage)
class CrewMessageAdmin(admin.ModelAdmin):
    list_display = ('execution', 'timestamp')
    list_filter = ('timestamp',)
    search_fields = ('execution__crew__name', 'content')

@admin.register(Agent)
class AgentAdmin(admin.ModelAdmin):
    form = AgentForm
    list_display = ('name', 'role', 'llm', 'function_calling_llm', 'verbose', 'allow_delegation', 'allow_code_execution')
    list_filter = ('verbose', 'allow_delegation', 'allow_code_execution', 'use_system_prompt', 'respect_context_window')
    search_fields = ('name', 'role', 'goal', 'backstory')
    filter_horizontal = ('tools',)
    fieldsets = (
        (None, {
            'fields': ('name', 'role', 'goal', 'backstory', 'llm', 'tools')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('function_calling_llm', 'max_iter', 'max_rpm', 'max_execution_time', 'verbose', 'allow_delegation', 'step_callback', 'cache', 'system_template', 'prompt_template', 'response_template', 'allow_code_execution', 'max_retry_limit', 'use_system_prompt', 'respect_context_window'),
        }),
    )

@admin.register(Task)
class TaskAdmin(admin.ModelAdmin):
    form = TaskForm
    list_display = ('description', 'agent', 'async_execution', 'human_input', 'output_type')
    list_filter = ('async_execution', 'human_input')
    filter_horizontal = ('tools', 'context')
    search_fields = ('description', 'agent__name', 'expected_output')
    readonly_fields = ('output',)

    def output_type(self, obj):
        if obj.output_json:
            return 'JSON'
        elif obj.output_pydantic:
            return 'Pydantic'
        elif obj.output_file:
            return 'File'
        else:
            return 'Default'
    output_type.short_description = 'Output Type'

    fieldsets = (
        (None, {
            'fields': ('description', 'agent', 'expected_output', 'tools', 'async_execution', 'context')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls'),
        }),
        ('Output', {
            'fields': ('output',),
        }),
    )

@admin.register(Tool)
class ToolAdmin(admin.ModelAdmin):
    list_display = ('name', 'description')
    search_fields = ('name', 'description', 'function')

# Register other models
admin.site.register(Pipeline)
admin.site.register(PipelineStage)
admin.site.register(PipelineRoute)
admin.site.register(PipelineExecution)
admin.site.register(PipelineRunResult)

================
File: agents/apps.py
================
from django.apps import AppConfig


class AgentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.agents'
    verbose_name = 'CrewAI Agents'

    def ready(self):
        pass  # We'll add any necessary imports or setup here later if needed

================
File: agents/celery.py
================
from celery import Celery
import os
from django.conf import settings

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

app = Celery('core')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)

================
File: agents/consumers.py
================
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
from .models import CrewExecution, CrewMessage, ChatMessage, Agent
from django.core.cache import cache
from apps.common.utils import format_message, get_llm
from .utils import get_tool_classes
import logging
import uuid
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, FunctionMessage, BaseMessage, messages_from_dict, messages_to_dict
import asyncio
import tiktoken
from langchain_community.chat_models import ChatLiteLLM
from langchain_core.tools import Tool
from django.utils import timezone
from apps.seo_manager.models import Client
from langchain.prompts import ChatPromptTemplate
from langchain.agents import initialize_agent, AgentType, AgentExecutor, create_structured_chat_agent
from langchain.agents.format_scratchpad import format_to_openai_function_messages
from langchain.agents.output_parsers import JSONAgentOutputParser
from langchain_core.callbacks import BaseCallbackHandler
import datetime
from langchain.tools import StructuredTool
from typing import Dict, Any, List
from pydantic import create_model
from langchain.memory import ConversationBufferMemory
from langchain_core.chat_history import BaseChatMessageHistory
import re
import time

logger = logging.getLogger(__name__)

def count_tokens(text):
    """Count tokens in text using tiktoken"""
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

class ConnectionTestConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        await self.accept()
        await self.send(text_data=json.dumps({
            'message': 'Connected to server'
        }))

    async def disconnect(self, close_code):
        pass

    async def receive(self, text_data):
        try:
            text_data_json = json.loads(text_data)
            message = text_data_json['message']

            # Echo the received message back to the client
            await self.send(text_data=json.dumps({
                'message': f'Server received: {message}'
            }))
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'error': 'Invalid JSON format'
            }))
        except KeyError:
            await self.send(text_data=json.dumps({
                'error': 'Missing "message" key in JSON'
            }))

class CrewExecutionConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.execution_id = self.scope['url_route']['kwargs']['execution_id']
        self.execution_group_name = f'crew_execution_{self.execution_id}'

        # Join room group
        await self.channel_layer.group_add(
            self.execution_group_name,
            self.channel_name
        )

        await self.accept()

        # Send initial status
        await self.send_execution_status()

    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.execution_group_name,
            self.channel_name
        )

    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message_type = text_data_json.get('type')

        if message_type == 'human_input':
            input_key = text_data_json.get('input_key')
            user_input = text_data_json.get('input')
            await self.handle_human_input(input_key, user_input)

    async def crew_execution_update(self, event):
        status = event.get('status', '')  # No formatting applied
        formatted_messages = [
            {
                'agent': msg.get('agent', 'System'),
                'content': format_message(msg.get('content', ''))
            } for msg in event.get('messages', []) if msg.get('content')
        ]
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
            'human_input_request': event.get('human_input_request')
        }))

    @database_sync_to_async
    def handle_human_input(self, input_key, user_input):
        cache.set(f"{input_key}_response", user_input, timeout=3600)
        execution = CrewExecution.objects.get(id=self.execution_id)
        CrewMessage.objects.create(
            execution=execution,
            agent='Human',
            content=f"Human input received: {user_input}"
        )

    @database_sync_to_async
    def get_execution_status(self):
        execution = CrewExecution.objects.get(id=self.execution_id)
        messages = CrewMessage.objects.filter(execution=execution).order_by('-timestamp')[:10]
        return {
            'status': execution.status,
            'messages': [{'agent': msg.agent, 'content': msg.content} for msg in messages],
        }

    async def send_execution_status(self):
        status_data = await self.get_execution_status()
        status = status_data['status']  # No formatting applied
        formatted_messages = [
            {
                'agent': msg['agent'],
                'content': format_message(msg['content'])
            } for msg in status_data['messages'] if msg.get('content')
        ]
        
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
        }))

================
File: agents/forms.py
================
import random
from django.conf import settings
from django import forms
from .models import CrewExecution, Agent, Task, Tool, Crew, get_available_tools, AVATAR_CHOICES
from apps.seo_manager.models import Client
from apps.common.utils import get_models
import json
import logging
from .utils import get_available_tools, get_tool_classes

logger = logging.getLogger(__name__)

class CrewExecutionForm(forms.ModelForm):
    inputs = forms.JSONField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = CrewExecution
        fields = ['inputs']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['inputs'].widget.attrs['class'] = 'form-control'
        self.fields['inputs'].help_text = 'Enter JSON formatted inputs for the crew execution.'

    def clean_inputs(self):
        inputs = self.cleaned_data.get('inputs')
        if inputs:
            try:
                return json.loads(inputs)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in inputs field")
        return {}

class HumanInputForm(forms.Form):
    response = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=True)

class AgentForm(forms.ModelForm):
    avatar = forms.ChoiceField(
        choices=[(choice, choice) for choice in AVATAR_CHOICES],
        widget=forms.RadioSelect(),
        required=False
    )
    llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=True
    )
    function_calling_llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=False
    )
    
    tools = forms.ModelMultipleChoiceField(
        queryset=Tool.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False
    )

    class Meta:
        model = Agent
        fields = '__all__'  # Include all fields from the model
        widgets = {
            'goal': forms.Textarea(attrs={'rows': 3}),
            'backstory': forms.Textarea(attrs={'rows': 3}),
            'system_template': forms.Textarea(attrs={'rows': 4}),
            'prompt_template': forms.Textarea(attrs={'rows': 4}),
            'response_template': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.SelectMultiple(attrs={'class': 'form-select'}),
            'llm': forms.Select(attrs={'class': 'form-select'}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for field in self.fields:
            if isinstance(self.fields[field].widget, forms.CheckboxInput):
                self.fields[field].widget.attrs['class'] = 'form-check-input'
            elif not isinstance(self.fields[field].widget, (forms.SelectMultiple, forms.RadioSelect)):
                self.fields[field].widget.attrs['class'] = 'form-control'

        # Ensure avatar choices are set
        self.fields['avatar'].choices = [(choice, choice) for choice in AVATAR_CHOICES]

        # Ensure the initial values are set correctly
        self.initial['llm'] = self.initial.get('llm', settings.GENERAL_MODEL)
        self.initial['function_calling_llm'] = self.initial.get('function_calling_llm', settings.GENERAL_MODEL)

    def clean(self):
        cleaned_data = super().clean()
        logger.debug(f"Cleaned form data: {cleaned_data}")
        return cleaned_data

    def save(self, commit=True):
        logger.debug(f"Saving form with data: {self.cleaned_data}")
        instance = super().save(commit=False)
        # Ensure LLM values are set on the instance
        instance.llm = self.cleaned_data.get('llm')
        instance.function_calling_llm = self.cleaned_data.get('function_calling_llm')
        if commit:
            instance.save()
            self.save_m2m()
        logger.debug(f"Saved instance: {instance.__dict__}")
        return instance

class TaskForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = Task
        fields = ['description', 'agent', 'expected_output', 'tools', 'async_execution', 'context', 'config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
            'expected_output': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.CheckboxSelectMultiple(),
            'context': forms.CheckboxSelectMultiple(),
            'output_json': forms.TextInput(),
            'output_pydantic': forms.TextInput(),
            'output_file': forms.TextInput(attrs={'placeholder': 'e.g., outputs/task_result.txt'}),
            'converter_cls': forms.TextInput(),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)

    def clean_config(self):
        config = self.cleaned_data.get('config')
        if config:
            try:
                return json.loads(config)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in config field")
        return None

    def clean_output_file(self):
        output_file = self.cleaned_data.get('output_file')
        if output_file:
            # You can add additional validation here if needed
            # For example, check if the path is within allowed directories
            pass
        return output_file

class ToolForm(forms.ModelForm):
    tool_class = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    tool_subclass = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    description = forms.CharField(widget=forms.Textarea(attrs={'readonly': 'readonly'}), required=False)

    class Meta:
        model = Tool
        fields = ['tool_class', 'tool_subclass', 'name', 'description']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_tools = get_available_tools()
        self.fields['tool_class'].choices = [(tool, tool) for tool in available_tools]
        self.fields['name'].widget = forms.HiddenInput()
        self.fields['name'].required = False
        
        if self.data.get('tool_class'):
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.data['tool_class'])
        elif self.instance.pk:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.instance.tool_class)

    def get_subclass_choices(self, tool_class):
        subclasses = get_tool_classes(tool_class)
        return [(cls.__name__, cls.__name__) for cls in subclasses]

    def clean(self):
        cleaned_data = super().clean()
        tool_class = cleaned_data.get('tool_class')
        tool_subclass = cleaned_data.get('tool_subclass')

        if tool_class:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(tool_class)

        if tool_class and tool_subclass:
            subclasses = dict(self.fields['tool_subclass'].choices)
            if tool_subclass not in subclasses:
                raise forms.ValidationError(f"Invalid tool subclass '{tool_subclass}' for tool class '{tool_class}'")

        # Set the name field to the value of tool_subclass
        cleaned_data['name'] = tool_subclass

        return cleaned_data

    def save(self, commit=True):
        instance = super().save(commit=False)
        instance.name = self.cleaned_data['tool_subclass']
        if commit:
            instance.save()
        return instance

class CrewForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    manager_callbacks = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    agents = forms.ModelMultipleChoiceField(
        queryset=Agent.objects.all(),
        required=False,
        widget=forms.SelectMultiple(attrs={'class': 'form-control form-select'})
    )

    class Meta:
        model = Crew
        fields = [
            'name', 'agents', 'tasks', 'process', 'verbose', 'manager_llm',
            'function_calling_llm', 'config', 'max_rpm', 'language',
            'language_file', 'memory', 'cache', 'embedder', 'full_output',
            'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks',
            'prompt_file', 'planning', 'planning_llm'
        ]
        # Note: input_variables is not included here as it's handled separately in the view

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_models = get_models()
        self.fields['manager_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['function_calling_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['planning_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['max_rpm'].widget.attrs['min'] = 0
        self.fields['max_rpm'].widget.attrs['step'] = 1

        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)
        if self.instance.manager_callbacks:
            self.initial['manager_callbacks'] = json.dumps(self.instance.manager_callbacks, indent=2)
        if self.instance.embedder:
            self.initial['embedder'] = json.dumps(self.instance.embedder, indent=2)

        # Remove the 'required' attribute from the agents field
        if 'agents' in self.fields:
            self.fields['agents'].required = False

        print(f"Initial manager_llm: {self.initial.get('manager_llm')}")  # Debugging line
        print(f"Initial function_calling_llm: {self.initial.get('function_calling_llm')}")  # Debugging line

    def clean_config(self):
        return self._clean_json_field('config')

    def clean_manager_callbacks(self):
        return self._clean_json_field('manager_callbacks')

    def clean_embedder(self):
        return self._clean_json_field('embedder')

    def _clean_json_field(self, field_name):
        data = self.cleaned_data.get(field_name)
        if data:
            try:
                return json.loads(data)
            except json.JSONDecodeError:
                raise forms.ValidationError(f"Invalid JSON format in {field_name} field")
        return None

================
File: agents/kanban_consumers.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
import logging

logger = logging.getLogger(__name__)
User = get_user_model()

class CrewKanbanConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        """
        Handle WebSocket connection setup
        """
        self.crew_id = self.scope['url_route']['kwargs']['crew_id']
        self.room_group_name = f'crew_{self.crew_id}_kanban'
        self.is_connected = False
        
        try:
            # Add to crew group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            await self.accept()
            self.is_connected = True
            logger.info(f"WebSocket connection established for crew {self.crew_id}")
        except Exception as e:
            logger.error(f"Error establishing WebSocket connection: {str(e)}")
            if not self.is_connected:
                await self.close()
    
    async def disconnect(self, close_code):
        """
        Handle WebSocket disconnection cleanup
        """
        try:
            self.is_connected = False
            await self.channel_layer.group_discard(
                self.room_group_name,
                self.channel_name
            )
            logger.info(f"WebSocket connection closed for crew {self.crew_id} with code {close_code}")
        except Exception as e:
            logger.error(f"Error during WebSocket disconnect: {str(e)}")
    
    async def receive(self, text_data):
        """
        Handle incoming WebSocket messages
        """
        if not self.is_connected:
            logger.warning("Received message but WebSocket is not connected")
            return
            
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            logger.debug(f"Received WebSocket message: {message_type}")
            
            # Handle ping messages immediately
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong'
                }))
                return
            
            handlers = {
                'execution_update': self.handle_execution_update,
                'agent_step': self.handle_agent_step,
                'human_input_request': self.handle_human_input_request,
                'task_complete': self.handle_task_complete
            }
            
            handler = handlers.get(message_type)
            if handler:
                await handler(data)
            else:
                logger.warning(f"Unknown message type received: {message_type}")
        
        except json.JSONDecodeError:
            logger.error(f"Failed to decode WebSocket message: {text_data}")
        except Exception as e:
            logger.error(f"Error processing WebSocket message: {str(e)}")
            if self.is_connected:
                await self.send(text_data=json.dumps({
                    'type': 'error',
                    'message': 'Internal server error occurred'
                }))
    
    async def handle_execution_update(self, data):
        """Handle execution status updates"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id from execution
            execution_id = data.get('execution_id')
            if execution_id:
                crewai_task_id = await self.get_task_id_for_execution(execution_id)
                data['crewai_task_id'] = crewai_task_id
            
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'execution_update',
                    **data
                }
            )
            logger.debug(f"Sent execution update for execution {execution_id}")
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            # Don't try to send error message if we already know connection is broken
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def handle_agent_step(self, data):
        """Handle individual agent step updates"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'agent_step',
                    'execution_id': data.get('execution_id'),
                    'agent': data.get('agent', ''),
                    'content': data.get('content', ''),
                    'step_type': data.get('step_type', ''),
                    'is_final_step': data.get('is_final_step', False)
                }
            )
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def handle_human_input_request(self, data):
        """Handle requests for human input"""
        if not self.is_connected:
            logger.warning("Cannot send human input request - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'human_input_request',
                    'execution_id': data.get('execution_id'),
                    'prompt': data.get('prompt', ''),
                    'context': data.get('context', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send human input request'
                    }))
                except:
                    pass

    async def handle_task_complete(self, data):
        """Handle task completion notifications"""
        if not self.is_connected:
            logger.warning("Cannot send task complete - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'task_complete',
                    'execution_id': data.get('execution_id'),
                    'message': data.get('message', ''),
                    'results': data.get('results', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending task complete: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send task complete'
                    }))
                except:
                    pass
    
    # WebSocket send handlers
    async def execution_update(self, event):
        """Send execution updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Ensure stage data has all required fields
            stage = event.get('stage', {})
            if stage:
                stage.setdefault('stage_type', 'processing')
                stage.setdefault('title', 'Processing...')
                stage.setdefault('content', '')
                stage.setdefault('status', 'in_progress')
                stage.setdefault('agent', 'System')
                stage.setdefault('completed', False)
                
                # Mark stage as completed if status is 'completed'
                if stage.get('status') == 'completed':
                    stage['completed'] = True
                
                # Ensure chat_message_prompts exists and has at least one item
                if 'chat_message_prompts' not in stage:
                    stage['chat_message_prompts'] = [{
                        'role': 'system',
                        'content': stage.get('content', 'Processing task...')
                    }]
            
            # Use the crewai_task_id directly from the event
            crewai_task_id = event.get('crewai_task_id')
            if not crewai_task_id:
                logger.debug(f"No CrewAI task ID provided in event for execution {event.get('execution_id')}")
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': event['execution_id'],  # Internal execution ID
                'status': event['status'],
                'crewai_task_id': crewai_task_id,  # Use task ID from event for kanban board placement
                'message': event.get('message'),
                'stage': stage
            }))
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def agent_step(self, event):
        """Send agent step updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id for this execution
            execution_id = event['execution_id']
            crewai_task_id = await self.get_task_id_for_execution(execution_id)
            
            # Format agent step as a stage update with chat_message_prompts
            stage_data = {
                'stage_type': event.get('step_type', 'agent_step'),
                'title': f"Agent: {event.get('agent', 'System')}",
                'content': event.get('content', ''),
                'status': 'in_progress',
                'agent': event.get('agent', 'System'),
                'completed': False,
                'chat_message_prompts': [{
                    'role': 'assistant',
                    'content': event.get('content', '')
                }]
            }
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': execution_id,
                'crewai_task_id': crewai_task_id,
                'stage': stage_data
            }))
            
            # Send a completion update for this stage if it's the final step
            if event.get('is_final_step', False):
                stage_data.update({
                    'status': 'completed',
                    'completed': True
                })
                await self.send(text_data=json.dumps({
                    'type': 'execution_update',
                    'execution_id': execution_id,
                    'crewai_task_id': crewai_task_id,
                    'stage': stage_data
                }))
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def human_input_request(self, event):
        """Send human input requests to WebSocket"""
        await self.send(text_data=json.dumps({
            'type': 'human_input_request',
            'execution_id': event['execution_id'],
            'prompt': event['prompt'],
            'context': event['context']
        }))
    
    async def task_complete(self, event):
        """Send task completion notifications to WebSocket"""
        execution_id = event['execution_id']
        crewai_task_id = await self.get_task_id_for_execution(execution_id)
        
        await self.send(text_data=json.dumps({
            'type': 'task_complete',
            'execution_id': execution_id,
            'crewai_task_id': crewai_task_id,
            'message': event['message'],
            'results': event['results']
        }))

    @database_sync_to_async
    def get_task_id_for_execution(self, execution_id):
        """Get CrewAI task ID for a given execution"""
        from .models import CrewExecution
        try:
            execution = CrewExecution.objects.get(id=execution_id)
            # Get the latest execution stage for this execution
            latest_stage = execution.executionstage_set.order_by('-created_at').first()
            return latest_stage.crewai_task_id if latest_stage else None
        except CrewExecution.DoesNotExist:
            return None

================
File: agents/models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from apps.common.utils import get_models
from pydantic import BaseModel
import os
import importlib
import logging
import uuid
import random
import json
from django.contrib.postgres.fields import ArrayField
from django.conf import settings
from apps.agents.utils import load_tool, get_tool_description

logger = logging.getLogger(__name__)

User = get_user_model()

import glob

def get_agent_avatars():
    # Get the default avatar list
    default_avatars = [
        'team-5.jpg', 'team-4.jpg', 'team-3.jpg', 'team-2.jpg', 'kal-visuals-square.jpg',
        'team-1.jpg', 'marie.jpg', 'ivana-squares.jpg', 'ivana-square.jpg'
    ]
    
    # Get additional avatars from static directory
    static_path = os.path.join('static', 'assets', 'img', 'agent-avatar*')
    additional_avatars = [os.path.basename(f) for f in glob.glob(static_path)]
    
    return default_avatars + additional_avatars

AVATAR_CHOICES = get_agent_avatars()

def random_avatar():
    return random.choice(AVATAR_CHOICES)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for dir_name in dirs:
            if not dir_name.startswith('__'):  # Exclude directories like __pycache__
                tool_path = os.path.relpath(os.path.join(root, dir_name), tools_dir)
                available_tools.append(tool_path.replace(os.path.sep, '.'))

    return available_tools

def default_embedder():
    return {'provider': 'openai'}

def user_directory_path(instance, filename):
    # File will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    return f'user_{instance.crew_execution.user.id}/{filename}'

class Tool(models.Model):
    tool_class = models.CharField(max_length=255)
    tool_subclass = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    module_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.module_path:
            self.module_path = f"apps.agents.tools.{self.tool_class}"
        
        try:
            tool = load_tool(self)
            if tool:
                self.name = getattr(tool, 'name', self.tool_subclass)
                self.description = get_tool_description(tool.__class__)
            else:
                raise ValueError(f"Failed to load tool: {self.module_path}.{self.tool_subclass}. Check the logs for more details.")
        except Exception as e:
            logger.error(f"Error in Tool.save: {str(e)}")
            raise ValidationError(f"Error loading tool: {str(e)}")

        super().save(*args, **kwargs)

class ToolRun(models.Model):
    """Model to track tool executions"""
    TOOL_RUN_STATUS = (
        ('pending', 'Pending'),
        ('running', 'Running'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )
    
    tool = models.ForeignKey(Tool, on_delete=models.CASCADE)
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    message = models.ForeignKey('ChatMessage', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    status = models.CharField(max_length=20, choices=TOOL_RUN_STATUS, default='pending')
    inputs = models.JSONField()
    result = models.JSONField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.tool.name} - {self.status} ({self.created_at})"

class Agent(models.Model):
    name = models.CharField(max_length=255)
    role = models.CharField(max_length=100)
    goal = models.TextField()
    backstory = models.TextField()
    llm = models.CharField(max_length=100, default=settings.GENERAL_MODEL)
    tools = models.ManyToManyField(Tool, blank=True)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    max_iter = models.IntegerField(default=25)
    max_rpm = models.IntegerField(null=True, blank=True)
    max_execution_time = models.IntegerField(null=True, blank=True)
    verbose = models.BooleanField(default=False)
    allow_delegation = models.BooleanField(default=False)
    step_callback = models.CharField(max_length=255, null=True, blank=True)
    cache = models.BooleanField(default=True)
    system_template = models.TextField(null=True, blank=True)
    prompt_template = models.TextField(null=True, blank=True)
    response_template = models.TextField(null=True, blank=True)
    allow_code_execution = models.BooleanField(default=False)
    max_retry_limit = models.IntegerField(default=2)
    use_system_prompt = models.BooleanField(default=True)
    respect_context_window = models.BooleanField(default=True)
    avatar = models.CharField(max_length=100, default=random_avatar)

    def __str__(self):
        return self.name

    def clean(self):
        super().clean()
        available_models = get_models()
        if self.llm not in available_models:
            raise ValidationError({'llm': f"Selected LLM '{self.llm}' is not available. Please choose from: {', '.join(available_models)}"})

    def get_tool_settings(self, tool):
        """Get settings for a specific tool."""
        return self.tool_settings.filter(tool=tool).first()

    def get_forced_output_tools(self):
        """Get all tools that have force_output_as_result=True."""
        return self.tools.filter(
            id__in=self.tool_settings.filter(
                force_output_as_result=True
            ).values_list('tool_id', flat=True)
        )

    def has_force_output_enabled(self, tool):
        """Check if force output is enabled for a specific tool."""
        tool_setting = self.tool_settings.filter(tool=tool).first()
        return tool_setting.force_output_as_result if tool_setting else False

class Task(models.Model):
    description = models.TextField()
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    expected_output = models.TextField()
    tools = models.ManyToManyField(Tool, blank=True)
    async_execution = models.BooleanField(default=False)
    context = models.ManyToManyField('self', symmetrical=False, blank=True)
    config = models.JSONField(null=True, blank=True)
    output_json = models.CharField(max_length=255, null=True, blank=True)
    output_pydantic = models.CharField(max_length=255, null=True, blank=True)
    output_file = models.CharField(max_length=255, null=True, blank=True)
    output = models.TextField(null=True, blank=True)
    callback = models.CharField(max_length=255, null=True, blank=True)
    human_input = models.BooleanField(default=False)
    converter_cls = models.CharField(max_length=255, null=True, blank=True)
    crew_execution = models.ForeignKey('CrewExecution', on_delete=models.CASCADE, null=True, blank=True)

    def __str__(self):
        return self.description[:50]

    def save_output_file(self, content):
        if self.output_file:
            file_name = os.path.basename(self.output_file)
        else:
            file_name = f"task_{self.id}_output.txt"
        
        file_path = user_directory_path(self, file_name)
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        
        with open(full_path, 'w') as f:
            f.write(content)
        
        self.output_file = file_path
        self.save()

class Crew(models.Model):
    name = models.CharField(max_length=100)
    agents = models.ManyToManyField(Agent)
    tasks = models.ManyToManyField(Task, through='CrewTask')
    process = models.CharField(max_length=20, choices=[('sequential', 'Sequential'), ('hierarchical', 'Hierarchical')], default='sequential')
    verbose = models.BooleanField(default=False)
    manager_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    config = models.JSONField(null=True, blank=True)
    max_rpm = models.IntegerField(null=True, blank=True)
    language = models.CharField(max_length=50, default='English')
    language_file = models.CharField(max_length=255, null=True, blank=True)
    memory = models.BooleanField(default=False)
    cache = models.BooleanField(default=True)
    embedder = models.JSONField(default=default_embedder)
    full_output = models.BooleanField(default=False)
    share_crew = models.BooleanField(default=False)
    output_log_file = models.CharField(max_length=255, null=True, blank=True)
    manager_agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True, related_name='managed_crews')
    manager_callbacks = models.JSONField(null=True, blank=True)
    prompt_file = models.CharField(max_length=255, null=True, blank=True)
    planning = models.BooleanField(default=False)
    planning_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    input_variables = ArrayField(
        models.CharField(max_length=100),
        blank=True,
        null=True,
        default=list
    )

    def __str__(self):
        return self.name

class CrewExecution(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE)
    status = models.CharField(max_length=25, choices=[
        ('PENDING', 'Pending'),
        ('RUNNING', 'Running'),
        ('WAITING_FOR_HUMAN_INPUT', 'Waiting for Human Input'),
        ('COMPLETED', 'Completed'),
        ('FAILED', 'Failed')
    ], default='PENDING')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    inputs = models.JSONField(null=True, blank=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE, null=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)
    crew_output = models.OneToOneField('CrewOutput', on_delete=models.SET_NULL, null=True, blank=True, related_name='crew_execution')
    task_id = models.CharField(max_length=100, null=True, blank=True)
    human_input_request = models.JSONField(null=True, blank=True)
    human_input_response = models.JSONField(null=True, blank=True)
    error_message = models.TextField(blank=True, null=True)

    def __str__(self):
        return f"{self.crew.name} - {self.created_at}"

    def save_task_output_file(self, task, content):
        task.crew_execution = self
        task.save_output_file(content)

class CrewMessage(models.Model):
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='messages')
    content = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    agent = models.CharField(max_length=255, null=True, blank=True)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement

    def __str__(self):
        return f"{self.timestamp}: {self.content[:50]}"

class Pipeline(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    status = models.CharField(max_length=20, default='Idle')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

    def clean(self):
        # Validate that stages are properly structured
        stages = self.stages.all().order_by('order')
        for stage in stages:
            if stage.is_parallel:
                if stage.crew is not None:
                    raise ValidationError("Parallel stages should not have a single crew assigned.")
            else:
                if stage.crew is None:
                    raise ValidationError("Sequential stages must have a crew assigned.")

class PipelineStage(models.Model):
    pipeline = models.ForeignKey(Pipeline, related_name='stages', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    crew = models.ForeignKey('Crew', on_delete=models.SET_NULL, null=True, blank=True)
    order = models.PositiveIntegerField()
    is_parallel = models.BooleanField(default=False)
    is_router = models.BooleanField(default=False)

    class Meta:
        ordering = ['order']

    def __str__(self):
        return f"{self.pipeline.name} - {self.name}"

    def clean(self):
        if self.is_router and self.crew is not None:
            raise ValidationError("Router stages should not have a crew assigned.")

class PipelineRoute(models.Model):
    stage = models.ForeignKey(PipelineStage, related_name='routes', on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    condition = models.TextField()  # This would store a serialized form of the condition
    target_pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.stage.name} - {self.name}"

class PipelineExecution(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    pipeline = models.ForeignKey(Pipeline, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, default='Pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.pipeline.name} Execution - {self.created_at}"

class PipelineRunResult(models.Model):
    execution = models.ForeignKey(PipelineExecution, related_name='run_results', on_delete=models.CASCADE)
    raw_output = models.TextField(blank=True)
    json_output = models.JSONField(null=True, blank=True)
    pydantic_output = models.TextField(null=True, blank=True)  # This would store a serialized form of the Pydantic model
    token_usage = models.JSONField(null=True, blank=True)
    trace = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"Run Result for {self.execution.pipeline.name}"

class CrewOutput(models.Model):
    raw = models.TextField()
    pydantic = models.JSONField(null=True, blank=True)
    json_dict = models.JSONField(null=True, blank=True)
    token_usage = models.JSONField(null=True, blank=True)

    @property
    def json(self):
        return json.dumps(self.json_dict) if self.json_dict else None

    def to_dict(self):
        return self.json_dict or (self.pydantic.dict() if self.pydantic else None) or {}

    def __str__(self):
        if self.pydantic:
            return str(self.pydantic)
        elif self.json_dict:
            return json.dumps(self.json_dict)
        else:
            return self.raw

    def save(self, *args, **kwargs):
        # Convert UsageMetrics to a dictionary if it's not already
        if self.token_usage and hasattr(self.token_usage, 'dict'):
            self.token_usage = self.token_usage.dict()
        super().save(*args, **kwargs)

class CrewTask(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE, related_name='crew_tasks')
    task = models.ForeignKey(Task, on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['order']
        unique_together = ('crew', 'task')

    def __str__(self):
        return f"{self.crew.name} - {self.task.description} (Order: {self.order})"

class AgentToolSettings(models.Model):
    agent = models.ForeignKey('Agent', on_delete=models.CASCADE, related_name='tool_settings')
    tool = models.ForeignKey('Tool', on_delete=models.CASCADE)
    force_output_as_result = models.BooleanField(default=False)

    class Meta:
        unique_together = ('agent', 'tool')


class ExecutionStage(models.Model):
    STAGE_TYPES = [
        ('task_start', 'Task Start'),
        ('thinking', 'Thinking'),
        ('tool_usage', 'Tool Usage'),
        ('tool_results', 'Tool Results'),
        ('human_input', 'Human Input'),
        ('completion', 'Completion')
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ]
    
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='stages')
    stage_type = models.CharField(max_length=20, choices=STAGE_TYPES)
    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    metadata = models.JSONField(default=dict)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'Execution Stage'
        verbose_name_plural = 'Execution Stages'
    
    def __str__(self):
        return f"{self.get_stage_type_display()} - {self.title}"

class Conversation(models.Model):
    session_id = models.UUIDField(unique=True)
    user = models.ForeignKey(get_user_model(), on_delete=models.CASCADE)
    agent = models.ForeignKey('Agent', on_delete=models.SET_NULL, null=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.SET_NULL, null=True)
    title = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ['-updated_at']

    def __str__(self):
        return f"{self.title} ({self.created_at.strftime('%Y-%m-%d %H:%M')})"

class ChatMessage(models.Model):
    """Model for storing chat messages."""
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE)
    session_id = models.CharField(max_length=255)
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    is_agent = models.BooleanField(default=False)
    is_deleted = models.BooleanField(default=False)  # Track if message is deleted
    timestamp = models.DateTimeField(auto_now_add=True)
    model = models.CharField(max_length=255, default='unknown')

    class Meta:
        ordering = ['timestamp']
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
            models.Index(fields=['session_id']),
            models.Index(fields=['is_deleted']),  # Add index for is_deleted field
        ]

    def __str__(self):
        return f"{self.timestamp}: {'Agent' if self.is_agent else 'User'} - {self.content[:50]}..."

class TokenUsage(models.Model):
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='token_usage')
    message = models.ForeignKey('ChatMessage', on_delete=models.SET_NULL, null=True, blank=True)
    tool_run = models.ForeignKey('ToolRun', on_delete=models.SET_NULL, null=True, blank=True)
    prompt_tokens = models.IntegerField(default=0)
    completion_tokens = models.IntegerField(default=0)
    total_tokens = models.IntegerField(default=0)
    model = models.CharField(max_length=100)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)  # Changed from JSONField to models.JSONField

    class Meta:
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
        ]

    def __str__(self):
        return f"{self.conversation_id} - {self.total_tokens} tokens"

class UserSlackIntegration(models.Model):
    """Store Slack integration details for users"""
    user = models.OneToOneField(get_user_model(), on_delete=models.CASCADE)
    access_token = models.CharField(max_length=255)
    team_id = models.CharField(max_length=32)
    team_name = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'user_slack_integrations'

    def __str__(self):
        return f"{self.user.username} - {self.team_name}"

================
File: agents/routing.py
================
from django.urls import re_path
from .consumers import ConnectionTestConsumer, ChatConsumer, CrewExecutionConsumer
from .kanban_consumers import CrewKanbanConsumer

websocket_urlpatterns = [
    re_path(r'ws/chat/$', ChatConsumer.as_asgi()),
    re_path(r'ws/crew_execution/(?P<execution_id>\w+)/$', CrewExecutionConsumer.as_asgi()),
    re_path(r'ws/test-connection/$', ConnectionTestConsumer.as_asgi()),
]

================
File: agents/tasks.py
================
from celery import shared_task
import asyncio
import logging
from .utils import load_tool
from django.shortcuts import get_object_or_404
from .models import Tool, ToolRun
import inspect
import json
import traceback

logger = logging.getLogger(__name__)

@shared_task(bind=True)
def run_tool(self, tool_id: int, inputs: dict):
    """Generic Celery task to run any tool"""
    try:
        # Load the tool
        tool = get_object_or_404(Tool, id=tool_id)
        tool_instance = load_tool(tool)
        
        if tool_instance is None:
            raise ValueError('Failed to load tool')

        # Create a tool run record
        tool_run = ToolRun.objects.create(
            tool=tool,
            status='running',
            inputs=inputs
        )
        
        try:
            # Process inputs if tool has args_schema
            if hasattr(tool_instance, 'args_schema'):
                processed_inputs = {}
                for key, value in inputs.items():
                    if value != '':
                        try:
                            processed_inputs[key] = json.loads(value)
                        except json.JSONDecodeError:
                            processed_inputs[key] = value
                            
                validated_inputs = tool_instance.args_schema(**processed_inputs)
                inputs = validated_inputs.dict()
            
            # Run the tool
            if inspect.iscoroutinefunction(tool_instance._run):
                # Create event loop for async tools
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    result = loop.run_until_complete(tool_instance._run(**inputs))
                finally:
                    loop.close()
            else:
                # Run sync tools directly
                result = tool_instance._run(**inputs)
            
            # Update tool run record with success
            tool_run.status = 'completed'
            tool_run.result = result
            tool_run.save()
            
            return {
                'status': 'completed',
                'result': result,
                'tool_run_id': tool_run.id
            }
            
        except Exception as e:
            # Update tool run record with error
            tool_run.status = 'failed'
            tool_run.error = str(e)
            tool_run.save()
            raise
            
    except Exception as e:
        logger.error(f"Error running tool: {str(e)}\n{traceback.format_exc()}")
        return {
            'status': 'failed',
            'error': str(e)
        }

================
File: agents/tests.py
================
from django.test import TestCase
from django.contrib.auth import get_user_model
from .models import Crew, CrewExecution, CrewMessage
from .tasks import execute_crew, resume_crew_execution
from unittest.mock import patch

User = get_user_model()

class CrewExecutionTestCase(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testuser', password='12345')
        self.crew = Crew.objects.create(name='Test Crew', process='sequential')
        self.execution = CrewExecution.objects.create(
            crew=self.crew,
            user=self.user,
            inputs={'test_input': 'value'}
        )

    @patch('apps.agents.tasks.run_crew')
    def test_execute_crew(self, mock_run_crew):
        mock_run_crew.return_value = {'test_output': 'result'}
        
        execute_crew(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'COMPLETED')
        self.assertEqual(self.execution.outputs, {'test_output': 'result'})

    @patch('apps.agents.tasks.run_crew')
    def test_execute_crew_human_input_required(self, mock_run_crew):
        from .tasks import HumanInputRequired
        mock_run_crew.side_effect = HumanInputRequired('Test human input required')
        
        execute_crew(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'WAITING_FOR_HUMAN_INPUT')
        self.assertEqual(self.execution.human_input_request, 'Test human input required')

    @patch('apps.agents.tasks.run_crew')
    def test_resume_crew_execution(self, mock_run_crew):
        mock_run_crew.return_value = {'test_output': 'result after human input'}
        
        self.execution.status = 'WAITING_FOR_HUMAN_INPUT'
        self.execution.human_input_response = 'Test human input'
        self.execution.save()
        
        resume_crew_execution(self.execution.id)
        
        self.execution.refresh_from_db()
        self.assertEqual(self.execution.status, 'COMPLETED')
        self.assertEqual(self.execution.outputs, {'test_output': 'result after human input'})

    def test_crew_message_creation(self):
        CrewMessage.objects.create(
            execution=self.execution,
            content='Test message'
        )
        
        self.assertEqual(CrewMessage.objects.count(), 1)
        self.assertEqual(CrewMessage.objects.first().content, 'Test message')

================
File: agents/tools.py
================


================
File: agents/urls.py
================
from django.urls import path
from . import views
from . import views_agents
from . import views_tasks
from . import views_tools
from . import views_crews
from . import views_kanban
from . import views_chat
from .views_chat import ChatView


app_name = 'agents'

urlpatterns = [
    path('', views.crewai_home, name='crewai_home'),
    path('crews/', views.crew_list, name='crew_list'),
    path('crew/<int:crew_id>/', views.crew_detail, name='crew_detail'),
    path('crew/<int:crew_id>/kanban/', views_kanban.crew_kanban, name='crew_kanban'),
    path('crew/<int:crew_id>/start-execution/', views_kanban.start_execution, name='start_execution'),
    path('crew/<int:crew_id>/active-executions/', views_kanban.get_active_executions, name='get_active_executions'),
    path('crew/execution/<int:execution_id>/input/', views_kanban.submit_human_input, name='submit_human_input'),
    path('executions/', views.execution_list, name='execution_list'),
    path('execution/<int:execution_id>/', views_kanban.execution_detail, name='execution_detail'),
    path('execution/<int:execution_id>/status/', views_kanban.get_active_executions, name='execution_status'),
    path('execution/<int:execution_id>/submit_human_input/', views.submit_human_input, name='submit_human_input'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    
    # Admin views
    path('manage/agents/', views_agents.manage_agents, name='manage_agents'),
    path('manage/agents/add/', views_agents.add_agent, name='add_agent'),
    path('manage/agents/edit/<int:agent_id>/', views_agents.edit_agent, name='edit_agent'),
    path('manage/agents/delete/<int:agent_id>/', views_agents.delete_agent, name='delete_agent'),
    
    path('manage/tasks/', views_tasks.manage_tasks, name='manage_tasks'),
    path('manage/tasks/add/', views_tasks.add_task, name='add_task'),
    path('manage/tasks/edit/<int:task_id>/', views_tasks.edit_task, name='edit_task'),
    path('manage/tasks/delete/<int:task_id>/', views_tasks.delete_task, name='delete_task'),
    
    path('manage/tools/', views_tools.manage_tools, name='manage_tools'),
    path('manage/tools/add/', views_tools.add_tool, name='add_tool'),
    path('manage/tools/edit/<int:tool_id>/', views_tools.edit_tool, name='edit_tool'),
    path('manage/tools/delete/<int:tool_id>/', views_tools.delete_tool, name='delete_tool'),
    path('tool-schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test-tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),
    path('tool-status/<str:task_id>/', views_tools.get_tool_status, name='get_tool_status'),
    path('get_tool_info/', views_tools.get_tool_info, name='get_tool_info'),
    path('get_tool_schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test_tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),  # Django 3.1+ automatically handles async views
    path('manage/crews/', views_crews.manage_crews, name='manage_crews'),
    path('manage/crews/add/', views_crews.crew_create_or_update, name='add_crew'),
    path('manage/crews/edit/<int:crew_id>/', views_crews.crew_create_or_update, name='edit_crew'),
    path('manage/crews/delete/<int:crew_id>/', views_crews.delete_crew, name='delete_crew'),
    path('manage/crews/update_agents/<int:crew_id>/', views_crews.update_crew_agents, name='update_crew_agents'),
    
    path('pipelines/', views.manage_pipelines, name='manage_pipelines'),
    path('manage/agents/card-view/', views_agents.manage_agents_card_view, name='manage_agents_card_view'),
    path('manage/crews/card-view/', views_crews.manage_crews_card_view, name='manage_crews_card_view'),
    
    path('connection-test/', views.connection_test, name='connection_test'),
    path('chat/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/delete/', views_chat.delete_conversation, name='delete_conversation'),
    
    # Slack OAuth
    path('slack/oauth/start/', views.slack_oauth_start, name='slack_oauth_start'),
    path('slack/oauth/callback/', views.slack_oauth_callback, name='slack_oauth_callback'),
]

================
File: agents/utils.py
================
import os
import importlib
from crewai_tools import BaseTool as CrewAIBaseTool
from langchain.tools import BaseTool as LangChainBaseTool
import logging
import crewai_tools
from typing import Optional
from django.core.cache import cache
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import re

logger = logging.getLogger(__name__)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for item in dirs + files:
            if item.endswith('.py') and not item.startswith('__'):
                rel_path = os.path.relpath(os.path.join(root, item), tools_dir)
                module_path = os.path.splitext(rel_path)[0].replace(os.path.sep, '.')
                available_tools.append(module_path)

    return available_tools

def get_tool_classes(tool_path):
    module_path = f"apps.agents.tools.{tool_path}"
    if module_path.endswith('.py'):
        module_path = module_path[:-3]
    try:
        module = importlib.import_module(module_path)
    except ImportError as e:
        logger.error(f"Failed to import module {module_path}: {e}")
        return []
    
    tool_classes = []
    for name, obj in module.__dict__.items():
        if isinstance(obj, type) and name.endswith('Tool'):
            try:
                if issubclass(obj, (CrewAIBaseTool, LangChainBaseTool)) or (hasattr(obj, '_run') and callable(getattr(obj, '_run'))):
                    if not any(issubclass(other, obj) and other != obj for other in module.__dict__.values() if isinstance(other, type)):
                        tool_classes.append(obj)
            except TypeError:
                # This can happen if obj is not a class or doesn't inherit from the expected base classes
                logger.warning(f"Skipping {name} as it's not a valid tool class")
    
    logger.debug(f"Found tool classes for {tool_path}: {[cls.__name__ for cls in tool_classes]}")
    return tool_classes

def get_tool_description(tool_class_obj):
    logger.debug(f"Attempting to get description for {tool_class_obj}")

    if hasattr(tool_class_obj, 'description'):
        description = getattr(tool_class_obj, 'description')
        if isinstance(description, str):
            logger.debug(f"Found description class attribute: {description}")
            return description

    if hasattr(tool_class_obj, 'name'):
        name = getattr(tool_class_obj, 'name')
        if isinstance(name, str):
            logger.debug(f"Found name class attribute: {name}")
            return name

    if hasattr(tool_class_obj, '__annotations__') and 'description' in tool_class_obj.__annotations__:
        description = tool_class_obj.__annotations__['description']
        if isinstance(description, str):
            logger.debug(f"Found description in class annotations: {description}")
            return description

    if hasattr(tool_class_obj, 'model_fields') and 'description' in tool_class_obj.model_fields:
        description = tool_class_obj.model_fields['description'].default
        if isinstance(description, str):
            logger.debug(f"Found description in model_fields: {description}")
            return description

    if tool_class_obj.__doc__:
        docstring = tool_class_obj.__doc__.strip()
        logger.debug(f"Found docstring: {docstring}")
        return docstring

    #  Corrected schema handling: Access the description directly if it exists.
    if hasattr(tool_class_obj, 'schema') and callable(tool_class_obj.schema):
        try:
            schema = tool_class_obj.schema()
            if isinstance(schema, dict) and 'description' in schema and isinstance(schema['description'], str):
                 logger.debug(f"Found description in schema: {schema['description']}")
                 return schema['description']
        except Exception as e:
            logger.warning(f"Error getting schema for {tool_class_obj.__name__}: {str(e)}")


    default_description = f"A tool of type {tool_class_obj.__name__}"
    logger.debug(f"Using default description: {default_description}")
    return default_description

def get_tool_class_obj(tool_class, tool_subclass):
    try:
        module = importlib.import_module(f"apps.agents.tools.{tool_class}")  # Ensure correct module path
        return getattr(module, tool_subclass)
    except (ImportError, AttributeError) as e:
        logger.error(f"Error importing tool class: {e}")
        return None

def load_tool(tool_model) -> Optional[CrewAIBaseTool]:
    logger.info(f"Attempting to load tool: {tool_model.tool_class}.{tool_model.tool_subclass}")
    
    try:
        # Check if it's a pre-built CrewAI tool
        if hasattr(crewai_tools, tool_model.tool_class):
            logger.info(f"Loading pre-built CrewAI tool: {tool_model.tool_class}")
            tool_class = getattr(crewai_tools, tool_model.tool_class)
            return tool_class()

        # If not, try to import a custom tool
        full_module_path = f"apps.agents.tools.{tool_model.tool_class}"
        logger.info(f"Attempting to import custom tool module: {full_module_path}")
        module = importlib.import_module(full_module_path)
        tool_class = getattr(module, tool_model.tool_subclass)
        
        if issubclass(tool_class, CrewAIBaseTool):
            logger.info(f"Loaded custom CrewAI tool: {tool_model.tool_subclass}")
            return tool_class()
        elif issubclass(tool_class, LangChainBaseTool):
            logger.info(f"Loaded and wrapped LangChain tool: {tool_model.tool_subclass}")
            # Wrap LangChain tool in CrewAI compatible class
            class WrappedLangChainTool(CrewAIBaseTool):
                name = tool_class.name
                description = get_tool_description(tool_class)

                def _run(self, *args, **kwargs):
                    return tool_class()(*args, **kwargs)

            return WrappedLangChainTool()
        else:
            raise ValueError(f"Unsupported tool class: {tool_class}")

    except ImportError as e:
        logger.error(f"Error importing tool module {full_module_path}: {str(e)}")
    except AttributeError as e:
        logger.error(f"Error finding tool class {tool_model.tool_subclass} in module {full_module_path}: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error loading tool {full_module_path}.{tool_model.tool_subclass}: {str(e)}")
    
    return None

def get_tool_info(tool_model):
    logger.info(f"Getting tool info for: {tool_model.tool_class}.{tool_model.tool_subclass}")
    
    full_module_path = f"apps.agents.tools.{tool_model.tool_class}"
    
    return {
        'module_path': full_module_path,
        'class_name': tool_model.tool_subclass
    }

class URLDeduplicator:
    def __init__(self):
        # Common CMS page identifiers
        self.cms_patterns = {
            'wordpress': [
                r'(?:page_id|p|post)=\d+',
                r'\d{4}/\d{2}/\d{2}',  # Date-based permalinks
                r'(?:category|tag)/[\w-]+',
            ],
            'woocommerce': [
                r'product=\d+',
                r'product-category/[\w-]+',
            ],
        }
        
        # Patterns that indicate filter/sort URLs
        self.filter_patterns = [
            # E-commerce filters
            r'product_type=\d+',
            r'prefilter=',
            r'filter\[.*?\]=',
            r'sort(?:by)?=',
            r'order=',
            r'view=',
            r'display=',
            # Pagination
            r'page=\d+',
            r'per_page=\d+',
            # Common parameters
            r'utm_.*?=',
        ]
        
        # Initialize sets for tracking seen URLs and content hashes
        self._seen_urls = set()
        self._seen_hashes = set()
        self._content_hashes = {}
        
    def should_process_url(self, url: str) -> bool:
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        
        # First check if it's a CMS page
        if self._is_cms_page(parsed.query):
            return True
            
        # For filter URLs, check both the filtered URL and the base URL
        if self._is_filter_url(parsed.query):
            # Create base URL without query parameters
            base_url = urlunparse((
                parsed.scheme,
                parsed.netloc,
                parsed.path,
                '',
                '',
                ''
            ))
            # Add base URL to seen URLs to avoid duplicate processing
            normalized_base = self._normalize_url(base_url)
            if normalized_base not in self._seen_urls:
                self._seen_urls.add(normalized_base)
                return True
            return False
            
        # If unclear, normalize and check if we've seen it
        normalized = self._normalize_url(url)
        return normalized not in self._seen_urls
        
    def _is_cms_page(self, query: str) -> bool:
        return any(
            re.search(pattern, query)
            for patterns in self.cms_patterns.values()
            for pattern in patterns
        )
        
    def _is_filter_url(self, query: str) -> bool:
        return any(
            re.search(pattern, query)
            for pattern in self.filter_patterns
        )
        
    def _normalize_url(self, url: str) -> str:
        parsed = urlparse(url)
        # Keep only essential query parameters
        query_params = parse_qs(parsed.query)
        essential_params = {
            k: v for k, v in query_params.items()
            if not any(re.search(pattern, f"{k}={v[0]}") 
                      for pattern in self.filter_patterns)
        }
        query = urlencode(essential_params, doseq=True) if essential_params else ''
        
        return urlunparse((
            parsed.scheme,
            parsed.netloc.lower(),
            parsed.path.rstrip('/'),
            '',
            query,
            ''
        ))
        
    def _hash_main_content(self, content: str) -> int:
        """Hash the main content, ignoring common dynamic elements"""
        # TODO: Implement content cleaning/normalization if needed
        return hash(content)
        
    def fallback_content_check(self, url: str, content: str) -> bool:
        """Use content hash as fallback for ambiguous cases"""
        if url not in self._content_hashes:
            content_hash = self._hash_main_content(content)
            if content_hash in self._seen_hashes:
                return False
            self._content_hashes[url] = content_hash
            self._seen_hashes.add(content_hash)
        return True

================
File: agents/views_agents.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Agent, AgentToolSettings
from .forms import AgentForm
import traceback
from django.conf import settings

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_agents(request):
    agents = Agent.objects.all().order_by('name')
    return render(request, 'agents/manage_agents.html', {'agents': agents})
@login_required
def manage_agents_card_view(request):
    agents = Agent.objects.prefetch_related('crew_set', 'task_set', 'tools').all().order_by('name')
    form = AgentForm()  # Now AgentForm is defined
    context = {
        'page_title': 'Manage Agents',
        'agents': agents,
        'form': form,
    }
    return render(request, 'agents/manage_agents_card_view.html', context)

@login_required
@user_passes_test(is_admin)
def add_agent(request):
    if request.method == 'POST':
        form = AgentForm(request.POST)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                
                # Save many-to-many fields
                form.save_m2m()
                
                # Handle tool settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent added successfully.')
                return redirect('agents:manage_agents')
            except Exception as e:
                messages.error(request, f"Error adding agent: {str(e)}")
    else:
        form = AgentForm()

    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Agent',
    }
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        form = AgentForm(request.POST, instance=agent)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                form.save_m2m()
                
                # Update tool settings
                agent.tool_settings.all().delete()  # Remove existing settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent updated successfully.')
                return redirect('agents:manage_agents_card_view')
            except Exception as e:
                messages.error(request, f"Error updating agent: {str(e)}")
    else:
        form = AgentForm(instance=agent)
    
    # Add page_title to the context
    context = {
        'form': form,
        'agent': agent,
        'page_title': 'Edit Agent',
    }
    
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        agent.delete()
        messages.success(request, 'Agent deleted successfully.')
        return redirect('agents:manage_agents')
    # Add page_title to the context
    context = {
        'object': agent,
        'type': 'agent',
        'page_title': 'Delete Agent',
    }
    return render(request, 'agents/confirm_delete.html', context)

================
File: agents/views_chat.py
================
from django.views.generic import TemplateView
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from apps.agents.models import Agent, Conversation
from apps.common.utils import get_models
from django.conf import settings
from apps.seo_manager.models import Client
import logging
import uuid

logger = logging.getLogger(__name__)

@login_required
@require_POST
def delete_conversation(request, session_id):
    try:
        conversation = get_object_or_404(Conversation, session_id=session_id, user=request.user)
        conversation.delete()
        logger.info(f"Deleted conversation: {conversation.id}")
        return JsonResponse({'status': 'success'})
    except Exception as e:
        logger.error(f"Error deleting conversation: {str(e)}")
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

class ChatView(LoginRequiredMixin, TemplateView):
    template_name = 'agents/chat.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        try:
            # Get session_id from URL parameters or generate new one
            session_id = self.kwargs.get('session_id', str(uuid.uuid4()))
            logger.info(f"Using chat session ID: {session_id}")
            
            # Get base queryset for conversations
            conversations_qs = Conversation.objects.filter(
                user=self.request.user,
                is_active=True
            ).select_related('agent', 'client').order_by('-updated_at')
            
            # Get current conversation if exists
            current_conversation = None
            if 'session_id' in self.kwargs:
                try:
                    current_conversation = conversations_qs.get(session_id=session_id)
                    logger.info(f"Found existing conversation: {current_conversation}")
                except Conversation.DoesNotExist:
                    logger.warning(f"No conversation found for session_id: {session_id}")
            
            # Get recent conversations (limited to 50)
            conversations = conversations_qs[:50]
            logger.info(f"Found {conversations.count()} conversations")
            
            # Get all agents
            agents = Agent.objects.all().order_by('name')
            logger.info(f"Found {agents.count()} agents")
            
            # Get all clients
            clients = Client.objects.all().order_by('name')
            logger.info(f"Found {clients.count()} clients")
            
            # Get models list
            models = get_models()
            logger.info(f"Found {len(models)} models")
            
            # Get default model
            default_model = settings.GENERAL_MODEL
            logger.info(f"Using default model: {default_model}")
            
            context.update({
                'page_title': 'Chat',
                'agents': agents,
                'clients': clients,
                'models': models,
                'conversations': conversations,
                'current_conversation': current_conversation,
                'add_agent_url': reverse('agents:add_agent'),
                'segment': 'chat',
                'default_model': default_model,
                'session_id': session_id,
            })
            logger.info("Context prepared successfully")
            
        except Exception as e:
            logger.error(f"Error preparing chat view context: {str(e)}", exc_info=True)
            raise
            
        return context

================
File: agents/views_crews.py
================
# This file was previously named views_admin.py
# The content remains the same, but you might want to remove any unused imports

import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Crew, CrewTask
from .forms import CrewForm
import json
from apps.seo_manager.models import Client
from django.conf import settings

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_crews(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews.html', context)

@login_required
@user_passes_test(is_admin)
def add_crew(request):
    if request.method == 'POST':
        form = CrewForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew added successfully.')
            return redirect('agents:manage_crews')
    else:
        initial_data = {
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        }
        logger.debug(f"Initial data for form: {initial_data}")
        form = CrewForm(initial=initial_data)
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew updated successfully.')
            return redirect('agents:manage_crews')
    else:
        form = CrewForm(instance=crew, initial={
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        })
    # Add page_title to the context
    context = {
        'form': form,
        'crew': crew,
        'page_title': 'Edit Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        crew.delete()
        messages.success(request, 'Crew deleted successfully.')
        return redirect('agents:manage_crews')
    # Add page_title to the context
    context = {
        'object': crew,
        'type': 'crew',
        'page_title': 'Delete Crew',
    }
    return render(request, 'agents/confirm_delete.html', context)

@login_required
@user_passes_test(is_admin)
def update_crew_agents(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        agent_ids = request.POST.getlist('agents')
        crew.agents.set(agent_ids)
        
        # Update manager_agent if it's in the POST data
        manager_agent_id = request.POST.get('manager_agent')
        if manager_agent_id:
            crew.manager_agent_id = manager_agent_id
        else:
            crew.manager_agent = None
        
        crew.save()
        messages.success(request, 'Crew agents updated successfully.')
    return redirect('agents:manage_crews')

@login_required
@user_passes_test(is_admin)
def manage_crews_card_view(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews_card_view.html', context)

@login_required
def crew_create_or_update(request, crew_id=None):
    if crew_id:
        crew = get_object_or_404(Crew, id=crew_id)
    else:
        crew = None

    next_url = request.GET.get('next') or request.POST.get('next')

    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            crew = form.save(commit=False)
            
            # Handle input variables
            input_variables = request.POST.getlist('input_variables[]')
            crew.input_variables = input_variables
            
            crew.save()
            form.save_m2m()  # This is important for saving many-to-many relationships
            
            # Handle task order
            task_order = request.POST.getlist('task_order[]')
            CrewTask.objects.filter(crew=crew).delete()
            for index, task_id in enumerate(task_order):
                CrewTask.objects.create(crew=crew, task_id=task_id, order=index)
            
            messages.success(request, f'Crew {"updated" if crew_id else "created"} successfully.')
            
            if next_url:
                return redirect(next_url)
            else:
                return redirect('agents:manage_crews')
        else:
            messages.error(request, f'Error {"updating" if crew_id else "creating"} crew. Please check the form.')
    else:
        form = CrewForm(instance=crew)
        input_variables = crew.input_variables if crew else []

    context = {
        'page_title': 'Create or Update Crew',
        'form': form,
        'crew': crew,
        'input_variables_json': json.dumps(input_variables),
        'next': next_url,
    }

    return render(request, 'agents/crew_form.html', context)

================
File: agents/views_kanban.py
================
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_protect
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.utils import timezone
import json

from .models import Crew, CrewExecution, ExecutionStage, Task, Agent, CrewTask
from apps.seo_manager.models import Client
from django.core.cache import cache

@login_required
def crew_kanban(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    client_id = request.GET.get('client_id')
    client = get_object_or_404(Client, id=client_id) if client_id else None
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        # Get executions that are associated with this task
        executions = CrewExecution.objects.filter(
            crew=crew,
            task=task
        ).prefetch_related('stages')
        
        execution_data = []
        for execution in executions:
            stages = execution.stages.all()
            stage_data = {}
            
            for stage in stages:
                stage_data[stage.stage_type] = {
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None
                }
                
                # Add stage-specific metadata
                if stage.metadata:
                    stage_data[stage.stage_type].update(stage.metadata)
            
            execution_data.append({
                'id': execution.id,
                'name': f'Execution #{execution.id}',
                'status': execution.status,
                'stages': stage_data
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'executions': execution_data
        })
    
    # Add page_title to the context
    context = {
        'crew': crew,
        'client': client,
        'tasks': kanban_tasks,
        'page_title': 'Crew Run',
    }
    return render(request, 'agents/crew_kanban.html', context)

@login_required
@require_http_methods(['POST'])
@csrf_protect
def start_execution(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    
    try:
        data = json.loads(request.body)
        client_id = data.get('client_id')
            
        if not client_id:
            return JsonResponse({
                'status': 'error',
                'message': 'Client ID is required'
            }, status=400)
            
        client = get_object_or_404(Client, id=client_id)
        
        # Get the first task for this crew
        crew_task = CrewTask.objects.filter(crew=crew).order_by('order').first()
        if not crew_task:
            return JsonResponse({
                'status': 'error',
                'message': 'No tasks found for this crew'
            }, status=400)
        
        # Create new execution
        execution = CrewExecution.objects.create(
            crew=crew,
            status='PENDING',
            inputs={
                'client_id': client_id
            },
            user=request.user,
            client=client
        )
        
        # Create initial stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_start',
            title='Starting New Execution',
            content='Initializing crew execution workflow',
            status='pending'
        )
        
        # Start the Celery task
        from .tasks import execute_crew
        task = execute_crew.delay(execution.id)
        
        # Update execution with task_id immediately
        execution.task_id = task.id
        execution.save()
        
        # Notify WebSocket clients
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'crew_{crew_id}_kanban',
            {
                'type': 'execution_update',
                'execution_id': execution.id,
                'task_id': crew_task.task.id,  # Send the task ID for proper board placement
                'status': 'PENDING',
                'message': 'New execution started',
                'stage': {
                    'stage_type': 'task_start',
                    'title': 'Starting New Execution',
                    'content': 'Initializing crew execution workflow',
                    'status': 'pending'
                }
            }
        )
        
        return JsonResponse({
            'status': 'success',
            'execution_id': execution.id,
            'task_id': crew_task.task.id
        })
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f'Error starting execution: {str(e)}', exc_info=True)
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(['GET'])
def get_active_executions(request, crew_id):
    """Get all active executions for a crew"""
    crew = get_object_or_404(Crew, id=crew_id)
    
    # Get all in-progress executions for this crew
    executions = CrewExecution.objects.filter(
        crew=crew,
        status__in=['pending', 'in_progress']
    ).prefetch_related('stages')
    
    execution_data = []
    for execution in executions:
        stages = execution.stages.all()
        stage_data = {}
        
        for stage in stages:
            stage_data[stage.stage_type] = {
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None
            }
            
            if stage.metadata:
                stage_data[stage.stage_type].update(stage.metadata)
        
        execution_data.append({
            'execution_id': execution.id,
            'task_id': execution.task_id if hasattr(execution, 'task_id') else None,
            'name': f'Execution #{execution.id}',
            'status': execution.status,
            'stages': stage_data
        })
    
    return JsonResponse({'executions': execution_data})

@login_required
@require_http_methods(['POST'])
@csrf_protect
def submit_human_input(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    try:
        data = json.loads(request.body)
        input_text = data.get('input')
        
        if not input_text:
            return JsonResponse({
                'status': 'error',
                'message': 'Input text is required'
            }, status=400)
        
        # Update execution with human input
        execution.human_input_response = {'input': input_text}
        execution.status = 'RUNNING'
        execution.save()
        
        # Create human input stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='human_input',
            title='Human Input Received',
            content=input_text,
            status='completed',
            metadata={
                'input_timestamp': timezone.now().isoformat()
            }
        )
        
        # Notify WebSocket clients
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            f'crew_{execution.crew.id}_kanban',
            {
                'type': 'stage_update',
                'execution_id': execution.id,
                'stage_type': 'human_input',
                'stage_data': {
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'completed': True
                }
            }
        )
        
        return JsonResponse({'status': 'success'})
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(["POST"])
def cancel_execution(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    if execution.task_id:
        # Revoke the Celery task
        from celery import current_app
        revoke = current_app.control.revoke(task_id=execution.task_id, terminate=True)
        
        # Update execution status
        execution.status = 'cancelled'
        execution.save()
        
        return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error', 'message': 'No task ID found'}, status=404)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution.objects.select_related('crew', 'crew_output'), id=execution_id)
    crew = execution.crew
    
    # Define the columns we want to show
    columns = [
        {'id': 'task_start', 'name': 'Task Start'},
        {'id': 'thinking', 'name': 'Thinking'},
        {'id': 'tool_usage', 'name': 'Tool Usage'},
        {'id': 'tool_results', 'name': 'Tool Results'},
        {'id': 'human_input', 'name': 'Human Input'},
        {'id': 'completion', 'name': 'Completion'}
    ]
    
    # Get all stages for this execution
    stages = execution.stages.all().select_related('agent').order_by('created_at')
    
    # Get all messages for this execution
    messages = execution.messages.all().order_by('timestamp')
    
    # Organize stages by stage_type
    kanban_columns = []
    for column in columns:
        column_stages = []
        
        # Add stages for this column
        for stage in stages:
            if stage.stage_type == column['id']:
                stage_data = {
                    'id': stage.id,
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None,
                    'created_at': stage.created_at,
                    'metadata': stage.metadata or {},
                    'type': 'stage'
                }
                column_stages.append(stage_data)
        
        # Add messages that might be related to this stage type
        if column['id'] == 'thinking':
            for message in messages:
                column_stages.append({
                    'id': f'msg_{message.id}',
                    'title': f'Message from {message.agent}',
                    'content': message.content,
                    'status': 'completed',
                    'agent': message.agent,
                    'created_at': message.timestamp,
                    'type': 'message'
                })
        
        # Add crew output to completion column
        if column['id'] == 'completion' and execution.crew_output:
            output_data = {
                'id': 'output',
                'title': 'Final Output',
                'content': execution.crew_output.raw,
                'status': 'completed',
                'created_at': execution.updated_at,
                'type': 'output',
                'metadata': {
                    'json_output': execution.crew_output.json_dict,
                    'token_usage': execution.crew_output.token_usage
                }
            }
            column_stages.append(output_data)
        
        kanban_columns.append({
            'id': column['id'],
            'name': column['name'],
            'stages': sorted(column_stages, key=lambda x: x['created_at'])
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': crew,
        'columns': kanban_columns
    }
    
    return render(request, 'agents/execution_detail.html', context)

================
File: agents/views_tasks.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Task
from .forms import TaskForm

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_tasks(request):
    tasks = Task.objects.all().order_by('description')
    # Add page_title to the context
    context = {
        'tasks': tasks,
        'page_title': 'Manage Tasks',
    }
    return render(request, 'agents/manage_tasks.html', context)

@login_required
@user_passes_test(is_admin)
def add_task(request):
    if request.method == 'POST':
        form = TaskForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task added successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        form = TaskForm(request.POST, instance=task)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task updated successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm(instance=task)
    # Add page_title to the context
    context = {
        'form': form,
        'task': task,
        'page_title': 'Edit Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        task.delete()
        messages.success(request, 'Task deleted successfully.')
        return redirect('agents:manage_tasks')
    # Add page_title to the context
    context = {
        'object': task,
        'type': 'task',
        'page_title': 'Delete Task',
    }
    return render(request, 'agents/confirm_delete.html', context)

================
File: agents/views_tools.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
import traceback
from .models import Tool
from .forms import ToolForm
from .utils import get_available_tools, get_tool_classes, get_tool_description, get_tool_class_obj, load_tool
from pydantic import BaseModel
import inspect
import json
import tiktoken
import csv
from io import StringIO
import asyncio
from asgiref.sync import sync_to_async

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

def count_tokens(text):
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

@login_required
@user_passes_test(is_admin)
def manage_tools(request):
    tools = Tool.objects.all().order_by('name')
    return render(request, 'agents/manage_tools.html', {'tools': tools, 'page_title': 'Manage Tools'})

@login_required
@user_passes_test(is_admin)
def add_tool(request):
    if request.method == 'POST':
        form = ToolForm(request.POST)
        logger.debug(f"POST data: {request.POST}")
        if form.is_valid():
            tool = form.save(commit=False)
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            logger.debug(f"Adding tool: class={tool_class}, subclass={tool_subclass}")
            
            # Get the tool class object and its description
            tool_classes = get_tool_classes(tool_class)
            logger.debug(f"Available tool classes: {[cls.__name__ for cls in tool_classes]}")
            if tool_classes:
                tool_class_obj = next((cls for cls in tool_classes if cls.__name__ == tool_subclass), None)
                if tool_class_obj:
                    logger.debug(f"Tool class object: {tool_class_obj}")
                    
                    tool.description = get_tool_description(tool_class_obj)
                    logger.debug(f"Tool description: {tool.description}")
                    
                    # Save the tool
                    tool.save()
                    
                    messages.success(request, 'Tool added successfully.')
                    return redirect('agents:manage_tools')
                else:
                    messages.error(request, f'Tool subclass {tool_subclass} not found.')
            else:
                messages.error(request, 'Tool class not found.')
        else:
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
            logger.error(f"Form errors: {form.errors}")
    else:
        form = ToolForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Tool',
    }
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        form = ToolForm(request.POST, instance=tool)
        if form.is_valid():
            tool = form.save(commit=False)
            tool.name = form.cleaned_data['tool_subclass']
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            tool_class_obj = get_tool_class_obj(tool_class, tool_subclass)
            tool.description = get_tool_description(tool_class_obj)
            tool.save()
            messages.success(request, 'Tool updated successfully.')
            return redirect('agents:manage_tools')
    else:
        form = ToolForm(instance=tool)
    # Add page_title to the context
    context = {
        'form': form,
        'tool': tool,
        'page_title': 'Edit Tool',
    }
    
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        tool.delete()
        messages.success(request, 'Tool deleted successfully.')
        return redirect('agents:manage_tools')
    return render(request, 'agents/confirm_delete.html', {'object': tool, 'type': 'tool', 'page_title': 'Delete Tool'})

@login_required
@user_passes_test(is_admin)
def get_tool_info(request):
    tool_class = request.GET.get('tool_class')
    logger.info(f"Received request for tool_class: {tool_class}")
    
    if tool_class:
        try:
            tool_objects = get_tool_classes(tool_class)
            logger.debug(f"Found tool objects: {[obj.__name__ for obj in tool_objects]}")
            
            class_info = []
            for obj in tool_objects:
                description = get_tool_description(obj)
                logger.debug(f"Tool: {obj.__name__}, Description: {description}")
                class_info.append({
                    'name': obj.__name__,
                    'description': description
                })
            
            logger.debug(f"Returning class_info: {class_info}")
            return JsonResponse({
                'classes': class_info
            })
        except ImportError as e:
            logger.error(f"ImportError: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"Failed to import tool module: {str(e)}"}, status=500)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"An unexpected error occurred: {str(e)}"}, status=500)
    
    logger.warning("Invalid request: tool_class parameter is missing")
    return JsonResponse({'error': 'Invalid request: tool_class parameter is missing'}, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_schema(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    try:
        tool_class = get_tool_class_obj(tool.tool_class, tool.tool_subclass)

        if tool_class is None:
            return JsonResponse({'error': 'Failed to load tool class'}, status=400)

        manual_schema = {
            "type": "object",
            "properties": {}
        }

        if hasattr(tool_class, 'args_schema') and issubclass(tool_class.args_schema, BaseModel):
            # Use Pydantic v2 method if available
            if hasattr(tool_class.args_schema, 'model_json_schema'):
                schema = tool_class.args_schema.model_json_schema()
            else:
                # Fallback for Pydantic v1
                schema = tool_class.args_schema.schema()

            for field_name, field_schema in schema.get('properties', {}).items():
                manual_schema['properties'][field_name] = {
                    "type": field_schema.get('type', 'string'),
                    "title": field_schema.get('title', field_name.capitalize()),
                    "description": field_schema.get('description', '')
                }
        else:
            # Fallback for tools without args_schema
            for param_name, param in inspect.signature(tool_class._run).parameters.items():
                if param_name not in ['self', 'kwargs']:
                    manual_schema['properties'][param_name] = {
                        "type": "string",
                        "title": param_name.capitalize(),
                        "description": ""
                    }

        if not manual_schema["properties"]:
            logger.error(f"No input fields found for tool: {tool_class}")
            return JsonResponse({'error': 'No input fields found for this tool'}, status=400)

        logger.debug(f"Generated schema for tool {tool_id}: {manual_schema}")
        return JsonResponse(manual_schema)
    except Exception as e:
        logger.error(f"Error getting tool schema: {str(e)}")
        return JsonResponse({'error': f'Error getting tool schema: {str(e)}'}, status=500)

@login_required
@user_passes_test(is_admin)
@require_http_methods(["POST"])
def test_tool(request, tool_id):
    """Run a tool test using Celery for both sync and async tools"""
    tool = get_object_or_404(Tool, id=tool_id)
    
    # Get inputs from request
    inputs = {key: value for key, value in request.POST.items() if key != 'csrfmiddlewaretoken'}
    
    try:
        # Start Celery task
        from .tasks.tools import run_tool
        task = run_tool.delay(tool_id, inputs)
        
        return JsonResponse({
            'status': 'started',
            'task_id': task.id,
            'message': f'Tool execution started. Task ID: {task.id}'
        })
        
    except Exception as e:
        logger.error(f"Error starting tool execution: {str(e)}\n{traceback.format_exc()}")
        return JsonResponse({
            'error': str(e)
        }, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_status(request, task_id):
    """Get the status of a tool execution"""
    from celery.result import AsyncResult
    
    task = AsyncResult(task_id)
    
    response = {
        'status': task.status,  # This will be one of: PENDING, STARTED, SUCCESS, FAILURE
    }
    
    if task.ready():
        if task.successful():
            try:
                result = task.get()
                if isinstance(result, dict):
                    response.update({
                        'result': result.get('result', ''),
                        'error': result.get('error')
                    })
                else:
                    response['result'] = str(result)
            except Exception as e:
                response.update({
                    'status': 'FAILURE',
                    'error': str(e)
                })
        else:
            response.update({
                'error': str(task.result)
            })
    
    return JsonResponse(response)

================
File: agents/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.paginator import Paginator
from django.http import JsonResponse
from django.views.decorators.http import require_POST, require_http_methods
from django.views.decorators.csrf import csrf_exempt, csrf_protect
from .models import Crew, CrewExecution, CrewMessage, Pipeline, Agent, CrewTask, Task, UserSlackIntegration
from .forms import CrewExecutionForm, HumanInputForm, AgentForm
from .tasks import execute_crew
from django.core.exceptions import ValidationError
import logging
import json
from django.urls import reverse
from django.core.cache import cache
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from django.conf import settings
import os
from apps.seo_manager.models import Client  # Import the Client model
from markdown_it import MarkdownIt  # Import markdown-it
from apps.common.utils import get_models
from slack_sdk.oauth import AuthorizeUrlGenerator
from slack_sdk.web import WebClient

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

# Initialize the MarkdownIt instance
md = MarkdownIt()

@login_required
@csrf_exempt
def connection_test(request):
    return render(request, 'agents/connection_test.html')

@login_required
def crewai_home(request):
    crews = Crew.objects.all()  # Get the first 3 crews for the summary
    recent_executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')[:10]
    clients = Client.objects.all()  # Get all clients
    
    # Get the selected client_id from the request, fallback to session
    selected_client_id = request.GET.get('client_id') or request.session.get('selected_client_id')
    
    if selected_client_id:
        request.session['selected_client_id'] = selected_client_id
    else:
        # If no client is selected, remove it from the session
        request.session.pop('selected_client_id', None)
    
    context = {
        'page_title': 'Crews Home',
        'crews': crews,
        'recent_executions': recent_executions,
        'clients': clients,
        'selected_client_id': selected_client_id,
    }
    return render(request, 'agents/crewai_home.html', context)

@login_required
def crew_list(request):
    logger.debug("Entering crew_list view")
    crews = Crew.objects.all()
    # Add page_title to the context
    context = {
        'crews': crews,
        'page_title': 'Crew List',
    }
    return render(request, 'agents/crew_list.html', context)

@login_required
def crew_detail(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    recent_executions = CrewExecution.objects.filter(crew=crew).order_by('-created_at')[:5]
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
    
    if request.method == 'POST':
        form = CrewExecutionForm(request.POST)
        if form.is_valid():
            execution = form.save(commit=False)
            execution.crew = crew
            execution.user = request.user
            execution.client = selected_client  # Associate the selected client with the execution
            
            # Handle input variables
            input_variables = json.loads(request.POST.get('input_variables', '{}'))
            execution.inputs = input_variables
            
            execution.save()
            
            # Start the execution
            execute_crew.delay(execution.id)
            
            messages.success(request, 'Crew execution started.')
            return JsonResponse({'status': 'success', 'execution_id': execution.id})
    else:
        form = CrewExecutionForm()
    
    context = {
        'page_title': 'Crew Detail',
        'crew': crew,
        'form': form,
        'recent_executions': recent_executions,
        'selected_client': selected_client,
    }
    return render(request, 'agents/crew_detail.html', context)

@login_required
def execution_list(request):
    logger.debug("Entering execution_list view")
    executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')
    crews = Crew.objects.all()

    # Apply filters
    crew_id = request.GET.get('crew')
    status = request.GET.get('status')

    if crew_id:
        executions = executions.filter(crew_id=crew_id)
    if status:
        executions = executions.filter(status=status)

    # Pagination
    paginator = Paginator(executions, 10)  # Show 10 executions per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_title': 'Execution List',
        'executions': page_obj,
        'crews': crews,
    }
    return render(request, 'agents/execution_list.html', context)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=execution.crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        stages = execution.stages.filter(task=task).order_by('created_at')
        
        stage_data = []
        for stage in stages:
            stage_data.append({
                'id': stage.id,
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None,
                'created_at': stage.created_at,
                'metadata': stage.metadata or {}
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'stages': stage_data
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': execution.crew,
        'tasks': kanban_tasks
    }
    
    return render(request, 'agents/execution_detail.html', context)

@login_required
def execution_status(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        
        # Get the last message ID from the request
        last_message_id = request.GET.get('last_message_id')
        
        # Only fetch new messages if there are any
        if last_message_id:
            messages = CrewMessage.objects.filter(
                execution=execution,
                id__gt=last_message_id
            ).order_by('timestamp')
        else:
            messages = CrewMessage.objects.filter(
                execution=execution
            ).order_by('timestamp')
        
        # Get status badge class
        status_classes = {
            'PENDING': 'info',
            'RUNNING': 'primary',
            'WAITING_FOR_HUMAN_INPUT': 'warning',
            'COMPLETED': 'success',
            'FAILED': 'danger'
        }
        status_class = status_classes.get(execution.status, 'secondary')
        
        response_data = {
            'status': execution.get_status_display(),
            'status_class': status_class,
            'updated_at': execution.updated_at.isoformat(),
            'outputs': execution.outputs,
            'human_input_request': execution.human_input_request,
            'messages': [{
                'id': msg.id,
                'agent': msg.agent,
                'content': msg.content,
                'timestamp': msg.timestamp.strftime("%d %b %H:%M")
            } for msg in messages],
        }
        return JsonResponse(response_data)
    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)

@login_required
@csrf_protect
@require_POST
def provide_human_input(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        if execution.status != 'WAITING_FOR_HUMAN_INPUT':
            return JsonResponse({'error': 'Execution is not waiting for human input'}, status=400)

        data = json.loads(request.body)
        user_input = data.get('input')

        if user_input is None:
            return JsonResponse({'error': 'No input provided'}, status=400)

        # Store the user input in the cache
        cache.set(f'human_input_response_{execution_id}', user_input, timeout=3600)

        logger.info(f"Stored user input for execution {execution_id}: {user_input}")

        # Update execution status
        execution.status = 'RUNNING'
        execution.save()

        # Send a WebSocket message to update the frontend
        async_to_sync(channel_layer.group_send)(
            f'crew_execution_{execution_id}',
            {
                'type': 'crew_execution_update',
                'status': 'RUNNING',
                'messages': [{'agent': 'Human', 'content': f'Input provided: {user_input}'}],
            }
        )

        # Return the actual user input
        return JsonResponse({'message': 'Human input received and processing resumed', 'input': user_input})
    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f"Error in provide_human_input: {str(e)}")
        return JsonResponse({'error': 'An unexpected error occurred'}, status=500)

@login_required
def manage_pipelines(request):
    pipelines = Pipeline.objects.all()
    context = {
        'page_title': 'Manage Pipelines',
        'pipelines': pipelines,
    }
    return render(request, 'agents/manage_pipelines.html', context)

@login_required
@require_POST
def submit_human_input(request, execution_id):
    input_key = request.POST.get('input_key')
    response = request.POST.get('response')
    
    if not input_key or not response:
        return JsonResponse({'error': 'Missing input_key or response'}, status=400)
    
    execution = get_object_or_404(CrewExecution, id=execution_id, user=request.user)
    
    # Store the response in the cache
    cache_key = f"{input_key}_response"
    cache.set(cache_key, response, timeout=3600)
    
    # Verify that the input was stored correctly
    stored_value = cache.get(cache_key)
    logger.info(f"Stored human input in cache for execution {execution_id}: key={cache_key}, value={response}")
    
    # Update execution status
    execution.status = 'RUNNING'
    execution.save()
    
    return JsonResponse({'message': 'Human input received and processed'})

@login_required
def chat_view(request):
    clients = Client.objects.all().order_by('name')
    print(f"Found {clients.count()} clients")  # Debug print
    
    context = {
        'agents': Agent.objects.all(),
        'models': get_models(),
        'default_model': settings.GENERAL_MODEL,
        'clients': clients,
    }
    return render(request, 'agents/chat.html', context)

@login_required
def slack_oauth_start(request):
    """Start Slack OAuth flow"""
    authorize_url_generator = AuthorizeUrlGenerator(
        client_id=settings.SLACK_CLIENT_ID,
        scopes=["chat:write", "channels:read", "channels:history"]
    )
    authorize_url = authorize_url_generator.generate("")
    return redirect(authorize_url)

@login_required
def slack_oauth_callback(request):
    """Handle Slack OAuth callback"""
    code = request.GET.get('code')
    if not code:
        return JsonResponse({"error": "No code provided"}, status=400)
    
    try:
        client = WebClient()
        response = client.oauth_v2_access(
            client_id=settings.SLACK_CLIENT_ID,
            client_secret=settings.SLACK_CLIENT_SECRET,
            code=code
        )
        
        # Save the tokens
        integration, created = UserSlackIntegration.objects.update_or_create(
            user=request.user,
            defaults={
                'access_token': response['access_token'],
                'team_id': response['team']['id'],
                'team_name': response['team']['name'],
                'is_active': True
            }
        )
        
        return redirect('settings_view')
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)
