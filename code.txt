This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-06T14:03:00.787Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
apps/
  agents/
    chat/
      formatters/
        __init__.py
        output_formatter.py
        table_formatter.py
        tool_formatter.py
      managers/
        crew_manager.py
        message_manager.py
        prompt_manager.py
        token_manager.py
        tool_manager.py
      tests/
        test_callback_handler.py
      history.py
    clients/
      manager.py
    integrations/
      slack_bot.py
      slack_message_formatter.py
    static/
      agents/
        js/
          chat/
            app.js
          components/
            tool_outputs/
              base.js
            message_list.js
            message.js
          modules/
            content_expander.js
          services/
            message_handler.js
            websocket.js
          crew_kanban.js
          tool_tester.js
    tasks/
      callbacks/
        execution.py
        tool.py
      core/
        agents.py
        crew.py
        tasks.py
      handlers/
        input.py
      messaging/
        execution_bus.py
      utils/
        __init__.py
        context.py
        logging.py
        tools.py
      __init__.py
      base.py
      tools.py
    templates/
      agents/
        modals/
          details_modal.html
          human_input_modal.html
          start_execution_modal.html
        agent_form.html
        base_agents.html
        chat.html
        confirm_delete.html
        connection_test.html
        crew_detail.html
        crew_form.html
        crew_kanban.html
        crew_list.html
        crewai_home.html
        dashboard_home.html
        execution_detail.html
        execution_list.html
        manage_agents_card_view.html
        manage_agents.html
        manage_crews_card_view.html
        manage_crews.html
        manage_tasks.html
        manage_tools.html
        task_form.html
        tool_form.html
        tool_test.html
    templatetags/
      __init__.py
      agent_filters.py
      agent_tags.py
    tests/
      integration/
        test_callback_flow.py
      test_file_writer_tool.py
    tools/
      agent_delegation_tool/
        __init__.py
        agent_delegation_tool.py
      business_credibility_tool/
        business_credibility_tool.py
      client_profile_tool/
        __init__.py
        client_profile_tool.py
        org_aware_client_profile_tool.py
      code_interpreter_tool/
        code_interpreter_tool.py
      competitor_tools/
        competitor_tools.py
      compression_tool/
        __init__.py
        compression_tool.py
      content_expertise_tool/
        content_expertise_tool.py
      crawl_website_tool/
        __init__.py
        crawl_website_tool.py
        test_crawl_endpoint.py
        utils.py
      crewai_file_writer/
        crewai_file_writer.py
      csv_search_tool/
        csv_search_tool.py
      deep_research_tool/
        deep_research_tool.py
      directory_read_tool/
        directory_read_tool.py
      directory_search_tool/
        directory_search_tool.py
      docx_search_tool/
        docx_search_tool.py
      file_read_tool/
        file_read_tool.py
      file_writer_tool/
        file_writer_tool.py
      firecrawl_crawl_tool/
        __init__.py
        firecrawl_crawl_tool.py
      google_analytics_tool/
        generic_google_analytics_tool.py
        google_analytics_tool.py
      google_overview_tool/
        google_overview_tool.py
      google_report_tool/
        __init__.py
        google_rankings_tool.py
        google_report_tool.py
      google_search_console_tool/
        generic_google_search_console_tool.py
      google_suggestions_tool/
        __init__.py
        google_suggestions_tool.py
      keyword_tools/
        __init__.py
        keyword_tools.py
        ranked_keywords_tool.py
      neuralami_api_tool/
        neuralami_api_tool.py
      pagespeed_tool/
        pagespeed_tool.py
      pandas_ai_tool/
        pandas_ai_tool.py
      pdf_extractor_tool/
        pdf_extractor_tool.py
      rag/
        rag_tool.py
      scrapper_tool/
        __init__.py
        scrapper_tool.py
      screenshot_tool/
        screenshot_tool.py
      search_context_tool/
        search_context_tool.py
        test_search_context_tool.py
      searxng_tool/
        __init__.py
        searxng_tool.py
      seo_audit_tool/
        content_type_detector.py
        seo_audit_tool.py
        seo_checkers.py
      seo_crawler_tool/
        seo_crawler_tool.py
      sitemap_retriever_tool/
        __init__.py
        sitemap_retriever_tool.py
      web_crawler_tool/
        __init__.py
        test_web_crawler_tool.py
        web_crawler_tool.py
      website_detector_tool/
        platforms.py
        website_detector_tool.py
      website_distiller_tool/
        __init__.py
        website_distiller_tool.py
      wordpress/
        base.py
        content_tool.py
        meta_tool.py
        post_tool.py
        reader_tool.py
      youtube_video_search_tool/
        youtube_video_search_tool.py
      __init__.py
      analytics_tool.py
      base_tool.py
      manager.py
      organization_context.py
      utils.py
    utils/
      scraper_adapters/
        __init__.py
        base.py
        firecrawl_adapter.py
        firecrawl_crawl_adapter.py
        playwright_adapter.py
      __init__.py
      client_utils.py
      crawl_url.py
      crawler_utils.py
      error_handling.py
      formatters.py
      get_targeted_keywords.py
      minimal_tools.py
      rate_limited_fetcher.py
      scrape_url.py
      scraper_service.py
      tool_utils.py
      url_utils.py
    websockets/
      handlers/
        agent_handler.py
        callback_handler.py
      services/
        base_chat_service.py
        chat_service.py
        crew_chat_service.py
      __init__.py
      base.py
      chat_consumer.py
    admin.py
    apps.py
    celery.py
    consumers.py
    forms.py
    kanban_consumers.py
    models.py
    routing.py
    tasks.py
    tools.py
    urls.py
    views_agents.py
    views_chat.py
    views_crews.py
    views_kanban.py
    views_tasks.py
    views_tools.py
    views.py
  api/
    serializers.py
    urls.py
    views.py
  common/
    services/
      llm/
        providers/
          __init__.py
          anthropic.py
          base.py
          gemini.py
          ollama.py
          openai.py
          openrouter.py
        utils/
          cache.py
          rate_limiter.py
          streaming.py
        __init__.py
        service.py
      __init__.py
      llm_cache.py
      llm_service.py
      rate_limiter.py
      streaming.py
    static/
      admin/
        js/
          llm_test_harness.js
      common/
        js/
          services/
            websocket.js
      js/
        services/
          websocket.js
    templates/
      admin/
        common/
          llm_test_harness.html
    templatetags/
      __init__.py
      markdown_filters.py
    tools/
      user_activity_tool.py
    websockets/
      base_consumer.py
      organization_consumer.py
    __init__.py
    admin.py
    apps.py
    chat_model_handler.py
    content_loader.py
    models.py
    summarizer.py
    tests.py
    urls.py
    utils.py
    views.py
  crawl_website/
    static/
      crawl_website/
        js/
          crawl-htmx.js
    templates/
      crawl_website/
        partials/
          _active_crawls.html
          _crawl_results_section.html
          _crawl_results.html
          _crawl_status_progress.html
        crawl.html
        index.html
    admin.py
    apps.py
    consumers.py
    export_utils.py
    models.py
    routing.py
    tasks.py
    tests.py
    urls.py
    utils.py
    views_updated.py
    views.py
  file_manager/
    templates/
      file_manager/
        file-manager.html
    templatetags/
      file_extension.py
      file_manager_extras.py
      info_value.py
    admin.py
    apps.py
    models.py
    storage.py
    tests.py
    urls.py
    views.py
  image_optimizer/
    static/
      image_optimizer/
        js/
          services/
            websocket.js
          optimize_app.js
    templates/
      image_optimizer/
        dashboard.html
        history.html
        optimize.html
    admin.py
    apps.py
    consumers.py
    models.py
    routing.py
    tasks.py
    tests.py
    urls.py
    views.py
  organizations/
    models/
      __init__.py
      base.py
      mixins.py
    templates/
      organizations/
        components/
          organization_switcher.html
        edit_organization.html
        settings.html
    templatetags/
      __init__.py
      organization_tags.py
    tests/
      __init__.py
      test_organization_context.py
    admin.py
    apps.py
    forms.py
    middleware.py
    shortcuts.py
    tests.py
    urls.py
    utils.py
    views.py
  research/
    static/
      research/
        js/
          research-websocket-init.js
          research-websocket.js
    templates/
      research/
        partials/
          _report.html
          _step.html
          progress.html
          reasoning.html
          sources.html
          steps.html
        create.html
        detail.html
        list.html
    templatetags/
      __init__.py
      research_tags.py
    websockets/
      research_consumer.py
    admin.py
    apps.py
    forms.py
    models.py
    services.py
    tasks.py
    urls.py
    views.py
  seo_audit/
    services/
      remediation_service.py
    static/
      seo_audit/
        js/
          app.js
          chart-init.js
          json-renderer.js
          plan-handlers.js
          results.js
          table-init.js
          utils.js
    templates/
      seo_audit/
        audit.html
        history.html
        results.html
    templatetags/
      seo_audit_tags.py
    admin.py
    apps.py
    consumers.py
    models.py
    routing.py
    tasks.py
    urls.py
    views.py
  seo_manager/
    static/
      seo_manager/
        js/
          client_detail.js
          meta_tags_dashboard.js
          ranking_data_management.js
    templates/
      seo_manager/
        credentials/
          add_ga_service_account.html
          add_sc_service_account.html
          select_analytics_account.html
        includes/
          activity_items.html
          keyword_import_modals.html
          keyword_modals.html
          objective_modals.html
        keywords/
          keyword_list_table.html
          keyword_list.html
          ranking_history.html
          search_console_keywords.html
        meta_tags/
          partials/
            meta_tags_comparison.html
            meta_tags_csv.html
            meta_tags_report.html
          meta_tags_dashboard.html
        projects/
          edit_project.html
          project_detail.html
          project_list_table.html
          project_list.html
        reports/
          monthly_report.html
        activity_log.html
        add_client.html
        add_ga_credentials_service_account.html
        add_sc_credentials_service_account.html
        base.html
        client_analytics.html
        client_detail.html
        client_form.html
        client_integrations.html
        client_list.html
        dashboard.html
        edit_business_objective.html
        edit_client.html
        input_view_id.html
        ranking_data_management.html
        select_ads_account.html
        select_analytics_account.html
        select_search_console_property.html
        select_search_console.html
        setup_service_account.html
    templatetags/
      __init__.py
      custom_filters.py
      form_tags.py
      seo_manager_filters.py
      seo_tags.py
    utils/
      meta_tags_analyzer.py
    views/
      __init__.py
      activity_views.py
      ads_views.py
      analytics_views.py
      auth_views.py
      business_objective_views.py
      client_views.py
      keyword_views.py
      meta_tags_views.py
      project_views.py
      ranking_views.py
      report_views.py
      search_console_views.py
    admin.py
    apps.py
    consumers.py
    exceptions.py
    forms.py
    google_auth.py
    middleware.py
    models.py
    routing.py
    services.py
    sitemap_extractor.py
    tasks.py
    urls.py
    utils.py
    views_analytics.py
    views.py
  summarizer/
    templates/
      summarizer/
        summarize.html
    templatetags/
      __init__.py
      replace_value.py
    __init__.py
    admin.py
    apps.py
    models.py
    urls.py
    views.py
  tasks/
    templatetags/
      formats.py
    admin.py
    apps.py
    celery.py
    decorators.py
    models.py
    tasks.py
    tests.py
    urls.py
    views.py
  users/
    admin.py
    apps.py
    forms.py
    models.py
    signals.py
    tests.py
    urls.py
    views.py
  utilities/
    templates/
      utilities/
        test_endpoint.html
    admin.py
    apps.py
    models.py
    tests.py
    urls.py
    views.py
config/
  asgi.py
  routing.py
  settings.py
  urls.py
core/
  __init__.py
  apps.py
  asgi.py
  b2_storage.py
  context_processors.py
  minio_storage.py
  routing.py
  settings.py
  storage.py
  urls.py
  version.py
  views.py
  wsgi.py
file_manager/
  file-manager.html
tasks_scripts/
  check-db-health.py
  check-disk-free.py
  clean-database.py
templates/
  authentication/
    change/
      basic.html
    complete/
      basic.html
    done/
      basic.html
      change-done.html
    error/
      404.html
      500.html
    lock/
      basic.html
      cover.html
      illustration.html
    reset/
      basic.html
      cover.html
      illustration.html
    reset-confirm/
      basic.html
    signin/
      basic.html
      cover.html
      illustration.html
    signup/
      basic.html
      cover.html
      illustration.html
    verification/
      basic.html
      cover.html
      illustration.html
  includes/
    configurator.html
    footer-full.html
    footer.html
    head.html
    items-table.html
    navigation-full.html
    navigation-shadow.html
    navigation.html
    scripts.html
    sidebar.html
    subdirectories.html
  layouts/
    base-full.html
    base-shadow.html
    base.html
  pages/
    account/
      billing.html
      invoice.html
      security.html
      settings.html
    apps/
      summarize.html
      tasks.html
      user-profile.html
    dashboards/
      default.html

================================================================
Repository Files
================================================================

================
File: apps/agents/chat/formatters/__init__.py
================
from .table_formatter import TableFormatter
from .tool_formatter import ToolFormatter
from .output_formatter import OutputFormatter

__all__ = ['TableFormatter', 'ToolFormatter', 'OutputFormatter']

================
File: apps/agents/chat/formatters/output_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class OutputFormatter:
    """Handles general output formatting"""
    
    @staticmethod
    def format_response(response: Dict) -> str:
        """Format agent response"""
        try:
            output = response.get("output")
            if not output:
                return "No response generated"
                
            # If output is a dict, check for tabular data
            if isinstance(output, dict):
                if "formatted_table" in output:
                    return output["formatted_table"]
                if TableFormatter.detect_tabular_data(output):
                    return TableFormatter.format_table(output)
                return json.dumps(output, indent=2)
                
            # If output is a string but contains JSON, try to parse and format
            if isinstance(output, str) and (output.startswith('{') or output.startswith('[')):
                try:
                    json_data = json.loads(output)
                    if "formatted_table" in json_data:
                        return json_data["formatted_table"]
                    if TableFormatter.detect_tabular_data(json_data):
                        return TableFormatter.format_table(json_data)
                    return json.dumps(json_data, indent=2)
                except json.JSONDecodeError:
                    pass
                    
            return output

        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}", exc_info=True)
            return "Error formatting response"

    @staticmethod
    def format_final_answer(content: Any) -> str:
        """Format the final agent response"""
        try:
            # Format as table if possible
            if TableFormatter.detect_tabular_data(content):
                content = TableFormatter.format_table(content)
            return f'<div class="agent-response">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting final answer: {str(e)}")
            return str(content)

================
File: apps/agents/chat/formatters/table_formatter.py
================
from typing import Any, Dict, List, Union
import json
import logging

logger = logging.getLogger(__name__)

class TableFormatter:
    """Generic table formatter for structured data"""
    
    @staticmethod
    def _is_json(data: str) -> bool:
        """Check if string is valid JSON"""
        try:
            json.loads(data)
            return True
        except (json.JSONDecodeError, TypeError):
            return False

    @staticmethod
    def _is_csv(data: str) -> bool:
        """Check if string appears to be CSV data"""
        if not isinstance(data, str):
            return False
        return (',' in data and 
                '\n' in data and 
                '{' not in data and 
                '[' not in data)

    @staticmethod
    def _parse_csv(csv_data: str) -> List[Dict]:
        """Convert CSV string to list of dictionaries"""
        try:
            lines = csv_data.strip().split('\n')
            headers = [h.strip() for h in lines[0].split(',')]
            
            return [
                {
                    headers[i]: value.strip() 
                    for i, value in enumerate(line.split(','))
                    if i < len(headers)
                }
                for line in lines[1:]
            ]
        except Exception as e:
            logger.error(f"Error parsing CSV: {str(e)}", exc_info=True)
            return []

    @staticmethod
    def _find_tabular_data(data: Any) -> Union[List[Dict], None]:
        """
        Recursively search for tabular data in the structure.
        Returns the first found list of dictionaries with consistent keys.
        """
        # Handle string input
        if isinstance(data, str):
            if TableFormatter._is_json(data):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return None
            elif TableFormatter._is_csv(data):
                return TableFormatter._parse_csv(data)
            else:
                return None

        # Handle list of dictionaries
        if isinstance(data, list) and data:
            if all(isinstance(item, dict) for item in data):
                # Get all unique keys from all objects
                keys = set().union(*(item.keys() for item in data))
                if keys:  # If we have keys, it's tabular
                    return data
            
            # Check each list item for nested tabular data
            for item in data:
                result = TableFormatter._find_tabular_data(item)
                if result:
                    return result

        # Handle dictionary
        if isinstance(data, dict):
            # First check direct values
            for value in data.values():
                if isinstance(value, list) and value:
                    if all(isinstance(item, dict) for item in value):
                        return value
            
            # Then check nested structures
            for value in data.values():
                result = TableFormatter._find_tabular_data(value)
                if result:
                    return result

        return None

    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data contains tabular structure anywhere in the hierarchy"""
        try:
            return TableFormatter._find_tabular_data(data) is not None
        except Exception:
            logger.error("Error detecting tabular data", exc_info=True)
            return False

    @staticmethod
    def format_table(data: Any) -> str:
        """Format tabular data into a markdown table"""
        try:
            tabular_data = TableFormatter._find_tabular_data(data)
            if not tabular_data:
                return str(data)

            # Get all unique keys from all objects
            keys = list(set().union(*(item.keys() for item in tabular_data)))
            
            # Calculate column widths
            col_widths = {key: len(str(key)) for key in keys}
            for row in tabular_data:
                for key in keys:
                    value = row.get(key)
                    if value is None:
                        continue
                    elif isinstance(value, (dict, list)):
                        str_value = json.dumps(value)
                    else:
                        str_value = str(value)
                    col_widths[key] = max(col_widths[key], len(str_value))

            # Build table
            # Header row
            table = "| " + " | ".join(
                str(key).ljust(col_widths[key]) 
                for key in keys
            ) + " |\n"
            
            # Separator row
            table += "|" + "|".join(
                "-" * (col_widths[key] + 2) 
                for key in keys
            ) + "|\n"
            
            # Data rows
            for row in tabular_data:
                table += "| " + " | ".join(
                    str(row.get(key, '')).ljust(col_widths[key]) 
                    for key in keys
                ) + " |\n"

            return table

        except Exception as e:
            logger.error(f"Error formatting table: {str(e)}", exc_info=True)
            return str(data)  # Return original data if formatting fails

================
File: apps/agents/chat/formatters/tool_formatter.py
================
import json
import logging
from typing import Any, Dict

from .table_formatter import TableFormatter

logger = logging.getLogger(__name__)

class ToolFormatter:
    """Handles formatting of tool outputs and usage messages"""
    
    @staticmethod
    def format_tool_output(content: Any) -> str:
        """Format tool output with proper styling"""
        try:
            if isinstance(content, dict):
                return f'<div class="json-output">{json.dumps(content, indent=2)}</div>'
            elif isinstance(content, str):
                # Try to parse as JSON first
                try:
                    json_content = json.loads(content)
                    return f'<div class="json-output">{json.dumps(json_content, indent=2)}</div>'
                except json.JSONDecodeError:
                    pass
                
                # Format as table if possible
                if TableFormatter.detect_tabular_data(content):
                    content = TableFormatter.format_table(content)
            
            return f'<div class="tool-output">{content}</div>'
        except Exception as e:
            logger.error(f"Error formatting tool output: {str(e)}")
            return str(content)

    @staticmethod
    def format_tool_usage(content: str, message_type: str = None) -> str:
        """Format tool usage messages"""
        if message_type == "tool_start" and content.startswith('Using tool:'):
            tool_info = content.split('\n')
            formatted = f'''
            <div class="tool-usage">
                <i class="fas fa-tools"></i>
                <div>
                    <strong>{tool_info[0]}</strong>
                    <div class="tool-input">{tool_info[1] if len(tool_info) > 1 else ''}</div>
                </div>
            </div>
            '''
            return formatted
        elif message_type == "tool_error":
            return f'''
            <div class="tool-error">
                <i class="fas fa-exclamation-triangle"></i>
                <div>{content}</div>
            </div>
            '''
        return content

    @staticmethod
    def format_tool_result(observation: Any) -> Dict:
        """Format tool output into a standardized structure"""
        try:
            result_data = {
                'tool_type': None,
                'format': None,
                'data': None,
                'metadata': {}
            }

            if isinstance(observation, dict):
                # Handle tabular data
                if TableFormatter.detect_tabular_data(observation):
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'table',
                        'data': TableFormatter.format_table(observation),
                        'metadata': {
                            'raw_data': observation.get('raw_data', {}),
                            'tool': observation.get('tool')
                        }
                    })
                
                # Handle validation errors
                elif observation.get('type') == 'error':
                    result_data.update({
                        'tool_type': 'error',
                        'format': 'error',
                        'data': {
                            'message': observation.get('message'),
                            'error_type': observation.get('error'),
                            'suggestion': observation.get('suggestion')
                        }
                    })
                
                # Handle other structured data
                else:
                    result_data.update({
                        'tool_type': observation.get('type', 'generic'),
                        'format': 'json',
                        'data': json.dumps(observation, indent=2),
                        'metadata': {
                            'tool': observation.get('tool')
                        }
                    })

            return result_data

        except Exception as e:
            logger.error(f"Error formatting tool result: {str(e)}", exc_info=True)
            return {
                'tool_type': 'error',
                'format': 'error',
                'data': {
                    'message': str(e),
                    'error_type': 'formatting_error'
                }
            }

================
File: apps/agents/chat/managers/crew_manager.py
================
import logging
from typing import Optional, Dict, Any
from django.core.cache import cache
from django.utils import timezone
from apps.agents.models import CrewExecution

logger = logging.getLogger(__name__)

class CrewManager:
    """Manages crew execution and message context for crew chats"""
    
    def __init__(self):
        self.execution = None
        self.context_key = None
    
    async def initialize(self, execution: CrewExecution):
        """Initialize crew manager with execution"""
        self.execution = execution
        self.context_key = f"crew_chat_context_{execution.id}"
        
        # Initialize context in cache if not exists
        if not cache.get(self.context_key):
            cache.set(self.context_key, {
                'messages': [],
                'task_outputs': {},
                'current_task': None
            }, timeout=3600)  # 1 hour timeout
    
    async def handle_human_input(self, message: str):
        """Handle human input for crew execution"""
        if not self.execution:
            raise ValueError("Crew execution not initialized")
            
        try:
            # Add message to context
            await self.add_message_to_context(message)
            
            # Update execution status
            self.execution.status = 'PROCESSING'
            await self.execution.asave()
            
            # Signal that human input is received
            cache.set(
                f"crew_human_input_{self.execution.id}",
                message,
                timeout=3600
            )
            
        except Exception as e:
            logger.error(f"Error handling human input: {str(e)}")
            raise
    
    async def add_message_to_context(self, message: str):
        """Add a message to the crew chat context"""
        if not self.context_key:
            raise ValueError("Context not initialized")
            
        try:
            context = cache.get(self.context_key, {})
            messages = context.get('messages', [])
            
            # Add message to context
            messages.append({
                'content': message,
                'timestamp': str(timezone.now()),
                'is_human': True
            })
            
            # Keep only last 50 messages
            if len(messages) > 50:
                messages = messages[-50:]
            
            context['messages'] = messages
            cache.set(self.context_key, context, timeout=3600)
            
        except Exception as e:
            logger.error(f"Error adding message to context: {str(e)}")
            raise
    
    async def add_task_output(self, task_id: int, output: Dict[str, Any]):
        """Add task output to context"""
        if not self.context_key:
            raise ValueError("Context not initialized")
            
        try:
            context = cache.get(self.context_key, {})
            task_outputs = context.get('task_outputs', {})
            
            # Add task output
            task_outputs[str(task_id)] = output
            context['task_outputs'] = task_outputs
            
            cache.set(self.context_key, context, timeout=3600)
            
        except Exception as e:
            logger.error(f"Error adding task output: {str(e)}")
            raise
    
    async def get_context(self) -> Dict[str, Any]:
        """Get current crew chat context"""
        if not self.context_key:
            raise ValueError("Context not initialized")
            
        return cache.get(self.context_key, {})
    
    async def update_current_task(self, task_id: Optional[int]):
        """Update current task in context"""
        if not self.context_key:
            raise ValueError("Context not initialized")
            
        try:
            context = cache.get(self.context_key, {})
            context['current_task'] = task_id
            cache.set(self.context_key, context, timeout=3600)
            
        except Exception as e:
            logger.error(f"Error updating current task: {str(e)}")
            raise

================
File: apps/agents/chat/managers/message_manager.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage, AIMessage, HumanMessage, SystemMessage
from django.core.cache import cache
from typing import List, Optional, Dict, Any
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter
from apps.agents.chat.formatters.table_formatter import TableFormatter
from apps.agents.models import ChatMessage, ToolRun
import logging
import json
from django.db import models
import asyncio

logger = logging.getLogger(__name__)

def messages_to_dict(messages: List[BaseMessage]) -> List[Dict]:
    """Convert message objects to dictionary format for storage."""
    return [{
        'type': message.__class__.__name__,
        'content': message.content,
        'additional_kwargs': message.additional_kwargs
    } for message in messages]

def dict_to_messages(messages_dict: List[Dict]) -> List[BaseMessage]:
    """Convert dictionary format back to message objects."""
    message_types = {
        'HumanMessage': HumanMessage,
        'AIMessage': AIMessage,
        'SystemMessage': SystemMessage
    }
    
    return [
        message_types[msg['type']](
            content=msg['content'],
            additional_kwargs=msg.get('additional_kwargs', {})
        ) for msg in messages_dict
    ]

class MessageManager(BaseChatMessageHistory):
    """
    Manages chat message history, storage, and formatting.
    Consolidates message-related functionality from across the codebase.
    """
    
    def __init__(self, 
                 conversation_id: Optional[str] = None,
                 session_id: Optional[str] = None,
                 agent_id: Optional[int] = None,
                 ttl: int = 3600):
        """
        Initialize the MessageManager.
        
        Args:
            conversation_id: Unique identifier for the conversation
            session_id: Unique identifier for the current session
            agent_id: ID of the agent associated with this conversation
            ttl: Time-to-live for cached messages in seconds
        """
        super().__init__()
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.agent_id = agent_id
        self.ttl = ttl
        self.tool_formatter = ToolFormatter()
        self.messages_cache_key = f"messages_{self.session_id}"
        self._messages = []

    @property
    def messages(self) -> List[BaseMessage]:
        """Get all messages in the history. Required by BaseChatMessageHistory."""
        if self.messages_cache_key:
            messages_dict = cache.get(self.messages_cache_key, [])
            return dict_to_messages(messages_dict)
        return self._messages.copy()

    @messages.setter
    def messages(self, messages: List[BaseMessage]) -> None:
        """Set messages in the history. Required by BaseChatMessageHistory."""
        self._messages = messages.copy()
        if self.messages_cache_key:
            messages_dict = messages_to_dict(messages)
            cache.set(self.messages_cache_key, messages_dict, self.ttl)

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Add a message to the history and persist it.
        This is the central function for all message persistence.
        
        Args:
            message: The message to add
            token_usage: Optional token usage stats
            
        Returns:
            ChatMessage: The created message object, or None if creation failed
        """
        try:
            # For agent finish messages, extract JSON data if present
            if isinstance(message, AIMessage) and message.content:
                # Look for JSON code blocks
                if '```json' in message.content:
                    parts = message.content.split('```json')
                    if len(parts) > 1:
                        text_content = parts[0].strip()
                        json_str = parts[1].split('```')[0].strip()
                        try:
                            # Validate JSON
                            json_data = json.loads(json_str)
                            # Store as separate messages
                            if text_content:
                                await self._store_message_in_db(AIMessage(content=text_content), token_usage)
                            message.content = json.dumps(json_data)
                        except json.JSONDecodeError:
                            # If JSON is invalid, keep original message
                            pass

            # Store in database only if we have a conversation ID
            if self.conversation_id:
                return await self._store_message_in_db(message, token_usage)
            return None
                
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    async def get_messages(self) -> List[BaseMessage]:
        """Get all non-deleted messages in the history."""
        try:
            if self.conversation_id:
                from apps.agents.models import ChatMessage, ToolRun
                
                # First get non-deleted messages
                query = {
                    'conversation_id': self.conversation_id,
                    'is_deleted': False  # Only get non-deleted messages
                }
                
                logger.debug(f"Retrieving messages for conversation {self.conversation_id}")
                    
                messages = await database_sync_to_async(
                    lambda: list(
                        ChatMessage.objects.filter(**query)
                        .prefetch_related(
                            # Only prefetch tool runs associated with non-deleted messages
                            models.Prefetch(
                                'tool_runs',
                                queryset=ToolRun.objects.filter(
                                    message__is_deleted=False,
                                    is_deleted=False
                                )
                            )
                        )
                        .order_by('timestamp')
                    )
                )()
                
                logger.debug(f"Retrieved {len(messages)} messages from database")

                result = []
                for msg in messages:
                    logger.debug(f"Processing message ID: {msg.id}, Content: {msg.content[:50]}...")
                    
                    # Process the message differently based on type
                    if not msg.is_agent:
                        # Human messages (no tool processing needed)
                        result.append(HumanMessage(
                            content=msg.content,
                            additional_kwargs={'id': str(msg.id)}
                        ))
                    else:
                        # For agent messages, we need to check tool runs
                        additional_kwargs = await self._process_tool_runs(msg) if msg.is_agent else {'id': str(msg.id)}
                        
                        # AI messages
                        result.append(AIMessage(
                            content=msg.content,
                            additional_kwargs=additional_kwargs
                        ))

                # Update the in-memory cache with the loaded messages
                self._messages = result.copy()
                if self.messages_cache_key:
                    messages_dict = messages_to_dict(result)
                    cache.set(self.messages_cache_key, messages_dict, self.ttl)
                
                return result
            return self._messages.copy()
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}", exc_info=True)
            return []

    @database_sync_to_async
    def _process_tool_runs(self, message):
        """Process tool runs for a message in a synchronous context."""
        additional_kwargs = {'id': str(message.id)}
        
        try:
            if hasattr(message, 'tool_runs'):
                tool_runs = list(message.tool_runs.all())
                logger.debug(f"Message {message.id} has {len(tool_runs)} tool runs")
                
                if tool_runs:
                    # Get the first tool run
                    tool_run = tool_runs[0]
                    tool_name = tool_run.tool.name if tool_run.tool else 'unknown_tool'
                    logger.debug(f"Tool run ID: {tool_run.id}, Tool: {tool_name}")
                    
                    # Parse tool output if it's JSON
                    if tool_run.result and tool_run.result.strip():
                        logger.debug(f"Tool result raw: {tool_run.result[:100]}...")
                        try:
                            tool_output = json.loads(tool_run.result)
                            logger.debug("Successfully parsed tool result as JSON")
                        except json.JSONDecodeError:
                            tool_output = tool_run.result
                            logger.debug("Could not parse tool result as JSON, using raw string")
                        
                        # Add tool data to additional_kwargs
                        additional_kwargs['tool_call'] = {
                            'name': tool_name,
                            'output': tool_output
                        }
                        logger.debug(f"Added tool_call to additional_kwargs for message {message.id}")
        except Exception as e:
            logger.error(f"Error processing tool runs: {str(e)}", exc_info=True)
            
        return additional_kwargs

    async def add_messages(self, messages: List[BaseMessage]) -> None:
        """Add multiple messages to the history."""
        for message in messages:
            await self.add_message(message)

    def clear(self) -> None:
        """Required abstract method: Clear all messages."""
        pass  # No cache to clear anymore

    async def clear_messages(self) -> None:
        """Clear all messages from the history."""
        try:
            if self.conversation_id:
                await database_sync_to_async(ChatMessage.objects.filter(
                    conversation_id=self.conversation_id
                ).delete)()
                
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    @database_sync_to_async
    def _store_message_in_db(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Store a message in the database.
        Centralized database persistence function.
        
        Returns:
            ChatMessage: The created message object, or None if creation failed
        """
        try:
            from apps.agents.models import ChatMessage, Conversation, TokenUsage, ToolRun, Tool
            
            # Get the conversation by session_id
            conversation = Conversation.objects.filter(
                session_id=self.session_id
            ).select_related('user', 'agent').first()
            
            if not conversation:
                logger.error(f"No conversation found with session ID: {self.session_id}")
                return None
                
            # Determine if message is from agent or user
            is_agent = not isinstance(message, HumanMessage)
            
            # Create the message
            chat_message = ChatMessage.objects.create(
                session_id=self.session_id,
                conversation=conversation,
                agent=conversation.agent,
                user=conversation.user,
                content=message.content,
                is_agent=is_agent,
                model=token_usage.get('model', 'unknown') if token_usage else 'unknown'
            )
            
            # Store token usage if provided
            if token_usage:
                TokenUsage.objects.create(
                    conversation=conversation,
                    message=chat_message,
                    prompt_tokens=token_usage.get('prompt_tokens', 0),
                    completion_tokens=token_usage.get('completion_tokens', 0),
                    total_tokens=token_usage.get('total_tokens', 0),
                    model=token_usage.get('model', 'unknown'),
                    metadata={'message_type': message.__class__.__name__}
                )
            
            # Store tool runs if this is a tool-related message
            if message.additional_kwargs.get('tool_call'):
                tool_call = message.additional_kwargs['tool_call']
                tool_name = tool_call.get('name')
                tool_input = tool_call.get('input', {})
                tool_output = tool_call.get('output')
                
                if tool_name:
                    tool = Tool.objects.filter(name=tool_name).first()
                    if tool:
                        # Ensure tool_output is proper JSON
                        try:
                            if isinstance(tool_output, str):
                                # If it's a string, try to parse it to ensure valid JSON
                                output_json = json.loads(tool_output)
                            else:
                                output_json = tool_output
                            # Store as JSON string
                            tool_output = json.dumps(output_json)
                        except:
                            # If not valid JSON, store as string
                            tool_output = str(tool_output)
                            
                        ToolRun.objects.create(
                            tool=tool,
                            conversation=conversation,
                            message=chat_message,
                            status='completed',
                            inputs=tool_input,
                            result=tool_output
                        )
            
            return chat_message
                
        except Exception as e:
            logger.error(f"Error storing message in database: {str(e)}", exc_info=True)
            raise


    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing by marking the message and subsequent messages as deleted."""
        try:
            # Get the message's timestamp
            message = await database_sync_to_async(
                ChatMessage.objects.get
            )(id=message_id)
            
            # Mark this message and all subsequent messages as deleted
            deleted_count = await database_sync_to_async(
                ChatMessage.objects.filter(
                    conversation_id=self.conversation_id,
                    timestamp__gte=message.timestamp
                ).update
            )(is_deleted=True)
            
            # Also mark associated tool runs as deleted
            await database_sync_to_async(
                ToolRun.objects.filter(
                    conversation_id=self.conversation_id,
                    message__timestamp__gte=message.timestamp
                ).update
            )(is_deleted=True)
            
            logger.debug(f"Message timestamp: {message.timestamp}. {deleted_count} messages and their tool runs marked as deleted.")
                    
        except Exception as e:
            logger.error(f"Error handling message edit: {str(e)}")
            raise

    def format_message(self, content: Any, message_type: Optional[str] = None) -> str:
        """Format a message for display."""
        try:
            # If content is a dict, convert to string representation
            if isinstance(content, dict):
                return json.dumps(content, indent=2)
                
            # Handle tool messages
            if message_type and message_type.startswith('tool_'):
                return self.tool_formatter.format_tool_usage(str(content), message_type)
                
            return str(content)
        except Exception as e:
            logger.error(f"Error formatting message: {str(e)}")
            return str(content)

    async def get_conversation_summary(self) -> str:
        """Get a summary of the conversation."""
        messages = await self.get_messages()
        if not messages:
            return "No messages in conversation"
        
        summary_parts = []
        for msg in messages:
            msg_type = msg.__class__.__name__.replace('Message', '')
            summary_parts.append(f"{msg_type}: {msg.content[:100]}...")
        
        return "\n".join(summary_parts) 

    async def get_message_ids(self) -> Dict[str, str]:
        """Get a mapping of message content to message IDs."""
        messages = await ChatMessage.objects.filter(
            conversation_id=self.conversation_id
        ).values('id', 'content')
        return {msg['content']: str(msg['id']) for msg in messages}

    async def add_messages(self, messages: List[BaseMessage]) -> None:
        """Add multiple messages to the history asynchronously."""
        for message in messages:
            await self.add_message(message)

    def add_messages_sync(self, messages: List[BaseMessage]) -> None:
        """Synchronous version of add_messages."""
        from django.db import transaction
        for message in messages:
            self.add_message_sync(message)
            
    def add_message_sync(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """Synchronous version of add_message."""
        try:
            # For agent finish messages, extract JSON data if present
            if isinstance(message, AIMessage) and message.content:
                # Look for JSON code blocks
                if '```json' in message.content:
                    parts = message.content.split('```json')
                    if len(parts) > 1:
                        text_content = parts[0].strip()
                        json_str = parts[1].split('```')[0].strip()
                        try:
                            # Validate JSON
                            json_data = json.loads(json_str)
                            # Store as separate messages
                            if text_content:
                                self._store_message_in_db_sync(AIMessage(content=text_content), token_usage)
                            message.content = json.dumps(json_data)
                        except json.JSONDecodeError:
                            # If JSON is invalid, keep original message
                            pass

            # Store in database only if we have a conversation ID
            if self.conversation_id:
                return self._store_message_in_db_sync(message, token_usage)
            return None
                
        except Exception as e:
            logger.error(f"Error adding message synchronously: {str(e)}")
            raise
    
    def get_messages_sync(self) -> List[BaseMessage]:
        """Synchronous version of get_messages."""
        try:
            if self.conversation_id:
                from apps.agents.models import ChatMessage, ToolRun
                
                # First get non-deleted messages
                query = {
                    'conversation_id': self.conversation_id,
                    'is_deleted': False  # Only get non-deleted messages
                }
                
                logger.debug(f"Retrieving messages synchronously for conversation {self.conversation_id}")
                    
                messages = list(
                    ChatMessage.objects.filter(**query)
                    .prefetch_related(
                        # Only prefetch tool runs associated with non-deleted messages
                        models.Prefetch(
                            'tool_runs',
                            queryset=ToolRun.objects.filter(
                                message__is_deleted=False,
                                is_deleted=False
                            )
                        )
                    )
                    .order_by('timestamp')
                )
                
                logger.debug(f"Retrieved {len(messages)} messages from database (sync)")

                result = []
                for msg in messages:
                    # Process the message differently based on type
                    if not msg.is_agent:
                        # Human messages (no tool processing needed)
                        result.append(HumanMessage(
                            content=msg.content,
                            additional_kwargs={'id': str(msg.id)}
                        ))
                    else:
                        # For agent messages, we need to check tool runs
                        additional_kwargs = self._process_tool_runs_sync(msg) if msg.is_agent else {'id': str(msg.id)}
                        
                        # AI messages
                        result.append(AIMessage(
                            content=msg.content,
                            additional_kwargs=additional_kwargs
                        ))

                # Update the in-memory cache with the loaded messages
                self._messages = result.copy()
                if self.messages_cache_key:
                    messages_dict = messages_to_dict(result)
                    cache.set(self.messages_cache_key, messages_dict, self.ttl)
                
                return result
            return self._messages.copy()
        except Exception as e:
            logger.error(f"Error getting messages synchronously: {str(e)}")
            return []
    
    def _process_tool_runs_sync(self, message):
        """Process tool runs for a message in a synchronous context."""
        additional_kwargs = {'id': str(message.id)}
        
        try:
            if hasattr(message, 'tool_runs'):
                tool_runs = list(message.tool_runs.all())
                
                if tool_runs:
                    # Get the first tool run
                    tool_run = tool_runs[0]
                    tool_name = tool_run.tool.name if tool_run.tool else 'unknown_tool'
                    
                    # Parse tool output if it's JSON
                    if tool_run.result and tool_run.result.strip():
                        try:
                            tool_output = json.loads(tool_run.result)
                        except json.JSONDecodeError:
                            tool_output = tool_run.result
                        
                        # Add tool data to additional_kwargs
                        additional_kwargs['tool_call'] = {
                            'name': tool_name,
                            'output': tool_output
                        }
        except Exception as e:
            logger.error(f"Error processing tool runs synchronously: {str(e)}")
            
        return additional_kwargs
        
    def _store_message_in_db_sync(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """Store a message in the database synchronously."""
        try:
            from apps.agents.models import ChatMessage, Conversation
            
            # Find the conversation
            conversation = Conversation.objects.filter(id=self.conversation_id).first()
            if not conversation:
                logger.error(f"Conversation with ID {self.conversation_id} not found")
                return None
                
            # Default message attributes
            message_attrs = {
                'conversation': conversation,
                'content': message.content or "",
                'is_agent': isinstance(message, AIMessage),
                'is_edited': False
            }
            
            # Add token usage if provided
            if token_usage:
                message_attrs.update({
                    'prompt_tokens': token_usage.get('prompt_tokens', 0),
                    'completion_tokens': token_usage.get('completion_tokens', 0),
                    'total_tokens': token_usage.get('total_tokens', 0)
                })
                
            # Create and save message
            chat_message = ChatMessage.objects.create(**message_attrs)
            
            # Update conversation
            conversation.updated_at = chat_message.timestamp
            conversation.save(update_fields=['updated_at'])
            
            logger.debug(f"Created message {chat_message.id} for conversation {self.conversation_id}")
            return chat_message
            
        except Exception as e:
            logger.error(f"Error storing message in DB: {str(e)}")
            return None

================
File: apps/agents/chat/managers/prompt_manager.py
================
import logging
from typing import Dict, List, Optional, Any, Union
from langchain.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.schema import SystemMessage, HumanMessage, AIMessage
from langchain_core.messages import BaseMessage
from django.utils import timezone
import json
from apps.common.utils import create_box

logger = logging.getLogger(__name__)

class PromptManager:
    """
    Manages prompt generation, formatting, and template management for chat agents.
    Consolidates prompt-related functionality from across the codebase.
    """
    
    def __init__(self, system_prompt: Optional[str] = None):
        """
        Initialize the PromptManager.
        
        Args:
            system_prompt: Optional system prompt to use as default
        """
        self.system_prompt = system_prompt or self._get_default_system_prompt()
        self.prompt_templates = {}
        self._box_width = 80

    def _get_default_system_prompt(self) -> str:
        """Get the default system prompt."""
        return """You are a helpful AI assistant. You aim to provide accurate, helpful responses
        while maintaining a professional and friendly tone. You will:
        1. Answer questions clearly and concisely
        2. Use appropriate tools when needed
        3. Admit when you don't know something
        4. Ask for clarification when needed
        5. Give output in markdown format"""

    def create_chat_prompt(self, 
                        system_prompt: Optional[str] = None,
                        tools: Optional[List] = None,
                        chat_history: Optional[List] = None,
                        client_data: Optional[Dict] = None) -> ChatPromptTemplate:
        """
        Create a chat prompt template with system message and message history.
        """
        # Debug logging for message template creation

        # Create the system prompt with explicit JSON format instructions
        system_template = '''{system_prompt}

    You have access to the following tools:

    {tools}

    Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

    Valid "action" values: "Final Answer" or {tool_names}

    Provide only ONE action per $JSON_BLOB, as shown:

    ```
    {{
      "action": $TOOL_NAME,
      "action_input": $INPUT
    }}
    ```

    IMPORTANT: For tools that require authentication or credentials (like analytics_credentials and analytics_property_id), 
    you MUST include these credentials in EVERY tool call, even for follow-up calls. 
    These credentials are NOT persistent between calls and must be explicitly included each time.

    Follow this format:

    Question: input question to answer
    Thought: consider previous and subsequent steps
    Action:
    $JSON_BLOB

    Observation: action result
    ... (repeat Thought/Action/Observation N times)
    Thought: I know what to respond
    Action:
    {{
    "action": "Final Answer",
    "action_input": "Final response to human"
    }}


    Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate.'''

        # Format tools and descriptions
        tool_descriptions = [f"{tool.name}: {tool.description}" for tool in (tools or [])]
        tool_names = [tool.name for tool in (tools or [])]

        # Create the prompt template with proper message structure
        messages = [
            ("system", system_template),
            MessagesPlaceholder(variable_name="chat_history", optional=True),
            ("human", "{input}\n\n{agent_scratchpad}\n\n(reminder to respond in a JSON blob no matter what)"),
        ]

        
        prompt = ChatPromptTemplate.from_messages(messages)

        # Only partially fill system-level variables, NOT agent_scratchpad or chat_history
        system_variables = {
            "system_prompt": system_prompt or self.system_prompt,
            "tools": "\n".join(tool_descriptions),
            "tool_names": ", ".join(tool_names)
        }
        
        partial = prompt.partial(**system_variables)



        return partial

    def format_chat_history(self, messages: Union[str, List[BaseMessage], List[Dict]]) -> List[BaseMessage]:
        """
        Format chat history for prompt inclusion.
        Handles string, dict, and BaseMessage formats.
        Escapes any template variables in message content.
        """
        if isinstance(messages, str):
            # Try to parse string as JSON list of messages
            try:
                messages = json.loads(messages)
            except:
                return []
        
        formatted_messages = []
        for msg in messages:
            if isinstance(msg, BaseMessage):
                # Escape any template variables in content
                content = msg.content.replace("{", "{{").replace("}", "}}")
                if isinstance(msg, HumanMessage):
                    formatted_messages.append(HumanMessage(content=content))
                elif isinstance(msg, AIMessage):
                    formatted_messages.append(AIMessage(content=content))
                else:
                    formatted_messages.append(msg.__class__(content=content))
            elif isinstance(msg, dict):
                # Convert dict to appropriate message type and escape content
                content = msg.get('content', '').replace("{", "{{").replace("}", "}}")
                if msg.get('type') == 'human' or msg.get('is_user', False):
                    formatted_messages.append(HumanMessage(content=content))
                else:
                    formatted_messages.append(AIMessage(content=content))
            else:
                logger.warning(f"Unhandled message format: {type(msg)}")
                
        return formatted_messages

    def _format_context(self, context: Dict) -> str:
        """Format additional context into a string."""
        context_parts = []
        for key, value in context.items():
            if isinstance(value, (list, dict)):
                context_parts.append(f"{key}:\n{self._format_structured_value(value)}")
            else:
                context_parts.append(f"{key}: {value}")
        return "\n".join(context_parts)

    def _format_structured_value(self, value: Any, indent: int = 2) -> str:
        """Format structured values (lists/dicts) with proper indentation."""
        if isinstance(value, list):
            return "\n".join(" " * indent + f"- {item}" for item in value)
        elif isinstance(value, dict):
            return "\n".join(" " * indent + f"{k}: {v}" for k, v in value.items())
        return str(value)

    def create_tool_prompt(self, tool_name: str, tool_args: Dict) -> str:
        """Create a prompt for tool execution."""
        return f"Using tool: {tool_name}\nInput: {tool_args}"

    def create_error_prompt(self, error: str) -> str:
        """Create a prompt for error messages."""
        return f"Error occurred: {error}\nPlease try again or use a different approach."

    def register_prompt_template(self, name: str, template: str) -> None:
        """Register a new prompt template."""
        self.prompt_templates[name] = template

    def get_prompt_template(self, name: str) -> Optional[str]:
        """Get a registered prompt template."""
        return self.prompt_templates.get(name)

    def format_prompt(self, template_name: str, **kwargs) -> Optional[str]:
        """Format a registered prompt template with provided arguments."""
        template = self.get_prompt_template(template_name)
        if template:
            try:
                return template.format(**kwargs)
            except KeyError as e:
                logger.error(f"Missing required argument in prompt template: {str(e)}")
            except Exception as e:
                logger.error(f"Error formatting prompt template: {str(e)}")
        return None 

    def create_agent_prompt(self, agent, client_data: Optional[Dict] = None) -> str:
        """
        Create the system prompt for the agent with client context.
        
        Args:
            agent: The agent instance
            client_data: Optional dictionary containing client information
        """
        try:
            # Base agent prompt with escaped variables
            prompt = f"""You are {agent.name}, an AI assistant.

Role: {agent.role}

Goal: {{{{goal}}}}

Backstory: {agent.backstory if hasattr(agent, 'backstory') else ''}
"""
            # Add client context if available
            if client_data:
                client_context = self._create_client_context(client_data)
                prompt += f"\n{client_context}"
            else:
                prompt += f"\nCurrent Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

            # Replace the goal placeholder with actual goal if available
            if hasattr(agent, 'goal'):
                prompt = prompt.replace('{{goal}}', agent.goal)
            else:
                prompt = prompt.replace('{{goal}}', 'Help users accomplish their tasks effectively.')
#            logger.debug(create_box("AGENT PROMPT",f"Agent prompt: {prompt}"))
            return prompt

        except Exception as e:
            logger.error(f"Error creating agent prompt: {str(e)}", exc_info=True)
            return self._get_default_system_prompt()


    def _create_client_context(self, client_data: Dict) -> str:
        """Create formatted client context string."""
        try:
            # Start with the current date, which we always want to include
            context = f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"
            
            if not client_data:
                return context
            
            # Process all client_data entries consistently
            for key, value in client_data.items():
                # Skip None values and the client object itself
                if value is None or key == 'client':
                    continue
                    
                # Format the key for better readability
                formatted_key = key.replace('_', ' ').title()
                
                # Handle different types of values
                if isinstance(value, dict):
                    # Use json.dumps for pretty-printing dictionaries
                    pretty_dict = json.dumps(value, indent=2)
                    context += f"\n\n{formatted_key}:\n{pretty_dict}"
                elif isinstance(value, list):
                    if value:  # Only add if the list has items
                        list_text = "\n".join([f"- {item}" for item in value])
                        context += f"\n\n{formatted_key}:\n{list_text}"
                else:
                    context += f"\n\n{formatted_key}: {value}"
            
            return context

        except Exception as e:
            logger.error(f"Error creating client context: {str(e)}", exc_info=True)
            return f"Current Context:\n- Current Date: {timezone.now().strftime('%Y-%m-%d')}"

================
File: apps/agents/chat/managers/token_manager.py
================
import logging
import tiktoken
from django.core.cache import cache
from django.db import models
from typing import Dict, Optional, Any
from channels.db import database_sync_to_async
from apps.agents.models import TokenUsage
from apps.common.utils import get_llm
from datetime import datetime
import uuid
import json

logger = logging.getLogger(__name__)

class TokenManager:
    """
    Manages token counting, tracking, and limits for chat conversations.
    Consolidates token-related functionality from across the codebase.
    """
    
    def __init__(self, conversation_id: str, session_id: str, model_name: str, max_token_limit: Optional[int] = None):
        """Initialize TokenManager with conversation ID and session ID"""
        self.conversation_id = conversation_id
        self.session_id = session_id
        self.model_name = model_name
        self.token_callback = None
        
        # Determine max token limit based on model
        # Gemini has a 1M token window, most others are 128k or less
        # Use 80% of the window to leave room for responses
        if max_token_limit is not None:
            self.max_token_limit = max_token_limit
        elif "gemini" in model_name.lower():
            self.max_token_limit = 800000  # 80% of 1M token window
            logger.debug("TokenManager: Using Gemini model with 800k token memory window")
        else:
            # For other models, assume 128k window and use 80% of that
            self.max_token_limit = 100000  # 80% of 128k token window
            logger.debug(f"TokenManager: Using standard model with {self.max_token_limit//1000}k token memory window")
        
        # Initialize token tracking
        self.reset_tracking()
        
        # Use cl100k_base as default tokenizer which works with most models
        # Don't try to map model names automatically as it won't work for all models (like Gemini)
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
        
        self.input_tokens = 0
        self.output_tokens = 0
        
    def set_token_callback(self, callback):
        """Set the token callback from the LLM."""
        self.token_callback = callback
    
    def track_token_usage(self, prompt_tokens: int = 0, completion_tokens: int = 0):
        """
        Track token usage for the current session.
        
        There is likely a double-counting issue happening. This method gets called
        multiple times for the same tokens.
        """
        # LOG before adding so we know the original values
        logger.debug(f"BEFORE track_token_usage: input={self.input_tokens}, output={self.output_tokens}")
        logger.debug(f"ADDING: prompt={prompt_tokens}, completion={completion_tokens}")
        
        # Don't add tokens if they're suspiciously high (likely double counted)
        if prompt_tokens > 20000 or completion_tokens > 5000:
            logger.warning(f"Unusually high token count detected: prompt={prompt_tokens}, completion={completion_tokens}. Skipping to prevent double counting.")
            return
        
        # Ensure values are actually integers
        self.input_tokens = (self.input_tokens or 0) + (prompt_tokens or 0)
        self.output_tokens = (self.output_tokens or 0) + (completion_tokens or 0)
        
        # LOG after adding so we know the new values
        logger.debug(f"AFTER track_token_usage: input={self.input_tokens}, output={self.output_tokens}")
        
        # Store in cache for session-level tracking
        if self.session_id:
            session_cache_key = f"token_totals_{self.session_id}"
            session_totals = cache.get(session_cache_key, {
                'prompt_tokens': 0,
                'completion_tokens': 0,
                'total_tokens': 0
            })
            
            # Only add the difference to avoid double counting
            if prompt_tokens > 0 or completion_tokens > 0:
                session_totals['prompt_tokens'] += prompt_tokens
                session_totals['completion_tokens'] += completion_tokens
                session_totals['total_tokens'] += (prompt_tokens + completion_tokens)
                
                cache.set(session_cache_key, session_totals, 3600)  # 1 hour expiry

    def get_current_usage(self) -> Dict[str, int]:
        """Get current token usage for the session."""
        # Always prioritize the token_callback data as it's the most accurate
        if self.token_callback:
            input_tokens = getattr(self.token_callback, 'input_tokens', 0) or 0
            output_tokens = getattr(self.token_callback, 'output_tokens', 0) or 0
            
            # Log these values for debugging
            logger.debug(f"Token callback reports: input={input_tokens}, output={output_tokens}")
            
            return {
                'prompt_tokens': input_tokens,
                'completion_tokens': output_tokens,
                'total_tokens': input_tokens + output_tokens,
                'model': self.model_name
            }
        
        # Fall back to instance variables if no callback is available
        logger.debug(f"No token callback, using instance vars: input={self.input_tokens}, output={self.output_tokens}")
        return {
            'prompt_tokens': self.input_tokens or 0,
            'completion_tokens': self.output_tokens or 0,
            'total_tokens': (self.input_tokens or 0) + (self.output_tokens or 0),
            'model': self.model_name
        }

    def reset_tracking(self):
        """Reset token tracking for the current session."""
        self.input_tokens = 0
        self.output_tokens = 0
        if self.token_callback:
            self.token_callback.input_tokens = 0
            self.token_callback.output_tokens = 0

    async def _reset_session_token_totals(self):
        """Reset token totals for the session."""
        if self.session_id:
            cache.delete(f"token_totals_{self.session_id}")

    @database_sync_to_async
    def store_token_usage(self, message_id: str, token_usage: Dict[str, Any]):
        """Store token usage in the database."""
        if not self.conversation_id:
            return

        try:
            TokenUsage.objects.create(
                conversation_id=self.conversation_id,
                message_id=message_id,
                prompt_tokens=token_usage.get('prompt_tokens', 0),
                completion_tokens=token_usage.get('completion_tokens', 0),
                total_tokens=token_usage.get('total_tokens', 0),
                model=token_usage.get('model', ''),
                metadata=token_usage.get('metadata', {})
            )
        except Exception as e:
            logger.error(f"Error storing token usage: {str(e)}")

    @database_sync_to_async
    def get_conversation_token_usage(self) -> Dict[str, int]:
        """Get total token usage for the conversation."""
        if not self.conversation_id:
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

        try:
            # Handle different types of conversation_id inputs
            # It could be either a numeric ID or a UUID session_id
            query = None
            
            try:
                # Check if it's a valid UUID (session_id)
                uuid.UUID(str(self.conversation_id))
                # If it's a UUID, filter by session_id
                query = TokenUsage.objects.filter(conversation__session_id=self.conversation_id)
            except (ValueError, TypeError):
                # If it's not a valid UUID, assume it's a database ID
                try:
                    # Try to convert to int in case it's a string representation of a number
                    conversation_id = int(self.conversation_id)
                    query = TokenUsage.objects.filter(conversation_id=conversation_id)
                except (ValueError, TypeError):
                    # If conversion to int fails, try as a string ID
                    query = TokenUsage.objects.filter(conversation_id=self.conversation_id)
            
            # Only count each message once to avoid double counting
            if query:
                # Exclude conversation-level tracking records to avoid double counting
                query = query.exclude(metadata__contains={'type': 'conversation_tracking'})
                
                # CRITICAL: Get only the maximum token usage per each unique message_id
                # This ensures we don't count the same message multiple times if it has multiple records
                unique_message_tokens = query.values('message_id').annotate(
                    max_total=models.Max('total_tokens'),
                    max_prompt=models.Max('prompt_tokens'),
                    max_completion=models.Max('completion_tokens')
                )
                
                # Sum up the maximums for each unique message
                total_tokens = sum(item['max_total'] or 0 for item in unique_message_tokens)
                prompt_tokens = sum(item['max_prompt'] or 0 for item in unique_message_tokens)
                completion_tokens = sum(item['max_completion'] or 0 for item in unique_message_tokens)
                
                # Log the number of records being counted to help debug
                num_records = len(unique_message_tokens)
                logger.debug(f"Counted token usage from {num_records} unique messages")
                
                return {
                    'total_tokens': total_tokens,
                    'prompt_tokens': prompt_tokens,
                    'completion_tokens': completion_tokens
                }
            
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}
            
        except Exception as e:
            logger.error(f"Error getting conversation token usage: {str(e)}", exc_info=True)
            return {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}

    async def track_conversation_tokens(self):
        """
        Track token usage for the entire conversation.
        
        IMPORTANT: This should be called sparingly, only when we need to record
        the current state of conversation tokens, not after every message.
        """
        if not self.conversation_id:
            return
            
        # Log that we're tracking conversation-level tokens to help with debugging
        logger.debug("Recording conversation-level token tracking")

        # We will NOT store the "current usage" again as a conversation-level record
        # as this leads to double counting. Instead, we'll ensure our existing token
        # tracking is properly attributed to this conversation.
        
        # Verify existing records are properly linked to this conversation
        # by counting how many we have
        existing_count = await self._count_token_records()
        logger.debug(f"Verified {existing_count} token usage records for conversation {self.conversation_id}")
            
    @database_sync_to_async
    def _count_token_records(self):
        """Count how many token records exist for this conversation."""
        try:
            # Handle different types of conversation_id inputs
            try:
                # Check if it's a valid UUID (session_id)
                uuid.UUID(str(self.conversation_id))
                count = TokenUsage.objects.filter(conversation__session_id=self.conversation_id).count()
            except (ValueError, TypeError):
                # If it's not a valid UUID, assume it's a database ID
                try:
                    conversation_id = int(self.conversation_id)
                    count = TokenUsage.objects.filter(conversation_id=conversation_id).count()
                except (ValueError, TypeError):
                    count = TokenUsage.objects.filter(conversation_id=self.conversation_id).count()
            return count
        except Exception as e:
            logger.error(f"Error counting token records: {e}")
            return 0

    def count_tokens(self, text: str) -> int:
        """Count tokens in text using the initialized tokenizer."""
        try:
            return len(self.tokenizer.encode(text, disallowed_special=()))
        except Exception as e:
            logger.error(f"Error counting tokens: {str(e)}")
            return 0

================
File: apps/agents/chat/managers/tool_manager.py
================
import logging
from typing import List, Dict, Any, Optional
from langchain.tools import Tool, StructuredTool
from apps.agents.utils import get_tool_classes
from channels.db import database_sync_to_async
from apps.agents.chat.formatters.tool_formatter import ToolFormatter

logger = logging.getLogger(__name__)

class ToolManager:
    """
    Manages tool loading, execution, and formatting.
    Consolidates tool-related functionality from across the codebase.
    """
    
    def __init__(self):
        """Initialize the ToolManager."""
        self.tools = []
        self.tool_formatter = ToolFormatter()

    async def load_tools(self, agent) -> List[Tool]:
        """Load and initialize agent tools."""
        try:
            tools = []
            seen_tools = set()
            
            # Get tools using database_sync_to_async
            agent_tools = await self._get_agent_tools(agent)
            
            for tool_model in agent_tools:
                try:
                    tool_key = f"{tool_model.tool_class}_{tool_model.tool_subclass}"
                    if tool_key in seen_tools:
                        continue
                    seen_tools.add(tool_key)

                    tool_classes = get_tool_classes(tool_model.tool_class)
                    tool_class = next((cls for cls in tool_classes 
                                   if cls.__name__ == tool_model.tool_subclass), None)
                    
                    if tool_class:
                        tool_instance = tool_class()
                        
                        # Convert to Langchain format
                        langchain_tool = self._create_langchain_tool(tool_instance)
                        if langchain_tool:
                            tools.append(langchain_tool)
                            
                except Exception as e:
                    logger.error(f"Error initializing tool {tool_model.tool_subclass}: {str(e)}")
                    continue

            self.tools = tools
            return tools
            
        except Exception as e:
            logger.error(f"Error loading tools: {str(e)}")
            raise

    @database_sync_to_async
    def _get_agent_tools(self, agent):
        """Get agent tools from database."""
        return list(agent.tools.all())

    def _create_langchain_tool(self, tool_instance) -> Optional[Tool]:
        """Create a Langchain tool from a tool instance."""
        try:
            # Use StructuredTool if args_schema is present
            if hasattr(tool_instance, 'args_schema'):
                return StructuredTool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None,
                    args_schema=tool_instance.args_schema
                )
            else:
                return Tool(
                    name=tool_instance.name,
                    description=self._create_tool_description(tool_instance),
                    func=tool_instance.run,
                    coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None
                )
        except Exception as e:
            logger.error(f"Error creating Langchain tool: {str(e)}")
            return None

    def _create_tool_description(self, tool_instance) -> str:
        """Create a description for the tool."""
        description = tool_instance.description
        if hasattr(tool_instance, 'args_schema'):
            schema = tool_instance.args_schema.schema()
            if 'properties' in schema:
                args_desc = []
                for name, details in schema['properties'].items():
                    arg_desc = f"- {name}: {details.get('description', 'No description')}"
                    if details.get('type'):
                        arg_desc += f" (type: {details['type']})"
                    args_desc.append(arg_desc)
                if args_desc:
                    description += "\nArguments:\n" + "\n".join(args_desc)
        return description

    async def execute_tool(self, tool_name: str, **kwargs) -> Any:
        """Execute a tool with given arguments."""
        try:
            tool = next((t for t in self.tools if t.name == tool_name), None)
            if not tool:
                raise ValueError(f"Tool not found: {tool_name}")
            
            if tool.coroutine:
                result = await tool.coroutine(**kwargs)
            else:
                result = tool.func(**kwargs)
                
            return result
            
        except Exception as e:
            logger.error(f"Error executing tool {tool_name}: {str(e)}")
            raise

    def format_tool_output(self, content: Any) -> str:
        """Format tool output for display."""
        return self.tool_formatter.format_tool_output(content)

    def format_tool_usage(self, content: str, message_type: str = None) -> str:
        """Format tool usage messages."""
        return self.tool_formatter.format_tool_usage(content, message_type)

================
File: apps/agents/chat/tests/test_callback_handler.py
================
import pytest
import asyncio
from unittest.mock import Mock, patch
from datetime import datetime
from langchain_core.agents import AgentFinish
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler

@pytest.fixture
def mock_consumer():
    consumer = Mock()
    consumer.session_id = "test_session"
    consumer.send_json = Mock()
    return consumer

@pytest.fixture
def callback_handler(mock_consumer):
    return WebSocketCallbackHandler(consumer=mock_consumer)

@pytest.mark.asyncio
async def test_send_message(callback_handler, mock_consumer):
    test_message = {
        'type': 'test_message',
        'content': 'test content'
    }
    await callback_handler._send_message(test_message)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_tool_start(callback_handler, mock_consumer):
    serialized = {'name': 'test_tool'}
    input_str = 'test input'
    await callback_handler.on_tool_start(serialized, input_str)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_tool_end(callback_handler, mock_consumer):
    output = 'test output'
    await callback_handler.on_tool_end(output)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_agent_finish(callback_handler, mock_consumer):
    finish = AgentFinish(
        return_values={'output': 'test output'},
        log='test log'
    )
    await callback_handler.on_agent_finish(finish)
    mock_consumer.send_json.assert_called_once()

@pytest.mark.asyncio
async def test_duplicate_agent_finish_prevention(callback_handler, mock_consumer):
    finish = AgentFinish(
        return_values={'output': 'test output'},
        log='test log'
    )
    # First call should send message
    await callback_handler.on_agent_finish(finish)
    # Second call with same output should not send message
    await callback_handler.on_agent_finish(finish)
    assert mock_consumer.send_json.call_count == 1

@pytest.mark.asyncio
async def test_message_lock(callback_handler, mock_consumer):
    # Test that message lock prevents concurrent sends
    async def send_messages():
        messages = [{'type': f'msg_{i}'} for i in range(5)]
        await asyncio.gather(*[callback_handler._send_message(msg) for msg in messages])
    
    await send_messages()
    assert mock_consumer.send_json.call_count == 5

================
File: apps/agents/chat/history.py
================
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import BaseMessage
from typing import List, Optional, Dict
import logging
from apps.agents.models import ChatMessage

logger = logging.getLogger(__name__)

class DjangoCacheMessageHistory(BaseChatMessageHistory):
    """Message history that uses Django's cache and database for storage."""
    
    def __init__(self, session_id: str, conversation_id: Optional[str] = None, agent_id: Optional[int] = None, ttl: int = 3600):
        """Initialize with session ID and optional conversation ID."""
        # Store these as instance variables since they're used by other parts of the system
        self.session_id = session_id
        self.conversation_id = conversation_id
        self.agent_id = agent_id
        self.ttl = ttl
        
        # Initialize the message manager for all operations
        from apps.agents.chat.managers.message_manager import MessageManager
        self.message_manager = MessageManager(
            conversation_id=conversation_id,
            session_id=session_id,
            agent_id=agent_id,
            ttl=ttl
        )

    async def aget_messages(self) -> List[BaseMessage]:
        """Get messages from the message manager."""
        try:
            return await self.message_manager.get_messages()
        except Exception as e:
            logger.error(f"Error getting messages: {str(e)}")
            return []

    async def add_message(self, message: BaseMessage, token_usage: Optional[Dict] = None) -> Optional[ChatMessage]:
        """
        Add message using the message manager.
        
        Returns:
            ChatMessage: The stored message object, or None if storage failed
        """
        try:
            return await self.message_manager.add_message(message, token_usage)
        except Exception as e:
            logger.error(f"Error adding message: {str(e)}")
            raise

    def clear(self) -> None:
        """Clear message history."""
        try:
            self.message_manager.clear()
        except Exception as e:
            logger.error(f"Error clearing messages: {str(e)}")
            raise

    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing by marking messages as deleted."""
        try:
            if self.conversation_id:
                await self.message_manager.handle_edit(message_id)
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise

================
File: apps/agents/clients/manager.py
================
import logging
from django.utils import timezone
from apps.seo_manager.models import Client
from channels.db import database_sync_to_async
from apps.agents.utils.client_utils import ClientDataUtils
from apps.organizations.utils import get_current_organization

logger = logging.getLogger(__name__)

class ClientDataManager:
    def __init__(self):
        pass

    @database_sync_to_async
    def get_client_data(self, client_id):
        """Get and format client data using the common utility"""
        if not client_id:
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
            
        try:
            # Get organization context from the current request if available
            organization = get_current_organization()
            organization_id = organization.id if organization else None
            
            # Use the common client utility to get client and client data with organization context
            client = ClientDataUtils.get_client_by_id(client_id, organization_id=organization_id)
            if not client:
                logger.warning(f"No client found with ID {client_id}, returning default data")
                return {
                    'client_id': None,
                    'current_date': timezone.now().date().isoformat(),
                }
                
            # Get full client data using the utility with organization context
            return ClientDataUtils.get_client_data(client, organization_id=organization_id)
            
        except Exception as e:
            logger.error(f"Error getting client data: {str(e)}", exc_info=True)
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }

================
File: apps/agents/integrations/slack_bot.py
================
import logging
import json
from slack_bolt import App
from slack_bolt.adapter.socket_mode import SocketModeHandler
from channels.layers import get_channel_layer
from asgiref.sync import sync_to_async
from slack_sdk import WebClient
import threading
import time
from django.conf import settings
from django.db import connections
from django.db.models import Model
import uuid
import hashlib
from typing import Dict, Any, Union, List, Optional
from langchain_core.agents import AgentFinish
from .slack_message_formatter import SlackMessageFormatter
from django.conf import settings
from apps.agents.websockets.services.chat_service import AgentChatService


logger = logging.getLogger(__name__)

_slack_client = None

def get_client_for_channel(channel_id, team_id=None):
    """Get the client ID for a given Slack channel"""
    from apps.agents.models import SlackChannelClientMapping
    try:
        mapping = SlackChannelClientMapping.objects.get(channel_id=channel_id)
        return mapping.client_id
    except SlackChannelClientMapping.DoesNotExist:
        logger.warning(f"No client mapping found for channel {channel_id}")
        return None

def get_django_user_from_slack(user_id, team_id):
    """Get Django user from Slack user ID and team ID"""
    from apps.agents.models import UserSlackIntegration
    try:
        # Get the Slack integration for this team
        integration = UserSlackIntegration.objects.get(team_id=team_id, is_active=True)
        
        # Verify this is the correct user using Slack API
        client = WebClient(token=integration.access_token)
        user_info = client.users_info(user=user_id)
        
        if user_info['ok']:
            return integration.user
        
    except Exception as e:
        logger.error(f"Error getting Django user from Slack: {e}")
    
    return None

class SlackWebSocketClient:
    """Client for handling Slack WebSocket connections."""

    def __init__(self, channel_id, thread_ts, user_id, client_id=None):
        """Initialize the client."""
        self.channel_id = channel_id
        self.thread_ts = thread_ts
        self.user_id = user_id
        self.client_id = client_id
        
        # Create a deterministic UUID from channel and thread
        hash_input = f"slack_{channel_id}_{thread_ts}".encode('utf-8')
        hash_hex = hashlib.md5(hash_input).hexdigest()
        self.session_id = str(uuid.UUID(hash_hex))
        
        self.websocket = None
        self.say_callback = None
        self.web_client = WebClient(token=settings.DSLACK_BOT_TOKEN)

    async def connect(self, say_callback):
        """Connect to chat service WebSocket"""
        try:
            self.say_callback = say_callback
            
            # Import here to avoid circular imports
            from apps.agents.websockets.services.chat_service import ChatService
            from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler
            from apps.agents.models import Agent
            
            # Get default agent
            agent = await sync_to_async(Agent.objects.get)(id=25)  # TODO: Make configurable
            
            # Create custom callback handler for Slack
            class SlackCallbackHandler(WebSocketCallbackHandler):
                def __init__(self, slack_client, message_formatter, channel_id):
                    super().__init__(slack_client)
                    self.slack_client = slack_client
                    self.message_formatter = message_formatter
                    self.channel_id = channel_id

                async def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any):
                    """Handle tool start - send tool name and input."""
                    try:
                        # Skip internal exceptions
                        if serialized.get('name') == '_Exception':
                            return

                        tool_name = serialized.get('name', 'Unknown Tool')
                        self.slack_client.say_callback(
                            channel=self.channel_id,
                            thread_ts=self.slack_client.thread_ts,
                            blocks=[{
                                "type": "section",
                                "text": {
                                    "type": "mrkdwn",
                                    "text": f"🔧 Using tool: *{tool_name}*"
                                }
                            }, {
                                "type": "section",
                                "text": {
                                    "type": "mrkdwn",
                                    "text": f"```{input_str}```"
                                }
                            }],
                            text="Tool started"
                        )
                        
                        # Track token usage if available
                        token_usage = kwargs.get('token_usage', {})
                        if self.token_manager:
                            self.token_manager.track_token_usage(
                                token_usage.get('prompt_tokens', 0),
                                token_usage.get('completion_tokens', 0)
                            )
                    except Exception as e:
                        logger.error(f"Error in on_tool_start: {str(e)}", exc_info=True)

                async def on_tool_end(self, tool_result: Any, tool_name: str = None, **kwargs):
                    """Handle tool completion by sending the result to Slack."""
                    try:
                        # Handle the result more safely
                        if isinstance(tool_result, str):
                            try:
                                result = json.loads(tool_result)
                            except json.JSONDecodeError:
                                # If it's not JSON, use the string directly
                                result = {"text": tool_result}
                        else:
                            result = tool_result
                        
                        # Format the result for Slack
                        formatted_result = self.message_formatter.format_tool_result(result)
                        
                        # If formatted result is a list of blocks
                        if isinstance(formatted_result, list):
                            # Check if we have an image block
                            image_blocks = [b for b in formatted_result if b.get('type') == 'image']
                            non_image_blocks = [b for b in formatted_result if b.get('type') != 'image']
                            
                            if image_blocks:
                                # First send non-image blocks
                                if non_image_blocks:
                                    self.slack_client.say_callback(
                                        channel=self.channel_id,
                                        thread_ts=self.slack_client.thread_ts,
                                        blocks=non_image_blocks[:50],  # Slack limit
                                        text="Tool result"
                                    )
                                
                                try:
                                    # Get time series info first
                                    time_series_info = self.message_formatter._find_time_series_data(result)
                                    if time_series_info:
                                        date_fields, metric_fields = time_series_info
                                        if date_fields and metric_fields:
                                            # Extract the data we need
                                            table_data = self.message_formatter._find_table_data(result)
                                            if table_data:
                                                # Create and upload chart
                                                chart_bytes = self.message_formatter._create_chart(
                                                    table_data,
                                                    date_fields[0],
                                                    metric_fields
                                                )
                                                
                                                # Upload file
                                                self.slack_client.files_upload_v2(
                                                    channel=self.channel_id,
                                                    thread_ts=self.slack_client.thread_ts,
                                                    file=chart_bytes,
                                                    filename="chart.png",
                                                    title="Time Series Chart"
                                                )
                                except Exception as e:
                                    logger.error(f"Error creating/uploading chart: {str(e)}", exc_info=True)
                                    # Continue without the chart
                            else:
                                # Send all blocks if no image
                                self.slack_client.say_callback(
                                    channel=self.channel_id,
                                    thread_ts=self.slack_client.thread_ts,
                                    blocks=formatted_result[:50],  # Slack limit
                                    text="Tool result"
                                )
                        else:
                            # If it's just text, send it directly
                            self.slack_client.say_callback(
                                channel=self.channel_id,
                                thread_ts=self.slack_client.thread_ts,
                                text=formatted_result
                            )
                            
                    except Exception as e:
                        logger.error(f"Error in on_tool_end: {str(e)}", exc_info=True)
                        self.slack_client.say_callback(
                            channel=self.channel_id,
                            thread_ts=self.slack_client.thread_ts,
                            text=f"Error processing tool result: {str(e)}"
                        )

                async def on_tool_error(self, error: str, **kwargs: Any):
                    """Handle tool errors"""
                    try:
                        self.slack_client.say_callback(
                            channel=self.channel_id,
                            thread_ts=self.slack_client.thread_ts,
                            blocks=[{
                                "type": "section",
                                "text": {
                                    "type": "mrkdwn",
                                    "text": f"❌ Tool error: {error}"
                                }
                            }],
                            text="Tool error"
                        )
                        
                        # Track token usage if available
                        token_usage = kwargs.get('token_usage', {})
                        if self.token_manager:
                            self.token_manager.track_token_usage(
                                token_usage.get('prompt_tokens', 0),
                                token_usage.get('completion_tokens', 0)
                            )
                    except Exception as e:
                        logger.error(f"Error in on_tool_error: {str(e)}", exc_info=True)

                async def on_agent_finish(self, finish: AgentFinish, **kwargs: Any):
                    """Handle agent completion - send final answer."""
                    try:
                        if hasattr(finish, 'return_values'):
                            output = finish.return_values.get('output', '')
                            if output.strip():
                                self.slack_client.say_callback(
                                    channel=self.channel_id,
                                    thread_ts=self.slack_client.thread_ts,
                                    blocks=[{
                                        "type": "section",
                                        "text": {
                                            "type": "mrkdwn",
                                            "text": output
                                        }
                                    }],
                                    text="Agent finished"
                                )
                            
                            # Track token usage if available
                            token_usage = kwargs.get('token_usage', {})
                            if self.token_manager:
                                self.token_manager.track_token_usage(
                                    token_usage.get('prompt_tokens', 0),
                                    token_usage.get('completion_tokens', 0)
                                )
                                await self.token_manager.track_conversation_tokens()
                    except Exception as e:
                        logger.error(f"Error in on_agent_finish: {str(e)}", exc_info=True)
            
            # Initialize chat service with custom handler
            callback_handler = SlackCallbackHandler(
                slack_client=self,
                message_formatter=SlackMessageFormatter(),
                channel_id=self.channel_id
            )
            
            # Initialize chat service
            self.chat_service = AgentChatService(
                agent=agent,
                model_name=settings.GENERAL_MODEL,  # TODO: Make configurable
                client_data={'client_id': self.client_id, 'user_id': self.user_id},
                callback_handler=callback_handler,
                session_id=self.session_id
            )
            
            # Initialize the service
            await self.chat_service.initialize()
            
            logger.info(f"Connected WebSocket for channel {self.channel_id}")
            
        except Exception as e:
            logger.error(f"Error connecting WebSocket: {e}", exc_info=True)
            raise

    async def send_json(self, content):
        """Callback handler uses this to send messages back to Slack"""
        if self.say_callback:
            message = content.get('message', '')
            if message:
                await sync_to_async(self.say_callback)(
                    text=message,
                    thread_ts=self.thread_ts
                )

    async def send_message(self, message):
        """Send message to chat service"""
        try:
            if not self.chat_service:
                raise Exception("WebSocket not connected")
                
            # Process message through chat service
            await self.chat_service.process_message(message)
            
        except Exception as e:
            logger.error(f"Error sending message: {e}", exc_info=True)
            if self.say_callback:
                await sync_to_async(self.say_callback)(
                    text=f"Error processing message: {str(e)}",
                    thread_ts=self.thread_ts
                )

    def say_callback(self, **kwargs):
        """Send a message to Slack."""
        return self.web_client.chat_postMessage(**kwargs)

    def files_upload_v2(self, **kwargs):
        """Upload a file to Slack using v2 API."""
        return self.web_client.files_upload_v2(**kwargs)

def process_message(message, say, is_mention=False):
    """Process a Slack message and send to chat service"""
    try:
        # Extract message details
        channel_id = message["channel"]
        user_id = message["user"]
        team_id = message.get("team")  # Get team ID from message
        text = message["text"]
        
        # Get Django user
        django_user = get_django_user_from_slack(user_id, team_id)
        if not django_user:
            logger.error(f"No Django user found for Slack user {user_id} in team {team_id}")
            say(
                text="Sorry, I couldn't find your user account. Please make sure you've connected your Slack account.",
                thread_ts=message.get('thread_ts', message.get('ts'))
            )
            return
        
        # For mentions, remove the bot mention
        if is_mention:
            text = text.split(">", 1)[1].strip()
            logger.info(f"Extracted text from mention: {text}")
        else:
            logger.info(f"Processing regular message: {text}")
        
        # Get thread_ts
        thread_ts = message.get('thread_ts', message.get('ts'))
        
        # Get client ID
        client_id = get_client_for_channel(channel_id)
        logger.info(f"Using client_id: {client_id} for channel: {channel_id}")

        # Send acknowledgment right away
        say(
            text="Processing your request...",
            thread_ts=thread_ts
        )
        
        # Create WebSocket client
        client = SlackWebSocketClient(
            channel_id=channel_id,
            thread_ts=thread_ts,
            user_id=django_user.id,  # Use Django user ID instead of Slack user ID
            client_id=client_id
        )
        
        # Create event loop for async operations
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        # Run async operations
        async def process():
            try:
                await client.connect(say)
                await client.send_message(text)
            except Exception as e:
                logger.error(f"Error in async processing: {e}", exc_info=True)
                await sync_to_async(say)(
                    text=f"Error processing message: {str(e)}",
                    thread_ts=thread_ts
                )
                
        # Run the async process in the event loop
        loop.run_until_complete(process())
        loop.close()
        
    except Exception as e:
        logger.error(f"Error processing message: {e}", exc_info=True)
        say(
            text=f"Sorry, I encountered an error: {str(e)}",
            thread_ts=message.get('thread_ts', message.get('ts'))
        )

def maintain_connection():
    """Keep the Slack connection alive and handle reconnections"""
    global _slack_client
    while True:
        try:
            if _slack_client and not _slack_client.is_connected():
                logger.warning("Slack connection lost, attempting to reconnect...")
                _slack_client.connect()
                if _slack_client.is_connected():
                    logger.info("Successfully reconnected to Slack")
                else:
                    logger.error("Failed to reconnect to Slack")
        except Exception as e:
            logger.error(f"Error in connection maintenance: {e}")
        time.sleep(60)  # Check connection every minute

def start_slack_bot():
    """Start the Slack bot in Socket Mode"""
    try:
        # Get tokens
        bot_token = settings.DSLACK_BOT_TOKEN
        app_token = settings.DSLACK_APP_TOKEN
        
        if not bot_token or not app_token:
            logger.warning("Slack tokens not found, skipping bot initialization")
            return
        
        # Initialize app with bot token
        app = App(token=bot_token)
        
        # Listen for messages (not mentions)
        @app.message("")
        def handle_message(message, say):
            logger.info(f"Received message: {message}")
            # Ignore bot messages
            if message.get("bot_id") or message.get("subtype") == "bot_message":
                logger.info("Ignoring bot message")
                return
            process_message(message, say)
        
        # Listen for mentions
        @app.event("app_mention")
        def handle_mention(event, say):
            logger.info(f"Received mention: {event}")
            process_message(event, say, is_mention=True)
        
        # Start socket mode handler in a thread
        def run_handler():
            try:
                handler = SocketModeHandler(app, app_token)
                handler.start()
            except Exception as e:
                logger.error(f"Error in socket handler: {e}", exc_info=True)
        
        socket_thread = threading.Thread(target=run_handler)
        socket_thread.daemon = True
        socket_thread.start()
        
    except Exception as e:
        logger.error(f"Error starting Slack bot: {str(e)}", exc_info=True)

================
File: apps/agents/integrations/slack_message_formatter.py
================
import json
from typing import Dict, List, Any, Optional, Tuple, Union
from datetime import datetime
import pandas as pd
import logging
import io
import base64
from django.conf import settings
import os
import matplotlib.pyplot as plt
import seaborn as sns

logger = logging.getLogger(__name__)

class SlackMessageFormatter:
    """Format tool outputs and messages for Slack using Block Kit."""
    
    @staticmethod
    def format_field_name(field: str) -> str:
        """Format a field name for display."""
        return field.replace('_', ' ').title()

    @staticmethod
    def _find_table_data(data: Any) -> Optional[List[Dict]]:
        """Find table-like data in the result."""
        if isinstance(data, dict):
            # Check common patterns in our API responses
            if 'analytics_data' in data and isinstance(data['analytics_data'], list):
                return data['analytics_data']
            if 'data' in data and isinstance(data['data'], list):
                return data['data']
            if 'results' in data and isinstance(data['results'], list):
                return data['results']
        elif isinstance(data, list) and data and isinstance(data[0], dict):
            return data
        return None

    @staticmethod
    def _find_time_series_data(data: Any) -> Optional[Tuple[List[str], List[Dict]]]:
        """Find time series data in the result."""
        table_data = SlackMessageFormatter._find_table_data(data)
        if not table_data:
            return None

        # Look for date/time fields
        date_fields = []
        metric_fields = []
        
        # Check first row for field types
        sample = table_data[0]
        for field, value in sample.items():
            field_lower = field.lower()
            # Check if field name suggests it's a date
            if any(date_hint in field_lower for date_hint in ['date', 'time', 'day', 'month', 'year']):
                try:
                    # Verify we can parse the date
                    pd.to_datetime(sample[field])
                    date_fields.append(field)
                except:
                    continue
            # For GA4 data, we know certain fields are metrics
            elif field in ['newUsers', 'totalUsers', 'sessions', 'screenPageViews', 'bounceRate', 'engagedSessions']:
                metric_fields.append(field)
            # Otherwise check if it's numeric
            elif isinstance(value, (int, float)) or (isinstance(value, str) and value.replace('.', '').isdigit()):
                metric_fields.append(field)

        if not date_fields or not metric_fields:
            return None

        return date_fields, metric_fields

    @staticmethod
    def _create_chart(data: List[Dict], date_field: str, metric_fields: List[str]) -> bytes:
        """Create a time series chart and return the bytes."""
        try:
            import seaborn as sns
            logger.info(f"Creating chart with date_field: {date_field}, metrics: {metric_fields}")
            
            df = pd.DataFrame(data)
            df[date_field] = pd.to_datetime(df[date_field])
            df = df.sort_values(date_field)
            
            # Convert metrics to numeric
            for metric in metric_fields:
                if df[metric].dtype == 'object':
                    df[metric] = pd.to_numeric(df[metric].str.replace(',', ''), errors='coerce')
            
            # Set seaborn style
            sns.set_style("whitegrid")
            plt.figure(figsize=(10, 6))
            
            # Create plot using seaborn
            for metric in metric_fields:
                sns.lineplot(data=df, x=date_field, y=metric, marker='o', label=metric)
            
            plt.title('Time Series Analysis')
            plt.xticks(rotation=45)
            plt.tight_layout()
            
            # Save to bytes
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png', dpi=150)
            plt.close()
            buffer.seek(0)
            return buffer.getvalue()
            
        except Exception as e:
            logger.error(f"Error creating chart: {str(e)}", exc_info=True)
            raise

    @staticmethod
    def format_table(data: List[Dict]) -> List[Dict]:
        """Format data as a Slack section block with fields."""
        if not data:
            return [{"type": "section", "text": {"type": "mrkdwn", "text": "No data available"}}]

        blocks = []
        
        # Add header
        blocks.append({
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "Data Summary"
            }
        })

        # Group related fields together
        for row in data:
            text_parts = []
            for key, value in row.items():
                if isinstance(value, (int, float)):
                    formatted_value = f"{value:,}"
                elif isinstance(value, str) and any(date_hint in key.lower() for date_hint in ['date', 'time', 'day']):
                    try:
                        date = pd.to_datetime(value)
                        formatted_value = date.strftime('%Y-%m-%d')
                    except:
                        formatted_value = value
                else:
                    formatted_value = str(value)
                
                text_parts.append(f"*{SlackMessageFormatter.format_field_name(key)}*: {formatted_value}")
            
            # Join all fields with newlines
            blocks.append({
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": "\n".join(text_parts)
                }
            })
            
            # Add divider between rows
            blocks.append({"type": "divider"})

        if len(data) > 10:
            blocks.append({
                "type": "context",
                "elements": [{
                    "type": "mrkdwn",
                    "text": f"_Showing 10 of {len(data)} rows_"
                }]
            })

        return blocks

    @staticmethod
    def _format_analytics_data(data: List[Dict]) -> List[Dict]:
        """Special formatter for analytics data."""
        if not data:
            return []
            
        blocks = []
        
        # Add header
        blocks.append({
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "Analytics Data Summary"
            }
        })

        # Add context about the data
        blocks.append({
            "type": "context",
            "elements": [{
                "type": "mrkdwn",
                "text": "📊 Showing analytics data with all available metrics"
            }]
        })

        blocks.append({"type": "divider"})

        # Convert data to a more readable format
        df = pd.DataFrame(data)
        
        # Create a section for each row of data
        for _, row in df.iterrows():
            # Split fields into two columns
            fields = []
            for col in df.columns:
                value = row[col]
                # Format numbers with commas
                if isinstance(value, (int, float)):
                    if str(value).endswith('.0'):  # Integer values
                        formatted_value = f"{int(value):,}"
                    else:  # Float values
                        formatted_value = f"{value:,.2f}"
                else:
                    formatted_value = str(value)
                
                fields.append({
                    "type": "mrkdwn",
                    "text": f"*{SlackMessageFormatter.format_field_name(col)}*\n{formatted_value}"
                })
            
            blocks.append({
                "type": "section",
                "fields": fields
            })
            
            blocks.append({"type": "divider"})

        # If we have numeric columns, add summary statistics
        numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns
        if not numeric_cols.empty:
            blocks.append({
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Summary Statistics"
                }
            })

            for col in numeric_cols:
                col_name = SlackMessageFormatter.format_field_name(col)
                total = df[col].sum()
                avg = df[col].mean()
                
                if str(total).endswith('.0'):  # Integer values
                    total_str = f"{int(total):,}"
                    avg_str = f"{avg:,.1f}"
                else:  # Float values
                    total_str = f"{total:,.2f}"
                    avg_str = f"{avg:,.2f}"

                blocks.append({
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*{col_name}*\n• Total: {total_str}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Statistics*\n• Average: {avg_str}"
                        }
                    ]
                })

        return blocks

    @staticmethod
    def format_tool_result(result: Any) -> Union[str, List[Dict]]:
        """Format a tool result for Slack using blocks where appropriate."""
        try:
            # Parse result if it's a string
            data = json.loads(result) if isinstance(result, str) else result
            logger.info(f"Formatting tool result. Data type: {type(data)}")
            
            # Try to find table data
            table_data = SlackMessageFormatter._find_table_data(data)
            if table_data:
                logger.info(f"Found table data with {len(table_data)} rows")
                blocks = []
                
                # Check if it's time series data first
                time_series_info = SlackMessageFormatter._find_time_series_data(data)
                if time_series_info:
                    date_fields, metric_fields = time_series_info
                    logger.info(f"Found time series data with date fields: {date_fields}, metric fields: {metric_fields}")
                    
                    # Create summary section
                    df = pd.DataFrame(table_data)
                    summary_blocks = []
                    for metric in metric_fields:
                        metric_name = SlackMessageFormatter.format_field_name(metric)
                        total = df[metric].sum()
                        avg = df[metric].mean()
                        max_val = df[metric].max()
                        max_date = df.loc[df[metric].idxmax(), date_fields[0]]
                        
                        summary_blocks.append({
                            "type": "section",
                            "text": {
                                "type": "mrkdwn",
                                "text": f"*{metric_name}*\n• Total: {total:,.0f}\n• Average: {avg:,.1f}\n• Peak: {max_val:,.0f} on {max_date}"
                            }
                        })
                    
                    blocks.extend(summary_blocks)
                    
                    try:
                        # Create chart
                        chart_bytes = SlackMessageFormatter._create_chart(table_data, date_fields[0], metric_fields)
                        blocks.append({
                            "type": "image",
                            "title": {
                                "type": "plain_text",
                                "text": "Time Series Chart"
                            },
                            "image_url": f"attachment://chart.png",
                            "alt_text": "Time Series Chart"
                        })
                    except Exception as e:
                        logger.error(f"Error creating chart: {str(e)}", exc_info=True)
                        # Continue without the chart
                    
                    logger.info(f"Returning {len(blocks)} blocks")
                    return blocks[:50]  # Ensure we don't exceed Slack's block limit
                
                # If not time series, check if it's analytics data
                elif any('sessionSource' in row for row in table_data):
                    blocks.extend(SlackMessageFormatter._format_analytics_data(table_data[:10]))
                    return blocks[:50]
                
                # Regular table data
                else:
                    return SlackMessageFormatter.format_table(table_data[:10])[:50]
            
            # If no table data found, format as code block
            return f"```\n{json.dumps(data, indent=2)}\n```"
            
        except Exception as e:
            logger.error(f"Error formatting tool result: {str(e)}", exc_info=True)
            return str(result)

================
File: apps/agents/static/agents/js/chat/app.js
================
// Get current timestamp for cache busting
const version = new Date().getTime();

// Create URLs with cache busting
const messageListUrl = new URL('/static/agents/js/components/message_list.js', window.location.href);
const webSocketUrl = new URL('/static/agents/js/services/websocket.js', window.location.href);
const messageHandlerUrl = new URL('/static/agents/js/services/message_handler.js', window.location.href);
const toolOutputUrl = new URL('/static/agents/js/components/tool_outputs/base.js', window.location.href);

// Add version parameter to each URL
messageListUrl.searchParams.set('v', version);
webSocketUrl.searchParams.set('v', version);
messageHandlerUrl.searchParams.set('v', version);
toolOutputUrl.searchParams.set('v', version);

// Initialize components asynchronously
async function initializeComponents() {
    // Import modules dynamically
    const [
        { MessageList },
        { ChatWebSocket },
        { MessageHandler },
        { ToolOutputManager }
    ] = await Promise.all([
        import(messageListUrl.toString()),
        import(webSocketUrl.toString()),
        import(messageHandlerUrl.toString()),
        import(toolOutputUrl.toString())
    ]);

    return { MessageList, ChatWebSocket, MessageHandler, ToolOutputManager };
}

class ChatApp {
    constructor(config) {
        this.config = config;
        this.participantType = 'unset'; // Track participant type
        this.crewInitialized = false; // Track if crew has been initialized
        
        // Initialize highlight.js
        hljs.configure({
            ignoreUnescapedHTML: true,
            languages: ['javascript', 'python', 'bash', 'json', 'html', 'css']
        });
        
        this.elements = {
            messages: document.getElementById('chat-messages'),
            input: document.getElementById('message-input'),
            sendButton: document.getElementById('send-message'),
            agentSelect: document.getElementById('agent-select'),
            modelSelect: document.getElementById('model-select'),
            clientSelect: document.getElementById('client-select'),
            crewSelect: document.getElementById('crew-select'),
            newChatBtn: document.getElementById('new-chat-btn'),
            shareBtn: document.getElementById('share-btn')
        };
    }

    async initialize() {
        // Import and initialize components
        const { MessageList, ChatWebSocket, MessageHandler, ToolOutputManager } = await initializeComponents();
        
        // Initialize components
        this.messageList = new MessageList(this.elements.messages);
        this.toolOutputManager = new ToolOutputManager();
        
        // Create message handler first without websocket
        this.messageHandler = new MessageHandler(this.messageList, this.toolOutputManager);
        
        // Create websocket with message handler
        this.websocket = new ChatWebSocket(this.config, this.messageHandler);
        
        // Update message handler with websocket
        this.messageHandler.websocket = this.websocket;
        
        // Set message handler callback for system messages
        this.messageHandler.onSystemMessage = this.handleSystemMessage.bind(this);
        
        // Initialize share button separately to ensure it's bound
        const shareBtn = document.getElementById('share-btn');
        if (shareBtn) {
            console.debug('Share button found, binding click event');
            shareBtn.addEventListener('click', (e) => {
                console.debug('Share button clicked');
                e.preventDefault();
                e.stopPropagation();
                this.exportToMarkdown();
            });
        } else {
            console.warn('Share button not found in DOM');
        }
        
        // Bind other event handlers
        this._bindEvents();

        // Listen for edit-message custom event
        document.addEventListener('edit-message', (event) => {
            const messageContainer = document.getElementById(`${event.detail.domId}-container`);
            if (messageContainer) {
                this.editMessage(messageContainer.querySelector('.edit-message'));
            }
        });

        // Connect WebSocket
        this.websocket.connect();
        
        // Initialize autosize for textarea
        if (this.elements.input) {
            autosize(this.elements.input);
        }
        
        // Set initial agent avatar and initialize chatConfig
        if (!window.chatConfig.currentAgent) {
            const selectedOption = this.elements.agentSelect?.selectedOptions[0];

            window.chatConfig.currentAgent = {
                avatar: selectedOption ? selectedOption.dataset.avatar : '/static/assets/img/team-3.jpg',
                name: selectedOption ? selectedOption.dataset.name : 'AI Assistant'
            };
        }
        this._updateAgentAvatar();
        
        // Update MessageList with current agent
        this.messageList.updateCurrentAgent(window.chatConfig.currentAgent);

        // Expose functions globally
        window.editMessage = this.editMessage.bind(this);
        window.copyMessage = this.copyMessage.bind(this);
        window.deleteConversation = this.deleteConversation.bind(this);
    }

    handleSystemMessage(message) {
        console.log('Handling system message:', message);
        // Update participant type from system message
        if (message.participant_type) {
            this.participantType = message.participant_type;
            this._updateUIForParticipantType();
        }
    }

    _updateUIForParticipantType() {
        console.log('Updating UI for participant type:', this.participantType);
        const selectedOption = this.elements.agentSelect?.selectedOptions[0];
        const selectedType = selectedOption?.dataset.type;

        // Update UI based on participant type
        if (this.participantType === 'crew' || selectedType === 'crew') {
            if (this.elements.agentSelect) {
                this.elements.agentSelect.disabled = true;
                this.elements.modelSelect.disabled = true;
            }
            // Update agent name to show crew if available
            const crewOption = this.elements.crewSelect?.selectedOptions[0];
            if (crewOption && document.getElementById('agent-name')) {
                document.getElementById('agent-name').textContent = `Crew: ${crewOption.textContent}`;
            }
        } else if (this.participantType === 'agent' || selectedType === 'agent') {
            if (this.elements.crewSelect) {
                this.elements.crewSelect.disabled = true;
            }
        }
    }

    _handleAgentOrCrewSelection() {
        const selectedOption = this.elements.agentSelect?.selectedOptions[0];
        if (!selectedOption) return;

        const selectedType = selectedOption.dataset.type;
        const selectedId = selectedOption.value;

        if (selectedType === 'crew') {
            // Just update the UI and participant type, don't start crew yet
            this.participantType = 'crew';
            this.crewInitialized = false; // Reset initialization flag
        } else {
            // Update participant type for agent
            this.participantType = 'agent';
        }

        this._updateUIForParticipantType();
        this._updateAgentAvatar();
    }

    _sendMessage() {
        const message = this.elements.input.value.trim();
        if (!message) return;

        // Check if the message handler is waiting for a human input response
        const hasPendingHumanInput = this.messageHandler && this.messageHandler.lastHumanInputContext;
        
        // Log detailed information about pending human input
        if (hasPendingHumanInput) {
            console.log('Handling message as human input response with context:', 
                JSON.stringify(this.messageHandler.lastHumanInputContext));
        }

        // Handle human input response separately
        if (hasPendingHumanInput) {
            // Send as user message with context
            this.websocket.send({
                type: 'user_message',
                message: message,
                context: this.messageHandler.lastHumanInputContext
            });
            
            // Clear the context after sending
            this.messageHandler.lastHumanInputContext = null;
        } 
        // Otherwise handle as a normal crew/agent message
        else if (this.participantType === 'crew' || this.elements.agentSelect?.selectedOptions[0]?.dataset.type === 'crew') {
            // If this is the first message to the crew, initialize it
            if (!this.crewInitialized) {
                this.websocket.send({
                    type: 'start_crew',
                    crew_id: this.elements.agentSelect.selectedOptions[0].value,
                    client_id: this.elements.clientSelect.value
                });
                this.crewInitialized = true;
            }
            
            // Send the crew message
            this.websocket.send({
                message: message,
                type: 'crew_message',
                crew_id: this.elements.agentSelect.selectedOptions[0].value,
                client_id: this.elements.clientSelect.value
            });
        } else {
            // Regular agent message
            this.websocket.send({
                message: message,
                agent_id: this.elements.agentSelect.selectedOptions[0].value,
                model: this.elements.modelSelect.value,
                client_id: this.elements.clientSelect.value
            });
        }

        // Clear input
        this.elements.input.value = '';
        autosize.update(this.elements.input);
    }

    editMessage(button) {
        const messageContainer = button.closest('.d-flex');
        if (!messageContainer) {
            console.warn('Could not find message container');
            return;
        }

        const messageText = messageContainer.querySelector('.message-text')?.textContent.trim();
        if (!messageText) {
            console.warn('Could not find message text');
            return;
        }
        
        // Get the message ID
        const domId = messageContainer.id.replace('-container', '');
        const backendId = this.messageList.getMessageId(domId);
        
        if (!backendId) {
            console.warn('No backend message ID found for container:', domId);
            return;
        }
        
        try {
            console.log('Editing message:', { domId, backendId, messageText });
            
            // Set input value to message content
            this.elements.input.value = messageText;
            this.elements.input.focus();
            autosize.update(this.elements.input);
            
            // Delete messages from the message list
            this.messageList.deleteMessagesFromIndex(domId);
            
            // Notify backend to handle edit
            this.websocket.send({
                type: 'edit',
                message: messageText,
                message_id: backendId,
                session_id: this.config.sessionId
            });
            
        } catch (error) {
            console.error('Error editing message:', error);
            alert('Failed to edit message. Please try again.');
        }
    }

    copyMessage(button) {
        const messageText = button.closest('.message-content')?.querySelector('.message-text')?.textContent.trim();
        if (!messageText) {
            console.warn('Could not find message text');
            return;
        }
        
        navigator.clipboard.writeText(messageText).then(() => {
            // Show temporary success indicator
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            setTimeout(() => {
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1000);
        }).catch(err => {
            console.error('Failed to copy text:', err);
        });
    }

    _bindEvents() {
        // Message sending
        if (this.elements.input && this.elements.sendButton) {
            this.elements.input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this._sendMessage();
                }
            });
            
            this.elements.sendButton.addEventListener('click', () => {
                this._sendMessage();
            });
        }

        // Agent/Crew selection
        if (this.elements.agentSelect) {
            this.elements.agentSelect.addEventListener('change', () => {
                this._handleAgentOrCrewSelection();
            });
        }

        // New chat button
        if (this.elements.newChatBtn) {
            this.elements.newChatBtn.addEventListener('click', () => {
                window.location.href = this.elements.newChatBtn.dataset.url;
            });
        }
    }

    _updateAgentAvatar() {
        const selectedOption = this.elements.agentSelect.selectedOptions[0];
        if (selectedOption) {
            const avatarPath = selectedOption.dataset.avatar || '/static/assets/img/team-3.jpg';
            const avatarUrl = avatarPath.startsWith('/') ? avatarPath : `/static/assets/img/${avatarPath}`;
            const name = selectedOption.dataset.name;
            
            const avatarImg = document.getElementById('agent-avatar').querySelector('img');
            if (avatarImg) {
                avatarImg.src = avatarUrl;
                avatarImg.alt = name;
            }
            
            const nameElement = document.getElementById('agent-name');
            if (nameElement) {
                nameElement.textContent = name;
            }
            
            // Update global config for Message component
            window.chatConfig.currentAgent = {
                avatar: avatarUrl,
                name: name
            };
            
            // Update MessageList with new agent info
            this.messageList.updateCurrentAgent(window.chatConfig.currentAgent);
        }
    }

    async deleteConversation(sessionId, event) {
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }

        if (!confirm('Are you sure you want to delete this conversation?')) {
            return;
        }

        try {
            const url = this.config.urls.deleteConversation.replace('{sessionId}', sessionId);
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': this.config.csrfToken,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error('Failed to delete conversation');
            }

            // Redirect to new chat if we're deleting the current conversation
            if (sessionId === this.config.sessionId) {
                window.location.href = this.config.urls.newChat;
            } else {
                // Otherwise just remove the conversation from the list
                const conversationElement = event.target.closest('.position-relative');
                if (conversationElement) {
                    conversationElement.remove();
                }
            }
        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Failed to delete conversation. Please try again.');
        }
    }

    scrollToBottom() {
        if (this.elements.messages) {
            const scrollHeight = this.elements.messages.scrollHeight;
            this.elements.messages.scrollTo({
                top: scrollHeight,
                behavior: 'smooth'
            });
        }
    }

    appendMessage(content, isAgent = false, withActions = true, messageId = null) {
        // Use MessageList's addMessage method
        const domId = this.messageList.addMessage(content, isAgent, 
            isAgent ? window.chatConfig.currentAgent?.avatar : null, 
            messageId
        );
        
        // Add event listeners for actions
        if (withActions) {
            this.addMessageEventListeners(domId);
        }
    }

    async deleteMessagesFromIndex(messageContainer) {
        // Get the actual message container if we're passed a child element
        const container = messageContainer.closest('.d-flex');
        if (!container) {
            console.warn('Could not find message container');
            return;
        }

        // Get the message ID from the container ID
        const domId = container.id.replace('-container', '');
        const backendId = this.messageList.getMessageId(domId);
        
        if (!backendId) {
            console.warn('No backend message ID found for container:', domId);
            return;
        }
        
        try {
            // Delete messages from the message list
            this.messageList.deleteMessagesFromIndex(domId);
            
            // Notify backend to handle edit
            const editData = {
                type: 'edit',
                message: this.elements.input.value.trim(),
                message_id: backendId,
                session_id: this.config.sessionId
            };
            this.websocket.send(editData);
            
        } catch (error) {
            console.error('Error editing messages:', error);
            alert('Failed to edit messages. Please try again.');
        }
    }

    addMessageEventListeners(domId) {
        const container = document.getElementById(`${domId}-container`);
        if (!container) return;

        const messageContent = container.querySelector('.message-content');
        const messageActions = container.querySelector('.message-actions');
        const copyButton = container.querySelector('.copy-message');
        const editButton = container.querySelector('.edit-message');

        // Copy button functionality
        if (copyButton) {
            copyButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const messageText = container.querySelector('.message-text').textContent.trim();
                navigator.clipboard.writeText(messageText).then(() => {
                    // Show success feedback
                    const icon = copyButton.querySelector('i');
                    icon.classList.remove('fa-copy');
                    icon.classList.add('fa-check');
                    setTimeout(() => {
                        icon.classList.remove('fa-check');
                        icon.classList.add('fa-copy');
                    }, 1000);
                });
            });
        }

        // Edit button functionality
        if (editButton) {
            editButton.addEventListener('click', async (e) => {
                e.stopPropagation();
                const messageText = container.querySelector('.message-text').textContent.trim();
                
                // 1. Put the message text in the input field
                this.elements.input.value = messageText;
                this.elements.input.focus();
                autosize.update(this.elements.input);

                // 2. Delete this message and all subsequent messages
                await this.deleteMessagesFromIndex(container);
            });
        }
    }

    exportToMarkdown() {
        let markdown = '# Chat Conversation\n\n';
        const messages = this.elements.messages.querySelectorAll('.d-flex');
        
        messages.forEach(message => {
            const isAgent = message.querySelector('.message.agent') !== null;
            let messageText = '';
            
            // Try to find message content in different possible locations
            const messageContent = message.querySelector('.message-text') || 
                                 message.querySelector('.tool-content-normalized') ||
                                 message.querySelector('.tool-text') ||
                                 message.querySelector('.tool-result');
                                 
            if (messageContent) {
                messageText = messageContent.textContent.trim();
            }
            
            // Check for tool output
            const toolOutput = message.querySelector('.tool-output');
            if (toolOutput) {
                const toolName = toolOutput.querySelector('.tool-name')?.textContent || 'Tool';
                messageText = `[${toolName} Output]\n${messageText}`;
            }
            
            if (messageText) {
                const role = isAgent ? 'Assistant' : 'User';
                markdown += `**${role}**: ${messageText}\n\n`;
            }
        });

        // Create a blob and trigger download
        const blob = new Blob([markdown], { type: 'text/markdown' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `chat-export-${new Date().toISOString().slice(0,10)}.md`;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }
}

export { ChatApp };

================
File: apps/agents/static/agents/js/components/tool_outputs/base.js
================
class ToolOutputManager {
    constructor() {
        this.activeContainer = null;
        this.messagesContainer = document.getElementById('chat-messages');
        this.charts = new Map(); // Store chart instances
        this.toolContainers = new Map(); // Map to store tool containers by tool run ID
        
        // The date-fns adapter is automatically registered via the bundle
    }

    handleToolStart(data) {
        try {
            // Try to parse if string, otherwise use as is
            const toolData = typeof data === 'string' ? JSON.parse(data) : data;
            const toolName = toolData.tool || 'Unknown Tool';
            
            // Create a unique ID for this tool run
            const toolRunId = toolData.run_id || `${toolName}-${Date.now()}`;
            
            // Create a new container for this tool output
            const container = document.createElement('div');
            container.className = 'd-flex justify-content-start mb-4';
            const containerId = `tool-${Date.now()}`;
            container.innerHTML = `
                <div class="avatar me-2">
                    <img src="${window.chatConfig.currentAgent.avatar}" 
                         alt="${window.chatConfig.currentAgent.name}" 
                         class="border-radius-lg shadow">
                </div>
                <div class="message agent" style="max-width: 90%;">
                    <div class="tool-output">
                        <div class="tool-header d-flex align-items-center justify-content-between">
                            <div class="d-flex align-items-center cursor-pointer collapsed" data-bs-toggle="collapse" data-bs-target="#${containerId}-content">
                                <i class="fas fa-chevron-down me-2 toggle-icon"></i>
                                <i class="fas fa-tools me-2"></i>
                                <span class="tool-name small">${toolName}</span>
                            </div>
                        </div>
                        <div class="tool-content mt-2 collapse" id="${containerId}-content">
                            ${toolData.input ? `
                            <div class="tool-input text-muted mb-2">
                                <small>Input: ${toolData.input}</small>
                            </div>` : ''}
                            <div class="tool-result"></div>
                        </div>
                    </div>
                </div>
            `;
            
            // Add to messages container
            if (this.messagesContainer) {
                this.messagesContainer.appendChild(container);
                this.activeContainer = container;
                
                // Store the container in our map using the tool run ID as key
                // This ensures multiple runs of the same tool don't overwrite each other
                this.toolContainers.set(toolRunId, {
                    container,
                    toolName
                });
                
                // Keep a reference for debugging
                console.debug(`Created tool container for ${toolName} with ID ${toolRunId}`);
                
                // Scroll to the new container
                container.scrollIntoView({ behavior: 'smooth', block: 'end' });
            }
        } catch (error) {
            console.error('Error handling tool start:', error);
            // Create a minimal container for error case
            const container = document.createElement('div');
            container.className = 'd-flex justify-content-start mb-4';
            container.innerHTML = `
                <div class="avatar me-2">
                    <img src="${window.chatConfig.currentAgent.avatar}" 
                         alt="${window.chatConfig.currentAgent.name}" 
                         class="border-radius-lg shadow">
                </div>
                <div class="message agent" style="max-width: 90%;">
                    <div class="tool-output">
                        <div class="tool-header d-flex align-items-center">
                            <i class="fas fa-tools me-2"></i>
                            <span class="tool-name small">Tool Execution</span>
                        </div>
                    </div>
                </div>
            `;
            
            if (this.messagesContainer) {
                this.messagesContainer.appendChild(container);
                this.activeContainer = container;
            }
        }
    }

    handleToolResult(result) {
        try {
            if (!result) {
                console.warn('Empty result passed to handleToolResult');
                return;
            }
            
            console.debug('ToolOutputManager.handleToolResult received:', result);
            
            // Try to find an appropriate container for this result
            let container = this.activeContainer;
            const toolName = result.toolName || (result.data && result.data.name);
            const toolRunId = result.toolRunId;
            
            // First try to find by run ID (most precise)
            if (toolRunId && this.toolContainers.has(toolRunId)) {
                container = this.toolContainers.get(toolRunId).container;
                console.debug(`Found container by run ID ${toolRunId}`);
            }
            // Then try by tool name (may not be unique if tool was run multiple times)
            else if (toolName) {
                // Look for the latest container with this tool name
                let latestContainer = null;
                let latestTimestamp = 0;
                
                for (const [id, data] of this.toolContainers.entries()) {
                    if (data.toolName === toolName) {
                        // Extract timestamp from the ID (assuming the format includes timestamp)
                        const timestampMatch = id.match(/.*-(\d+)$/);
                        if (timestampMatch) {
                            const timestamp = parseInt(timestampMatch[1], 10);
                            if (timestamp > latestTimestamp) {
                                latestTimestamp = timestamp;
                                latestContainer = data.container;
                            }
                        }
                    }
                }
                
                if (latestContainer) {
                    container = latestContainer;
                    console.debug(`Found latest container for tool ${toolName}`);
                }
            }
            
            if (!container) {
                console.warn('No active tool container found for result');
                return;
            }

            const resultContainer = container.querySelector('.tool-result');
            if (!resultContainer) {
                console.warn('No result container found within the tool container');
                return;
            }

            if (result.type === 'error') {
                resultContainer.innerHTML = `
                    <div class="tool-error mt-2">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <span class="text-danger small">${result.data}</span>
                    </div>
                `;
            } else if (result.type === 'text') {
                // Check if the text looks like CSV data
                const text = result.data.trim();
                // More robust CSV detection - check for consistent number of columns
                const lines = text.split(/[\n\r]+/).filter(row => row.trim());
                const firstLineCommas = (lines[0] || '').split(',').length - 1;
                
                // Check if this looks like CSV data:
                // 1. Has commas
                // 2. No double line breaks (not markdown)
                // 3. At least 2 columns
                // 4. Consistent number of columns in first few rows
                const isLikelyCSV = text.includes(',') && 
                                  !text.includes('\n\n') && 
                                  firstLineCommas >= 1 &&
                                  lines.slice(0, Math.min(5, lines.length))
                                       .every(line => (line.split(',').length - 1) === firstLineCommas);

                if (isLikelyCSV) {
                    try {
                        // Split into rows and parse CSV
                        const headers = this._parseCSVRow(lines[0]);
                        
                        // Only proceed if we have valid headers
                        if (headers.length > 1) {
                            const data = lines.slice(1).map(row => {
                                const values = this._parseCSVRow(row);
                                return headers.reduce((obj, header, i) => {
                                    // Try to convert numeric values
                                    let value = values[i] || '';
                                    value = value.trim();
                                    
                                    // Convert to number if possible and not empty
                                    if (value !== '' && !isNaN(value) && !isNaN(parseFloat(value))) {
                                        value = parseFloat(value);
                                    }
                                    
                                    obj[header] = value;
                                    return obj;
                                }, {});
                            });

                            // If we successfully parsed it as CSV and have data
                            if (data.length > 0) {
                                console.debug('Successfully parsed CSV data:', {
                                    headers,
                                    rowCount: data.length,
                                    sampleRow: data[0]
                                });
                                this._handleVisualData(resultContainer, data);
                                return;
                            }
                        }
                    } catch (e) {
                        console.debug('CSV parsing failed, falling back to text display', e);
                    }
                }
                
                // If not CSV or parsing failed, display as text
                const parsedContent = marked.parse(result.data);
                resultContainer.innerHTML = `
                    <div class="tool-text mt-2">
                        <div class="tool-content-normalized">${parsedContent}</div>
                    </div>
                `;
            } else if (result.type === 'json' || (result.type === 'table' && Array.isArray(result.data))) {
                // Show appropriate visualization based on the data
                this._handleVisualData(resultContainer, result.data);
            } else {
                // Default to JSON display for unknown types
                resultContainer.innerHTML = `
                    <div class="tool-json mt-2">
                        <pre class="tool-content-normalized"><code>${JSON.stringify(result.data, null, 2)}</code></pre>
                    </div>
                `;
            }
            
            // Auto-expand the result
            const collapseEl = container.querySelector('.tool-content');
            if (collapseEl && collapseEl.classList.contains('collapse')) {
                new bootstrap.Collapse(collapseEl).show();
            }
            
            // Clear active container once we've rendered a result into it
            if (this.activeContainer === container) {
                this.activeContainer = null;
            }
            
        } catch (error) {
            console.error('Error handling tool result:', error);
        }
    }
    
    // Helper method to handle visualization for data
    _handleVisualData(resultContainer, data) {
        const timeSeriesData = this._findTimeSeriesData(data);
        
        if (timeSeriesData) {
            // Add visualization toggle buttons
            const toggleContainer = document.createElement('div');
            toggleContainer.className = 'mb-2 btn-group';
            toggleContainer.innerHTML = `
                <button class="btn btn-primary btn-sm active" data-view="chart">
                    <i class="fas fa-chart-line me-1"></i>Chart
                </button>
                <button class="btn btn-primary btn-sm" data-view="table">
                    <i class="fas fa-table me-1"></i>Table
                </button>
            `;
            
            // Add visualization container
            const vizContainer = document.createElement('div');
            vizContainer.className = 'visualization-container';
            vizContainer.style.width = '100%';            
            resultContainer.appendChild(toggleContainer);
            resultContainer.appendChild(vizContainer);
            
            // Add event listeners for toggle buttons
            toggleContainer.querySelectorAll('button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const view = e.currentTarget.dataset.view;
                    this._updateVisualization(vizContainer, view, timeSeriesData, data);
                    
                    // Update active button
                    toggleContainer.querySelectorAll('button').forEach(b => 
                        b.classList.toggle('active', b === e.currentTarget));
                });
            });
            
            // Initialize with chart view
            this._updateVisualization(vizContainer, 'chart', timeSeriesData, data);
        } else {
            // Check if we have tabular data
            const tableData = this._findTableData(data);
            if (tableData && tableData.length > 0) {
                resultContainer.innerHTML += this._createTable(tableData);
                this._addCsvDownloadButton(resultContainer, tableData);
            } else {
                // Default to JSON display
                resultContainer.innerHTML += `
                    <div class="tool-json mt-2">
                        <pre class="small"><code>${JSON.stringify(data, null, 2)}</code></pre>
                    </div>
                `;
            }
        }
    }

    _updateVisualization(container, view, timeSeriesData, originalData) {
        // Clear previous visualization
        container.innerHTML = '';
        
        if (view === 'chart' && timeSeriesData) {
            // Set container to full width before creating chart
            container.style.width = '100%';
            container.style.minHeight = '400px';
            
            // Force layout recalculation before creating chart
            container.getBoundingClientRect();            // Create chart with filtered data
            this._createChart(container, timeSeriesData);
        } else if (view === 'table') {
            // Create table with original data
            container.innerHTML = this._createTable(originalData);
            
            // Initialize DataTable
            setTimeout(() => {
                try {
                    const tableId = container.querySelector('table').id;
                    new simpleDatatables.DataTable(`#${tableId}`, {
                        searchable: true,
                        fixedHeight: false,
                        perPage: 10
                    });
                } catch (error) {
                    console.warn('Failed to initialize DataTable:', error);
                }
            }, 100);
        }
    }

    _findTableData(data) {
        // If data is already an array of objects with at least one row, it's tabular
        if (Array.isArray(data) && data.length > 0 && typeof data[0] === 'object') {
            return data;
        }

        // Look for arrays in the object values
        if (typeof data === 'object') {
            for (const key in data) {
                const value = data[key];
                if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                    return value;
                }
            }
        }

        return null;
    }

    _createTable(data) {
        if (!Array.isArray(data) || !data.length) return '';

        const tableId = `table-${Date.now()}`;
        const headers = Object.keys(data[0]);
        const rows = data.map(row => headers.map(header => {
            const value = row[header];
            // Format dates and numbers
            if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                return new Date(value).toISOString().split('T')[0];
            }
            if (typeof value === 'number') {
                return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
            }
            return value;
        }));

        const tableHtml = `
            <div class="table-responsive">
                <table id="${tableId}" class="table table-sm">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th>${this._formatFieldName(header)}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `
                            <tr>
                                ${row.map(cell => `<td>${cell}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;

        // Initialize DataTable after a short delay to ensure the table is in the DOM
        setTimeout(() => {
            try {
                const tableElement = document.getElementById(tableId);
                if (tableElement) {
                    new simpleDatatables.DataTable(`#${tableId}`, {
                        searchable: true,
                        fixedHeight: false,
                        perPage: 10,
                        perPageSelect: [10, 25, 50, 100]
                    });
                } else {
                    console.warn(`Table element ${tableId} not found in DOM`);
                }
            } catch (error) {
                console.warn(`Failed to initialize DataTable for ${tableId}:`, error);
            }
        }, 100);

        return tableHtml;
    }

    _addCsvDownloadButton(container, data) {
        if (!data || !data.length) return;

        // Get or create tool-actions container
        let toolActions = container.querySelector('.tool-actions');
        if (!toolActions) {
            toolActions = document.createElement('div');
            toolActions.className = 'tool-actions d-flex align-items-center mt-2';
            container.appendChild(toolActions);
        }

        const headers = Object.keys(data[0]);
        const csvContent = [
            headers.join(','),
            ...data.map(row => headers.map(header => {
                let value = row[header];
                // Format dates and numbers
                if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                    value = new Date(value).toISOString().split('T')[0];
                } else if (typeof value === 'number') {
                    value = value.toFixed(2);
                }
                // Handle values that need quotes (contains commas, quotes, or newlines)
                if (typeof value === 'string' && (value.includes(',') || value.includes('"') || value.includes('\n'))) {
                    value = `"${value.replace(/"/g, '""')}"`;
                }
                return value;
            }).join(','))
        ].join('\n');

        // Create download button
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        
        const downloadButton = document.createElement('a');
        downloadButton.href = url;
        downloadButton.download = 'table_data.csv';
        downloadButton.className = 'btn btn-link text-primary p-0 ms-2';
        downloadButton.innerHTML = '<i class="fas fa-download"></i>';
        downloadButton.title = 'Download as CSV';
        
        // Clean up the URL on click
        downloadButton.addEventListener('click', () => {
            setTimeout(() => URL.revokeObjectURL(url), 100);
        });

        // Create copy button
        const copyButton = document.createElement('button');
        copyButton.className = 'btn btn-link text-primary p-0 ms-2';
        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
        copyButton.title = 'Copy CSV to clipboard';
        
        copyButton.addEventListener('click', async () => {
            try {
                await navigator.clipboard.writeText(csvContent);
                // Show success feedback
                const originalIcon = copyButton.innerHTML;
                copyButton.innerHTML = '<i class="fas fa-check text-success"></i>';
                setTimeout(() => {
                    copyButton.innerHTML = originalIcon;
                }, 1000);
            } catch (err) {
                console.error('Failed to copy:', err);
                // Show error feedback
                const originalIcon = copyButton.innerHTML;
                copyButton.innerHTML = '<i class="fas fa-times text-danger"></i>';
                setTimeout(() => {
                    copyButton.innerHTML = originalIcon;
                }, 1000);
            }
        });

        // Add buttons to container
        toolActions.appendChild(copyButton);
        toolActions.appendChild(downloadButton);
    }

    _findTimeSeriesData(data) {
        // Check if data is an array of objects with date/time and numeric fields
        if (!Array.isArray(data) || !data.length) return null;

        // Look for date/time fields (prefer 'date' or 'timestamp' if they exist)
        const dateFields = Object.keys(data[0]).filter(key => {
            const value = data[0][key];
            return typeof value === 'string' && !isNaN(Date.parse(value));
        });

        if (dateFields.length === 0) return null;

        // Prefer fields named 'date' or 'timestamp', otherwise take the first date field
        const dateField = dateFields.find(field => 
            field.toLowerCase() === 'date' || 
            field.toLowerCase() === 'timestamp'
        ) || dateFields[0];

        // Find numeric fields, excluding those that end with common suffixes for derived values
        const excludeSuffixes = ['_change', '_previous', '_percent', '_ratio', '_delta'];
        const numericFields = Object.keys(data[0]).filter(key => {
            if (key === dateField) return false;
            const value = data[0][key];
            // Check if it's a number and doesn't end with excluded suffixes
            return typeof value === 'number' && 
                   !excludeSuffixes.some(suffix => key.toLowerCase().endsWith(suffix.toLowerCase()));
        });

        if (numericFields.length === 0) return null;

        // Find potential categorical fields (string fields with a reasonable number of unique values)
        const maxCategories = 10; // Maximum number of unique categories to consider
        const categoricalFields = Object.keys(data[0]).filter(key => {
            if (key === dateField || numericFields.includes(key)) return false;
            const values = new Set(data.map(item => item[key]));
            return typeof data[0][key] === 'string' && values.size > 1 && values.size <= maxCategories;
        });

        // If we found categorical fields, use the first one for grouping
        const categoryField = categoricalFields.length > 0 ? categoricalFields[0] : null;

        // Group data by date and category (if exists)
        const groupedData = new Map();
        
        data.forEach(item => {
            const date = new Date(item[dateField]);
            const dateKey = date.toISOString().split('T')[0]; // Group by day
            const categoryKey = categoryField ? item[categoryField] : 'default';
            const groupKey = `${dateKey}|${categoryKey}`;
            
            if (!groupedData.has(groupKey)) {
                groupedData.set(groupKey, {
                    counts: {},
                    sums: {},
                    date,
                    category: categoryKey
                });
            }
            
            const group = groupedData.get(groupKey);
            numericFields.forEach(field => {
                if (typeof item[field] === 'number' && !isNaN(item[field])) {
                    group.sums[field] = (group.sums[field] || 0) + item[field];
                    group.counts[field] = (group.counts[field] || 0) + 1;
                }
            });
        });

        // Convert grouped data back to array format with averages
        const aggregatedData = Array.from(groupedData.values()).map(group => {
            const result = {
                [dateField]: group.date
            };
            if (categoryField) {
                result[categoryField] = group.category;
            }
            numericFields.forEach(field => {
                if (group.counts[field]) {
                    result[field] = group.sums[field] / group.counts[field];
                }
            });
            return result;
        });

        // Sort by date
        aggregatedData.sort((a, b) => a[dateField] - b[dateField]);

        return {
            dateField,
            numericFields,
            categoryField,
            data: aggregatedData
        };
    }

    _createChart(container, timeSeriesData) {
        const { dateField, numericFields, categoryField, data } = timeSeriesData;
        const chartId = `chart-${Date.now()}`;
        const canvas = document.createElement('canvas');
        canvas.id = chartId;

        // Ensure full width by setting style before appending to container
        canvas.style.width = '100%';
        canvas.style.height = '400px';        
        
        container.appendChild(canvas);

        const ctx = canvas.getContext('2d');
        
        // Create datasets based on numeric fields and categories
        let datasets = [];
        if (categoryField) {
            // Get unique categories
            const categories = [...new Set(data.map(item => item[categoryField]))];
            
            // For each numeric field and category combination
            numericFields.forEach(field => {
                categories.forEach(category => {
                    const categoryData = data.filter(item => item[categoryField] === category);
                    datasets.push({
                        label: `${this._formatFieldName(field)} - ${category}`,
                        data: categoryData.map(item => ({ x: new Date(item[dateField]), y: item[field] })),
                        borderColor: this._getRandomColor(),
                        tension: 0.4,
                        fill: false,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointHitRadius: 10
                    });
                });
            });
        } else {
            // Original behavior for no categories
            datasets = numericFields.map(field => ({
                label: this._formatFieldName(field),
                data: data.map(item => ({ x: new Date(item[dateField]), y: item[field] })),
                borderColor: this._getRandomColor(),
                tension: 0.4,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointHitRadius: 10
            }));
        }

        // Determine the time unit based on the data
        const dates = data.map(item => new Date(item[dateField]));
        const timeUnit = this._determineTimeUnit(dates);
        
        // Calculate min and max dates for the scale
        const minDate = new Date(Math.min(...dates));
        const maxDate = new Date(Math.max(...dates));
        
        // Calculate a reasonable number of ticks based on the date range
        const range = maxDate - minDate;
        const numberOfTicks = Math.min(10, data.length);
        
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: timeUnit,
                            displayFormats: {
                                hour: 'MMM d, HH:mm',
                                day: 'MMM d',
                                week: 'MMM d',
                                month: 'MMM yyyy'
                            },
                            tooltipFormat: timeUnit === 'hour' ? 'MMM d, HH:mm' :
                                         timeUnit === 'day' ? 'MMM d, yyyy' :
                                         timeUnit === 'week' ? 'MMM d, yyyy' :
                                         'MMM yyyy'
                        },
                        min: minDate,
                        max: maxDate,
                        ticks: {
                            source: 'auto',
                            autoSkip: true,
                            maxTicksLimit: numberOfTicks
                        },
                        title: {
                            display: true,
                            text: 'Time'
                        }
                    },
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Value'
                        },
                        ticks: {
                            autoSkip: true,
                            maxTicksLimit: 8
                        }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Time Series Data'
                    },
                    tooltip: {
                        enabled: true,
                        mode: 'index',
                        intersect: false,
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                return `${label}: ${value.toLocaleString(undefined, {maximumFractionDigits: 2})}`;
                            }
                        }
                    },
                    legend: {
                        position: 'top',
                        align: 'center'
                    }
                },
                elements: {
                    point: {
                        radius: 3,
                        hitRadius: 10,
                        hoverRadius: 5
                    },
                    line: {
                        tension: 0.4
                    }
                }
            }
        });

        // Set fixed dimensions for chart container
        const containerWidth = container.clientWidth || container.offsetWidth || 600;
        canvas.style.height = '400px';
        canvas.style.width = containerWidth + 'px';
        
        this.charts.set(chartId, chart);
        
        // Add resize handler to ensure chart adapts to container width changes
        const resizeObserver = new ResizeObserver(() => {
            try {
                // Update canvas width to match container width
                const newWidth = container.clientWidth || container.offsetWidth;
                if (newWidth > 0) {
                    canvas.style.width = newWidth + 'px';
                    chart.resize();
                }
            } catch (e) {
                console.warn('Error resizing chart:', e);
            }
        });
        resizeObserver.observe(container);

        return chartId;
    }

    _formatFieldName(field) {
        // Convert camelCase or snake_case to Title Case
        return field
            .replace(/([A-Z])/g, ' $1') // Split camelCase
            .replace(/_/g, ' ')         // Replace underscores with spaces
            .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()); // Title case
    }

    _determineTimeUnit(dates) {
        if (dates.length < 2) return 'day'; // Default to day if not enough data points
        
        // Sort dates to ensure correct interval calculation
        dates.sort((a, b) => a - b);
        
        // Calculate all intervals between consecutive dates
        const intervals = [];
        for (let i = 1; i < dates.length; i++) {
            intervals.push(dates[i] - dates[i-1]);
        }
        
        // Get median interval in milliseconds
        intervals.sort((a, b) => a - b);
        const medianInterval = intervals[Math.floor(intervals.length / 2)];
        
        // Convert to hours for easier comparison
        const hours = medianInterval / (1000 * 60 * 60);
        
        // Determine appropriate unit based on median interval
        // For hourly data (intervals between 30 mins and 4 hours)
        if (hours <= 4) return 'hour';
        
        // For daily data (intervals between 4 hours and 5 days)
        if (hours <= 24 * 5) return 'day';
        
        // For weekly data (intervals between 5 days and 15 days)
        if (hours <= 24 * 15) return 'week';
        
        // For monthly data (intervals greater than 15 days)
        return 'month';
    }

    _getRandomColor() {
        const colors = [
            '#3498db', '#2ecc71', '#e74c3c', '#f1c40f', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#16a085', '#c0392b'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    _convertTimeSeriesDataToTable(timeSeriesData) {
        const { dateField, numericFields, data } = timeSeriesData;
        
        // Convert the time series data to a tabular format
        return data.map(item => {
            const row = {
                [dateField]: new Date(item[dateField]).toISOString()
            };
            numericFields.forEach(field => {
                row[field] = item[field];
            });
            return row;
        });
    }

    // Helper method to properly parse CSV rows (handling quoted values)
    _parseCSVRow(row) {
        const values = [];
        let currentValue = '';
        let insideQuotes = false;
        
        for (let i = 0; i < row.length; i++) {
            const char = row[i];
            
            if (char === '"') {
                if (insideQuotes && row[i + 1] === '"') {
                    // Handle escaped quotes
                    currentValue += '"';
                    i++;
                } else {
                    // Toggle quote state
                    insideQuotes = !insideQuotes;
                }
            } else if (char === ',' && !insideQuotes) {
                // End of value
                values.push(currentValue.trim());
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
        
        // Add the last value
        values.push(currentValue.trim());
        return values;
    }
}

export { ToolOutputManager };

================
File: apps/agents/static/agents/js/components/message_list.js
================
import { Message } from '/static/agents/js/components/message.js';

class MessageList {
    constructor(container) {
        this.container = container;
        this.messages = [];
        this.messageIds = new Map();  // Track message IDs
        
        // Get agent info from window.chatConfig
        this.currentAgent = {
            avatar: '/static/assets/img/agent-avatar-female-3.jfif',
            name: 'Agent'
        };
        
        this._setupContainer();
    }

    // Add method to update current agent
    updateCurrentAgent(agent) {
        if (agent?.avatar && agent?.name) {
            this.currentAgent = {
                avatar: agent.avatar,
                name: agent.name
            };
        }
    }

    _setupContainer() {
        // Ensure container has proper styling
        this.container.style.overflowY = 'auto';
    }

    addMessage(content, isAgent = false, avatar = null, messageId = null) {
        // Ensure content is a string
        const contentStr = typeof content === 'string' ? content : 
                          (content && typeof content === 'object') ? JSON.stringify(content) : String(content);
        
        console.log(`MessageList.addMessage: Adding ${isAgent ? 'agent' : 'user'} message with ID ${messageId}, content: ${contentStr.substring(0, 30)}...`);
        
        // Check for duplicate messages by comparing content
        const existingMessages = this.container.querySelectorAll('.message-text');
        for (const existingMsg of existingMessages) {
            if (existingMsg.textContent.trim() === contentStr.trim()) {
                const timestamp = new Date().toISOString();
                console.warn(`[${timestamp}] DUPLICATE MESSAGE DETECTED: ${contentStr.substring(0, 30)}...`);
            }
        }
        
        // Use the string version of content for creating the message
        const message = new Message(contentStr, isAgent, avatar);
        this.messages.push(message);
        const domId = this._appendMessageToDOM(message);
        
        // Track message ID if provided
        if (messageId) {
            this.messageIds.set(domId, messageId);
        }
        
        this._scrollToBottom();
        return domId;
    }

    _appendMessageToDOM(message) {
        const domId = `msg-${Date.now()}`;
        const messageElement = message.render(domId);
        this.container.appendChild(messageElement);
        
        // Handle code blocks if any
        const codeBlocks = messageElement.querySelectorAll('pre code');
        if (codeBlocks.length > 0) {
            codeBlocks.forEach(block => {
                hljs.highlightElement(block);
            });
        }
        
        return domId;
    }

    _scrollToBottom() {
        this.container.scrollTop = this.container.scrollHeight;
    }

    clear() {
        this.messages = [];
        this.messageIds.clear();
        this.container.innerHTML = '';
    }

    // Method to handle historical messages
    loadHistory(messages) {
        this.clear();
        messages.forEach(msg => {
            this.addMessage(
                msg.content,
                msg.is_agent,
                msg.avatar,
                msg.id
            );
        });
    }

    deleteMessagesFromIndex(domId) {
        const container = document.getElementById(`${domId}-container`);
        if (!container) {
            console.warn('Could not find message container');
            return;
        }

        // Get the message ID
        const messageId = this.messageIds.get(domId);
        if (!messageId) {
            console.warn('No backend message ID found for container:', domId);
            return;
        }

        // Find all messages after this one (including this one)
        let currentElement = container;
        const messagesToDelete = [];
        
        while (currentElement) {
            if (currentElement.id && currentElement.id.includes('msg-')) {
                const currentDomId = currentElement.id.replace('-container', '');
                messagesToDelete.push({
                    element: currentElement,
                    domId: currentDomId,
                    backendId: this.messageIds.get(currentDomId)
                });
            }
            currentElement = currentElement.nextElementSibling;
        }

        // Remove messages and clear their IDs
        messagesToDelete.forEach(({ element, domId }) => {
            this.messageIds.delete(domId);
            element.remove();
        });
    }

    getMessageId(domId) {
        const messageId = this.messageIds.get(domId);
        return messageId;
    }
}

export { MessageList };

================
File: apps/agents/static/agents/js/components/message.js
================
class Message {
    constructor(content, isAgent = false, avatar = null) {
        // Handle case where content is a JSON object with message field
        if (typeof content === 'object' && content !== null && content.message) {
            this.content = content.message;
            this.rawContent = content;
            this.isCrewMessage = content.type === 'crew_message';
            this.isAgent = isAgent || this.isCrewMessage; // Treat crew messages like agent messages
        } else {
            this.content = content;
            this.rawContent = null;
            this.isCrewMessage = false;
            this.isAgent = isAgent;
        }
        this.avatar = avatar || (this.isAgent ? window.chatConfig.currentAgent.avatar : '/static/assets/img/user-avatar.jfif');
    }

    _detectAndFormatTableData(content) {
        try {
            // First check if content starts with markdown headers or common markdown elements
            if (typeof content === 'string' && 
                (content.trim().startsWith('#') || 
                 content.trim().startsWith('*') || 
                 content.trim().startsWith('-'))) {
                return null; // Let the markdown parser handle it
            }

            // Try to parse the content as JSON
            let data = content;
            if (typeof content === 'string') {
                // Check if content is wrapped in markdown code block
                const codeBlockMatch = content.match(/```(?:json)?\n([\s\S]*?)\n```/);
                if (codeBlockMatch) {
                    try {
                        // Clean up the JSON content
                        let jsonContent = codeBlockMatch[1].trim();
                        data = JSON.parse(jsonContent);
                    } catch (e) {
                        console.debug('Content is not valid JSON, will be handled as markdown');
                        return null;
                    }
                }
            }

            // Look for common patterns in the data structure
            if (typeof data === 'object' && data !== null) {
                // Check for common response patterns and nested data
                for (const key of ['data', 'results', 'analytics_data', 'records', 'rows', 'items', 'response']) {
                    if (data[key] && Array.isArray(data[key]) && data[key].length > 0) {
                        const tableHtml = this._createTable(data[key]);
                        if (tableHtml) {
                            // If there's text before or after the code block, preserve it
                            let parts = [];
                            if (this.rawContent && this.rawContent.message) {
                                parts = this.rawContent.message.split(/```json\n[\s\S]*?\n```/);
                            } else {
                                parts = this.content.split(/```(?:json)?\n[\s\S]*?\n```/);
                            }
                            const prefix = parts[0] ? marked.parse(parts[0].trim()) : '';
                            const suffix = parts[1] ? marked.parse(parts[1].trim()) : '';
                            return prefix + tableHtml + suffix;
                        }
                    }
                }

                // If no list found in known keys, check all values
                for (const value of Object.values(data)) {
                    if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                        return this._createTable(value);
                    }
                }
            }
        } catch (error) {
            console.error('Error detecting table data:', error);
        }
        return null;
    }

    _createTable(data) {
        if (!Array.isArray(data) || !data.length) return null;

        const tableId = `table-${Date.now()}`;
        const headers = Object.keys(data[0]);
        const rows = data.map(row => headers.map(header => {
            const value = row[header];
            // Format dates and numbers
            if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                return new Date(value).toISOString().split('T')[0];
            }
            if (typeof value === 'number') {
                return value.toLocaleString(undefined, { maximumFractionDigits: 2 });
            }
            return value;
        }));

        return `
            <div class="table-responsive">
                <table id="${tableId}" class="table table-sm">
                    <thead>
                        <tr>
                            ${headers.map(header => `<th>${this._formatFieldName(header)}</th>`).join('')}
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map(row => `
                            <tr>
                                ${row.map(cell => `<td>${cell}</td>`).join('')}
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            </div>
        `;
    }

    _formatFieldName(field) {
        // Convert camelCase or snake_case to Title Case
        return field
            .replace(/([A-Z])/g, ' $1') // Split camelCase
            .replace(/_/g, ' ')         // Replace underscores with spaces
            .replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()); // Title case
    }

    render(domId) {
        const messageElement = document.createElement('div');
        messageElement.id = `${domId}-container`;
        messageElement.className = `d-flex ${this.isAgent ? 'justify-content-start' : 'justify-content-end'} mb-4`;

        // Format content for display
        let formattedContent = this.content;
        
        // Ensure content is a string and not an object
        if (typeof formattedContent === 'object' && formattedContent !== null) {
            formattedContent = JSON.stringify(formattedContent);
        }
        
        if (this.isAgent || this.isCrewMessage) {
            try {
                // First try to detect and format table data
                const tableHtml = this._detectAndFormatTableData(formattedContent);
                if (tableHtml) {
                    formattedContent = tableHtml;
                } else {
                    formattedContent = marked.parse(formattedContent);
                }
            } catch (error) {
                console.error('Error parsing content:', error);
                // If there was an error, ensure we have a string to display
                formattedContent = String(formattedContent);
            }
        }

        messageElement.innerHTML = `
            ${this.isAgent || this.isCrewMessage ? `<div class="avatar me-2">
                <img src="${this.avatar}" 
                     alt="${this.isCrewMessage ? 'Crew' : window.chatConfig.currentAgent.name}" 
                     class="border-radius-lg shadow">
            </div>` : ''}
            <div class="message ${this.isAgent || this.isCrewMessage ? 'agent' : 'user'}" style="max-width: 75%;">
                <div class="message-content">
                    <div class="message-actions">
                        <button class="btn btn-link copy-message" title="Copy to clipboard">
                            <i class="fas fa-copy"></i>
                        </button>
                        ${!this.isAgent && !this.isCrewMessage ? `
                        <button class="btn btn-link edit-message" title="Edit message">
                            <i class="fas fa-edit"></i>
                        </button>` : ''}
                    </div>
                    <div class="message-text">
                        ${formattedContent}
                    </div>
                </div>
            </div>
            ${!this.isAgent && !this.isCrewMessage ? `<div class="avatar ms-2">
                <img src="${this.avatar}" alt="User" class="border-radius-lg shadow">
            </div>` : ''}
        `;

        // Add event listeners for message actions
        const copyButton = messageElement.querySelector('.copy-message');
        if (copyButton) {
            copyButton.addEventListener('click', () => {
                const textToCopy = messageElement.querySelector('.message-text').textContent;
                navigator.clipboard.writeText(textToCopy).then(() => {
                    copyButton.innerHTML = '<i class="fas fa-check"></i>';
                    setTimeout(() => {
                        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
                    }, 1000);
                }).catch(err => {
                    console.error('Failed to copy text:', err);
                    copyButton.innerHTML = '<i class="fas fa-times"></i>';
                    setTimeout(() => {
                        copyButton.innerHTML = '<i class="fas fa-copy"></i>';
                    }, 1000);
                });
            });
        }

        // Add event listener for edit button
        const editButton = messageElement.querySelector('.edit-message');
        if (editButton) {
            editButton.addEventListener('click', () => {
                const event = new CustomEvent('edit-message', { detail: { domId } });
                document.dispatchEvent(event);
            });
        }

        // Initialize DataTable for any tables in the message
        const table = messageElement.querySelector('table');
        if (table) {
            setTimeout(() => {
                try {
                    new simpleDatatables.DataTable(table, {
                        searchable: true,
                        fixedHeight: false,
                        perPage: 10
                    });
                } catch (error) {
                    console.warn(`Failed to initialize DataTable:`, error);
                }
            }, 100);
        }

        return messageElement;
    }
}

export { Message };

================
File: apps/agents/static/agents/js/modules/content_expander.js
================
// Content expander module for handling expandable card content
export class ContentExpander {
    constructor() {
        this.sidePanel = null;
        this.activeCard = null;
        this.setupSidePanel();
    }

    setupSidePanel() {
        // Create side panel if it doesn't exist
        if (!document.getElementById('content-side-panel')) {
            const panel = document.createElement('div');
            panel.id = 'content-side-panel';
            panel.className = 'position-fixed end-0 top-0 h-100 bg-white shadow-lg';
            panel.style.width = '0';
            panel.style.transition = 'width 0.3s ease-in-out';
            panel.style.zIndex = '1040';
            panel.innerHTML = `
                <div class="d-flex flex-column h-100">
                    <div class="p-3 border-bottom d-flex justify-content-between align-items-center">
                        <h6 class="mb-0 content-title"></h6>
                        <div>
                            <button class="btn btn-link text-dark p-0 me-3" id="export-content">
                                <i class="fas fa-download"></i>
                            </button>
                            <button class="btn btn-link text-dark p-0" id="close-panel">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="p-3 flex-grow-1 overflow-auto content-body"></div>
                </div>
            `;
            document.body.appendChild(panel);
            this.sidePanel = panel;
            
            // Add event listeners
            document.getElementById('close-panel').addEventListener('click', () => this.closeSidePanel());
            document.getElementById('export-content').addEventListener('click', () => this.exportContent());
        }
    }

    expandContent(cardElement, title, content, metadata = {}) {
        console.log('expandContent called', { title, content, metadata });
        this.activeCard = cardElement;
        this.activeContent = { title, content, metadata };
        
        // Highlight active card
        if (this.activeCard) {
            this.activeCard.classList.add('border-primary');
        }
        
        // Update panel content
        const titleEl = this.sidePanel.querySelector('.content-title');
        const bodyEl = this.sidePanel.querySelector('.content-body');
        
        titleEl.textContent = title;
        // Use the global markdown-it instance
        if (!window.md) {
            console.error('markdown-it not initialized');
            return;
        }
        
        // Check if content appears to be markdown
        // const isMarkdown = /^#|\[.*\]\(.*\)|\*{1,2}|`{1,3}/.test(content);

        const renderedContent = window.md.render(content);

        console.log('Rendered content:', renderedContent);  // Fixed syntax error here
    
        bodyEl.innerHTML = `
            <div class="card border-0">
                <div class="card-body">
                    <div class="markdown-content mb-3">${renderedContent}</div>
                    ${this.renderMetadata(metadata)}
                </div>
            </div>
        `;
            
        // Show panel
        this.sidePanel.style.width = '500px';
    }

    renderMetadata(metadata) {
        if (!Object.keys(metadata).length) return '';
        
        return `
            <div class="border-top pt-3 mt-3">
                ${Object.entries(metadata).map(([key, value]) => `
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <small class="text-muted">${key}:</small>
                        <span class="text-sm">${value}</span>
                    </div>
                `).join('')}
            </div>
        `;
    }

    closeSidePanel() {
        // Remove highlight from active card
        if (this.activeCard) {
            this.activeCard.classList.remove('border-primary');
            this.activeCard = null;
        }
        
        // Hide panel
        this.sidePanel.style.width = '0';
    }

    exportContent() {
        if (!this.activeContent) return;
        
        const { title, content, metadata } = this.activeContent;
        const exportData = {
            title,
            content,
            metadata,
            exportedAt: new Date().toISOString()
        };
        
        // Create blob and download
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${title.toLowerCase().replace(/\s+/g, '-')}-${new Date().getTime()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
}

================
File: apps/agents/static/agents/js/services/message_handler.js
================
class MessageHandler {
    constructor(messageList, toolOutputManager) {
        this.messageList = messageList;
        this.toolOutputManager = toolOutputManager;
        this.websocket = null;  // Will be set after construction
        this.messagesContainer = document.getElementById('chat-messages');
        this.currentToolContainer = null;
        this.loadingIndicator = null;
        this.onSystemMessage = null; // Callback for system messages
        this.lastHumanInputContext = null; // Store context for human input
        this.processedMessageIds = new Set(); // Track message IDs that have been processed
        this.toolRunMessages = new Map(); // Map of message IDs to tool run IDs
    }

    handleMessage(message) {
        console.log('Received message:', message);

        switch (message.type) {
            case 'system_message':
                this.handleSystemMessage(message);
                break;
            case 'user_message':
                this.handleUserMessage(message);
                break;
            case 'agent_message':
                this.removeLoadingIndicator();
                this.handleAgentMessage(message);
                break;
            case 'crew_message':
                // Only remove loading indicator if crew execution is completed
                if (message.status && (message.status === 'DONE' || message.status === 'COMPLETED')) {
                    this.removeLoadingIndicator();
                }
                this.handleCrewMessage(message);
                break;
            case 'execution_update':
                this.handleExecutionUpdate(message);
                break;
            case 'agent_finish':
                console.log('Agent finish:', message);
                this.handleAgentFinish(message);
                break;
            case 'tool_start':
                this.handleToolStart(message);
                break;
            case 'tool_end':
                this.handleToolEnd(message);
                break;
            case 'tool_result':
                this.handleToolResult(message);
                break;
            case 'error':
                console.log('Error message:', message);
                this.handleErrorMessage(message);
                break;
            default:
                console.warn('Unknown message type:', message.type);
        }
    }

    showLoadingIndicator() {
        // Remove any existing loading indicator first
        this.removeLoadingIndicator();

        // Create the loading indicator
        const loadingContainer = document.createElement('div');
        loadingContainer.className = 'd-flex justify-content-start mb-4 streaming-message';
        loadingContainer.innerHTML = `
            <div class="avatar me-2">
                <img src="${this.messageList.currentAgent.avatar}" 
                     alt="${this.messageList.currentAgent.name}" 
                     class="border-radius-lg shadow">
            </div>
            <div class="agent-message" style="max-width: 75%;">
                <div class="message-content loading-content">
                    <div class="typing-indicator">
                        <div class="typing-dots">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                        <div class="typing-text ms-2">Thinking...</div>
                    </div>
                </div>
            </div>
        `;

        this.loadingIndicator = loadingContainer;
        this.messagesContainer.appendChild(loadingContainer);
        this.scrollToBottom();
    }

    removeLoadingIndicator() {
        if (this.loadingIndicator) {
            this.loadingIndicator.remove();
            this.loadingIndicator = null;
        }
    }

    scrollToBottom() {
        if (this.messagesContainer) {
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        }
    }

    handleSystemMessage(message) {
        // Call the system message callback if set
        if (this.onSystemMessage) {
            this.onSystemMessage(message);
        }

        if (message.connection_status) {
            this.handleConnectionStatus(message.connection_status);
        }
    }

    handleConnectionStatus(status) {
        const dot = document.querySelector('.connection-dot');
        if (dot) {
            dot.className = 'connection-dot ' + status;
        }
    }

    handleUserMessage(message) {
        // Skip if we've already processed this message
        if (message.id && this.processedMessageIds.has(message.id)) {
            console.log('Skipping already processed user message:', message.id);
            return;
        }
        
        // Track this message as processed if it has an ID
        if (message.id) {
            this.processedMessageIds.add(message.id);
        }
        
        // Add the message to the UI
        this.messageList.addMessage(message.message, false, null, message.id);
        
        // Only show loading indicator for fresh messages
        // (not historical ones loaded from the server)
        const isHistoricalMessage = message.timestamp && 
            new Date(message.timestamp).getTime() < Date.now() - 5000; // 5 seconds threshold
            
        if (!isHistoricalMessage) {
            // IMPORTANT: We remove the human input context handling from here
            // It's now handled directly in ChatApp._sendMessage
            
            this.showLoadingIndicator();
        }
    }

    handleAgentMessage(message) {
        // Skip if we've already processed this message
        if (message.id && this.processedMessageIds.has(message.id)) {
            console.log('Skipping already processed agent message:', message.id);
            return;
        }
        
        // Track this message as processed if it has an ID
        if (message.id) {
            this.processedMessageIds.add(message.id);
        }

        const messageContent = message.content || message.message;
        
        // Skip empty messages
        if (!messageContent || messageContent.trim() === '') {
            console.warn('Skipping empty agent message');
            return;
        }
        
        // Handle special message content
        if (messageContent === 'I\'m thinking...') {
            return; // Skip "thinking" messages
        }
        
        // Handle tool-related messages
        if (messageContent.startsWith('Tool Start:')) {
            // Extract tool info and create a tool container
            const toolMatch = messageContent.match(/Tool Start:\s*(.+?)($|\n)/);
            if (toolMatch) {
                const toolName = toolMatch[1].trim();
                console.debug(`Extracted tool name: "${toolName}" from message: "${messageContent}"`);
                
                // Generate a unique run ID if we don't have one from the backend
                // Use the message ID if available, or generate a timestamp-based one
                const toolRunId = `${toolName}-${message.id || Date.now()}`;
                
                this.handleToolStart({
                    tool: toolName,
                    input: '',  // No input available in this format
                    run_id: toolRunId
                });
                
                // Store this tool run ID for future reference
                if (message.id) {
                    this.toolRunMessages.set(message.id, toolRunId);
                }
            }
            return;
        }
        
        if (messageContent === 'Tool Result') {
            // For tool result messages, use the handleToolResult method
            this.handleToolResult(message);
            return;
        }
        
        // For regular agent messages, add to the message list as a simple string
        this.messageList.addMessage(messageContent, true, null, message.id);
        
        this.scrollToBottom();
    }

    handleAgentFinish(message) {
        this.removeLoadingIndicator();
        try {
            const data = typeof message.message === 'string' ? JSON.parse(message.message) : message.message;
            if (data.analytics_data && Array.isArray(data.analytics_data)) {
                this.toolOutputManager.handleToolResult({
                    type: 'table',
                    data: data.analytics_data
                });
            } else {
                this.messageList.addMessage(message.message, true, null, message.id);
            }
        } catch (error) {
            this.messageList.addMessage(message.message, true, null, message.id);
        }
    }

    handleToolStart(message) {
        console.debug('handleToolStart received:', message);
        
        const toolData = {
            tool: message.tool || message.content?.tool || message.message?.tool,
            input: message.input || message.content?.input || message.message?.input,
            run_id: message.run_id || message.content?.run_id || message.message?.run_id
        };
        
        console.debug('Passing to ToolOutputManager:', toolData);
        this.toolOutputManager.handleToolStart(toolData);
    }

    handleToolEnd(message) {
        // Handle tool end if needed
    }

    handleToolResult(message) {
        let result;
        console.debug('Processing tool result:', message);
        
        // Try to determine the associated tool run ID
        let toolRunId = null;
        if (message.additional_kwargs && message.additional_kwargs.tool_call && 
            message.additional_kwargs.tool_call.run_id) {
            // If the backend provides a run ID, use it
            toolRunId = message.additional_kwargs.tool_call.run_id;
        } else if (message.id && this.toolRunMessages) {
            // Look for a previously recorded tool run message that might be related
            // This is a heuristic - the result likely follows the tool start message
            const possibleStartIds = [...this.toolRunMessages.keys()].sort();
            for (const startId of possibleStartIds) {
                if (startId < message.id) {
                    // This start came before our result, might be related
                    toolRunId = this.toolRunMessages.get(startId);
                }
            }
        }
        
        try {
            // First check for tool data in additional_kwargs
            if (message.additional_kwargs && message.additional_kwargs.tool_call) {
                console.debug('Found tool_call in additional_kwargs:', message.additional_kwargs.tool_call);
                const toolData = message.additional_kwargs.tool_call;
                const toolOutput = toolData.output;
                const toolName = toolData.name;
                
                if (toolOutput.error) {
                    result = { type: 'error', data: toolOutput.error, toolName, toolRunId };
                } else if (toolOutput.analytics_data && Array.isArray(toolOutput.analytics_data)) {
                    result = { type: 'table', data: toolOutput.analytics_data, toolName, toolRunId };
                } else if (toolOutput.text) {
                    // Special case for search results which often have a text field
                    result = { type: 'text', data: toolOutput.text, toolName, toolRunId };
                } else {
                    result = { type: 'json', data: toolOutput, toolName, toolRunId };
                }
            } else {
                // Legacy format - handle both content and message formats
                const data = message.content || message.message;
                console.debug('No tool_call in additional_kwargs, parsing message content:', data);
                
                // Don't attempt to parse if it's just the string "Tool Result"
                if (data === "Tool Result") {
                    console.error('Tool result message without data, skipping display');
                    return;
                }
                
                const parsedData = typeof data === 'string' ? JSON.parse(data) : data;
                
                if (parsedData.error) {
                    result = { type: 'error', data: parsedData.error, toolRunId };
                } else if (parsedData.analytics_data && Array.isArray(parsedData.analytics_data)) {
                    result = { type: 'table', data: parsedData.analytics_data, toolRunId };
                } else {
                    result = { type: 'json', data: parsedData, toolRunId };
                }
            }
        } catch (error) {
            console.error('Error parsing tool result:', error);
            result = { type: 'text', data: message.content || message.message, toolRunId };
        }
        
        console.debug('Passing result to ToolOutputManager:', result);
        this.toolOutputManager.handleToolResult(result);
    }

    handleErrorMessage(message) {
        console.error('Server error:', message.message);
    }

    handleCrewMessage(message) {
        // Skip if we've already processed this message
        if (message.id && this.processedMessageIds.has(message.id)) {
            console.log('Skipping already processed crew message:', message.id);
            return;
        }
        
        // Track this message as processed if it has an ID
        if (message.id) {
            this.processedMessageIds.add(message.id);
        }

        // Handle crew-specific messages
        if (message.message && typeof message.message === 'string') {
            // Handle tool messages
            if (message.message.startsWith('Using tool:') || message.message.startsWith('Tool Start:')) {
                // Don't add the tool start message directly to chat
                const toolMessage = message.message;
                const toolMatch = toolMessage.match(/^(?:Tool Start:|Using Tool:)\s*(.+?)($|\n)/);
                const toolName = toolMatch ? toolMatch[1].trim() : 'Tool';
                const inputMatch = toolMessage.match(/Input:(.*?)(?:\n|$)/s);
                const input = inputMatch ? inputMatch[1].trim() : '';
                
                this.toolOutputManager.handleToolStart({
                    tool: toolName,
                    input: input
                });
                return;
            } else if (message.message.startsWith('Tool Result:') || message.message.startsWith('Tool result:')) {
                // Don't add the tool result message directly to chat
                const resultContent = message.message.replace(/^(Tool Result:|Tool result:)/, '').trim();
                
                // Try to parse as JSON first
                try {
                    const jsonData = JSON.parse(resultContent);
                    if (jsonData.analytics_data && Array.isArray(jsonData.analytics_data)) {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'table', 
                            data: jsonData.analytics_data 
                        });
                    } else {
                        this.toolOutputManager.handleToolResult({ 
                            type: 'json', 
                            data: jsonData 
                        });
                    }
                } catch (jsonError) {
                    // If not JSON, handle as text result
                    this.toolOutputManager.handleToolResult({ 
                        type: 'text', 
                        data: resultContent 
                    });
                }
                return;
            } else if (message.message.startsWith('Tool Error:')) {
                // Don't add the tool error message directly to chat
                const errorMessage = message.message.replace('Tool Error:', '').trim();
                this.toolOutputManager.handleToolResult({
                    type: 'error',
                    data: errorMessage
                });
                return;
            }
        }

        // If this is a human input request, store the context
        if (message.context?.is_human_input) {
            console.log('Human input request received, storing context:', message.context);
            // Store the context so when user replies, we'll send it back with the response
            this.lastHumanInputContext = message.context;
            
            // Remove loading indicator to show we're waiting for user input
            this.removeLoadingIndicator();
            
            // Add a visual indicator to show that we're expecting input
            const inputIndicator = document.querySelector('#message-input');
            if (inputIndicator) {
                inputIndicator.setAttribute('placeholder', 'Type your response...');
                inputIndicator.focus();
            }
        }

        // Only add non-tool messages to UI
        if (message.message && 
            !message.message.startsWith('Using tool:') && 
            !message.message.startsWith('Tool Start:') && 
            !message.message.startsWith('Tool Result:') && 
            !message.message.startsWith('Tool result:') && 
            !message.message.startsWith('Tool Error:')) {
            this.messageList.addMessage(
                message.message, 
                true,
                null,
                message.id
            );
            this.scrollToBottom();
        }
    }

    handleExecutionUpdate(message) {
        // Handle execution status updates
        if (message.status === 'RUNNING') {
            this.showLoadingIndicator();
        } else if (message.status === 'COMPLETED' || message.status === 'FAILED') {
            this.removeLoadingIndicator();
        }
        
        // Only add non-tool messages to UI
        if (message.message && 
            !message.message.startsWith('Using tool:') && 
            !message.message.startsWith('Tool Start:') && 
            !message.message.startsWith('Tool Result:') && 
            !message.message.startsWith('Tool result:') && 
            !message.message.startsWith('Tool Error:')) {
            this.messageList.addMessage(
                message.message, 
                true,
                null,
                message.id
            );
            this.scrollToBottom();
        }
    }

    _sendMessage(message) {
        if (!this.websocket) {
            console.error('No websocket available for sending message');
            return;
        }

        // If we have human input context, send as human input response
        if (this.lastHumanInputContext) {
            this.websocket.send({
                type: 'user_message',
                message: message,
                context: this.lastHumanInputContext
            });
            this.lastHumanInputContext = null;
        } else {
            // Send as regular message
            this.websocket.send(message);
        }
    }
}

export { MessageHandler };

================
File: apps/agents/static/agents/js/services/websocket.js
================
class ChatWebSocket {
    constructor(config, messageHandler) {
        this.config = config;
        this.messageHandler = messageHandler;
        this.socket = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000; // Start with 1 second
        this.isReconnecting = false;
        this.lastMessageQueue = [];  // Queue to store messages during reconnection
    }

    connect() {
        // If already connecting or reconnecting is in progress, don't try to connect again
        if (this.socket?.readyState === WebSocket.CONNECTING || this.isReconnecting) {
            console.log('WebSocket already connecting or reconnecting in progress, skipping connect attempt');
            return;
        }

        // Close any existing socket cleanly before creating a new one
        if (this.socket) {
            try {
                // Only try to close if not already closed
                if (this.socket.readyState !== WebSocket.CLOSED && this.socket.readyState !== WebSocket.CLOSING) {
                    console.log('Closing existing socket before reconnect');
                    this.socket.onclose = null; // Prevent the close handler from firing
                    this.socket.close(1000, 'Clean closure before reconnect');
                }
            } catch (e) {
                console.warn('Error closing existing socket:', e);
            }
        }

        const wsUrl = `${this.config.urls.wsBase}?session=${this.config.sessionId}`;
        this.socket = new WebSocket(wsUrl);

        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.reconnectAttempts = 0;
            this.isReconnecting = false;
            this.messageHandler.handleConnectionStatus('connected');
            
            // Send any queued messages
            while (this.lastMessageQueue.length > 0) {
                const message = this.lastMessageQueue.shift();
                this.send(message);
            }
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                this.messageHandler.handleMessage(data);
            } catch (error) {
                console.error('Error handling message:', error);
            }
        };

        this.socket.onclose = (event) => {
            console.log('WebSocket closed:', event);
            this.messageHandler.handleConnectionStatus('disconnected');
            
            // Don't attempt to reconnect if this was a normal closure or we're already reconnecting
            if (event.code === 1000 || event.code === 1001 || this.isReconnecting) {
                console.log('WebSocket closed normally or already reconnecting, not attempting reconnect');
                return;
            }
            
            // Start reconnection process
            this._handleReconnect();
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.messageHandler.handleConnectionStatus('error');
            // Don't attempt reconnect here - let the onclose handler do it
        };
    }

    send(data) {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            console.log('Sending WebSocket message:', data);
            this.socket.send(JSON.stringify(data));
        } else {
            console.warn('WebSocket is not open, queueing message:', data);
            // Queue the message if we're reconnecting
            if (this.isReconnecting) {
                this.lastMessageQueue.push(data);
            }
        }
    }

    _handleReconnect() {
        if (this.isReconnecting) {
            console.log('Already attempting to reconnect, skipping');
            return;
        }

        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.isReconnecting = true;
            this.reconnectAttempts++;
            
            // Use a more moderate reconnection delay with a maximum cap
            const delay = Math.min(this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1), 5000);
            console.log(`Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
            
            setTimeout(() => {
                if (this.isReconnecting) {  // Double-check we're still in reconnecting state
                    console.log('Reconnecting...');
                    this.connect();
                }
            }, delay);
        } else {
            console.error('Max reconnection attempts reached');
            this.messageHandler.handleConnectionStatus('disconnected');
            this.messageHandler.handleError('Connection lost. Please refresh the page.');
            this.isReconnecting = false;
        }
    }

    disconnect() {
        this.isReconnecting = false; // Stop any reconnection in progress
        if (this.socket) {
            try {
                this.socket.close(1000, 'Normal closure');  // Use 1000 for normal closure
            } catch (e) {
                console.warn('Error closing socket during disconnect:', e);
            }
        }
    }
}

export { ChatWebSocket };

================
File: apps/agents/static/agents/js/crew_kanban.js
================
// Check required dependencies
if (typeof bootstrap === 'undefined') {
    console.error('Bootstrap is required but not loaded');
}
if (typeof markdownit === 'undefined') {
    console.error('markdown-it is required but not loaded');
}
if (typeof jKanban === 'undefined') {
    console.error('jKanban is required but not loaded');
}

// Verify required variables from template
if (typeof crewId === 'undefined') {
    console.error('crewId is required but not defined');
}
if (typeof clientId === 'undefined') {
    console.warn('clientId is not defined'); // warning since it can be null
}

// Initialize markdown-it globally
window.md = window.markdownit();

// WebSocket configuration and state
const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
let socket = null;
let reconnectAttempts = 0;
const maxReconnectAttempts = 5;
let reconnectDelay = 1000;
let pingInterval = null;
let lastPongTime = Date.now();

// Task tracking
let lastUpdatedTaskId = null;
let lastUpdatedTaskIndex = null;  // Track last used task index

// DOM elements cache
const elements = {
    kanbanContainer: document.getElementById('kanban-tasks'),
    executionNumber: document.getElementById('execution-number'),
    cancelButton: document.getElementById('cancelExecutionBtn')
};

// Initialize CSRF token
function getCsrfToken() {
    const token = document.querySelector('[name=csrfmiddlewaretoken]');
    if (!token) {
        console.error('CSRF token not found');
        return '';
    }
    return token.value;
}

// Import ContentExpander module
import { ContentExpander } from './modules/content_expander.js';
console.log('ContentExpander imported');
// Initialize content expander
const contentExpander = new ContentExpander();
console.log('ContentExpander initialized', contentExpander);
async function fetchActiveExecutions() {
    try {
        const response = await fetch(`/agents/crew/${crewId}/active-executions/`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        // Update cancel button based on active executions
        const hasActiveExecution = data.executions && data.executions.length > 0;
        const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
        updateCancelButton(hasActiveExecution, activeExecutionId);
        
        // Clear boards first
        document.querySelectorAll('.kanban-drag').forEach(board => {
            board.innerHTML = '';
        });
        
        // Repopulate with active executions
        data.executions.forEach(execution => {
            updateKanbanBoard({
                execution_id: execution.execution_id,
                task_id: execution.task_id,
                name: execution.name,
                status: execution.status,
                stages: execution.stages
            });
        });
        
        return data;
    } catch (error) {
        console.error('Error fetching active executions:', error);
        return null;
    }
}

function connectWebSocket() {
    if (socket && socket.readyState === WebSocket.OPEN) {
        console.log('WebSocket already connected');
        return;
    }
    
    // Close existing socket if it exists
    if (socket) {
        socket.close();
    }

    // Clear all kanban boards
    document.querySelectorAll('.kanban-drag').forEach(board => {
        board.innerHTML = '';
    });
    
    try {
        socket = new WebSocket(
            `${wsScheme}://${window.location.host}/ws/crew/${crewId}/kanban/`
        );
        
        socket.onopen = function(e) {
            console.log('WebSocket connection established');
            // Fetch active executions when connection is established
            fetchActiveExecutions();
        };

        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);
            
            if (!data.type) {
                console.error("Message missing type:", data);
                return;
            }
            
            handleWebSocketMessage(data);
        };

        socket.onclose = function(e) {
            console.log('WebSocket connection closed', e.code, e.reason);
            stopPingInterval();
            
            // Don't reconnect if closed normally
            if (e.code === 1000 || e.code === 1001) {
                console.log('WebSocket closed normally');
                return;
            }
            
            // Attempt to reconnect if not at max attempts
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                
                // Exponential backoff with jitter
                reconnectDelay = Math.min(reconnectDelay * 2, 30000);
                const jitter = Math.random() * 1000;
                setTimeout(connectWebSocket, reconnectDelay + jitter);
            } else {
                console.error('Max reconnection attempts reached');
            }
        };

        socket.onerror = function(e) {
            console.error('WebSocket error:', e);
            // Let onclose handle reconnection
        };
        
    } catch (error) {
        console.error('Error creating WebSocket:', error);
        // Attempt to reconnect on connection error
        if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            setTimeout(connectWebSocket, reconnectDelay);
        }
    }
}

// Ping interval to keep connection alive
function startPingInterval() {
    stopPingInterval(); // Clear any existing interval
    
    // Send ping every 15 seconds
    pingInterval = setInterval(() => {
        if (socket && socket.readyState === WebSocket.OPEN) {
            // Check if we haven't received a pong in 45 seconds
            if (Date.now() - lastPongTime > 45000) {
                console.log('No pong received for 45 seconds, reconnecting...');
                socket.close();
                connectWebSocket();
                return;
            }
            
            socket.send(JSON.stringify({ type: 'ping' }));
        }
    }, 15000);
}

function stopPingInterval() {
    if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
    }
}

// Initial connection
connectWebSocket();

// Clean up on page unload
window.addEventListener('beforeunload', () => {
    stopPingInterval();
    if (socket) {
        socket.close();
    }
});


function updateKanbanBoard(data) {
    // Only proceed if we have an execution_id
    if (!data.execution_id) {
        console.log('No execution_id provided, skipping update');
        return;
    }
    
    // Update cancel button based on execution status
    if (data.execution_id && data.status) {
        const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
        updateCancelButton(isActive, isActive ? data.execution_id : null);
    }
    
    // Update execution number in header
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = ` - Execution #${data.execution_id}`;
    }

    // Use task_index for board placement, fallback to last used index
    const taskIndex = data.task_index !== undefined ? data.task_index : lastUpdatedTaskIndex;
    console.log('Updating board with task index:', taskIndex, '(from data:', data.task_index, ', last:', lastUpdatedTaskIndex, ')');
    
    // Get all kanban boards in order
    const taskBoards = document.querySelectorAll('.kanban-board');
    let targetBoard;
    
    if (taskIndex !== null && taskIndex !== undefined && taskIndex < taskBoards.length) {
        targetBoard = taskBoards[taskIndex];
        lastUpdatedTaskIndex = taskIndex;  // Update the last used index
        console.log('Found target board for index:', taskIndex);
    } else {
        // Fallback to first board if no valid index available
        targetBoard = taskBoards[0];
        console.log('Using first board as fallback, no valid task index');
    }

    if (targetBoard) {
        addUpdateToBoard(targetBoard, data);
    } else {
        console.log('No board found for update');
    }
}

function handleHumanInputSubmit(button) {
    const stageItem = button.closest('.stage-item');
    const executionId = stageItem.getAttribute('data-execution-id');
    console.log("Submitting human input for execution:", executionId);
    
    if (!executionId) {
        console.error("No execution ID found for human input submission");
        alert('Error: Could not determine execution ID');
        return;
    }

    const textarea = button.parentElement.querySelector('textarea');
    const input = textarea.value.trim();
    
    if (!input) {
        alert('Please enter a response before submitting.');
        return;
    }
    
    // Disable the button and textarea while submitting
    button.disabled = true;
    textarea.disabled = true;
    
    console.log(`Sending human input to /agents/crew/execution/${executionId}/input/`);
    
    fetch(`/agents/crew/execution/${executionId}/input/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            input: input
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("Successfully submitted human input:", data);
        // Clear and disable the input after successful submission
        textarea.value = '';
    })
    .catch(error => {
        console.error('Error submitting human input:', error);
        alert('Failed to submit input. Please try again.');
        // Re-enable the button and textarea on error
        button.disabled = false;
        textarea.disabled = false;
    });
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

function updateAgentProgress(data) {
    console.log('Updating agent progress:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    const stageContainer = execution.querySelector('.card-body');
    const agentSection = stageContainer.querySelector('.agent-progress') || 
        stageContainer.insertAdjacentHTML('beforeend', '<div class="agent-progress mt-3"></div>');

    const progressHtml = `
        <div class="alert alert-info mb-2">
            <strong>${data.agent || 'Agent'}</strong>: ${data.content}
        </div>
    `;
    
    if (agentSection.children.length > 5) {
        agentSection.removeChild(agentSection.firstChild);
    }
    agentSection.insertAdjacentHTML('beforeend', progressHtml);
}

function handleTaskComplete(data) {
    console.log('Task completed:', data);
    const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
    if (!execution) return;

    // Show completion message
    const stageContainer = execution.querySelector('.card-body');
    const completionHtml = `
        <div class="alert alert-success mb-0">
            <strong>Task Complete!</strong> ${data.message || ''}
        </div>
    `;
    stageContainer.insertAdjacentHTML('beforeend', completionHtml);
}

function handleWebSocketMessage(data) {
    console.log('Received WebSocket message:', data);
    
    try {
        if (data.type === 'execution_update') {
            // For all updates, use task_index if provided, otherwise keep current
            const taskIndex = data.task_index !== undefined ? data.task_index : lastUpdatedTaskIndex;
            if (data.task_index !== undefined) {
                lastUpdatedTaskIndex = data.task_index;
            }
            console.log('Using task index:', taskIndex, '(from data:', data.task_index, ', last:', lastUpdatedTaskIndex, ')');
            
            updateKanbanBoard({
                ...data,
                task_index: taskIndex
            });
        } else if (data.type === 'human_input_request') {
            console.log('Received human input request:', data);
            // Create a stage object for the human input request
            const stageData = {
                execution_id: data.execution_id,
                task_index: data.task_index,
                stage: {
                    stage_type: 'human_input_request',
                    title: 'Human Input Required',
                    content: data.prompt,
                    status: 'waiting_for_human_input',
                    agent: 'System'
                },
                status: 'WAITING_FOR_HUMAN_INPUT'
            };
            updateKanbanBoard(stageData);
        } else {
            console.warn('Unknown message type:', data.type);
        }
    } catch (error) {
        console.error('Error processing WebSocket message:', error);
    }
}

// Initial fetch of active executions and setup of cancel button
document.addEventListener('DOMContentLoaded', async function() {
    const data = await fetchActiveExecutions();
    const hasActiveExecution = data && data.executions && data.executions.length > 0;
    const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
    updateCancelButton(hasActiveExecution, activeExecutionId);
});







function getCurrentTime() {
    return new Date().toLocaleTimeString();
}

function getStatusBadgeClass(status) {
    switch (status?.toLowerCase()) {
        case 'running':
            return 'info';
        case 'completed':
            return 'success';
        case 'failed':
            return 'danger';
        case 'waiting_for_human_input':
            return 'warning';
        case 'pending':
        default:
            return 'secondary';
    }
}

// Function to show/hide cancel button based on execution status
function updateCancelButton(hasActiveExecution, executionId) {
    const cancelBtn = document.getElementById('cancelExecutionBtn');
    if (!cancelBtn) {
        console.error('Cancel button not found');  // Debug log
        return;
    }
    cancelBtn.style.display = hasActiveExecution ? 'block' : 'none';
    if (hasActiveExecution) {
        cancelBtn.setAttribute('data-execution-id', executionId);
    } else {
        cancelBtn.removeAttribute('data-execution-id');
    }
}

// Add cancel execution functionality
async function cancelExecution(executionId) {
    try {
        const result = await Swal.fire({
            title: 'Cancel Execution',
            html: `
                <div class="text-start">
                    <p>Are you sure you want to cancel this execution?</p>
                    <p class="text-warning">This action cannot be undone.</p>
                </div>
            `,
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, Cancel Execution',
            cancelButtonText: 'No, Keep Running',
            customClass: {
                confirmButton: 'btn bg-gradient-danger me-3',
                cancelButton: 'btn bg-gradient-secondary ms-3',
                actions: 'my-3'
            },
            buttonsStyling: false
        });

        if (result.isConfirmed) {
            const response = await fetch(`/agents/execution/${executionId}/cancel/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error('Failed to cancel execution');
            }
            
            Swal.fire({
                title: 'Execution Cancelled',
                text: 'The execution has been cancelled successfully.',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
            
            updateCancelButton(false);
        }
    } catch (error) {
        console.error('Error cancelling execution:', error);
        Swal.fire({
            title: 'Error',
            text: 'Failed to cancel execution. Please try again.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    }
}

// Add click handler for cancel button
document.getElementById('cancelExecutionBtn').addEventListener('click', function() {
    const executionId = this.getAttribute('data-execution-id');
    if (executionId) {
        cancelExecution(executionId);
    }
});

function addUpdateToBoard(taskBoard, data) {
    
    const kanbanDrag = taskBoard.querySelector('.kanban-drag');
    if (!kanbanDrag) return;
    
    const stageId = `stage-${data.execution_id}-${Date.now()}`;
    const stage = data.stage || {};
    
    // Special handling for human input request - only when it's an actual input request, not just a status update
    if (stage.stage_type === 'human_input_request' && data.status === 'WAITING_FOR_HUMAN_INPUT') {
        const cardHtml = `
            <div class="card mb-2 border-0 shadow-none">
                <div class="card-body p-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="badge bg-gradient-${getStatusBadgeClass(stage.status)} text-xs">${stage.status || 'unknown'}</span>
                        <button class="btn btn-link text-dark p-0 expand-content" data-stage-id="${stageId}">
                            <i class="fas fa-expand-alt"></i>
                        </button>
                    </div>
                    <h6 class="text-sm mb-2">${stage.title || 'Human Input Required'}</h6>
                    <div class="content-preview text-sm mb-3">
                        ${stage.content || ''}
                    </div>
                    <div class="human-input-container">
                        <div class="form-group">
                            <textarea class="form-control" rows="3" placeholder="Enter your response here..."></textarea>
                            <button class="btn btn-primary btn-sm mt-2" onclick="handleHumanInputSubmit(this)">Submit</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Create card element
        const card = document.createElement('div');
        card.id = stageId;
        card.className = 'kanban-item stage-item';
        card.setAttribute('data-execution-id', data.execution_id);
        card.setAttribute('data-stage-id', stageId);
        card.innerHTML = cardHtml;
        console.log('Adding click listener to expand button')
        // Add click handler for expand button
        card.querySelector('.expand-content').addEventListener('click', (e) => {
            console.log('Expand button clicked');
            e.stopPropagation();
            contentExpander.expandContent(
                card,
                stage.title || 'Human Input Required',
                stage.content || '',
                {
                    Status: stage.status || 'unknown',
                    Agent: stage.agent || 'System',
                    'Stage Type': stage.stage_type || 'unknown',
                    Timestamp: getCurrentTime()
                }
            );
        });
        
        kanbanDrag.appendChild(card);
        return;
    }
    const contentPreview = stage.content ? window.md.render(stage.content) : '';
    
    const cardHtml = `
        <div class="card mb-2 border-0 shadow-none">
            <div class="card-body p-3">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="badge bg-gradient-${getStatusBadgeClass(stage.status)} text-xs">${stage.status || 'unknown'}</span>
                    <button class="btn btn-link text-dark p-0 expand-content" data-stage-id="${stageId}">
                        <i class="fas fa-expand-alt"></i>
                    </button>
                </div>
                <h6 class="text-sm mb-2">${stage.title || 'Untitled'}</h6>
                <div class="content-preview text-sm" style="max-height: 4.5em; overflow: hidden; position: relative;">
                    <div class="content-text markdown-content">${contentPreview}</div>
                    <div class="content-fade" style="position: absolute; bottom: 0; left: 0; right: 0; height: 20px; background: linear-gradient(transparent, white);"></div>
                </div>
            </div>
        </div>
    `;

    // Create card element
    const card = document.createElement('div');
    card.id = stageId;
    card.className = 'kanban-item';
    card.innerHTML = cardHtml;
    
    // Add click handler for expand button
    card.querySelector('.expand-content').addEventListener('click', (e) => {
        e.stopPropagation();
        contentExpander.expandContent(
            card,
            stage.title || 'Untitled',
            stage.content || '',
            {
                Status: stage.status || 'unknown',
                Agent: stage.agent || 'System',
                'Stage Type': stage.stage_type || 'unknown',
                Timestamp: getCurrentTime()
            }
        );
    });
    
    kanbanDrag.appendChild(card);
}

function showStartExecutionModal() {
    Swal.fire({
        title: 'Start Crew Execution',
        html: `
            <div class="text-start">
                <p>You are about to start a new crew execution.</p>
                ${!clientId ? '<p class="text-danger">Warning: No client selected. Please select a client first.</p>' : ''}
                <p>The crew will begin processing tasks in sequence.</p>
            </div>
        `,
        icon: 'info',
        showCancelButton: true,
        confirmButtonText: 'Start Execution',
        cancelButtonText: 'Cancel',
        customClass: {
            confirmButton: 'btn bg-gradient-success',
            cancelButton: 'btn bg-gradient-danger'
        },
        buttonsStyling: false
    }).then((result) => {
        if (result.isConfirmed) {
            startExecution();
        }
    });
}

function startExecution() {
    const csrfToken = getCsrfToken();
    
    if (!csrfToken) {
        Swal.fire({
            title: 'Error',
            text: 'CSRF token not found. Please refresh the page.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    if (!clientId) {
        Swal.fire({
            title: 'Error',
            text: 'No client selected. Please select a client first.',
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
        return;
    }

    // Clear all kanban boards
    const kanbanBoards = document.querySelectorAll('.kanban-board');
    kanbanBoards.forEach(board => {
        const kanbanDrag = board.querySelector('.kanban-drag');
        if (kanbanDrag) {
            kanbanDrag.innerHTML = '';
        }
    });

    // Reset execution number
    const executionSpan = document.getElementById('execution-number');
    if (executionSpan) {
        executionSpan.textContent = '';
    }

    fetch(`/agents/crew/${crewId}/start-execution/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken
        },
        body: JSON.stringify({
            client_id: clientId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            Swal.fire({
                title: 'Success',
                text: 'Execution started successfully',
                icon: 'success',
                customClass: {
                    confirmButton: 'btn bg-gradient-success'
                },
                buttonsStyling: false
            });
        } else {
            throw new Error(data.message || 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        Swal.fire({
            title: 'Error',
            text: 'Error starting execution: ' + error.message,
            icon: 'error',
            customClass: {
                confirmButton: 'btn bg-gradient-primary'
            },
            buttonsStyling: false
        });
    });
}

// Export functions that need to be globally accessible
window.showStartExecutionModal = showStartExecutionModal;
window.handleHumanInputSubmit = handleHumanInputSubmit;

================
File: apps/agents/static/agents/js/tool_tester.js
================
/**
 * Tool tester client handling
 * Handles client selection and attribute population for tool testing
 */

document.addEventListener('DOMContentLoaded', function() {
    // Initialize client dropdown if tool schema requires client-related fields
    initClientDropdown();
    
    // Set up form submission handling for client attributes
    const toolForm = document.getElementById('tool-test-form');
    const clientAttributesInput = document.getElementById('client-attributes');
    
    if (toolForm && clientAttributesInput) {
        toolForm.addEventListener('submit', function(e) {
            // Check if client attributes are needed but not provided
            if (hasClientRelatedProperties() && 
                (!clientAttributesInput.value || clientAttributesInput.value === '{}')) {
                
                const clientSelect = document.getElementById('client-select');
                if (clientSelect && clientSelect.value === '') {
                    e.preventDefault();
                    alert('Please select a client to populate required attributes.');
                    return false;
                }
            }
        });
    }
});

/**
 * Initialize the client dropdown
 * Fetches clients and sets up the dropdown
 */
function initClientDropdown() {
    // Wait for tool schema to be loaded
    const checkSchema = setInterval(() => {
        if (window.toolSchema) {
            clearInterval(checkSchema);
            
            // Check if the tool requires client-related fields
            if (hasClientRelatedProperties()) {
                // Show client selection container
                const clientSelectionContainer = document.getElementById('client-selection-container');
                if (clientSelectionContainer) {
                    clientSelectionContainer.style.display = 'block';
                }
                
                // Fetch clients for the dropdown
                fetchClients();
                
                // Set up client selection handling
                const clientSelect = document.getElementById('client-select');
                if (clientSelect) {
                    clientSelect.addEventListener('change', handleClientSelection);
                }
            }
        }
    }, 100);
}

/**
 * Check if the tool schema contains client-related properties
 * This includes properties like client_id, analytics_property_id, etc.
 */
function hasClientRelatedProperties() {
    if (!window.toolSchema || !window.toolSchema.properties) {
        return false;
    }
    
    const properties = window.toolSchema.properties;
    
    // List of known client-related property names
    const clientRelatedProps = [
        'client_id', 
        'analytics_property_id', 
        'analytics_credentials',
        'search_console_property_url',
        'search_console_credentials',
        'website_url',
        'client_name'
    ];
    
    // Check if any of the client-related properties are in the schema
    return clientRelatedProps.some(prop => prop in properties);
}

/**
 * Fetch clients from the server
 */
function fetchClients() {
    fetch('/agents/tools/clients/')
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(clients => {
            populateClientDropdown(clients);
        })
        .catch(error => {
            console.error('Error fetching clients:', error);
            const clientSelect = document.getElementById('client-select');
            if (clientSelect) {
                clientSelect.innerHTML = '<option value="">Failed to load clients</option>';
            }
        });
}

/**
 * Populate the client dropdown with fetched clients
 */
function populateClientDropdown(clients) {
    const clientSelect = document.getElementById('client-select');
    if (!clientSelect) return;
    
    clientSelect.innerHTML = '<option value="">-- Select a client --</option>';
    
    clients.forEach(client => {
        const option = document.createElement('option');
        option.value = client.id;
        option.textContent = client.name;
        if (client.website_url) {
            option.textContent += ` (${client.website_url})`;
        }
        clientSelect.appendChild(option);
    });
}

/**
 * Handle client selection
 * Fetches client attributes and populates form fields
 */
function handleClientSelection() {
    const clientSelect = document.getElementById('client-select');
    const clientId = clientSelect.value;
    const loadingIndicator = document.getElementById('loading-indicator');
    
    if (!clientId) {
        // Clear client attributes if no client is selected
        document.getElementById('client-attributes').value = '';
        return;
    }
    
    // Show loading indicator
    if (loadingIndicator) {
        loadingIndicator.style.display = 'block';
    }
    
    // Fetch client attributes
    fetch(`/agents/tools/client-attributes/${clientId}/`)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(attributes => {
            // Store client attributes in hidden input
            document.getElementById('client-attributes').value = JSON.stringify(attributes);
            
            // Auto-fill form fields with client attributes
            autoFillClientFields(attributes);
            
            // Hide loading indicator
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        })
        .catch(error => {
            console.error('Error fetching client attributes:', error);
            
            // Hide loading indicator
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            // Show error message
            alert('Failed to load client attributes. Please try again.');
        });
}

/**
 * Auto-fill form fields with client attributes
 */
function autoFillClientFields(attributes) {
    if (!window.toolSchema || !window.toolSchema.properties) return;
    
    const properties = window.toolSchema.properties;
    
    // Map of schema properties to client attribute keys
    const propertyMappings = {
        'client_id': 'client_id',
        'client_name': 'client_name',
        'website_url': 'website_url',
        'analytics_property_id': 'analytics_property_id',
        'analytics_credentials': 'analytics_credentials',
        'search_console_property_url': 'search_console_property_url',
        'search_console_credentials': 'search_console_credentials',
        'targeted_keywords': 'targeted_keywords'
    };
    
    // For each property in the schema, check if we have a matching attribute
    Object.keys(properties).forEach(propName => {
        if (propName in propertyMappings) {
            const attrName = propertyMappings[propName];
            const input = document.getElementById(propName);
            
            if (input && attributes[attrName] !== undefined) {
                const value = attributes[attrName];
                
                if (properties[propName].type === 'object' && typeof value === 'object') {
                    // For object types (like credentials), stringify the value
                    input.value = JSON.stringify(value, null, 2);
                } else {
                    // For other types, just set the value
                    input.value = value;
                }
                
                // Add highlighting effect to show auto-filled fields
                input.classList.add('autofilled');
                setTimeout(() => {
                    input.classList.remove('autofilled');
                }, 2000);
            }
        }
    });
}

================
File: apps/agents/tasks/callbacks/execution.py
================
import logging
import traceback
from crewai.agents.parser import AgentAction, AgentFinish
from apps.agents.models import CrewExecution, Task
from ..utils.logging import log_crew_message
from ..messaging.execution_bus import ExecutionMessageBus

logger = logging.getLogger(__name__)

class TaskCallback:
    def __init__(self, execution_id):
        self.execution_id = execution_id
        self.current_task_index = None
        self.current_agent_role = None
        self.message_bus = ExecutionMessageBus(execution_id)

    def __call__(self, task_output):
        """Handle task callback from CrewAI."""
        try:
            #logger.debug(f"TaskCallback called with task_output: {task_output}")
            #logger.debug(f"Current task index: {self.current_task_index}")
            logger.info(
                "Task executed - Name: %s, Description: %s",
                task_output.name or "Unnamed Task",
                task_output.description
            )
        
            execution = CrewExecution.objects.get(id=self.execution_id)
            
            # Get the task ID based on task index
            ordered_tasks = Task.objects.filter(
                crewtask__crew=execution.crew
            ).order_by('crewtask__order')
            
            if self.current_task_index is not None and self.current_task_index < len(ordered_tasks):
                crewai_task_id = ordered_tasks[self.current_task_index].id
                self.current_agent_role = ordered_tasks[self.current_task_index].agent.role
            else:
                crewai_task_id = None
            
            if task_output.raw:
                logger.debug(f"TaskCallback: processing task output with index: {self.current_task_index}")
                # Log to database
                log_crew_message(
                    execution=execution,
                    content=task_output.raw,
                    agent=self.current_agent_role,
                    crewai_task_id=crewai_task_id,
                    task_index=self.current_task_index
                )

        except Exception as e:
            logger.error(f"Error in task callback: {str(e)}")
            logger.error(f"Full traceback:\n{traceback.format_exc()}")
            raise

class StepCallback:
    def __init__(self, execution_id):
        self.execution_id = execution_id
        self.current_task_index = None
        self.current_agent_role = None
        self.message_bus = ExecutionMessageBus(execution_id)

    def __call__(self, step_output):
        """Handle step callback from CrewAI."""
        try:
            if isinstance(step_output, AgentFinish):
                #logger.debug(f"StepCallback: Skipping AgentFinish output for task index: {self.current_task_index}")
                #logger.debug(f"StepCallback: AgentFinish attributes: {vars(step_output)}")
                return
            else:
                #logger.debug(f"StepCallback: Processing step output for task index: {self.current_task_index}")
                #logger.debug(f"Step output: {step_output}")
                pass
            logger.debug("Received StepCallback")
            # Only process tool usage
            if isinstance(step_output, AgentAction):
                execution = CrewExecution.objects.get(id=self.execution_id)
                
                # Get the task ID based on task index
                ordered_tasks = Task.objects.filter(
                    crewtask__crew=execution.crew
                ).order_by('crewtask__order')
                
                if self.current_task_index is not None and self.current_task_index < len(ordered_tasks):
                    crewai_task_id = ordered_tasks[self.current_task_index].id
                    self.current_agent_role = ordered_tasks[self.current_task_index].agent.role
                else:
                    crewai_task_id = None

                # Log tool usage
                log_crew_message(
                    execution=execution,
                    content=f"Using tool: {step_output.tool}\nInput: {step_output.tool_input}",
                    agent=self.current_agent_role,
                    crewai_task_id=crewai_task_id,
                    task_index=self.current_task_index
                )
                
                if step_output.result:
                    # Log tool result
                    log_crew_message(
                        execution=execution,
                        content=f"Tool result: {step_output.result}",
                        agent=self.current_agent_role,
                        crewai_task_id=crewai_task_id,
                        task_index=self.current_task_index
                    )

        except Exception as e:
            logger.error(f"Error in step callback: {str(e)}")
            logger.error(f"Full traceback:\n{traceback.format_exc()}")
            raise

================
File: apps/agents/tasks/callbacks/tool.py
================
import logging
from apps.agents.tools.base_tool import ToolUsageError
from crewai.utilities.events import on
from apps.agents.models import CrewExecution
from ..utils.logging import log_crew_message

logger = logging.getLogger(__name__)

@on(ToolUsageError)
def tool_error_callback(source, event: ToolUsageError):
    """
    This callback is triggered whenever a tool encounters an error during execution.

    Args:
        source: The source of the event (likely the ToolUsage instance).
        event (ToolUsageError): The ToolUsageError event containing error details.
    """
    execution_id = source.task.execution_id  # Assuming you've stored execution_id in the Task
    execution = CrewExecution.objects.get(id=execution_id)
    agent_role = event.agent_role

    error_message = f"Tool '{event.tool_name}' failed for agent '{agent_role}'."
    error_message += f"\n Error: {event.error}"
    error_message += f"\n Tool Arguments: {event.tool_args}"
    error_message += f"\n Run Attempts: {event.run_attempts}"
    error_message += f"\n Delegations: {event.delegations}"
    
    log_crew_message(execution, error_message, agent='Tool Error Callback')
    logger.error(error_message)

================
File: apps/agents/tasks/core/agents.py
================
import logging
from functools import partial
import json
from crewai import Agent
from crewai.llm import LLM
from ..utils.tools import load_tool_in_task
from ..handlers.input import human_input_handler
from ..callbacks.execution import StepCallback
from apps.common.utils import get_llm

logger = logging.getLogger(__name__)

class ProxiedLLM(LLM):
    """Wrapper to make ChatOpenAI work with CrewAI"""
    def __init__(self, llm):
        self.llm = llm
        super().__init__(
            model=llm.model_name,
            temperature=llm.temperature,
        )
        
    def call(self, messages, *args, **kwargs):
        """
        Enhanced call method that safely handles various input formats and prevents errors
        from propagating to CrewAI's error handling code where they might cause the
        'ConverterError object is not subscriptable' issue.
        """
        if not messages:
            logger.error("Error in ProxiedLLM call: Empty or None messages provided")
            return "Error: No messages provided to the language model."
        
        try:
            # Log the original messages for debugging and log the last two messages 
            logger.debug(f"ProxiedLLM received {len(messages)} messages")
            #logger.debug(f"Last messages: {messages[-1:]}")
            
            # Create a deep copy of messages to avoid modifying the original
            sanitized_messages = []
            
            for message in messages:
                # If message isn't a dict, convert it to one
                if not isinstance(message, dict):
                    sanitized_message = {"role": "user", "content": str(message)}
                else:
                    sanitized_message = message.copy()
                
                # Handle content field specially
                if 'content' in sanitized_message:
                    content = sanitized_message['content']
                    
                    # Handle None content
                    if content is None:
                        sanitized_message['content'] = ""
                        sanitized_messages.append(sanitized_message)
                        continue
                    
                    # If content is already a string, keep it as is
                    if isinstance(content, str):
                        sanitized_messages.append(sanitized_message)
                        continue
                    
                    # Handle complex content types (lists, dicts, etc.)
                    try:
                        # Handle code interpreter special case
                        if isinstance(content, list) and len(content) > 0:
                            if isinstance(content[0], dict) and 'code' in content[0]:
                                # Create a simplified representation
                                code = content[0].get('code', '')
                                libraries = content[0].get('libraries_used', [])
                                simplified = {"code": code, "libraries_used": libraries}
                                sanitized_message['content'] = json.dumps(simplified)
                            else:
                                # Convert list to JSON string
                                sanitized_message['content'] = json.dumps(content)
                        elif isinstance(content, dict):
                            # Convert dict to JSON string
                            sanitized_message['content'] = json.dumps(content)
                        else:
                            # Convert any other type to string
                            sanitized_message['content'] = str(content)
                    except Exception as e:
                        # If all else fails, use string representation
                        logger.warning(f"Error serializing message content: {str(e)}")
                        sanitized_message['content'] = str(content)
                
                sanitized_messages.append(sanitized_message)
            
            # Log sanitized messages
            logger.debug(f"Processed {len(sanitized_messages)} messages for LLM")
            # log the first 200 chars of the latest message
            logger.debug(f"Last message: {sanitized_messages[-1]['content'][:200]}")
            # log the first 200 chars of the first message
            logger.debug(f"First message: {sanitized_messages[0]['content'][:200]}")
            
            # Invoke the LLM with the sanitized messages
            response = self.llm.invoke(sanitized_messages)
            # log the first 200 chars of the response
            logger.debug(f"Response: {response.content[:200]}")
            return response.content
        
        except Exception as e:
            # Detailed error logging but return a simple string response
            # This ensures we never propagate an exception object that could cause
            # the 'not subscriptable' error in CrewAI
            logger.error(f"Error in ProxiedLLM call: {str(e)}", exc_info=True)
            return f"Error processing request: {str(e)}"

def create_crewai_agents(agent_models, execution_id):
    agents = []
    for agent_model in agent_models:
        try:
            agent_params = {
                'role': agent_model.role,
                'goal': agent_model.goal,
                'backstory': agent_model.backstory,
                'verbose': agent_model.verbose,
                'allow_delegation': agent_model.allow_delegation,
                'step_callback': StepCallback(execution_id),
                'human_input_handler': partial(human_input_handler, execution_id=execution_id),
                'tools': [],
                'execution_id': execution_id
            }

            # Handle LLM fields for Agent
            llm_fields = ['llm', 'function_calling_llm']
            for field in llm_fields:
                value = getattr(agent_model, field)
                #logger.debug(f"LLM field: {field}, value: {value}")
                if value:
                    agent_llm, _ = get_llm(value)
                    #logger.debug(f"Agent LLM: {agent_llm}")
                    # Wrap the ChatOpenAI instance for CrewAI compatibility
                    agent_params[field] = ProxiedLLM(agent_llm)

            # Load tools with their settings
            for tool in agent_model.tools.all():
                loaded_tool = load_tool_in_task(tool)
                if loaded_tool:
                    # Get tool settings
                    tool_settings = agent_model.get_tool_settings(tool)
                    if tool_settings and tool_settings.force_output_as_result:
                        # Apply the force output setting
                        loaded_tool = type(loaded_tool)(
                            result_as_answer=True,
                            **{k: v for k, v in loaded_tool.__dict__.items() if k != 'result_as_answer'}
                        )
                    agent_params['tools'].append(loaded_tool)
                else:
                    logger.warning(f"Failed to load tool {tool.name} for agent {agent_model.name}")

            optional_params = ['max_iter', 'max_rpm', 'system_template', 'prompt_template', 'response_template']
            agent_params.update({param: getattr(agent_model, param) for param in optional_params if getattr(agent_model, param) is not None})
            
            agent = Agent(**agent_params)
            logger.debug(f"CrewAI Agent created successfully for agent id: {agent_model.id} with {len(agent_params['tools'])} tools")
            agents.append(agent)
        except Exception as e:
            logger.error(f"Error creating CrewAI Agent for agent {agent_model.id}: {str(e)}")
    return agents

================
File: apps/agents/tasks/core/crew.py
================
import logging
import traceback
from datetime import datetime
import re
import os
from functools import partial
from celery import shared_task
from django.conf import settings
from django.core.cache import cache
from crewai import Crew
from crewai.agents.agent_builder.base_agent_executor_mixin import CrewAgentExecutorMixin
from apps.agents.models import CrewExecution, ExecutionStage, CrewOutput, Task
from ..utils.logging import log_crew_message, update_execution_status
from .agents import create_crewai_agents
from .tasks import create_crewai_tasks
from ..callbacks.execution import StepCallback, TaskCallback
from ..handlers.input import human_input_handler
from apps.common.utils import get_llm
import time
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.shortcuts import get_object_or_404
from apps.seo_manager.models import Client
from apps.file_manager.storage import PathManager
from apps.organizations.utils import OrganizationContext
from contextlib import nullcontext
from django.utils import timezone

logger = logging.getLogger(__name__)

def clean_text(text, field_name):
    """Generic function to clean text by escaping JSON-like structures and removing problematic characters"""
    if not text:
        return text

    #logger.debug(f"Original {field_name}: {repr(text)}")

    try:
        # First remove any problematic whitespace/newline characters
        text = text.strip()

        # Handle the specific {{{{{ }}}}} format used in examples
        def escape_json_block(match):
            content = match.group(1)
            # Remove extra whitespace and newlines within the JSON
            content = ' '.join(content.split())
            return f"{{{{{{{{ {content} }}}}}}}}"

        # First pass: Handle the example blocks with multiple braces
        text = re.sub(r'{{{{{(.*?)}}}}}', escape_json_block, text, flags=re.DOTALL)

        # Second pass: Handle any remaining JSON-like structures
        def escape_json_block(match):
            content = match.group(1)
            # Remove extra whitespace and newlines within the JSON
            content = ' '.join(content.split())
            return f"{{{{ {content} }}}}"

        # Handle regular JSON blocks
        text = re.sub(r'(?<!{){([^{].*?)}(?!})', escape_json_block, text, flags=re.DOTALL)

        # Final pass: Escape any remaining single braces that might be format strings
        text = re.sub(r'(?<!{){(?!{)', '{{', text)
        text = re.sub(r'(?<!})}(?!})', '}}', text)

        #logger.debug(f"Cleaned {field_name}: {repr(text)}")
        return text

    except Exception as e:
        logger.error(f"Error cleaning ba{field_name}: {str(e)}")
        logger.error(f"Problematic {field_name}: {repr(text)}")
        # Return a safely escaped version as fallback
        return text.replace("{", "{{").replace("}", "}}")

def initialize_crew(execution):
    """Initialize a CrewAI crew instance from a CrewExecution object"""
    try:
        # Create regular agents (excluding manager)
        regular_agents = list(execution.crew.agents.all())
        #logger.debug(f"Regular agents: {regular_agents}")
        # Create CrewAI agents for regular agents
        agents = create_crewai_agents(regular_agents, execution.id)
        #logger.debug(f"Created CrewAI agents: {agents}")
        if not agents:
            raise ValueError("No valid agents created")
            
        # Create manager agent separately if it exists
        manager_agent = None
        if execution.crew.manager_agent:
            manager_agents = create_crewai_agents([execution.crew.manager_agent], execution.id)
            if manager_agents:
                manager_agent = manager_agents[0]
        
        # Fetch and order the tasks
        ordered_tasks = Task.objects.filter(
            crew=execution.crew
        ).order_by('crewtask__order')
        
        tasks = create_crewai_tasks(ordered_tasks, agents, execution)
        if not tasks:
            raise ValueError("No valid tasks for crew execution")

        # Handle LLM fields first
        llm_fields = ['manager_llm', 'function_calling_llm', 'planning_llm']
        llm_params = {}
        for field in llm_fields:
            value = getattr(execution.crew, field)
            if value:
                #logger.debug(f"Using LLM: {value}")
                crew_llm, _ = get_llm(value)
                llm_params[field] = crew_llm

        # Build crew parameters
        crew_params = {
            'agents': agents,
            'tasks': tasks,
            'step_callback': StepCallback(execution.id),
            'task_callback': TaskCallback(execution.id),
            'process': execution.crew.process,
            'verbose': execution.crew.verbose,
            'execution_id': str(execution.id),
            **llm_params  # Add LLM parameters
        }

        # Add manager agent if it exists
        if manager_agent:
            crew_params['manager_agent'] = manager_agent

        # Add optional parameters if they exist
        optional_params = [
            'memory', 'max_rpm', 'language', 'language_file', 'full_output',
            'share_crew', 'output_log_file', 'planning', 'manager_callbacks', 
            'prompt_file', 'cache', 'embedder'
        ]

        for param in optional_params:
            value = getattr(execution.crew, param, None)
            if value is not None:
                crew_params[param] = value

        # Create and return the crew instance
        # logger.debug(f"Creating Crew with parameters: {crew_params}")
        crew = Crew(**crew_params)
        
        if not crew:
            raise ValueError("Failed to create Crew instance")
            
        return crew
        
    except Exception as e:
        logger.error(f"Error in initialize_crew: {str(e)}")
        logger.error(f"Full traceback:\n{traceback.format_exc()}")
        raise

def get_client_data(client):
    """Helper function to get formatted client data with analytics credentials"""
    if not client:
        logger.warning("get_client_data called with None client")
        return {}
    
    # Format SEO projects into a readable string
    seo_projects_list = []
    for project in client.seo_projects.all().order_by('-implementation_date'):
        project_str = (
            f"Project: {project.title}\n"
            f"Description: {project.description}\n"
            f"Status: {project.status}\n"
            f"Implementation Date: {project.implementation_date.isoformat() if project.implementation_date else 'Not set'}\n"
            f"Completion Date: {project.completion_date.isoformat() if project.completion_date else 'Not set'}"
        )
        seo_projects_list.append(project_str)
    
    seo_projects_str = "\n\n".join(seo_projects_list) if seo_projects_list else ""
    
    client_data = {
        'client_id': client.id,
        'client_name': client.name,
        'client_website_url': client.website_url,
        'client_business_objectives': '\n'.join(str(obj) for obj in client.business_objectives) if client.business_objectives else '',
        'client_target_audience': client.target_audience,
        'client_profile': client.client_profile,
        'client_seo_projects': seo_projects_str,
    }
    
    # Add Google Analytics credentials if available
    try:
        if hasattr(client, 'ga_credentials') and client.ga_credentials:
            ga_creds = client.ga_credentials
            
            # Try to get property_id using get_property_id() method if available
            if hasattr(ga_creds, 'get_property_id') and callable(getattr(ga_creds, 'get_property_id')):
                try:
                    property_id = ga_creds.get_property_id()
                    client_data['analytics_property_id'] = str(property_id) if property_id is not None else ''
                    logger.debug(f"Got property_id '{property_id}' using get_property_id() method")
                except Exception as e:
                    logger.warning(f"Failed to get property_id using get_property_id() method: {e}")
                    client_data['analytics_property_id'] = ''
            else:
                # Fallback to direct attribute access
                client_data['analytics_property_id'] = getattr(ga_creds, 'property_id', '')
                
                # Fallback to view_id for older GA3 structure
                if not client_data['analytics_property_id'] and hasattr(ga_creds, 'view_id'):
                    client_data['analytics_property_id'] = getattr(ga_creds, 'view_id', '')
                    logger.debug(f"Using view_id as fallback for property_id")
            
            # Create actual credentials dictionary with real values
            client_data['analytics_credentials'] = {
                'ga_client_id': getattr(ga_creds, 'ga_client_id', ''),
                'client_secret': getattr(ga_creds, 'client_secret', ''), 
                'refresh_token': getattr(ga_creds, 'refresh_token', ''),
                'token_uri': getattr(ga_creds, 'token_uri', 'https://oauth2.googleapis.com/token'),
                'access_token': getattr(ga_creds, 'access_token', '')
            }
            
            # Log safely without exposing sensitive data
            logger.debug(f"Added Google Analytics credentials for client {client.name} (ID: {client.id})")
            
            # Add warning for missing critical fields
            missing_fields = []
            for field in ['ga_client_id', 'client_secret', 'refresh_token']:
                if not getattr(ga_creds, field, ''):
                    missing_fields.append(field)
            
            if missing_fields:
                logger.warning(f"Missing critical Analytics credential fields for client {client.name}: {', '.join(missing_fields)}")
        else:
            logger.debug(f"Client {client.name} (ID: {client.id}) has no Google Analytics credentials")
    except Exception as e:
        logger.error(f"Error adding Google Analytics credentials for client {client.name}: {str(e)}")
    
    # Add Search Console credentials if available
    try:
        if hasattr(client, 'sc_credentials') and client.sc_credentials:
            sc_creds = client.sc_credentials
            
            # Use the get_property_url method properly
            try:
                if hasattr(sc_creds, 'get_property_url') and callable(getattr(sc_creds, 'get_property_url')):
                    property_url = sc_creds.get_property_url()
                    client_data['search_console_property_url'] = property_url if property_url else ''
                    logger.debug(f"Got property_url using get_property_url() method")
                else:
                    # Fallback to direct attribute access
                    property_url = getattr(sc_creds, 'property_url', '') or getattr(sc_creds, 'property_id', '')
                    client_data['search_console_property_url'] = property_url
            except Exception as e:
                logger.error(f"Error calling get_property_url: {str(e)}")
                # Fallback to direct attribute access
                property_url = getattr(sc_creds, 'property_url', '') or getattr(sc_creds, 'property_id', '')
                client_data['search_console_property_url'] = property_url
            
            if not property_url:
                logger.warning(f"Client {client.name} has Search Console credentials but no valid property URL")
            
            # Create actual credentials dictionary with real values
            client_data['search_console_credentials'] = {
                'sc_client_id': getattr(sc_creds, 'sc_client_id', ''),
                'client_secret': getattr(sc_creds, 'client_secret', ''),
                'refresh_token': getattr(sc_creds, 'refresh_token', ''),
                'token_uri': getattr(sc_creds, 'token_uri', 'https://oauth2.googleapis.com/token'),
                'access_token': getattr(sc_creds, 'access_token', '')
            }
            
            # Log safely without exposing sensitive data
            logger.debug(f"Added Search Console credentials for client {client.name} (ID: {client.id})")
            
            # Add warning for missing critical fields
            missing_fields = []
            for field in ['sc_client_id', 'client_secret', 'refresh_token']:
                if not getattr(sc_creds, field, ''):
                    missing_fields.append(field)
            
            if missing_fields:
                logger.warning(f"Missing critical Search Console credential fields for client {client.name}: {', '.join(missing_fields)}")
        else:
            logger.debug(f"Client {client.name} (ID: {client.id}) has no Search Console credentials")
    except Exception as e:
        logger.error(f"Error adding Search Console credentials for client {client.name}: {str(e)}")
    
    # Log the available keys for debugging
    logger.debug(f"Client data keys available for crew: {', '.join(client_data.keys())}")
    
    return client_data

# Note: To use credentials in task descriptions, reference them like:
# "Task: Analyze traffic using Google Analytics credentials: {analytics_credentials} 
# and property ID: {analytics_property_id}, along with Search Console data using
# credentials: {search_console_credentials} and property URL: {search_console_property_url}"
#
# Example task description for CrewAI tasks:
# ```
# Task:
# Perform a comprehensive analysis of {client_name}'s website traffic patterns.
# 
# Details:
# - Current Date: {current_date}
# - Client Website: {client_website_url}
# - Client ID: {client_id}
# - Google Analytics Property ID: {analytics_property_id}
# - Search Console Property URL: {search_console_property_url}
# 
# Use the Google Analytics credentials and Search Console credentials provided below:
# 
# Google Analytics Credentials:
# {analytics_credentials}
# 
# Search Console Credentials:
# {search_console_credentials}
# 
# First, analyze traffic trends from Google Analytics. Then, examine keyword performance
# from Search Console. Finally, provide actionable recommendations based on your findings.
# ```
def run_crew(task_id, crew, execution):
    """Run the crew and handle the execution"""
    try:
        # Update to running status
        update_execution_status(execution, 'RUNNING')
        
        # Create execution stage for running
        ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_execution',
            title='Running Task',
            content=f'Executing tasks for crew {crew.name}',
            status='in_progress'
        )
        
        # Get crew inputs with all task-specific data
        inputs = {
            'execution_id': execution.id,
            'current_date': datetime.now().strftime("%Y-%m-%d"),
        }
        
        # Add conversation history if available
        conversation_history = execution.get_conversation_history()
        if conversation_history:
            # Convert conversation history to string if it's a list to avoid interpolation errors
            if isinstance(conversation_history, list):
                inputs['conversation_history'] = "\n".join([str(msg) for msg in conversation_history])
            else:
                inputs['conversation_history'] = str(conversation_history)
        
        # Only add client-specific inputs if client exists
        if execution.client:
            inputs.update(get_client_data(execution.client))
        
        # Create callback instances
        step_callback = StepCallback(execution.id)
        task_callback = TaskCallback(execution.id)
        
        # Monkey patch the crew's _execute_tasks method to track current task
        original_execute_tasks = crew._execute_tasks
        
        def execute_tasks_with_tracking(*args, **kwargs):
            task_outputs = []
            futures = []
            last_sync_output = None
            
            for task_index, task in enumerate(crew.tasks):
                #logger.debug(f"Starting task {task_index}")
                
                # Get the agent and continue with original logic
                agent_to_use = crew._get_agent_to_use(task)
                if not agent_to_use:
                    raise ValueError(f"No agent available for task: {task.description}")
                
                # Set current task index in callbacks BEFORE execution
                step_callback.current_task_index = task_index
                task_callback.current_task_index = task_index
                step_callback.current_agent_role = agent_to_use.role
                task_callback.current_agent_role = agent_to_use.role
                
                # Update execution status with current task index
                
                # Create or update agent executor with callbacks and human input handler
                if not agent_to_use.agent_executor:
                    logger.debug(f"Creating agent executor for {agent_to_use.role}")
                    logger.debug(f"Agent LLM before executor creation: {agent_to_use.llm}")
                    agent_to_use.create_agent_executor(tools=task.tools)
                    logger.debug(f"Agent executor created. Executor LLM: {agent_to_use.agent_executor.llm}")
                    
                agent_to_use.agent_executor.callbacks = [step_callback]
                # Patch the _ask_human_input method on the mixin class
                from crewai.agents.agent_builder.base_agent_executor_mixin import CrewAgentExecutorMixin
                CrewAgentExecutorMixin._ask_human_input = staticmethod(partial(human_input_handler, execution_id=execution.id))
                
                #logger.debug(f"Set task index to {task_index} before executing task with description: {task.description}")
                
                # Execute task
                try:
                    if task.async_execution:
                        context = crew._get_context(task, [last_sync_output] if last_sync_output else [])
                        future = task.execute_async(agent=agent_to_use, context=context)
                        futures.append((task, future, task_index))
                    else:
                        if futures:
                            task_outputs = crew._process_async_tasks(futures)
                            futures.clear()
                        
                        context = crew._get_context(task, task_outputs)
                        #logger.debug(f"Executing task {task_index} with agent {agent_to_use.role}")
                        
                        # If this is a human input task, add the input to context
                        if task.human_input:
                            input_key = f"execution_{execution.id}_task_{task_index}_input"
                            
                            # First execution to get the prompt
                            initial_output = task.execute_sync(agent=agent_to_use, context=context)
                            #logger.debug(f"Initial execution complete, waiting for human input")
                            
                            # Wait for human input
                            human_response = cache.get(input_key)
                            while not human_response:
                                time.sleep(1)
                                human_response = cache.get(input_key)
                            
                            logger.debug(f"Received human input: {human_response}")
                            
                            # Make sure context is a dictionary
                            if isinstance(context, str):
                                new_context = {'input': context}
                            elif context is None:
                                new_context = {}
                            else:
                                new_context = context.copy()
                                
                            # Add input to context and execute again
                            new_context['human_input'] = human_response
                            new_context['input'] = human_response
                            #logger.debug(f"Context for second execution: {new_context}")
                            
                            task_output = task.execute_sync(agent=agent_to_use, context=new_context)
                            logger.debug(f"Second execution complete with input")
                        else:
                            # Non-human input task
                            task_output = task.execute_sync(agent=agent_to_use, context=context)
                        #logger.debug(f"Task execution complete. Output: {task_output}")
                        task_outputs = [task_output]
                        last_sync_output = task_output
                        
                        #logger.debug(f"Completed task {task_index}")
                except Exception as e:
                    logger.error(f"Error executing task {task_index}: {str(e)}")
                    raise
            
            if futures:
                task_outputs = crew._process_async_tasks(futures)
            
            return crew._create_crew_output(task_outputs)
            
        # Replace the original _execute_tasks method
        crew._execute_tasks = execute_tasks_with_tracking
        
        # Set callbacks on crew
        crew.step_callback = step_callback
        crew.task_callback = task_callback
        
        for agent in crew.agents:
            if not hasattr(agent, 'backstory') or agent.backstory is None:
                logger.warning(f"Agent {agent.role} has no backstory!")
                continue

            try:
                # Store original backstory
                original_backstory = agent.backstory
                # Clean and update the backstory
                cleaned_backstory = clean_text(original_backstory,"backstory")
                agent.backstory = cleaned_backstory
                agent._original_backstory = cleaned_backstory  

            except Exception as e:
                logger.error(f"Error cleaning backstory for {agent.role}: {str(e)}")
                # Fallback to simple escaping if cleaning fails
                agent.backstory = original_backstory.replace("{", "{{").replace("}", "}}")
                agent._original_backstory = agent.backstory
                
        # Clean expected_output for each task
        for task in crew.tasks:
            if hasattr(task, 'expected_output') and task.expected_output:
                original_expected_output = task.expected_output
                cleaned_expected_output = clean_text(original_expected_output, "expected_output")
                task.expected_output = cleaned_expected_output
                # Store the original for reference if needed
                task._original_expected_output = cleaned_expected_output
                
        # Sanitize inputs
        sanitized_inputs = {}
        for k, v in inputs.items():
            # Handle string values
            if isinstance(v, str):
                sanitized_inputs[k] = v.strip()
            # For dictionary values, pass through directly
            elif isinstance(v, dict):
                # Keep the original data for the actual crew inputs without any redaction
                sanitized_inputs[k] = v
            # Keep other values as is
            else:
                sanitized_inputs[k] = v
                
        # Add some debugging information
        logger.debug(f"Prepared {len(sanitized_inputs)} input parameters for crew execution")
        logger.debug(f"Input keys: {', '.join(sanitized_inputs.keys())}")
        
        # Run the crew based on process type
        if execution.crew.process == 'sequential':
            logger.debug("Starting sequential crew execution")
            result = crew.kickoff(inputs=sanitized_inputs)
        elif execution.crew.process == 'hierarchical':
            logger.debug("Starting hierarchical crew execution")
            result = crew.kickoff(inputs=sanitized_inputs)
        elif execution.crew.process == 'for_each':
            logger.debug("Starting for_each crew execution")
            inputs_array = sanitized_inputs.get('inputs_array', [])
            result = crew.kickoff_for_each(inputs=inputs_array)
        elif execution.crew.process == 'async':
            logger.debug("Starting async crew execution")
            result = crew.kickoff_async(inputs=sanitized_inputs)
        elif execution.crew.process == 'for_each_async':
            logger.debug("Starting for_each_async crew execution")
            inputs_array = sanitized_inputs.get('inputs_array', [])
            result = crew.kickoff_for_each_async(inputs=inputs_array)
        else:
            raise ValueError(f"Unknown process type: {execution.crew.process}")
            
        # Create completion stage
        ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_completion',
            title='Execution Complete',
            content=f'Completed all tasks for crew {crew.name}',
            status='completed'
        )
        
        # Store result in CrewOutput
        crew_output = CrewOutput.objects.create(
            raw=str(result),
            json_dict=result if isinstance(result, dict) else None
        )
        
        # Update execution with output
        execution.crew_output = crew_output
        execution.save()
        logger.debug(f"Crew output: {result}")
        return result
        
    except Exception as e:
        # Create error stage
        ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_error',
            title='Execution Error',
            content=str(e),
            status='error'
        )
        raise 


def handle_execution_error(execution, exception, task_id=None):
    logger.error(f"Error during crew execution: {str(exception)}", exc_info=True)
    update_execution_status(execution, 'FAILED')
    error_message = f"Crew execution failed: {str(exception)}"
    log_crew_message(execution, error_message, agent=None)
    execution.error_message = error_message
    execution.save()

    # Print the full traceback to stdout
    print("Full traceback:")
    traceback.print_exc()

def save_result_to_file(execution, result):
    """
    Save crew execution result to cloud storage using PathManager.
    
    Args:
        execution: The execution instance
        result: The result to save
    """
    try:
        # Generate the file name with timestamp
        timestamp = datetime.now().strftime("%y-%m-%d-%H-%M")
        crew_name = execution.crew.name.replace(' ', '_')
        
        # Get client name if available, otherwise use a default
        client_name = 'no_client'
        if execution.client_id:
            try:
                client = Client.objects.get(id=execution.client_id)
                if client.status == 'active':  # Check if client is active
                    client_name = client.name.replace(' ', '_')
                    logger.info(f"Using client name: {client_name} for output file")
                else:
                    logger.warning(f"Client {client.name} is not active (status: {client.status})")
            except Client.DoesNotExist:
                logger.warning(f"Client with ID {execution.client_id} not found")
            
        file_name = f"{client_name}-finaloutput_{timestamp}.txt"
        
        # Create relative path for the file
        relative_path = os.path.join(
            'crew_runs',
            crew_name,
            file_name
        )
        
        # Initialize PathManager with user ID
        path_manager = PathManager(user_id=execution.user.id)
        
        # Convert content to string and create a ContentFile
        content = str(result)
        file_obj = ContentFile(content.encode('utf-8'))
        file_obj.name = file_name
        
        # Save the file using PathManager
        saved_path = path_manager.save_file(file_obj, relative_path)
        
        # Log the file creation
        log_message = f"Final output saved to: {saved_path}"
        log_crew_message(execution, log_message, agent="System")
        logger.info(log_message)
        
        return saved_path
        
    except Exception as e:
        error_message = f"Error saving crew result file: {str(e)}"
        logger.error(error_message)
        log_crew_message(execution, error_message, agent="System")
        raise

@shared_task(bind=True)
def execute_crew(self, execution_id, organization_id=None):
    """Execute a crew with the given execution ID"""
    try:
        # Set organization context if provided
        from apps.organizations.utils import OrganizationContext
        from contextlib import nullcontext
        
        # If organization_id is not provided, try to get it from the execution object first
        if not organization_id:
            try:
                # Use unfiltered_objects to avoid organization filtering when fetching initial object
                from apps.agents.models import CrewExecution
                execution_obj = CrewExecution.unfiltered_objects.get(id=execution_id)
                organization_id = execution_obj.organization_id
            except Exception as e:
                logger.warning(f"Could not determine organization for execution {execution_id}: {str(e)}")
        
        # Use organization context manager if we have an organization ID
        context_manager = OrganizationContext.organization_context(organization_id) if organization_id else nullcontext()
        
        with context_manager:
            execution = CrewExecution.objects.get(id=execution_id)
            #logger.debug(f"Attempting to start crew execution for id: {execution_id} (task_id: {self.request.id})")
            
            # Save the Celery task ID
            execution.task_id = self.request.id
            execution.save()
            
            # Create initial stage
            ExecutionStage.objects.create(
                execution=execution,
                stage_type='task_start',
                title='Starting Execution',
                content=f'Starting execution for crew: {execution.crew.name}',
                status='completed'
            )
            
            # Update execution status to PENDING with task_index 0
            update_execution_status(execution, 'PENDING', task_index=0)
            
            logger.debug(f"Starting crew execution for id: {execution_id} (task_id: {self.request.id})")
            
            # Initialize crew
            crew = initialize_crew(execution)
            if not crew:
                raise ValueError("Failed to initialize crew")
            
            # Run crew
            result = run_crew(self.request.id, crew, execution)
            
            # Save the result and update execution status to COMPLETED
            if result:
                #log_crew_message(execution, str(result), agent='System')
                save_result_to_file(execution, result)
                pass

            # Use the last task index when setting completed status
            last_task_index = len(crew.tasks) - 1 if crew and crew.tasks else None
            update_execution_status(execution, 'COMPLETED', task_index=last_task_index)
            
            return execution.id
            
    except Exception as e:
        logger.error(f"Error during crew execution: {str(e)}")
        if 'execution' in locals():
            handle_execution_error(execution, e, task_id=getattr(self, 'request', None) and self.request.id)
        logger.error(f"Full traceback:\n{traceback.format_exc()}")
        raise

================
File: apps/agents/tasks/core/tasks.py
================
import logging
import os
from datetime import datetime
from django.core.files.storage import default_storage
from django.conf import settings
from crewai import Task as CrewAITask
from apps.agents.models import Task, Agent
from ..utils.tools import load_tool_in_task
from ..utils.logging import log_crew_message
from crewai import Task

logger = logging.getLogger(__name__)

def create_crewai_tasks(task_models, agents, execution):
    tasks = []
    for task_model in task_models:
        try:
            # Get and log the agent model details
            agent_model = Agent.objects.get(id=task_model.agent_id)
            task_model.save()

            # Try to find matching agent
            crewai_agent = next((agent for agent in agents if agent.role == agent_model.role), None)
            
            if not crewai_agent:
                logger.warning(f"""
No matching CrewAI agent found for task {task_model.id}
Looking for role: {agent_model.role}
Available roles: {[agent.role for agent in agents]}
""")
                continue

            task_tools = []
            for tool_model in task_model.tools.all():
                tool = load_tool_in_task(tool_model)
                if tool:
                    task_tools.append(tool)

            human_input = bool(task_model.human_input) if task_model.human_input is not None else False
            task_dict = {
                'description': task_model.description,
                'agent': crewai_agent,
                'expected_output': task_model.expected_output,
                'async_execution': task_model.async_execution,
                'human_input': human_input,
                'tools': task_tools,
                'execution_id': execution.id
            }

            optional_fields = ['output_json', 'output_pydantic', 'converter_cls']
            task_dict.update({field: getattr(task_model, field) for field in optional_fields if getattr(task_model, field) is not None})

            # Handle output_file
            if task_model.output_file:
                try:
                    # Generate a unique file path
                    description_part = task_model.description[:20]  # First 20 chars of description
                    timestamp = datetime.now().strftime("%y-%m-%d-%H-%M")
                    
                    # Get the file name and extension
                    file_name, file_extension = os.path.splitext(task_model.output_file)
                    
                    # Create the relative path
                    relative_path = os.path.join(
                        str(execution.user.id),
                        description_part,
                        f"{file_name}_{timestamp}{file_extension}"
                    )

                    # Get the full URL for the file
                    full_url = default_storage.url(relative_path)
                    
                    logger.debug(f"Output file will be saved to: {relative_path}")
                    log_crew_message(execution, f"Task output will be saved to: {full_url}", agent='System')

                    task_dict['output_file'] = relative_path

                except Exception as e:
                    logger.error(f"Error setting up output file path: {str(e)}", exc_info=True)
                    # Continue without output file if there's an error
                    pass

            if task_model.human_input:
                logger.debug(f"Creating task with human input enabled: {task_model.description}")
                # Add specific configuration for human input tasks
                task_dict.update({
                    'require_human_input': True,
                    'process_human_input': True
                })

            tasks.append(CrewAITask(**task_dict))
            logger.debug(f"CrewAITask created successfully for task: {task_model.id}")
        except Exception as e:
            logger.error(f"Error creating CrewAITask for task {task_model.id}: {str(e)}", exc_info=True)
    return tasks 

def create_writing_task():
    return Task(
        description="Write content to specified file",
        expected_output="SUCCESS: File 'fluffy-1.0.txt' written to 1/fluffy-1.0.txt (Length: 175 chars)",  # Match tool's success format
        agent=writer_agent,
        tools=[FileWriterTool(result_as_answer=True)],  # Force direct tool output
        max_retries=1  # Prevent infinite loops
    )

================
File: apps/agents/tasks/handlers/input.py
================
import logging
import time
from django.core.cache import cache
from apps.agents.models import CrewExecution
from ..messaging.execution_bus import ExecutionMessageBus

logger = logging.getLogger(__name__)

def human_input_handler(prompt, execution_id):
    """Handle human input requests via websocket."""
    logger.debug(f"human_input_handler called with prompt: {prompt}, execution_id: {execution_id}")
    execution = CrewExecution.objects.get(id=execution_id)
    message_bus = ExecutionMessageBus(execution_id)
    
    # Get current task index from execution state
    current_task = getattr(human_input_handler, 'current_task_index', 0)
    
    # Use consistent cache key format
    input_key = f"execution_{execution_id}_task_{current_task}_input"
    logger.debug(f"Using cache key: {input_key}")
    
    # Clear any existing value for this key
    cache.delete(input_key)
    
    # Send the human input request
    message_bus.publish('human_input_request', {
        'human_input_request': prompt,
        'task_index': current_task,
        'context': {
            'execution_id': execution_id,
            'task_index': current_task
        }
    })
    
    # Wait for input
    max_wait_time = 3600  # 1 hour
    start_time = time.time()
    
    while time.time() - start_time < max_wait_time:
        response = cache.get(input_key)
        
        if response:
            logger.debug(f"Received human input: {response}")
            # Send status update
            # message_bus.publish('execution_update', {
            #     'status': 'RUNNING',
            #     'message': f"Received human input: {response}",
            #     'task_index': current_task
            # })
            return str(response)
            
        time.sleep(1)
    
    logger.warning("No human input received within timeout period")
    return "APPROVED."

================
File: apps/agents/tasks/messaging/execution_bus.py
================
import logging
from datetime import datetime
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from apps.agents.models import CrewExecution, ChatMessage

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

class ExecutionMessageBus:
    """Central message bus for crew execution events and websocket communication"""
    def __init__(self, execution_id):
        self.execution_id = execution_id
        self.execution = CrewExecution.objects.get(id=execution_id)

    def publish(self, event_type, data):
        """Publish event to all relevant interfaces"""
        try:
            #logger.debug(f"Publishing event {event_type} with data: {data}")
            
            # Special handling for human input requests
            if data.get('human_input_request'):
                self._send_to_groups('human_input_request', data)
                return
                
            if event_type == 'agent_action':
                self._handle_agent_action(data)
            elif event_type == 'agent_finish':
                self._handle_agent_finish(data)
            elif event_type == 'execution_update':
                self._handle_status_update(data)
        except Exception as e:
            logger.error(f"Error publishing event {event_type}: {str(e)}")

    def _send_to_groups(self, message_type, data):
        """Send message to all relevant websocket groups"""
        try:
            #logger.debug(f"Sending message to groups for execution {self.execution_id}")
            groups = []
            if self.execution.crew:
                groups.append(f'crew_{self.execution.crew.id}_kanban')
            if self.execution.conversation:
                groups.append(f'chat_{self.execution.conversation.session_id}')

            # Special handling for human input requests
            if data.get('human_input_request'):
                message = {
                    'type': 'human_input_request',
                    'execution_id': self.execution_id,
                    'prompt': data['human_input_request'],
                    'context': data.get('context', {}),
                    'task_index': data.get('task_index')
                }
            else:
                # Construct message with data first, then override with our fields
                message = {
                    **data,  # Base data first
                    'type': message_type,
                    'execution_id': self.execution_id,
                    'status': self.execution.status,
                    'task_index': data.get('task_index')  # Ensure task_index is last
                }

            #logger.debug(f"Sending message: {message}")

            for group in groups:
                try:
                    async_to_sync(channel_layer.group_send)(group, message)
                    #logger.debug(f"Sent message to group {group}")
                except Exception as e:
                    logger.error(f"Failed to send to group {group}: {str(e)}")

        except Exception as e:
            logger.error(f"Error in _send_to_groups: {str(e)}")

    def _handle_agent_action(self, data):
        message = {
            **data,  # Include all original data first
            'message': data['log'],
            'agent': data['agent_role'],
            'stage': {
                'stage_type': 'task_action',
                'title': 'Agent Action',
                'content': data['log'],
                'agent': data['agent_role'],
                'status': 'completed'
            }
        }
        
        self._send_to_groups('execution_update', message)
        
        if self.execution.conversation:
            self._store_chat_message(data['log'], data['agent_role'])

    def _handle_status_update(self, data):
        #logger.debug(f"Handling status update with task_index: {data.get('task_index')}")
        message = {
            **data,  # Include all original data first
            'message': data.get('message'),
            'stage': {
                'stage_type': 'status_update',
                'title': 'Status Update',
                'content': data.get('message') or f'Status changed to {data["status"]}',
                'status': data['status'].lower(),
                'agent': 'System'
            }
        }
        #logger.debug(f"Sending status update with task_index: {message.get('task_index')}")
        self._send_to_groups('execution_update', message)

    def _store_chat_message(self, content, agent_role):
        """Store message in chat history"""
        if self.execution.conversation:
            ChatMessage.objects.create(
                conversation=self.execution.conversation,
                content=content,
                is_agent=True,
                agent_role=agent_role
            )

================
File: apps/agents/tasks/utils/__init__.py
================
"""
Utility functions for agent tasks.
"""

from .logging import log_crew_message

__all__ = ['log_crew_message']

================
File: apps/agents/tasks/utils/context.py
================
from contextvars import ContextVar

current_task_id = ContextVar('current_task_id', default=None)

class TaskContext:
    def __init__(self, task_id):
        self.task_id = task_id
        self.token = None

    def __enter__(self):
        self.token = current_task_id.set(self.task_id)
        return self

    def __exit__(self, *args):
        current_task_id.reset(self.token)

================
File: apps/agents/tasks/utils/logging.py
================
import logging
import time
from datetime import datetime
from apps.agents.models import CrewExecution, ExecutionStage, CrewMessage, Task
from ..messaging.execution_bus import ExecutionMessageBus

logger = logging.getLogger(__name__)

def update_execution_status(execution, status, message=None, task_index=None):
    """Update execution status and notify all UIs"""
    try:
        execution.status = status
        execution.save()
        
        # Create execution stage
        if message:
            ExecutionStage.objects.create(
                execution=execution,
                stage_type='status_update',
                title=status,
                content=message,
                status=status.lower()
            )
        
        # Use message bus for notifications with consistent event type
        message_bus = ExecutionMessageBus(execution.id)
        message_bus.publish('execution_update', {
            'status': status,
            'message': message,
            'task_index': task_index
        })
        
    except Exception as e:
        logger.error(f"Error updating execution status: {str(e)}")

def log_crew_message(execution, content, agent=None, human_input_request=None, crewai_task_id=None, task_index=None):
    """Log crew message and send via websocket"""
    try:
        # Store message in database if there's content
        if content:
            CrewMessage.objects.create(
                execution=execution,
                content=content,
                agent=agent,
                crewai_task_id=crewai_task_id
            )
            #logger.debug(f"Stored message in database: {content[:100]}")
        else:
            logger.warning("Attempted to log an empty message, skipping database storage")

        # Send via message bus
        message_bus = ExecutionMessageBus(execution.id)
        message_bus.publish('execution_update', {
            'status': 'RUNNING',
            'message': content,
            'task_index': task_index,
            'stage': {
                'stage_type': 'agent_action',
                'title': 'Agent Action',
                'content': content,
                'status': 'in_progress',
                'agent': agent or 'System'
            }
        })

    except Exception as e:
        logger.error(f"Error in log_crew_message: {str(e)}")

================
File: apps/agents/tasks/utils/tools.py
================
import importlib
import logging
import sys
import functools
from crewai.tools import BaseTool as CrewAIBaseTool
from langchain.tools import BaseTool as LangChainBaseTool
from apps.agents.utils import get_tool_info
from pydantic import BaseModel
from typing import Any, Optional, Dict, List, Union, Callable, Type, Annotated

logger = logging.getLogger(__name__)

def load_tool_in_task(tool_model):
    """Load a tool from the database and return an instance ready for use with CrewAI.
    
    Since our BaseTool now inherits from CrewAI's BaseTool, we don't need any special adapters.
    """
    tool_info = get_tool_info(tool_model)
    
    try:
        print(f"Attempting to load tool: {tool_model.tool_class}.{tool_model.tool_subclass}", file=sys.stderr)
        logger.info(f"Attempting to load tool: {tool_model.tool_class}.{tool_model.tool_subclass}")
        
        module = importlib.import_module(tool_info['module_path'])
        tool_class = getattr(module, tool_info['class_name'])
        
        # Create the tool instance
        tool_instance = tool_class()
        
        # Special handling for known problematic tools
        if tool_model.tool_subclass == 'CodeInterpreterTool':
            # More robust error handling for CodeInterpreterTool
            logger.info("Adding enhanced error handling for CodeInterpreterTool")
            original_run = tool_instance._run
            
            def safe_run(*args, **kwargs):
                try:
                    # Handle the specific input pattern that causes errors
                    if len(args) > 0:
                        # Log the input for debugging
                        logger.debug(f"CodeInterpreterTool received: {str(args[0])[:100]}...")
                        
                        # Handle list input
                        if isinstance(args[0], list):
                            if len(args[0]) > 0 and isinstance(args[0][0], dict) and 'code' in args[0][0]:
                                code = args[0][0].get('code', '')
                                libraries = args[0][0].get('libraries_used', [])
                                return original_run(code=code, libraries_used=libraries)
                        
                        # Handle dictionary input
                        elif isinstance(args[0], dict) and 'code' in args[0]:
                            return original_run(code=args[0].get('code', ''), 
                                               libraries_used=args[0].get('libraries_used', []))
                    
                    # For other formats, pass through to the original method
                    return original_run(*args, **kwargs)
                except Exception as e:
                    logger.error(f"Error in CodeInterpreterTool: {str(e)}", exc_info=True)
                    return f"Error executing code: {str(e)}"
            
            # Replace the _run method with our safe version
            tool_instance._run = safe_run
        
        # For Google tools, just make sure they have proper name and description
        # No need for special adapters anymore since our tools now inherit from CrewAI BaseTool
        if tool_model.tool_subclass in ['GenericGoogleAnalyticsTool', 'GenericGoogleSearchConsoleTool', 'GoogleAnalyticsTool', 'GoogleSearchConsoleTool', 'GoogleOverviewTool', 'GoogleReportTool', 'GoogleRankingsTool']:
            logger.info(f"Using Google tool: {tool_model.tool_subclass}")
            
            # Make sure name and description are set properly
            if not hasattr(tool_instance, 'name') or not tool_instance.name:
                tool_instance.name = tool_model.name
            if not hasattr(tool_instance, 'description') or not tool_instance.description:
                tool_instance.description = tool_model.description
                
        # Return the tool instance directly
        return tool_instance
        
    except Exception as e:
        logger.error(f"Error loading tool {tool_model.tool_class}.{tool_model.tool_subclass}: {str(e)}", exc_info=True)
        print(f"Error loading tool {tool_model.tool_class}.{tool_model.tool_subclass}: {str(e)}", file=sys.stderr)
        
        # Create a minimal fallback tool
        try:
            # Create a simple fallback tool that inherits from CrewAI BaseTool
            class FallbackTool(CrewAIBaseTool):
                name = tool_model.name
                description = f"Fallback for {tool_model.name} that returns an error message"
                
                def _run(self, *args, **kwargs):
                    return f"The tool {self.name} could not be loaded properly: {str(e)}"
            
            return FallbackTool()
        except Exception as fallback_error:
            logger.error(f"Failed to create fallback tool: {str(fallback_error)}", exc_info=True)
            return None

================
File: apps/agents/tasks/__init__.py
================
from celery import shared_task
from .core.crew import execute_crew
from .tools import run_tool

__all__ = ['execute_crew', 'run_tool']

================
File: apps/agents/tasks/base.py
================
from celery import Task
from celery.utils.log import get_task_logger
from typing import Any, Dict, Optional

logger = get_task_logger(__name__)

class ProgressTask(Task):
    """Base task class that provides standardized progress reporting."""
    
    def update_progress(self, current: int, total: int, status: str = None, **kwargs) -> None:
        """
        Update task progress in a standardized way.
        
        Args:
            current: Current progress value
            total: Total expected value
            status: Status message
            **kwargs: Additional progress information
        """
        try:
            meta = {
                'current': current,
                'total': total,
                'progress_status': status,
                **kwargs
            }
            logger.debug(f"Updating task progress: {meta}")
            
            # Update state through standard Celery mechanism
            self.update_state(
                state='PROGRESS',
                meta=meta
            )
            
            # Force backend update to ensure persistence
            if hasattr(self, 'backend') and hasattr(self.backend, 'store_result'):
                try:
                    self.backend.store_result(
                        self.request.id,
                        meta,
                        'PROGRESS'
                    )
                except Exception as e:
                    logger.error(f"Failed to force progress update in backend: {e}")
        except Exception as e:
            logger.error(f"Failed to update progress: {e}")
    
    def before_start(self, task_id: str, args: Any, kwargs: Any) -> None:
        """Initialize progress tracking when task starts."""
        super().before_start(task_id, args, kwargs)
        self.update_progress(0, 100, "Task starting")

================
File: apps/agents/tasks/tools.py
================
from celery import shared_task
import asyncio
import logging
from ..utils import load_tool
from django.shortcuts import get_object_or_404
from ..models import Tool, ToolRun
import inspect
import json
import traceback
from apps.organizations.utils import OrganizationContext

logger = logging.getLogger(__name__)

@shared_task(bind=True)
def run_tool(self, tool_id: int, inputs: dict, organization_id: str):
    """Generic Celery task to run any tool"""
    try:
        # Load the tool
        tool = get_object_or_404(Tool, id=tool_id)
        tool_instance = load_tool(tool)
        
        if tool_instance is None:
            raise ValueError('Failed to load tool')

        # Create a tool run record
        tool_run = ToolRun.objects.create(
            tool=tool,
            status='STARTED',
            inputs=inputs
        )
        
        try:
            # Process inputs if tool has args_schema
            if hasattr(tool_instance, 'args_schema'):
                processed_inputs = {}
                for key, value in inputs.items():
                    if value != '':
                        try:
                            # Try to parse the string as JSON
                            parsed_value = json.loads(value)
                            processed_inputs[key] = parsed_value
                        except json.JSONDecodeError:
                            # If it's not valid JSON, use the raw value
                            processed_inputs[key] = value
                
                #logger.debug(f"Processed inputs before validation: {processed_inputs}")
                # Let Pydantic handle any type conversions
                validated_inputs = tool_instance.args_schema(**processed_inputs)
                inputs = validated_inputs.dict()
                
                # Get the signature of the _run method to only pass parameters it accepts
                sig = inspect.signature(tool_instance._run)
                # Filter inputs to only include parameters accepted by the _run method
                filtered_inputs = {}
                for param_name in sig.parameters:
                    if param_name in inputs:
                        filtered_inputs[param_name] = inputs[param_name]
                    
                #logger.debug(f"Filtered inputs to match method signature: {filtered_inputs}")
                inputs = filtered_inputs
            
            # Set organization context before running the tool
            with OrganizationContext.organization_context(organization_id):
                # logger.debug(f"Organization context set to: {organization_id}") # Removed log
                # Run the tool
                if inspect.iscoroutinefunction(tool_instance._run):
                    # Create event loop for async tools
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    try:
                        result = loop.run_until_complete(tool_instance._run(**inputs))
                    finally:
                        loop.close()
                else:
                    result = tool_instance._run(**inputs)
            
            # Update tool run record
            tool_run.status = 'SUCCESS'
            tool_run.result = result
            tool_run.save()
            
            return {
                'result': result,
                'error': None
            }
            
        except Exception as e:
            logger.error(f"Error running tool: {str(e)}\n{traceback.format_exc()}")
            tool_run.status = 'FAILURE'
            tool_run.error = str(e)
            tool_run.save()
            raise
            
    except Exception as e:
        logger.error(f"Error in run_tool task: {str(e)}\n{traceback.format_exc()}")
        raise

================
File: apps/agents/templates/agents/modals/details_modal.html
================
<!-- Details Modal -->
<div class="modal fade" id="detailsModal" tabindex="-1" aria-labelledby="detailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-xl">
        <div class="modal-content">
            <div class="modal-header bg-gradient-primary">
                <h5 class="modal-title text-white" id="detailsModalLabel">
                    <i class="fas fa-info-circle me-2"></i>Stage Details
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-3">  <!-- reduced padding from p-4 -->
                <div class="row">
                    <div class="col-12">  <!-- changed from col-md-6 -->
                        <div class="card card-plain">
                            <div class="card-header pb-0">
                                <h6 class="text-uppercase text-primary">Basic Information</h6>
                            </div>
                            <div class="card-body py-2">  <!-- reduced padding -->
                                <dl class="row mb-0">  <!-- added mb-0 to remove bottom margin -->
                                    <dt class="col-auto text-dark me-2">Status:</dt>  <!-- modified for inline -->
                                    <dd class="col-auto me-4"><span class="badge bg-gradient-info" id="modalStatus"></span></dd>
                                    <dt class="col-auto text-dark me-2">Stage Type:</dt>
                                    <dd class="col-auto me-4"><span class="badge bg-gradient-success" id="modalStageType"></span></dd>
                                    <dt class="col-auto text-dark me-2">Agent:</dt>
                                    <dd class="col-auto"><span class="badge bg-gradient-warning" id="modalAgent"></span></dd>
                                </dl>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="row mt-3">  <!-- reduced margin from mt-4 -->
                    <div class="col-12">
                        <div class="card card-plain">
                            <div class="card-header pb-0">
                                <h6 class="text-uppercase text-primary">Content</h6>
                            </div>
                            <div class="card-body">
                                <div class="bg-gray-100 border rounded p-3" style="max-height: 600px; overflow-y: auto;">  <!-- increased from 400px -->
                                    <div id="modalContent"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer bg-gray-100">
                <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn bg-gradient-primary">
                    <i class="fas fa-download me-2"></i>Export Details
                </button>
            </div>
        </div>
    </div>
</div>

================
File: apps/agents/templates/agents/modals/human_input_modal.html
================
<!-- Human Input Modal -->
<div class="modal fade" id="humanInputModal" tabindex="-1" role="dialog" aria-labelledby="humanInputModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="humanInputModalLabel">Provide Human Input</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="humanInputText">Input</label>
          <textarea class="form-control" id="humanInputText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="submitHumanInput()">Submit</button>
      </div>
    </div>
  </div>
</div>

================
File: apps/agents/templates/agents/modals/start_execution_modal.html
================
<!-- Start Execution Modal -->
<div class="modal fade" id="startExecutionModal" tabindex="-1" role="dialog" aria-labelledby="startExecutionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="startExecutionModalLabel">Start New Execution</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to start a new execution for this crew?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="startExecution()">Start Execution</button>
      </div>
    </div>
  </div>
</div>

================
File: apps/agents/templates/agents/agent_form.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load agent_filters %}

{% block title %} {% if agent %}Edit Agent{% else %}Add Agent{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if agent %}Edit Agent{% else %}Add Agent{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        {% if request.GET.next %}
                            <input type="hidden" name="next" value="{{ request.GET.next }}">
                        {% endif %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.name.errors %}has-error{% endif %}">
                                    <label for="{{ form.name.id_for_label }}" class="form-control-label">Name</label>
                                    {{ form.name }}
                                    {% if form.name.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.name.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group {% if form.role.errors %}has-error{% endif %}">
                                    <label for="{{ form.role.id_for_label }}" class="form-control-label">Role</label>
                                    {{ form.role }}
                                    {% if form.role.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.role.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.goal.errors %}has-error{% endif %}">
                                    <label for="{{ form.goal.id_for_label }}" class="form-control-label">Goal</label>
                                    {{ form.goal }}
                                    {% if form.goal.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.goal.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.backstory.errors %}has-error{% endif %}">
                                    <label for="{{ form.backstory.id_for_label }}" class="form-control-label">Backstory</label>
                                    {{ form.backstory }}
                                    {% if form.backstory.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.backstory.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.llm.errors %}has-error{% endif %}">
                                    <label for="{{ form.llm.id_for_label }}" class="form-control-label">Language Model</label>
                                    <select name="llm" id="{{ form.llm.id_for_label }}" class="form-select">
                                        {% for value, display in form.llm.field.choices %}
                                            <option value="{{ value }}" {% if value == form.llm.value %}selected{% endif %}>{{ display }}</option>
                                        {% endfor %}
                                    </select>
                                    {% if form.llm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group {% if form.function_calling_llm.errors %}has-error{% endif %}">
                                    <label for="{{ form.function_calling_llm.id_for_label }}" class="form-control-label">Function Calling LLM</label>
                                    <select name="function_calling_llm" id="{{ form.function_calling_llm.id_for_label }}" class="form-select">
                                        {% for value, display in form.function_calling_llm.field.choices %}
                                            <option value="{{ value }}" {% if value == form.function_calling_llm.value %}selected{% endif %}>{{ display }}</option>
                                        {% endfor %}
                                    </select>
                                    {% if form.function_calling_llm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.function_calling_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.tools.errors %}has-error{% endif %}">
                                    <label for="{{ form.tools.id_for_label }}" class="form-control-label">Tools</label>
                                    <div class="tool-selection">
                                        {% for tool in form.tools.field.queryset %}
                                        <div class="tool-option mb-2">
                                            <div class="d-flex align-items-center">
                                                <div class="form-check">
                                                    <input type="checkbox" 
                                                           name="tools" 
                                                           value="{{ tool.id }}" 
                                                           id="tool_{{ tool.id }}"
                                                           class="form-check-input tool-checkbox"
                                                           {% if tool.id|stringformat:"i" in form.tools.value|stringformat:"s" %}checked{% endif %}>
                                                    <label class="form-check-label" for="tool_{{ tool.id }}">{{ tool.name }}</label>
                                                </div>
                                                <div class="ms-3 form-check">
                                                    <input type="checkbox" 
                                                           name="force_tool_output_{{ tool.id }}" 
                                                           id="force_tool_{{ tool.id }}"
                                                           class="form-check-input"
                                                           {% if agent and agent|has_force_output_enabled:tool %}checked{% endif %}>
                                                    <label class="form-check-label" for="force_tool_{{ tool.id }}">
                                                        <small>Force Output as Result</small>
                                                        <i class="fas fa-info-circle" data-bs-toggle="tooltip" title="When checked, the tool's output will be used directly as the task result without agent modifications."></i>
                                                    </label>
                                                </div>
                                            </div>
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_iter.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_iter.id_for_label }}" class="form-control-label">Max Iterations</label>
                                    {{ form.max_iter }}
                                    {% if form.max_iter.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_iter.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_rpm.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_rpm.id_for_label }}" class="form-control-label">Max RPM</label>
                                    {{ form.max_rpm }}
                                    {% if form.max_rpm.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_rpm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group {% if form.max_execution_time.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_execution_time.id_for_label }}" class="form-control-label">Max Execution Time</label>
                                    {{ form.max_execution_time }}
                                    {% if form.max_execution_time.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_execution_time.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.verbose.errors %}has-error{% endif %}">
                                    {{ form.verbose }}
                                    <label class="form-check-label" for="{{ form.verbose.id_for_label }}">Verbose</label>
                                    {% if form.verbose.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.verbose.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.allow_delegation.errors %}has-error{% endif %}">
                                    {{ form.allow_delegation }}
                                    <label class="form-check-label" for="{{ form.allow_delegation.id_for_label }}">Allow Delegation</label>
                                    {% if form.allow_delegation.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.allow_delegation.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.cache.errors %}has-error{% endif %}">
                                    {{ form.cache }}
                                    <label class="form-check-label" for="{{ form.cache.id_for_label }}">Cache</label>
                                    {% if form.cache.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.cache.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.step_callback.errors %}has-error{% endif %}">
                                    <label for="{{ form.step_callback.id_for_label }}" class="form-control-label">Step Callback</label>
                                    {{ form.step_callback }}
                                    {% if form.step_callback.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.step_callback.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.system_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.system_template.id_for_label }}" class="form-control-label">System Template</label>
                                    {{ form.system_template }}
                                    {% if form.system_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.system_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.prompt_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.prompt_template.id_for_label }}" class="form-control-label">Prompt Template</label>
                                    {{ form.prompt_template }}
                                    {% if form.prompt_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.prompt_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group {% if form.response_template.errors %}has-error{% endif %}">
                                    <label for="{{ form.response_template.id_for_label }}" class="form-control-label">Response Template</label>
                                    {{ form.response_template }}
                                    {% if form.response_template.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.response_template.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.allow_code_execution.errors %}has-error{% endif %}">
                                    {{ form.allow_code_execution }}
                                    <label class="form-check-label" for="{{ form.allow_code_execution.id_for_label }}">Allow Code Execution</label>
                                    {% if form.allow_code_execution.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.allow_code_execution.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.use_system_prompt.errors %}has-error{% endif %}">
                                    {{ form.use_system_prompt }}
                                    <label class="form-check-label" for="{{ form.use_system_prompt.id_for_label }}">Use System Prompt</label>
                                    {% if form.use_system_prompt.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.use_system_prompt.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch {% if form.respect_context_window.errors %}has-error{% endif %}">
                                    {{ form.respect_context_window }}
                                    <label class="form-check-label" for="{{ form.respect_context_window.id_for_label }}">Respect Context Window</label>
                                    {% if form.respect_context_window.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.respect_context_window.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group {% if form.max_retry_limit.errors %}has-error{% endif %}">
                                    <label for="{{ form.max_retry_limit.id_for_label }}" class="form-control-label">Max Retry Limit</label>
                                    {{ form.max_retry_limit }}
                                    {% if form.max_retry_limit.errors %}
                                        <div class="invalid-feedback" style="display: block;">
                                            {{ form.max_retry_limit.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group {% if form.avatar.errors %}has-error{% endif %}">
                                    <label class="form-control-label">Avatar</label>
                                    <div class="avatar-selection">
                                        {% for choice in form.avatar.field.choices %}
                                        <div class="avatar-option">
                                            <input type="radio" name="{{ form.avatar.name }}" id="avatar_{{ forloop.counter }}" value="{{ choice.0 }}" {% if form.avatar.value == choice.0 %}checked{% endif %} class="avatar-input">
                                            <label for="avatar_{{ forloop.counter }}" class="avatar-label">
                                                <img src="{% static 'assets/img/'|add:choice.0 %}" alt="{{ choice.0 }}" class="avatar-image">
                                            </label>
                                        </div>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{{ request.GET.next|default:'/agents/manage/' }}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Agent</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>


{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<style>
    .avatar-selection {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
    }
    .avatar-option {
        position: relative;
    }
    .avatar-input {
        display: none;
    }
    .avatar-label {
        cursor: pointer;
        display: inline-block;
        padding: 2px;
        border-radius: 50%;
        transition: all 0.3s ease;
    }
    .avatar-image {
        width: 72px;
        height: 72px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid #fff;
        box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
        transition: all 0.15s ease;
    }
    .avatar-input:checked + .avatar-label .avatar-image {
        border-color: #5e72e4;
        box-shadow: 0 0 0 2px #5e72e4;
    }
    .avatar-input:checked + .avatar-label::after {
        content: '✓';
        position: absolute;
        top: -5px;
        right: -5px;
        background-color: #2dce89;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
    }
    .tool-selection {
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #ced4da;
        padding: 10px;
        border-radius: 4px;
    }
    .tool-selection label {
        display: block;
        margin-bottom: 5px;
    }
</style>
{% endblock extrastyle %}

{% block extra_js %}
{{ block.super }}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add 'form-control' class to all input, select, and textarea elements
        var formElements = document.querySelectorAll('input, select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        // Add 'form-select' class to select elements
        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        // Add 'form-check-input' class to checkbox inputs
        var checkboxInputs = document.querySelectorAll('input[type="checkbox"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Add click event for avatar selection
        var avatarInputs = document.querySelectorAll('.avatar-input');
        avatarInputs.forEach(function(input) {
            input.addEventListener('change', function() {
                document.querySelectorAll('.avatar-label').forEach(function(label) {
                    label.classList.remove('selected');
                });
                if (this.checked) {
                    this.nextElementSibling.classList.add('selected');
                }
            });
        });

        // Trigger change event on the checked avatar input to highlight it on page load
        var checkedAvatar = document.querySelector('.avatar-input:checked');
        if (checkedAvatar) {
            checkedAvatar.dispatchEvent(new Event('change'));
        }

        // Add form validation
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                event.preventDefault();
                alert('Please fill in all required fields.');
            }
        });
    });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/base_agents.html
================
{% extends "layouts/base.html" %}

{% block title %} CrewAI Agents {% endblock %}

{% block content %}

<div class="container-fluid">
    <div class="row">
        <div class="col-md-3">
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Agents</h5>
                    <a href="{% url 'agents:manage_agents' %}" class="text-muted">
                        <i class="fas fa-cog"></i>
                    </a>
                </div>
                <div class="card-body">
                    {% block agents_list %}{% endblock %}
                </div>
            </div>
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">Previous Tasks</h5>
                </div>
                <div class="card-body">
                    {% block previous_tasks %}{% endblock %}
                </div>
            </div>
        </div>
        <div class="col-md-9">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">CrewAI Execution</h5>
                </div>
                <div class="card-body">
                    {% block main_content %}{% endblock %}
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
    // Add any JavaScript specific to the agents app here
</script>
{% endblock extra_js %}

{% block extrastyle %}
<style>
    .card-header .fa-cog {
        font-size: 1.2em;
        transition: transform 0.3s ease;
    }
    .card-header .fa-cog:hover {
        transform: rotate(90deg);
    }
</style>
{% endblock extrastyle %}

================
File: apps/agents/templates/agents/chat.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
{% csrf_token %}
<div class="container-fluid py-4">
    <div class="row">
        <!-- Conversation List Sidebar -->
        <div class="col-md-3 order-2 order-md-1">
            <div class="card">
                <div class="card-header p-2">
                    <h6 class="mb-0">Conversations</h6>
                </div>
                <div class="card-body p-2" style="height: 75vh; overflow-y: auto;">
                    <div class="list-group list-group-flush" id="conversation-list">
                        {% for conv in conversations %}
                        <div class="position-relative mb-2">
                            <a href="{% url 'agents:chat' session_id=conv.session_id %}" 
                               class="list-group-item list-group-item-action border-radius-lg py-2 px-3 d-flex flex-column
                               {% if current_conversation and current_conversation.id == conv.id %}
                               bg-gradient-primary active
                               {% else %}
                               bg-transparent
                               {% endif %}">
                                <div class="d-flex justify-content-between align-items-center pe-4">
                                    <h6 class="mb-1 text-sm font-weight-bold {% if current_conversation and current_conversation.id == conv.id %}text-white{% else %}text-default{% endif %}">
                                        {{ conv.title|truncatechars:30 }}
                                    </h6>
                                    <small class="{% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-secondary{% endif %}">
                                        {{ conv.updated_at|date:"M d, Y" }}
                                    </small>
                                </div>
                                <div class="d-flex justify-content-between align-items-center">
                                    <small class="{% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-body{% endif %}">
                                        {% if conv.participant_type == 'crew' and conv.crew_execution %}
                                            {{ conv.crew_execution.crew.name }}
                                        {% else %}
                                            {% if conv.agent %}{{ conv.agent.name }}{% endif %}
                                        {% endif %}
                                        {% if conv.client %} - {{ conv.client.name }}{% endif %}
                                    </small>
                                </div>
                            </a>
                            <button type="button"
                                    class="btn btn-link position-absolute top-0 end-0 mt-2 me-1 p-1 z-index-3 {% if current_conversation and current_conversation.id == conv.id %}text-white opacity-8{% else %}text-danger{% endif %}"
                                    onclick="deleteConversation('{{ conv.session_id }}', event)"
                                    title="Delete conversation">
                                <i class="fas fa-trash-alt text-xs"></i>
                            </button>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="col-md-9 d-flex flex-column order-1 order-md-2">
            <div class="row g-2 mb-2">
                <div class="col-lg-2 col-md-6">
                    <div class="card mb-0">
                        <div class="card-body p-2 d-flex align-items-center justify-content-center">
                            <div class="d-inline-flex align-items-center gap-2">
                                <span class="connection-dot my-auto"></span>
                                <button id="new-chat-btn" class="btn btn-primary btn-sm my-auto" data-url="{% url 'agents:chat' %}">New Chat</button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-3 col-md-6">
                    <div class="card mb-0">
                        <div class="card-body p-2">
                            <div class="form-group mb-0">
                                <label for="agent-select" class="form-control-label">Select Agent or Crew</label>
                                <select class="form-control" id="agent-select" searchable="true">
                                    <optgroup label="Agents">
                                        {% for agent in agents %}
                                            <option value="{{ agent.id }}" 
                                                data-type="agent"
                                                data-avatar="{{ agent.avatar }}"
                                                data-name="{{ agent.name }}"
                                                {% if current_conversation and current_conversation.agent_id == agent.id %}selected{% endif %}>
                                                {{ agent.name }}
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                    <optgroup label="Crews">
                                        {% for crew in crews %}
                                            <option value="{{ crew.id }}"
                                                data-type="crew"
                                                data-name="{{ crew.name }}"
                                                {% if current_conversation and current_conversation.crew_execution and current_conversation.crew_execution.crew_id == crew.id %}selected{% endif %}>
                                                {{ crew.name }}
                                            </option>
                                        {% endfor %}
                                    </optgroup>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-4 col-md-6">
                    <div class="card mb-0">
                        <div class="card-body p-2">
                            <div class="form-group mb-0">
                                <label for="model-select" class="form-control-label">Select Model</label>
                                <select class="form-control" id="model-select" searchable="true">
                                    {% for model in models %}
                                        <option value="{{ model }}" {% if model == default_model %}selected{% endif %}>
                                            {{ model }}
                                        </option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-3 col-md-6">
                    <div class="card mb-0">
                        <div class="card-body p-2">
                            <div class="form-group mb-0">
                                <label for="client-select" class="form-control-label">Select Client</label>
                                <select class="form-control" id="client-select" searchable="true">
                                    <option value="">No Client</option>
                                    {% for client in clients %}
                                        <option value="{{ client.id }}" {% if current_conversation and current_conversation.client_id == client.id %}selected{% endif %}>
                                            {{ client.name }}
                                        </option>
                                    {% endfor %}
                                </select>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div class="card flex-grow-1 d-flex flex-column">
                <div class="card-header py-2 px-3">
                    <div class="row g-0 align-items-center">
                        <div class="col-md-6">
                            <div class="d-flex align-items-center">
                                <div class="avatar avatar-sm me-2" id="agent-avatar">
                                    <img src="{% static 'assets/img/team-3.jpg' %}" class="avatar-img rounded-circle" alt="AI">
                                </div>
                                <h6 class="mb-0 text-sm" id="agent-name">AI Assistant</h6>
                            </div>
                        </div>
                        <div class="col-md-6 d-flex justify-content-end align-items-center">
                            <button id="share-btn" class="btn btn-link text-secondary me-2 p-1" title="Export conversation">
                                <i class="fas fa-share-alt"></i>
                            </button>
                            <span class="badge bg-gradient-primary" id="selected-model">
                                {{ default_model }}
                            </span>
                        </div>
                    </div>
                </div>
                <div class="card-body p-2 flex-grow-1" 
                     id="chat-messages" 
                     data-session-id="{{ session_id }}"
                     {% if current_conversation %}data-conversation-id="{{ current_conversation.id }}"{% endif %}
                     style="overflow-y: auto;">
                    <!-- Messages will be inserted here by JavaScript -->
                </div>
                <div class="card-footer p-2">
                    <div class="row">
                        <div class="col">
                            <div class="input-group">
                                <textarea id="message-input" class="form-control" 
                                    placeholder="Type your message..." rows="1"
                                    style="resize: none;"></textarea>
                                <button class="btn btn-primary mb-0 px-4" id="send-message" style="min-width: 100px;">
                                    <i class="fas fa-paper-plane me-2"></i>Send
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css">
<link rel="stylesheet" href="{% static 'agents/css/chat.css' %}?v={% now 'U' %}">
{% endblock extrastyle %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/marked.min.js' %}?v={% now 'U' %}"></script>
<script src="{% static 'assets/js/plugins/autosize.min.js' %}?v={% now 'U' %}"></script>
<script src="{% static 'assets/js/plugins/highlight.min.js' %}?v={% now 'U' %}"></script>
<script src="{% static 'assets/js/plugins/datatables.js' %}?v={% now 'U' %}"></script>
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}?v={% now 'U' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>

<script>
    // Initialize chat configuration
    window.chatConfig = {
        sessionId: '{{ session_id }}',
        currentConversation: {% if current_conversation %}{{ current_conversation.id }}{% else %}null{% endif %},
        urls: {
            newChat: '{% url "agents:chat" %}',
            deleteConversation: '/agents/chat/{sessionId}/delete/',
            wsBase: `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws/chat/`
        },
        csrfToken: document.querySelector('[name=csrfmiddlewaretoken]').value,
        defaultModel: '{{ default_model }}'
    };
</script>

<script type="module">
    const appUrl = new URL("{% static 'agents/js/chat/app.js' %}", window.location.href);
    appUrl.searchParams.set('v', '{{ now|date:"YmdHis" }}');
    
    async function initializeApp() {
        const { ChatApp } = await import(appUrl.toString());
        const app = new ChatApp(window.chatConfig);
        app.initialize();
    }
    
    document.addEventListener('DOMContentLoaded', initializeApp);
</script>

<script>
    document.getElementById('new-chat-btn').addEventListener('click', function() {
        const url = this.dataset.url;
        // Update the model badge with the currently selected model
        const selectedModel = document.querySelector('#model-select').value;
        document.getElementById('selected-model').textContent = selectedModel;
        
        // Existing new chat initialization code...
    });

    // If you have a model selector dropdown, also update on change:
    document.querySelector('#model-select').addEventListener('change', function(e) {
        document.getElementById('selected-model').textContent = this.value;
    });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/confirm_delete.html
================
{% extends "layouts/base.html" %}

{% block title %} Confirm Delete {% endblock %}

{% block content %}
<div class="container-fluid">
    <h1 class="mb-4">Confirm Delete</h1>
    <p>Are you sure you want to delete the following {{ type }}?</p>
    <p><strong>{{ object }}</strong></p>
    <form method="post">
        {% csrf_token %}
        <button type="submit" class="btn btn-danger">Confirm Delete</button>
        <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-secondary">Cancel</a>
    </form>
</div>
{% endblock content %}

================
File: apps/agents/templates/agents/connection_test.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} WebSocket Connection Test {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>WebSocket Connection Test</h6>
        </div>
        <div class="card-body">
          <div id="status" class="alert alert-info">Initializing...</div>
          <button id="connect-btn" class="btn btn-primary mb-3">Connect to WebSocket</button>
          <button id="send-btn" class="btn btn-secondary mb-3" disabled>Send Test Message</button>
          <div id="log" class="bg-light p-3" style="height: 300px; overflow-y: auto;">
            <pre><code></code></pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    const statusDiv = document.getElementById('status');
    const logDiv = document.getElementById('log');
    const connectBtn = document.getElementById('connect-btn');
    const sendBtn = document.getElementById('send-btn');
    let socket = null;

    function log(message) {
      const logContent = logDiv.querySelector('code');
      logContent.innerHTML += message + '\n';
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function connect() {
      log('Attempting to connect...');
      
      const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsPath = `${wsScheme}${window.location.host}/ws/connection_test/`;
      
      log(`Connecting to: ${wsPath}`);
      
      socket = new WebSocket(wsPath);

      socket.onopen = function(e) {
        log('WebSocket connection established');
        statusDiv.textContent = 'Connected';
        statusDiv.className = 'alert alert-success';
        connectBtn.disabled = true;
        sendBtn.disabled = false;
      };

      socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        if (data.error) {
          log(`Error: ${data.error}`);
        } else {
          log(`Received message: ${data.message}`);
        }
      };

      socket.onclose = function(event) {
        if (event.wasClean) {
          log(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);
        } else {
          log('Connection died');
        }
        statusDiv.textContent = 'Disconnected';
        statusDiv.className = 'alert alert-danger';
        connectBtn.disabled = false;
        sendBtn.disabled = true;
      };

      socket.onerror = function(error) {
        log(`WebSocket Error: ${error.message}`);
        console.error('WebSocket Error:', error);
        statusDiv.textContent = 'Error occurred';
        statusDiv.className = 'alert alert-danger';
      };
    }

    connectBtn.onclick = connect;

    sendBtn.onclick = function() {
      if (socket && socket.readyState === WebSocket.OPEN) {
        const message = 'Test message from client';
        socket.send(JSON.stringify({ message: message }));
        log(`Sent message: ${message}`);
      } else {
        log('WebSocket is not connected');
      }
    };
  });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/crew_detail.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Detail {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-lg-8 col-md-12">
      <!-- Existing crew details card -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between">
            <h6 class="mb-0">{{ crew.name }}</h6>
          </div>
          <p class="text-sm mb-0">{{ crew.description }}</p>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder">Process</h6>
              <p class="text-sm mb-3">{{ crew.get_process_display }}</p>
            </div>
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder">Verbose</h6>
              <p class="text-sm mb-3">{{ crew.verbose|yesno:"Yes,No" }}</p>
            </div>
          </div>
          <hr class="horizontal dark">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Agents</h6>
              <ul class="list-group">
                {% for agent in crew.agents.all %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">
                  <strong class="text-dark">{{ agent.name }}</strong> &nbsp;|&nbsp; {{ agent.role }}
                </li>
                {% empty %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">No agents assigned to this crew.</li>
                {% endfor %}
              </ul>
            </div>
            <div class="col-md-6">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Tasks</h6>
              <ul class="list-group">
                {% for task in crew.tasks.all %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">{{ task.description|slice:":250" }}</li>
                {% empty %}
                <li class="list-group-item border-0 ps-0 pt-0 text-sm">No tasks assigned to this crew.</li>
                {% endfor %}
              </ul>
            </div>
          </div>
        </div>
      </div>

      <!-- Modify the "Start New Execution" card -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6 class="mb-0">Start New Execution for {{ crew.name }}</h6>
          {% if selected_client %}
            <p class="text-sm mb-0">Selected Client: {{ selected_client.name }}</p>
            <p class="text-sm mb-0">Selected Client URL: {{ selected_client.website_url }}</p>
          {% else %}
            <p class="text-sm mb-0">No client selected</p>
          {% endif %}
        </div>
        <div class="card-body">
          <form method="post" id="crew-execution-form">
            {% csrf_token %}
            {% for field in form %}
              {% if field.name != 'crew' %}
                <div class="form-group">
                  <label for="{{ field.id_for_label }}" class="form-control-label">{{ field.label }}</label>
                  {% if field.field.widget.input_type == 'textarea' %}
                    <textarea class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}" rows="4">{{ field.value|default:'' }}</textarea>
                  {% elif field.field.widget.input_type == 'select' %}
                    <select class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}">
                      {% for choice in field.field.choices %}
                        <option value="{{ choice.0 }}" {% if choice.0 == field.value %}selected{% endif %}>{{ choice.1 }}</option>
                      {% endfor %}
                    </select>
                  {% else %}
                    <input type="{{ field.field.widget.input_type }}" class="form-control" id="{{ field.id_for_label }}" name="{{ field.name }}" value="{{ field.value|default:'' }}">
                  {% endif %}
                  {% if field.help_text %}
                    <small class="form-text text-muted">{{ field.help_text }}</small>
                  {% endif %}
                  {% for error in field.errors %}
                    <div class="invalid-feedback d-block">{{ error }}</div>
                  {% endfor %}
                </div>
              {% endif %}
            {% endfor %}

            <!-- Add dynamic input fields based on crew.input_variables -->
            {% if crew.input_variables %}
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mt-4 mb-3">Input Variables</h6>
              {% for variable in crew.input_variables %}
                <div class="form-group">
                  <label for="input_{{ variable }}" class="form-control-label">{{ variable|title }}</label>
                  <input type="text" class="form-control" id="input_{{ variable }}" name="input_variables[{{ variable }}]" required>
                </div>
              {% endfor %}
            {% endif %}

            <button type="submit" class="btn btn-primary mt-3" id="submit-btn">Start Execution</button>
          </form>
        </div>
      </div>
      <!-- New card for real-time updates -->
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Real-time Execution Updates</h6>
          <p class="text-sm">
            <i class="fa fa-clock me-1"></i>
            Status: <span id="execution-status" class="badge bg-gradient-info">No active execution</span>
          </p>
        </div>
        <div class="card-body p-3">
          <!-- Human input section -->
          <div id="human-input-section" style="display: none; margin-bottom: 20px;">
            <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Human Input Required</h6>
            <div id="human-input-prompt" class="text-sm mb-2"></div>
            <textarea id="human-input-response" class="form-control mb-3" rows="3"></textarea>
            <button id="submit-human-input" class="btn btn-primary">Submit Input</button>
          </div>

          <!-- Messages container with timeline styling -->
          <div class="messages-container" style="width: 100%; padding-left: 45px; position: relative;">
            <!-- Timeline vertical line -->
            <div style="position: absolute; left: 16px; top: 0; bottom: 0; width: 2px; background-color: #dee2e6;"></div>
            
            <div id="execution-messages">
              <!-- Messages will be dynamically inserted here -->
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-4 col-md-12 mt-4 mt-lg-0">
      <div class="card h-100">
        <div class="card-header pb-0">
          <h6 class="mb-0">Recent Executions</h6>
        </div>
        <div class="card-body p-3">
          <div class="timeline timeline-one-side">
            {% for execution in recent_executions %}
            <div class="timeline-block mb-3">
              <span class="timeline-step">
                <i class="ni ni-bell-55 text-{% if execution.status == 'COMPLETED' %}success{% elif execution.status == 'FAILED' %}danger{% else %}warning{% endif %}"></i>
              </span>
              <div class="timeline-content">
                <h6 class="text-dark text-sm font-weight-bold mb-0">{{ execution.get_status_display }}</h6>
                <p class="text-secondary font-weight-bold text-xs mt-1 mb-0">{{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}</p>
                <p class="text-sm mt-3 mb-2">
                  <a href="{% url 'agents:execution_detail' execution.id %}" class="text-primary">View Details</a>
                </p>
              </div>
            </div>
            {% empty %}
            <p class="text-sm mb-0">No previous executions for this crew.</p>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<!-- Human Input Modal -->
<div class="modal fade" id="human-input-modal" tabindex="-1" role="dialog" aria-labelledby="human-input-modal-label" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="human-input-modal-label">Human Input Required</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="human-input-prompt" class="form-control-label">Prompt:</label>
          <p id="human-input-prompt" class="text-sm mb-3"></p>
          <label for="human-input-response" class="form-control-label">Your Response:</label>
          <textarea class="form-control" id="human-input-response" rows="4"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="submit-human-input">Submit</button>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  $(function () {
    let socket = null;
    let activeExecutionId = null;

    $('#crew-execution-form').on('submit', function(e) {
      e.preventDefault();
      var form = $(this);
      var url = form.attr('action');
      
      // Serialize the form data, including the dynamic input variables
      var formData = form.serializeArray();
      var inputVariables = {};
      formData.forEach(function(item) {
        if (item.name.startsWith('input_variables[')) {
          var key = item.name.match(/\[(.*?)\]/)[1];
          inputVariables[key] = item.value;
        }
      });
      
      // Add the input_variables to the form data
      formData.push({name: 'input_variables', value: JSON.stringify(inputVariables)});
      
      $.ajax({
        type: "POST",
        url: url,
        data: $.param(formData),
        success: function(data) {
          activeExecutionId = data.execution_id;
          connectWebSocket(activeExecutionId);
          $('#execution-status').text('Execution started');
          $('#execution-messages').empty();
        },
        error: function(xhr, status, error) {
          var errorMessage = xhr.status + ': ' + xhr.statusText;
          alert('Error - ' + errorMessage);
        }
      });
    });

    function connectWebSocket(executionId) {
      const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
      const wsPath = `${wsScheme}${window.location.host}/ws/crew_execution/${executionId}/`;
      
      socket = new WebSocket(wsPath);

      socket.onopen = function(e) {
        console.log('WebSocket connection established');
      };

      socket.onmessage = function(event) {
        const data = JSON.parse(event.data);
        handleWebSocketMessage(data);
      };

      socket.onclose = function(event) {
        console.log('WebSocket connection closed');
      };

      socket.onerror = function(error) {
        console.error('WebSocket Error:', error);
      };
    }

    function handleWebSocketMessage(data) {
      if (data.status) {
        let statusClass = 'info';
        if (data.status === 'COMPLETED') statusClass = 'success';
        else if (data.status === 'FAILED') statusClass = 'danger';
        else if (data.status === 'WAITING_FOR_HUMAN_INPUT') statusClass = 'warning';
        
        $('#execution-status').removeClass().addClass(`badge bg-gradient-${statusClass}`).text(data.status);
      }
      
      if (data.messages && data.messages.length > 0) {
        data.messages.forEach(msg => {
          const timestamp = new Date().toLocaleString();
          const messageHtml = `
            <div class="message-block">
              <span class="timeline-step">
                <i class="ni ${msg.agent ? 'ni-spaceship text-primary' : 'ni-bell-55 text-success'} text-gradient"></i>
              </span>
              <div class="message-content">
                <div class="d-flex justify-content-between">
                  <h6 class="text-dark text-sm font-weight-bold mb-0">${msg.agent || 'System Message'}</h6>
                  <p class="text-secondary font-weight-bold text-xs mt-1 mb-0">${timestamp}</p>
                </div>
                <div class="message-content">
                  <div class="text-sm mt-2 mb-0 message-preview">
                    ${msg.content.substring(0, 150)}${msg.content.length > 150 ? '...' : ''}
                  </div>
                  <div class="message-full collapse">
                    <div class="text-sm mt-2 mb-0">
                      ${msg.content}
                    </div>
                  </div>
                  ${msg.content.length > 150 ? `
                    <a href="javascript:;" class="text-xs text-primary toggle-message">Show more</a>
                  ` : ''}
                </div>
              </div>
            </div>
          `;
          $('#execution-messages').append(messageHtml);
        });
        
        // Scroll to the bottom of the messages container
        const messagesContainer = document.querySelector('.messages-container');
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      if (data.human_input_request) {
        showHumanInputPrompt(data.human_input_request);
      } else if (data.status !== 'WAITING_FOR_HUMAN_INPUT') {
        $('#human-input-section').hide();
      }

      if (data.status === 'COMPLETED' || data.status === 'FAILED') {
        socket.close();
        activeExecutionId = null;
      }
    }

    function showHumanInputPrompt(prompt) {
      $('#human-input-prompt').text(prompt);
      $('#human-input-section').show();
      $('#human-input-response').focus();
    }

    // Update this event listener
    $(document).on('click', '#submit-human-input', function() {
    let userInput = $('#human-input-response').val();
    let inputKey = `human_input_request_${activeExecutionId}`;
    
    $.ajax({
        type: "POST",
        url: `/agents/execution/${activeExecutionId}/submit_human_input/`,
        data: {
            input_key: inputKey,
            response: userInput
        },
        headers: {
            "X-CSRFToken": getCookie("csrftoken")
        },
        success: function(data) {
            $('#human-input-section').hide();
            $('#human-input-response').val('');
            
            // Scroll to the bottom of the messages container
            const messagesContainer = document.getElementById('execution-messages-container');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        },
        error: function(xhr, status, error) {
            console.error('Error submitting human input:', error);
            alert('Error submitting input. Please try again.');
        }
    });
});
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }

    // Add this event handler for the show more/less functionality
    $(document).on('click', '.toggle-message', function(e) {
      e.preventDefault();
      const messageContent = $(this).closest('.message-content');
      const preview = messageContent.find('.message-preview');
      const full = messageContent.find('.message-full');
      
      if (full.hasClass('show')) {
        full.collapse('hide');
        preview.show();
        $(this).text('Show more');
      } else {
        full.collapse('show');
        preview.hide();
        $(this).text('Show less');
      }
    });
  });
</script>
{% endblock extra_js %}

{% block extrastyle %}
{{ block.super }}
<style>
  .message-block {
    position: relative;
    margin-bottom: 1.5rem;
    width: 100%;
  }

  .timeline-step {
    position: absolute;
    left: -29px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid #dee2e6;
  }

  .message-content {
    width: 100%;
  }

  .message-preview {
    display: block !important; /* Override the previous -webkit-box display */
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  .message-full {
    margin-top: 0.5rem;
    display: none; /* Hide by default */
  }

  .message-full.show {
    display: block;
  }

  .messages-container {
    max-height: 600px;
    overflow-y: auto;
  }

  /* Add styles for code blocks within messages */
  .message-content pre {
    background-color: #f8f9fa;
    padding: 1rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-size: 0.875em;
  }

  .message-content code {
    font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
</style>
{% endblock extrastyle %}

================
File: apps/agents/templates/agents/crew_form.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} {% if crew %}Edit Crew{% else %}Add Crew{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if crew %}Edit Crew{% else %}Add Crew{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post" id="crew-form">
                        {% csrf_token %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.name.id_for_label }}" class="form-control-label">Name</label>
                                    {{ form.name }}
                                    {% if form.name.errors %}
                                        <div class="text-danger">
                                            {{ form.name.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.agents.id_for_label }}" class="form-control-label">Agents</label>
                                    {{ form.agents }}
                                    {% if form.agents.errors %}
                                        <div class="text-danger">
                                            {{ form.agents.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="{{ form.tasks.id_for_label }}" class="form-control-label">Tasks</label>
                                    {{ form.tasks }}
                                    {% if form.tasks.errors %}
                                        <div class="text-danger">
                                            {{ form.tasks.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label class="form-control-label">Task Order</label>
                                    <ul id="task-order-list" class="list-group">
                                        {% for crew_task in crew.crew_tasks.all %}
                                            <li class="list-group-item" data-task-id="{{ crew_task.task.id }}">
                                                <span class="badge bg-primary me-2">{{ forloop.counter }}</span>
                                                {{ crew_task.task.description }}
                                                <input type="hidden" name="task_order[]" value="{{ crew_task.task.id }}">
                                            </li>
                                        {% endfor %}
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.process.id_for_label }}" class="form-control-label">Process</label>
                                    {{ form.process }}
                                    {% if form.process.errors %}
                                        <div class="text-danger">
                                            {{ form.process.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_llm.id_for_label }}" class="form-control-label">Manager LLM</label>
                                    {{ form.manager_llm }}
                                    {% if form.manager_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.function_calling_llm.id_for_label }}" class="form-control-label">Function Calling LLM</label>
                                    {{ form.function_calling_llm }}
                                    {% if form.function_calling_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.function_calling_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.config.id_for_label }}" class="form-control-label">Config</label>
                                    {{ form.config }}
                                    {% if form.config.errors %}
                                        <div class="text-danger">
                                            {{ form.config.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.max_rpm.id_for_label }}" class="form-control-label">Max RPM</label>
                                    {{ form.max_rpm }}
                                    {% if form.max_rpm.errors %}
                                        <div class="text-danger">
                                            {{ form.max_rpm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.language.id_for_label }}" class="form-control-label">Language</label>
                                    {{ form.language }}
                                    {% if form.language.errors %}
                                        <div class="text-danger">
                                            {{ form.language.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.language_file.id_for_label }}" class="form-control-label">Language File</label>
                                    {{ form.language_file }}
                                    {% if form.language_file.errors %}
                                        <div class="text-danger">
                                            {{ form.language_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.embedder.id_for_label }}" class="form-control-label">Embedder</label>
                                    {{ form.embedder }}
                                    {% if form.embedder.errors %}
                                        <div class="text-danger">
                                            {{ form.embedder.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.output_log_file.id_for_label }}" class="form-control-label">Output Log File</label>
                                    {{ form.output_log_file }}
                                    {% if form.output_log_file.errors %}
                                        <div class="text-danger">
                                            {{ form.output_log_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_agent.id_for_label }}" class="form-control-label">Manager Agent</label>
                                    {{ form.manager_agent }}
                                    {% if form.manager_agent.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_agent.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.manager_callbacks.id_for_label }}" class="form-control-label">Manager Callbacks</label>
                                    {{ form.manager_callbacks }}
                                    {% if form.manager_callbacks.errors %}
                                        <div class="text-danger">
                                            {{ form.manager_callbacks.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.prompt_file.id_for_label }}" class="form-control-label">Prompt File</label>
                                    {{ form.prompt_file }}
                                    {% if form.prompt_file.errors %}
                                        <div class="text-danger">
                                            {{ form.prompt_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.planning_llm.id_for_label }}" class="form-control-label">Planning LLM</label>
                                    {{ form.planning_llm }}
                                    {% if form.planning_llm.errors %}
                                        <div class="text-danger">
                                            {{ form.planning_llm.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.verbose }}
                                    <label class="form-check-label" for="{{ form.verbose.id_for_label }}">Verbose</label>
                                    {% if form.verbose.errors %}
                                        <div class="text-danger">
                                            {{ form.verbose.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.memory }}
                                    <label class="form-check-label" for="{{ form.memory.id_for_label }}">Memory</label>
                                    {% if form.memory.errors %}
                                        <div class="text-danger">
                                            {{ form.memory.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.cache }}
                                    <label class="form-check-label" for="{{ form.cache.id_for_label }}">Cache</label>
                                    {% if form.cache.errors %}
                                        <div class="text-danger">
                                            {{ form.cache.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.full_output }}
                                    <label class="form-check-label" for="{{ form.full_output.id_for_label }}">Full Output</label>
                                    {% if form.full_output.errors %}
                                        <div class="text-danger">
                                            {{ form.full_output.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.share_crew }}
                                    <label class="form-check-label" for="{{ form.share_crew.id_for_label }}">Share Crew</label>
                                    {% if form.share_crew.errors %}
                                        <div class="text-danger">
                                            {{ form.share_crew.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-check form-switch">
                                    {{ form.planning }}
                                    <label class="form-check-label" for="{{ form.planning.id_for_label }}">Planning</label>
                                    {% if form.planning.errors %}
                                        <div class="text-danger">
                                            {{ form.planning.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <!-- Replace the existing input variables section with this -->
                        <div class="row mt-3">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="input_variables" class="form-control-label">Input Variables</label>
                                    <div id="input-variables-container" class="row">
                                        <!-- We'll populate this dynamically with JavaScript -->
                                    </div>
                                    <button type="button" id="add-variable" class="btn btn-outline-primary btn-sm mt-2">Add Variable</button>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{% url 'agents:manage_crews' %}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Crew</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.14.0/Sortable.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Choices.js for select fields
        var selectFields = document.querySelectorAll('select');
        selectFields.forEach(function(select) {
            new Choices(select, {
                removeItemButton: true,
                placeholder: true,
                placeholderValue: 'Select an option'
            });
        });
        try {
            const initialInputVariables = JSON.parse('{{ input_variables_json|safe }}');
            // ... rest of your code ...
        } catch (error) {
            console.error('Error parsing initial input variables:', error, '{{ input_variables_json|safe }}'); //log the json
        }
        // Add classes to form elements
        var formElements = document.querySelectorAll('input:not([type="checkbox"]):not([type="radio"]), select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        var checkboxInputs = document.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Form validation and submission
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            event.preventDefault();
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                alert('Please fill in all required fields.');
                return;
            }

            const formData = new FormData(form);
            const inputVariables = formData.getAll('input_variables[]');
            console.log('Submitting form with input variables:', inputVariables);
            form.submit();
        });

        const taskSelect = document.getElementById('{{ form.tasks.id_for_label }}');
        const taskOrderList = document.getElementById('task-order-list');

        // Initialize Sortable
        new Sortable(taskOrderList, {
            animation: 150,
            onEnd: function() {
                updateTaskOrder();
            }
        });

        // Update task order when tasks are selected or deselected
        taskSelect.addEventListener('change', function() {
            updateTaskList();
        });

        function updateTaskList() {
            const selectedTasks = Array.from(taskSelect.selectedOptions);
            const currentOrder = Array.from(taskOrderList.children).map(li => li.dataset.taskId);
            
            // Remove tasks that are no longer selected
            currentOrder.forEach(taskId => {
                if (!selectedTasks.some(option => option.value === taskId)) {
                    const li = taskOrderList.querySelector(`li[data-task-id="${taskId}"]`);
                    if (li) li.remove();
                }
            });

            // Add newly selected tasks
            selectedTasks.forEach(function(option) {
                if (!currentOrder.includes(option.value)) {
                    const listItem = document.createElement('li');
                    listItem.className = 'list-group-item';
                    listItem.dataset.taskId = option.value;
                    listItem.innerHTML = `
                        <span class="badge bg-primary me-2"></span>
                        ${option.text}
                        <input type="hidden" name="task_order[]" value="${option.value}">
                    `;
                    taskOrderList.appendChild(listItem);
                }
            });

            updateTaskOrder();
        }

        function updateTaskOrder() {
            const items = taskOrderList.querySelectorAll('li');
            items.forEach(function(item, index) {
                item.querySelector('.badge').textContent = index + 1;
                item.querySelector('input[name="task_order[]"]').value = item.dataset.taskId;
            });
        }

        const inputVariablesContainer = document.getElementById('input-variables-container');
    const addVariableButton = document.getElementById('add-variable');

    addVariableButton.addEventListener('click', function() {
        addInputVariable();
    });

    inputVariablesContainer.addEventListener('click', function(e) {
        if (e.target.classList.contains('remove-variable') || e.target.closest('.remove-variable')) {
            e.target.closest('.col-md-4').remove();
        }
    });

    function addInputVariable(value = '') {
        const newInput = document.createElement('div');
        newInput.className = 'col-md-4 mb-2';
        newInput.innerHTML = `
            <div class="input-group">
                <input type="text" name="input_variables[]" class="form-control form-control-sm" value="${value}" required>
                <button type="button" class="btn btn-outline-secondary btn-sm remove-variable">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        `;
        inputVariablesContainer.appendChild(newInput);
    }

    // Parse and render initial input variables
    try {
        const initialInputVariables = JSON.parse('{{ input_variables_json|safe }}');
        console.log('Initial input variables:', initialInputVariables);
        
        if (Array.isArray(initialInputVariables)) {
            initialInputVariables.forEach(variable => {
                addInputVariable(variable);
                console.log('Added input variable:', variable);
            });
        }
    } catch (error) {
        console.error('Error parsing initial input variables:', error);
    }
});
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/crew_kanban.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Kanban {% endblock %}
{% block extrastyle %}
{{ block.super }}
<link rel="stylesheet" type="text/css" href="{% static 'agents/css/crew_kanban.css' %}?v=29" crossorigin="anonymous"/>
{% endblock extrastyle %}

{% block content %}
{% csrf_token %}

<div class="container-fluid py-4">
    <!-- Header Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <!-- Left side with crew info -->
                        <div class="d-flex">
                            <div class="me-3">
                                <div class="avatar avatar-xl position-relative">
                                    <img src="{% static 'assets/img/team-1.jpg' %}" alt="profile_image" class="w-100 border-radius-lg shadow-sm">
                                </div>
                            </div>
                            <div>
                                <h5 class="mb-1">{{ crew.name }}</h5>
                                <p class="mb-0 font-weight-bold text-sm">Execution #{{ execution.id }}</p>
                                <p class="mb-0 text-sm">Started: {{ execution.created_at|date:"Y-m-d H:i:s" }}</p>
                                <p class="mb-0 text-sm">Client: {{client.name}} - {{client.website_url}}</p>
                            </div>
                        </div>
                        
                        <!-- Right side with buttons -->
                        <div class="d-flex gap-2">
                            <button id="cancelExecutionBtn" class="btn btn-danger" style="display: none;">
                                <i class="fas fa-stop-circle me-2"></i>Cancel Execution
                            </button>
                            <button class="btn btn-primary" onclick="showStartExecutionModal()">
                                <i class="fas fa-play me-2"></i>Start Crew Execution
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Tasks Section -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex align-items-center">
                        <h6 class="mb-0">Tasks</h6>
                        <span id="execution-number" class="text-sm ms-2"></span>
                    </div>
                </div>
                <div class="card-body">
                    <div class="kanban-container" id="kanban-tasks">
                        {% for task in tasks %}
                        <!-- Task Board -->
                        <div class="kanban-board" data-task-id="{{ task.id }}">
                            <header class="kanban-board-header rounded-top p-3">
                                <div class="text-white">
                                    <div class="task-description" data-bs-toggle="collapse" 
                                         href="#taskDesc{{ task.id }}" role="button" 
                                         aria-expanded="false" aria-controls="taskDesc{{ task.id }}">
                                        {{ task.name|truncatechars:200 }}
                                    </div>
                                    <div class="collapse" id="taskDesc{{ task.id }}">
                                        <div class="text-white-50 mt-2">
                                            {{ task.name }}
                                        </div>
                                    </div>
                                </div>
                            </header>
                            <div class="kanban-drag bg-white rounded-bottom border border-top-0">
                                <!-- Task items will be dynamically added here -->
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- Add SweetAlert2 -->
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<!-- jKanban -->
<script src="{% static 'assets/js/plugins/jkanban/jkanban.min.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script>
    // Initialize crew and client IDs from Django template
    const crewId = "{{ crew.id }}";
    const clientId = "{% if client %}{{ client.id }}{% else %}null{% endif %}";

    // Initialize markdown-it
    window.md = window.markdownit();
</script>
<script src="{% static 'agents/js/crew_kanban.js' %}?v={% now 'YmdHis' %}" type="module"></script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/crew_list.html
================
{% extends "agents/base_agents.html" %}

{% block agents_list %}
<ul class="list-group">
    {% for crew in crews %}
    <li class="list-group-item">
        <a href="{% url 'agents:crew_detail' crew.id %}" data-toggle="tooltip" title="{{ crew.description }}">
            {{ crew.name }}
        </a>
    </li>
    {% empty %}
    <li class="list-group-item">No CrewAI crews available.</li>
    {% endfor %}
</ul>
{% endblock %}

{% block previous_tasks %}
<ul class="list-group">
    {% for execution in request.user.crewaiexecution_set.all|slice:":5" %}
    <li class="list-group-item">
        <a href="{% url 'agents:execution_detail' execution.id %}">
            {{ execution.crew.name }} - {{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}
        </a>
    </li>
    {% empty %}
    <li class="list-group-item">No previous tasks.</li>
    {% endfor %}
</ul>
{% endblock %}

{% block main_content %}
<h2>Welcome to CrewAI Agents</h2>
<p>Select a crew from the list on the left to start a new execution or view previous tasks.</p>
{% endblock %}

{% block extra_js %}
{{ block.super }}
<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    })
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/crewai_home.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Dashboard {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <!-- Client Selection Dropdown -->
  <div class="row mb-4">
    <div class="col-6">
      <div class="card">
        <div class="card-body p-3">
          <form id="client-select-form" method="get">
            <div class="row align-items-center">
              <div class="col-md-3">
                <label for="client-select" class="form-label mb-0">Select Client:</label>
              </div>
              <div class="col-md-9">
                <select class="form-select" name="client_id" id="client-select">
                  <option value="">None</option>
                  {% for client in clients %}
                    <option value="{{ client.id }}" {% if client.id|stringformat:"s" == selected_client_id %}selected{% endif %}>
                      {{ client.name }}
                    </option>
                  {% endfor %}
                </select>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>

    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Crews</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ crews.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Recent Executions</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ recent_executions.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div> 

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-lg-6">
              <div class="d-flex flex-column h-100">
                <p class="mb-1 pt-2 text-bold">Welcome back, {{ request.user.username|capfirst }}</p>
                <h5 class="font-weight-bolder">Crew Dashboard</h5>
                <p class="mb-5">What do you want to do with your crews today.</p>
                <a class="text-body text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews_card_view' %}">
                  View All Crews
                  <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
                </a>
              </div>
            </div>
            <div class="col-lg-5 ms-auto text-center mt-5 mt-lg-0">
              <div class="bg-gradient-primary border-radius-lg h-100">
                <img src="{% static 'assets/img/shapes/waves-white.svg' %}" class="position-absolute h-100 w-50 top-0 d-lg-block d-none" alt="waves">
                <div class="position-relative d-flex align-items-center justify-content-center h-100">
                  <img class="w-100 position-relative z-index-2 pt-4" src="{% static 'assets/img/illustrations/rocket-white.png' %}" alt="rocket">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card h-100 p-3">
        <div class="overflow-hidden position-relative border-radius-lg bg-cover h-100" style="background-image: url('{% static 'assets/img/ivancik.jpg' %}');">
          <span class="mask bg-gradient-dark"></span>
          <div class="card-body position-relative z-index-1 d-flex flex-column h-100 p-3">
            <h5 class="text-white font-weight-bolder mb-4 pt-2">Manage Your Crews</h5>
            <p class="text-white">Create, edit, and manage your crews and their executions.</p>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews' %}">
              Read More
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Crews List -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Your Crews</h6>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Crew</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Process</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Language</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for crew in crews %}
                <tr>
                  <td>
                    <div class="d-flex px-3 py-1">
                      <div>
                        <img src="{% static 'assets/img/team-3.jpg' %}" class="avatar avatar-sm me-3" alt="crew">
                      </div>
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">
                          {% if selected_client_id %}
                            <a href="{% url 'agents:crew_kanban' crew.id %}?client_id={{ selected_client_id }}" class="text-sm mb-0">{{ crew.name }}</a>
                          {% else %}
                            {{ crew.name }}
                          {% endif %}
                        </h6>
                        <p class="text-xs text-secondary mb-0">{{ crew.agents.count }} Agents</p>
                      </div>
                    </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.get_process_display }}</p>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.language }}</p>
                  </td>
                  <td class="align-middle">
                    {% if selected_client_id %}
                    <a href="{% url 'agents:execution_list' %}?client_id={{ selected_client_id }}" class="btn btn-link text-dark px-3 mb-0">
                      <i class="fas fa-info-circle text-dark me-2"></i>Details
                    </a>
                    {% else %}
                    <span class="text-xs text-secondary">Select a client first</span>
                    {% endif %}
                  </td>
                </tr>
                {% empty %}
                <tr>
                  <td colspan="4" class="text-center py-4">
                    <p class="text-sm mb-0">No crews found.</p>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<!-- Add jQuery if not already included in base template -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Handle client selection change
    document.getElementById('client-select').addEventListener('change', function() {
      document.getElementById('client-select-form').submit();
    });
  });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/dashboard_home.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Dashboard {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <!-- New Client Selection Card -->
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Select Client</p>
                <form id="client-select-form" method="get">
                  <select class="form-control" name="client_id" id="client-select">
                    <option value="">All Clients</option>
                    {% for client in clients %}
                      <option value="{{ client.id }}" {% if client.id|stringformat:"s" == selected_client_id %}selected{% endif %}>
                        {{ client.name }}
                      </option>
                    {% endfor %}
                  </select>
                </form>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-building text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Crews</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ crews.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Recent Executions</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ recent_executions.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-body p-3">
          <div class="row">
            <div class="col-lg-6">
              <div class="d-flex flex-column h-100">
                <p class="mb-1 pt-2 text-bold">Welcome back, {{ request.user.username }}</p>
                <h5 class="font-weight-bolder">CrewAI Dashboard</h5>
                <p class="mb-5">Here's what's happening with your CrewAI today.</p>
                <a class="text-body text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:manage_crews' %}">
                  View All Crews
                  <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
                </a>
              </div>
            </div>
            <div class="col-lg-5 ms-auto text-center mt-5 mt-lg-0">
              <div class="bg-gradient-primary border-radius-lg h-100">
                <img src="{% static 'assets/img/shapes/waves-white.svg' %}" class="position-absolute h-100 w-50 top-0 d-lg-block d-none" alt="waves">
                <div class="position-relative d-flex align-items-center justify-content-center h-100">
                  <img class="w-100 position-relative z-index-2 pt-4" src="{% static 'assets/img/illustrations/rocket-white.png' %}" alt="rocket">
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card h-100 p-3">
        <div class="overflow-hidden position-relative border-radius-lg bg-cover h-100" style="background-image: url('{% static 'assets/img/ivancik.jpg' %}');">
          <span class="mask bg-gradient-dark"></span>
          <div class="card-body position-relative z-index-1 d-flex flex-column h-100 p-3">
            <h5 class="text-white font-weight-bolder mb-4 pt-2">Quick Actions</h5>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:add_crew' %}">
              Create New Crew
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
            <a class="text-white text-sm font-weight-bold mb-0 icon-move-right mt-auto" href="{% url 'agents:execution_list' %}">
              View Executions
              <i class="fas fa-arrow-right text-sm ms-1" aria-hidden="true"></i>
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="row mt-4">
    <div class="col-lg-7 mb-lg-0 mb-4">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Crew Summaries</h6>
        </div>
        <div class="card-body p-3">
          {% for crew in crews %}
          <div class="d-flex mb-3">
            <div class="icon icon-shape bg-gradient-dark shadow text-center border-radius-md">
              <i class="ni ni-mobile-button text-lg opacity-10" aria-hidden="true"></i>
            </div>
            <div class="ms-3">
              <div class="numbers">
                <h6 class="mb-1 text-dark text-sm">{{ crew.name }}</h6>
                <span class="text-sm">Agents: {{ crew.agent_set.count }}, Tasks: {{ crew.task_set.count }}</span>
              </div>
            </div>
            <div class="ms-auto">
              <a class="btn btn-link text-dark px-3 mb-0" href="{% url 'agents:crew_detail' crew.id %}">
                <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>View
              </a>
            </div>
          </div>
          {% endfor %}
        </div>
      </div>
    </div>
    <div class="col-lg-5">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Recent Executions</h6>
        </div>
        <div class="card-body p-3">
          <ul class="list-group">
            {% for execution in recent_executions %}
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-mobile-button text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">{{ execution.crew.name }}</h6>
                  <span class="text-xs">{{ execution.created_at|date:"SHORT_DATETIME_FORMAT" }}</span>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:execution_detail' execution.id %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            {% endfor %}
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Add links to existing pages -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0 p-3">
          <h6 class="mb-0">Navigation</h6>
        </div>
        <div class="card-body p-3">
          <ul class="list-group">
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-bullet-list-67 text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">Manage Crews</h6>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:manage_crews' %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
              <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm me-3 bg-gradient-dark shadow text-center">
                  <i class="ni ni-calendar-grid-58 text-white opacity-10"></i>
                </div>
                <div class="d-flex flex-column">
                  <h6 class="mb-1 text-dark text-sm">Execution List</h6>
                </div>
              </div>
              <div class="d-flex">
                <a class="btn btn-link btn-icon-only btn-rounded btn-sm text-dark icon-move-right my-auto" href="{% url 'agents:execution_list' %}">
                  <i class="ni ni-bold-right" aria-hidden="true"></i>
                </a>
              </div>
            </li>
            <!-- Add more links to other existing pages as needed -->
          </ul>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>

<script>
  $(function() {
    $('#client-select').change(function() {
      $('#client-select-form').submit();
    });
  });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/execution_detail.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Execution Detail {% endblock %}

{% block extrastyle %}
{{ block.super }}
<!-- jKanban styles -->
<!-- <link rel="stylesheet" href="{% static 'assets/css/plugins/jkanban/jkanban.min.css' %}"/> -->
<style>
.kanban-container {
  padding: 1.25rem;
  display: flex;
  overflow-x: auto;
}

.kanban-board {
  min-width: 320px;
  max-width: 640px;
  margin: 0 0.9375rem;
}

.kanban-drag {
  min-height: 200px;
  padding: 1.25rem;
}

.kanban-item {
  margin-bottom: 0.9375rem;
}

/* Custom scrollbar for better visibility */
.kanban-container::-webkit-scrollbar {
  height: 0.5rem;
}

.kanban-container::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
}

.kanban-container::-webkit-scrollbar-thumb {
  background: var(--bs-primary);
  border-radius: 0.25rem;
}

.kanban-container::-webkit-scrollbar-thumb:hover {
  background: var(--bs-primary-darker);
}

/* Stage status indicators */
.stage-status {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  border-radius: 0.25rem;
  font-size: 0.875rem;
  font-weight: 600;
}

.status-completed { background-color: #28a745; color: white; }
.status-in_progress { background-color: #007bff; color: white; }
.status-pending { background-color: #6c757d; color: white; }
.status-error { background-color: #dc3545; color: white; }

.stage-item {
  border: 1px solid #e9ecef;
  border-radius: 0.5rem;
  padding: 1rem;
  margin-bottom: 1rem;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  transition: all 0.3s ease;
}

.stage-item:hover {
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  transform: translateY(-2px);
}

.stage-content {
  margin-top: 1rem;
}

.stage-metadata {
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #6c757d;
}

.stage-agent {
  display: inline-flex;
  align-items: center;
  margin-top: 0.5rem;
  font-size: 0.875rem;
  color: #495057;
}

.stage-agent i {
  margin-right: 0.25rem;
}

/* Progress bar styles */
.progress-wrapper {
  margin-top: 1rem;
}

.progress {
  height: 8px;
  margin-bottom: 0.5rem;
  overflow: hidden;
  background-color: #e9ecef;
  border-radius: 0.25rem;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
}

.progress-bar {
  height: 100%;
  background-color: var(--bs-primary);
  transition: width .6s ease;
}

.progress-percentage {
  font-size: 0.75rem;
  color: #6c757d;
  text-align: right;
}

/* Task description styles */
.task-description {
  cursor: pointer;
  position: relative;
  padding-right: 1.5rem;
}

.task-description:after {
  content: '\f107';
  font-family: 'Font Awesome 5 Free';
  font-weight: 900;
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  transition: transform .2s;
}

.task-description[aria-expanded="true"]:after {
  transform: translateY(-50%) rotate(180deg);
}

/* Modal styles */
.modal-content {
  border: none;
  border-radius: 0.5rem;
  box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
}

.modal-header {
  border-bottom: 1px solid #e9ecef;
  padding: 1.25rem;
}

.modal-body {
  padding: 1.25rem;
}

.modal-footer {
  border-top: 1px solid #e9ecef;
  padding: 1.25rem;
}

/* Button styles */
.btn-icon {
  padding: 0.5rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 0.375rem;
  transition: all .15s ease-in-out;
}

.btn-icon i {
  font-size: 1rem;
}

.btn-icon:hover {
  transform: translateY(-1px);
}

/* Utility classes */
.text-xs {
  font-size: 0.75rem !important;
}

.text-sm {
  font-size: 0.875rem !important;
}

.font-weight-bold {
  font-weight: 600 !important;
}

.text-truncate-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
</style>
{% endblock extrastyle %}

{% block content %}
<div class="container-fluid py-4">
  <!-- Execution Header -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="row align-items-center">
            <div class="col-auto">
              <div class="avatar avatar-xl position-relative">
                <img src="{% static 'assets/img/team-1.jpg' %}" alt="profile_image" class="w-100 border-radius-lg shadow-sm">
              </div>
            </div>
            <div class="col">
              <div class="h-100">
                <h5 class="mb-1">Crew: {{ crew.name }}</h5>
                <p class="mb-0 font-weight-bold text-sm">Execution #{{ execution.id }}</p>
                <p class="mb-0 text-sm">Started: {{ execution.created_at|date:"Y-m-d H:i:s" }}</p>
                <p class="mb-0 text-sm">Client: {{client.name}} - {{client.website_url}}</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Kanban Board -->
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Tasks</h6>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="kanban-container">
            {% for column in columns %}
            <div class="kanban-board card">
              <header class="kanban-board-header bg-gradient-primary p-3">
                <div class="d-flex align-items-center">
                  <h6 class="text-white mb-0">{{ column.name }}</h6>
                </div>
              </header>
              <div class="kanban-drag p-3">
                {% for stage in column.stages %}
                <div class="stage-item">
                  <div class="d-flex justify-content-between align-items-center">
                    <span class="stage-status status-{{ stage.status|lower }}">{{ stage.status }}</span>
                    <small class="text-muted">{{ stage.created_at|date:"H:i:s" }}</small>
                  </div>
                  <h6 class="mt-2 mb-1">{{ stage.title }}</h6>
                  <div class="stage-content">
                    <div class="content-preview">
                      <p class="text-sm mb-2">{{ stage.content|truncatechars:150 }}</p>
                      {% if stage.content|length > 150 %}
                      <button class="btn btn-link btn-sm p-0 toggle-content" 
                              data-bs-toggle="collapse" 
                              data-bs-target="#content-{{ stage.id }}" 
                              aria-expanded="false">
                        Show More
                      </button>
                      <div class="collapse" id="content-{{ stage.id }}">
                        <div class="pt-2">
                          {{ stage.content|linebreaks }}
                          {% if stage.metadata %}
                          <div class="stage-metadata">
                            <h6 class="text-sm font-weight-bold">Metadata:</h6>
                            {% if stage.type == 'output' and stage.metadata.json_output %}
                            <pre class="text-sm">{{ stage.metadata.json_output|pprint }}</pre>
                            {% if stage.metadata.token_usage %}
                            <div class="mt-2">
                              <h6 class="text-sm font-weight-bold">Token Usage:</h6>
                              <pre class="text-sm">{{ stage.metadata.token_usage|pprint }}</pre>
                            </div>
                            {% endif %}
                            {% else %}
                            <pre class="text-sm">{{ stage.metadata|pprint }}</pre>
                            {% endif %}
                          </div>
                          {% endif %}
                        </div>
                      </div>
                      {% endif %}
                    </div>
                  </div>
                  {% if stage.agent %}
                  <div class="stage-agent">
                    <i class="fas fa-{% if stage.type == 'message' %}comment{% else %}robot{% endif %}"></i>
                    {{ stage.agent }}
                  </div>
                  {% endif %}
                </div>
                {% endfor %}
              </div>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{block.super}}
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const md = new markdownit();
    document.querySelectorAll('.stage-content .content-preview p').forEach(function(el) {
        const markdownContent = el.textContent;
        el.innerHTML = md.render(markdownContent);
    });

    // Add event listeners for content toggling
    document.querySelectorAll('.toggle-content').forEach(button => {
        button.addEventListener('click', function() {
            const expanded = this.getAttribute('aria-expanded') === 'true';
            this.textContent = expanded ? 'Show More' : 'Show Less';
        });
    });
});
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/execution_list.html
================
{% extends "agents/base_agents.html" %}
{% load static %}

{% block main_content %}
<div class="container mt-4">
    <h2>Executions</h2>

    <div class="card mb-4">
        <div class="card-header">
            <h3>Filter Executions</h3>
        </div>
        <div class="card-body">
            <form method="get" class="form-inline">
                <div class="form-group mr-2">
                    <label for="crew" class="mr-2">Crew:</label>
                    <select name="crew" id="crew" class="form-control">
                        <option value="">All Crews</option>
                        {% for crew in crews %}
                        <option value="{{ crew.id }}" {% if request.GET.crew == crew.id|stringformat:"s" %}selected{% endif %}>{{ crew.name }}</option>
                        {% endfor %}
                    </select>
                </div>
                <div class="form-group mr-2">
                    <label for="status" class="mr-2">Status:</label>
                    <select name="status" id="status" class="form-control">
                        <option value="">All Statuses</option>
                        <option value="PENDING" {% if request.GET.status == 'PENDING' %}selected{% endif %}>Pending</option>
                        <option value="RUNNING" {% if request.GET.status == 'RUNNING' %}selected{% endif %}>Running</option>
                        <option value="COMPLETED" {% if request.GET.status == 'COMPLETED' %}selected{% endif %}>Completed</option>
                        <option value="FAILED" {% if request.GET.status == 'FAILED' %}selected{% endif %}>Failed</option>
                    </select>
                </div>
                <button type="submit" class="btn btn-primary">Filter</button>
            </form>
        </div>
    </div>

    <div class="card">
        <div class="card-header">
            <h3>Execution List</h3>
        </div>
        <div class="card-body">
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Crew</th>
                        <th>Status</th>
                        <th>Started</th>
                        <th>Last Updated</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
                    {% for execution in executions %}
                    <tr>
                        <td>{{ execution.crew.name }}</td>
                        <td>
                            <span class="badge badge-{% if execution.status == 'COMPLETED' %}success{% elif execution.status == 'FAILED' %}danger{% elif execution.status == 'RUNNING' %}warning{% else %}secondary{% endif %}">
                                {{ execution.get_status_display }}
                            </span>
                        </td>
                        <td>{{ execution.created_at|date:"Y-m-d H:i:s" }}</td>
                        <td>{{ execution.updated_at|date:"Y-m-d H:i:s" }}</td>
                        <td>
                            <a href="{% url 'agents:execution_detail' execution.id %}" class="btn btn-sm btn-info">View Details</a>
                        </td>
                    </tr>
                    {% empty %}
                    <tr>
                        <td colspan="5">No executions found.</td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>

            {% if is_paginated %}
            <nav aria-label="Execution list pagination">
                <ul class="pagination justify-content-center">
                    {% if page_obj.has_previous %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.previous_page_number }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}" aria-label="Previous">
                            <span aria-hidden="true">&laquo;</span>
                        </a>
                    </li>
                    {% endif %}

                    {% for num in page_obj.paginator.page_range %}
                    {% if page_obj.number == num %}
                    <li class="page-item active"><a class="page-link" href="#">{{ num }}</a></li>
                    {% elif num > page_obj.number|add:'-3' and num < page_obj.number|add:'3' %}
                    <li class="page-item"><a class="page-link" href="?page={{ num }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}">{{ num }}</a></li>
                    {% endif %}
                    {% endfor %}

                    {% if page_obj.has_next %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.next_page_number }}{% for key, value in request.GET.items %}{% if key != 'page' %}&{{ key }}={{ value }}{% endif %}{% endfor %}" aria-label="Next">
                            <span aria-hidden="true">&raquo;</span>
                        </a>
                    </li>
                    {% endif %}
                </ul>
            </nav>
            {% endif %}
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
{{ block.super }}
<script>
    $(function () {
        $('[data-toggle="tooltip"]').tooltip()
    })
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_agents_card_view.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Agents - Card View {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
            <h6 class="mb-0">Agents</h6>
            <p class="text-sm mb-0">
                View and manage your AI agents.
            </p>
            </div>
            <div class="d-flex align-items-center">
            <a href="{% url 'agents:manage_agents' %}" class="btn btn-sm  me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
            </a>
            <a href="{% url 'agents:manage_agents_card_view' %}" class="btn btn-sm  me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
            </a>
            <a href="{% url 'agents:add_agent' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Agent</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="p-3">
            <div class="row g-3 mb-4">
              <div class="col-md-6">
                <input type="text" id="searchInput" class="form-control" placeholder="Search agents...">
              </div>
              <div class="col-md-6">
                <select id="roleFilter" class="form-select">
                  <option value="">All Roles</option>
                  <option value="Analyst">Analyst</option>
                  <option value="Support">Support</option>
                  <option value="Creator">Creator</option>
                  <option value="Engineer">Engineer</option>
                  <option value="Manager">Manager</option>
                </select>
              </div>
            </div>
            <div class="row" id="agentCards">
              {% for agent in agents %}
              <div class="col-lg-4 col-md-6 mb-4">
                <div class="card h-100">
                  <div class="card-header p-3 pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                      <div>
                        <h5 class="mb-0">{{ agent.name }}</h5>
                        <p class="text-sm mb-0">{{ agent.role }}</p>
                      </div>
                      <div class="avatar avatar-xl position-relative">
                        <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="Agent avatar" class="w-100 border-radius-lg shadow-sm">
                      </div>
                    </div>
                  </div>
                  <div class="card-body p-3">
                    <p class="text-sm mb-2"><strong>Goal:</strong> {{ agent.goal|truncatechars:100 }}</p>
                    <p class="text-sm mb-2"><strong>LLM:</strong> {{ agent.llm }}</p>
                    <p class="text-sm mb-2"><strong>Crews:</strong> 
                      {% for crew in agent.crew_set.all %}
                        <span class="badge bg-gradient-info"><a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit crew">{{ crew.name }}</a></span>
                      {% empty %}
                        <span class="text-muted">No crews</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-2"><strong>Tasks:</strong> 
                      {% for task in agent.task_set.all %}
                        <span class="badge bg-gradient-dark"><a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">{{ task.description|truncatechars:20 }}</a></span>
                      {% empty %}
                        <span class="text-muted">No tasks</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-0"><strong>Tools:</strong></p>
                    <div class="d-flex flex-wrap gap-1 mb-2">
                      {% for tool in agent.tools.all %}
                        <span class="badge bg-gradient-success">{{ tool.name }}</span>
                      {% empty %}
                        <span class="text-muted">No tools</span>
                      {% endfor %}
                    </div>
                  </div>
                  <div class="card-footer p-3">
                    <div class="d-flex justify-content-between">
                        <a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="btn btn-link text-dark mb-0 ps-0" data-toggle="tooltip" data-original-title="Edit agent">
                          <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit
                        </a>
                        <form action="{% url 'agents:duplicate_agent' agent.id %}" method="POST" class="d-inline">
                          {% csrf_token %}
                          <input type="hidden" name="next" value="{{ request.path }}">
                          <button type="submit" class="btn btn-link text-info mb-0" data-toggle="tooltip" data-original-title="Duplicate agent">
                            <i class="fas fa-clone me-2"></i>Duplicate
                          </button>
                        </form>
                        <a href="{% url 'agents:delete_agent' agent.id %}" class="btn btn-link text-danger mb-0 pe-0" data-toggle="tooltip" data-original-title="Delete agent">
                          <i class="far fa-trash-alt me-2"></i>Delete
                        </a>
                      </div>
                  </div>
                </div>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Create/Edit Agent Modal -->
<div class="modal fade" id="agentModal" tabindex="-1" role="dialog" aria-labelledby="agentModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="agentModalLabel">Create New Agent</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="agentForm">
          <div class="form-group mb-3">
            <label for="agentName" class="form-control-label">Name</label>
            <input type="text" class="form-control" id="agentName" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentRole" class="form-control-label">Role</label>
            <input type="text" class="form-control" id="agentRole" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentGoal" class="form-control-label">Goal</label>
            <textarea class="form-control" id="agentGoal" rows="3" required></textarea>
          </div>
          <div class="form-group mb-3">
            <label for="agentLLM" class="form-control-label">LLM</label>
            <input type="text" class="form-control" id="agentLLM" required>
          </div>
          <div class="form-group mb-3">
            <label for="agentAvatar" class="form-control-label">Avatar</label>
            <select class="form-control" id="agentAvatar" name="avatar" required>
              {% for avatar in form.avatar.field.choices %}
                <option value="{{ avatar.0 }}" data-img="{% static 'assets/img/'|add:avatar.0 %}">Avatar {{ forloop.counter }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="text-center">
            <img id="avatarPreview" src="" alt="Avatar preview" class="img-fluid rounded-circle" style="width: 100px; height: 100px; object-fit: cover;">
          </div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" onclick="saveAgent()">Save Agent</button>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  let currentAgentId = null;

  function editAgent(agentId) {
    currentAgentId = agentId;
    // Fetch agent details and populate the form
    // This is a placeholder - you'll need to implement the actual data fetching
    $('#agentModalLabel').text('Edit Agent');
    $('#agentModal').modal('show');
  }

  function saveAgent() {
    const agentData = {
      name: $('#agentName').val(),
      role: $('#agentRole').val(),
      goal: $('#agentGoal').val(),
      llm: $('#agentLLM').val(),
      avatar: $('#agentAvatar').val(),
      // Add more fields as needed
    };

    const url = currentAgentId ? `/agents/manage/agents/${currentAgentId}/update/` : '/agents/manage/agents/add/';
    const method = currentAgentId ? 'PUT' : 'POST';

    $.ajax({
      url: url,
      method: method,
      data: JSON.stringify(agentData),
      contentType: 'application/json',
      success: function(response) {
        $('#agentModal').modal('hide');
        // Refresh the page or update the cards
        location.reload();
      },
      error: function(error) {
        console.error('Error saving agent:', error);
      }
    });
  }

  function deleteAgent(agentId) {
    if (confirm('Are you sure you want to delete this agent?')) {
      $.ajax({
        url: `/agents/manage/agents/${agentId}/delete/`,
        method: 'DELETE',
        success: function(response) {
          // Remove the agent card or refresh the page
          location.reload();
        },
        error: function(error) {
          console.error('Error deleting agent:', error);
        }
      });
    }
  }

  $(document).ready(function() {
    $('#searchInput').on('keyup', function() {
      var value = $(this).val().toLowerCase();
      $("#agentCards .col-md-4").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });

    $('#roleFilter, #statusFilter').on('change', function() {
      var roleValue = $('#roleFilter').val().toLowerCase();
      var statusValue = $('#statusFilter').val().toLowerCase();
      $("#agentCards .col-md-4").filter(function() {
        var roleMatch = roleValue === '' || $(this).find('.text-capitalize').text().toLowerCase().indexOf(roleValue) > -1;
        var statusMatch = statusValue === '' || $(this).find('.badge').text().toLowerCase().indexOf(statusValue) > -1;
        $(this).toggle(roleMatch && statusMatch);
      });
    });

    // Avatar preview functionality
    $('#agentAvatar').change(function() {
      const selectedOption = $(this).find('option:selected');
      const imgSrc = selectedOption.data('img');
      $('#avatarPreview').attr('src', imgSrc);
    });

    // Trigger change event to show initial avatar
    $('#agentAvatar').trigger('change');
  });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_agents.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Agents {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
              <h5 class="mb-0">Agents</h5>
              <p class="text-sm mb-0">
                  View and manage your AI agents.
              </p>
          </div>
          <div class="d-flex align-items-center">
              <!-- Removed btn-group to separate the icons -->
              <a href="{% url 'agents:manage_agents' %}" class="btn btn-sm  me-2" title="Table View">
                  <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_agents_card_view' %}" class="btn btn-sm  me-2" title="Card View">
                  <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_agent' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Agent</a>
          </div>
      </div>
        <div class="table-responsive">
          <table class="table table-flush" id="agents-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Avatar</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Role</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">LLM</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for agent in agents %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="{{ agent.name }}'s avatar" class="avatar avatar-sm rounded-circle me-2">
                </td>
                <td class="text-sm font-weight-normal">
                  {{ agent.name }}
                </td>
                <td class="text-sm font-weight-normal">{{ agent.role }}</td>
                <td class="text-sm font-weight-normal">{{ agent.llm }}</td>
                <td class="text-sm font-weight-normal">
                  <div class="d-flex align-items-center gap-2">
                    <a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit agent">
                      Edit
                    </a>
                    <form action="{% url 'agents:duplicate_agent' agent.id %}" method="POST" class="d-inline mx-2">
                      {% csrf_token %}
                      <input type="hidden" name="next" value="{{ request.path }}">
                      <button type="submit" class="btn btn-link text-info font-weight-bold text-xs p-0 m-0" data-toggle="tooltip" data-original-title="Duplicate agent">
                        Duplicate
                      </button>
                    </form>
                    <a href="{% url 'agents:delete_agent' agent.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete agent">
                      Delete
                    </a>
                  </div>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="5" class="text-sm font-weight-normal">No agents found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

</div>

{% endblock content %}

{% block extra_js %}
  <script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>

  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#agents-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      perPageSelect: [25, 50, 100, 150]
    });
  </script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_crews_card_view.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Crews {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  {% if selected_client %}
    <div class="alert alert-info" role="alert">
      Selected Client: {{ selected_client.name }}
    </div>
  {% else %}
    <div class="alert alert-warning" role="alert">
      No client selected. Showing all crews.
    </div>
  {% endif %}
  
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-0">Crews</h6>
              <p class="text-sm mb-0">
                View and manage your AI agent crews.
              </p>
            </div>
            <div class="d-flex align-items-center">
              <a href="{% url 'agents:manage_crews' %}" class="btn btn-sm me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-sm me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_crew' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Crew</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="p-3">
            <div class="row g-3 mb-4">
              <div class="col-md-6">
                <input type="text" id="searchInput" class="form-control" placeholder="Search crews...">
              </div>
              <div class="col-md-6">
                <select id="processFilter" class="form-select">
                  <option value="">All Processes</option>
                  <option value="Sequential">Sequential</option>
                  <option value="Parallel">Parallel</option>
                  <option value="Hierarchical">Hierarchical</option>
                </select>
              </div>
            </div>
            <div class="row" id="crewCards">
              {% for crew in crews %}
              <div class="col-lg-4 col-md-6 mb-4">
                <div class="card h-100">
                  <div class="card-header p-3 pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                      <div>
                        <h5 class="mb-0">
                          <a href="{% url 'agents:crew_kanban' crew.id %}{% if selected_client %}?client_id={{ selected_client.id }}{% endif %}" class="text-dark">
                            {{ crew.name }}
                            <i class="fas fa-play ms-1" aria-hidden="true"></i>
                          </a>
                        </h5>
                        <p class="text-sm mb-0">{{ crew.get_process_display }}</p>
                      </div>
                      <div class="avatar-group">
                        {% for agent in crew.agents.all|slice:":3" %}
                          <a href="javascript:;" class="avatar avatar-sm rounded-circle" data-bs-toggle="tooltip" data-bs-placement="bottom" title="{{ agent.name }}">
                            <img src="{% static 'assets/img/'|add:agent.avatar %}" alt="{{ agent.name }}">
                          </a>
                        {% endfor %}
                        {% if crew.agents.count > 3 %}
                          <a href="javascript:;" class="avatar avatar-sm rounded-circle" data-bs-toggle="tooltip" data-bs-placement="bottom" title="{{ crew.agents.count|add:'-3' }} more">
                            <span class="avatar-text bg-gradient-primary">+{{ crew.agents.count|add:'-3' }}</span>
                          </a>
                        {% endif %}
                      </div>
                    </div>
                  </div>
                  <div class="card-body p-3">
                    <p class="text-sm mb-2"><strong>Agents:</strong> 
                      {% for agent in crew.agents.all %}
                        <span class="badge bg-gradient-info"><a href="{% url 'agents:edit_agent' agent.id %}?next={{ request.path|urlencode }}" class="text-white font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit agent">{{ agent.name }}</a></span>
                      {% empty %}
                        <span class="text-muted">No agents</span>
                      {% endfor %}
                    </p>
                    <p class="text-sm mb-2"><strong>Tasks:</strong> 
                      {% for task in crew.tasks.all %}
                        <span class="badge bg-gradient-dark"><a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-white" font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">{{ task.description|truncatechars:20 }}</a></span>
                      {% empty %}
                        <span class="text-muted">No tasks</span>
                      {% endfor %}
                    </p>
                  </div>
                  <div class="card-footer p-3">
                    <div class="d-flex justify-content-between">
                      <a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="btn btn-link text-dark mb-0 ps-0" data-toggle="tooltip" data-original-title="Edit crew">
                        <i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit
                      </a>

                      <form action="{% url 'agents:duplicate_crew' crew.id %}" method="POST" class="d-inline">
                        {% csrf_token %}
                        <input type="hidden" name="next" value="{{ request.path }}">
                        <button type="submit" class="btn btn-link text-info mb-0" data-toggle="tooltip" data-original-title="Duplicate crew">
                          <i class="fas fa-clone me-2"></i>Duplicate
                        </button>
                      </form>

                      <a href="{% url 'agents:delete_crew' crew.id %}" class="btn btn-link text-danger mb-0 pe-0" data-toggle="tooltip" data-original-title="Delete crew">
                        <i class="far fa-trash-alt me-2"></i>Delete
                      </a>
                    </div>
                  </div>
                </div>
              </div>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- Load jQuery first -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script>
  $(document).ready(function() {
    $('#searchInput').on('keyup', function() {
      var value = $(this).val().toLowerCase();
      $("#crewCards .col-lg-4").filter(function() {
        $(this).toggle($(this).text().toLowerCase().indexOf(value) > -1)
      });
    });

    $('#processFilter').on('change', function() {
      var processValue = $(this).val().toLowerCase();
      $("#crewCards .col-lg-4").filter(function() {
        var processMatch = processValue === '' || $(this).find('.text-sm').text().toLowerCase().indexOf(processValue) > -1;
        $(this).toggle(processMatch);
      });
    });

    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl)
    });
  });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_crews.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Crews {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  {% if selected_client %}
    <div class="alert alert-info" role="alert">
      Selected Client: {{ selected_client.name }}
    </div>
  {% else %}
    <div class="alert alert-warning" role="alert">
      No client selected. Showing all crews.
    </div>
  {% endif %}

  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-0">Crews</h6>
              <p class="text-sm mb-0">
                Manage your AI agent crews
              </p>
            </div>
            <div class="d-flex align-items-center">
              <a href="{% url 'agents:manage_crews' %}" class="btn btn-sm me-2" title="Table View">
                <i class="fas fa-table fs-5"></i>
              </a>
              <a href="{% url 'agents:manage_crews_card_view' %}" class="btn btn-sm me-2" title="Card View">
                <i class="fas fa-id-card fs-5"></i>
              </a>
              <a href="{% url 'agents:add_crew' %}?next={{ request.path|urlencode }}" class="btn btn-primary btn-sm">Add Crew</a>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Crew</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Process</th>
                  <th class="text-center text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Agents</th>
                  <th class="text-center text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Tasks</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for crew in crews %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">
                          <a href="{% url 'agents:crew_kanban' crew.id %}{% if selected_client %}?client_id={{ selected_client.id }}{% endif %}" class="text-dark font-weight-bold">
                            {{ crew.name }}
                          </a>
                        </h6>
                        <p class="text-xs text-secondary mb-0">{{ crew.description|truncatechars:50 }}</p>
                      </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ crew.get_process_display }}</p>
                  </td>
                  <td class="align-middle text-center text-sm">
                    <span class="badge badge-sm bg-gradient-success">{{ crew.agents.count }}</span>
                  </td>
                  <td class="align-middle text-center">
                    <span class="text-secondary text-xs font-weight-bold">{{ crew.tasks.count }}</span>
                  </td>
                  <td class="align-middle">
                    <div class="d-flex align-items-center gap-2">
                      <a href="{% url 'agents:edit_crew' crew.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit crew">
                        Edit
                      </a>
                      <form action="{% url 'agents:duplicate_crew' crew.id %}" method="POST" class="d-inline mx-2">
                        {% csrf_token %}
                        <input type="hidden" name="next" value="{{ request.path }}">
                        <button type="submit" class="btn btn-link text-info font-weight-bold text-xs p-0 m-0" data-toggle="tooltip" data-original-title="Duplicate crew">
                          Duplicate
                        </button>
                      </form>
                      <a href="{% url 'agents:delete_crew' crew.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete crew">
                        Delete
                      </a>
                    </div>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_tasks.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Tasks {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Tasks</h5>
            <p class="text-sm mb-0">
              View and manage your AI agent tasks.
            </p>
          </div>
          <div>
            <a href="{% url 'agents:add_task' %}" class="btn btn-primary btn-sm">Add New Task</a>
          </div>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="tasks-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Description</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Agent</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Async Execution</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Human Input</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Output Type</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for task in tasks %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}">{{ task.description|truncatechars:50 }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ task.agent.name|default:"N/A" }}</td>
                <td class="text-sm font-weight-normal">{% if task.async_execution %}Yes{% else %}No{% endif %}</td>
                <td class="text-sm font-weight-normal">{% if task.human_input %}Yes{% else %}No{% endif %}</td>
                <td class="text-sm font-weight-normal">
                  {% if task.output_json %}JSON
                  {% elif task.output_pydantic %}Pydantic
                  {% elif task.output_file %}File
                  {% else %}Default
                  {% endif %}
                </td>
                <td class="text-sm font-weight-normal">
                  <div class="d-flex align-items-center gap-2">
                    <a href="{% url 'agents:edit_task' task.id %}?next={{ request.path|urlencode }}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit task">
                      Edit
                    </a>
                    <form action="{% url 'agents:duplicate_task' task.id %}" method="POST" class="d-inline mx-2">
                      {% csrf_token %}
                      <input type="hidden" name="next" value="{{ request.path }}">
                      <button type="submit" class="btn btn-link text-info font-weight-bold text-xs p-0 m-0" data-toggle="tooltip" data-original-title="Duplicate task">
                        Duplicate
                      </button>
                    </form>
                    <a href="{% url 'agents:delete_task' task.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete task">
                      Delete
                    </a>
                  </div>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="6" class="text-sm font-weight-normal">No tasks found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

</div>
{% endblock content %}

{% block extra_js %}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#tasks-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 50,
      perPageSelect: [25, 50, 100, 150]
    });
  </script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/manage_tools.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Manage Tools {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Tools</h5>
            <p class="text-sm mb-0">
              View and manage your AI agent tools.
            </p>
          </div>
          <a href="{% url 'agents:add_tool' %}" class="btn btn-primary btn-sm">Add New Tool</a>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="tools-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Description</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Tool Class</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for tool in tools %}
              <tr>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_tool' tool.id %}">{{ tool.name }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ tool.description|truncatechars:50 }}</td>
                <td class="text-sm font-weight-normal">{{ tool.tool_class }}</td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'agents:edit_tool' tool.id %}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit tool">
                    Edit
                  </a>
                  |
                  <a href="#" class="text-primary font-weight-bold text-xs test-tool-btn" data-tool-id="{{ tool.id }}" data-bs-toggle="modal" data-bs-target="#testToolModal">
                    Test
                  </a>
                  |
                  <a href="{% url 'agents:delete_tool' tool.id %}" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Delete tool">
                    Delete
                  </a>
                </td>
              </tr>
              {% empty %}
              <tr>
                <td colspan="4" class="text-sm font-weight-normal">No tools found.</td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Test Tool Modal -->
<div class="modal fade" id="testToolModal" tabindex="-1" aria-labelledby="testToolModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="testToolModalLabel">Test Tool</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <form id="toolTestForm" onsubmit="return false;">
          {% csrf_token %}
          <div id="toolInputs" class="mb-3">
            <!-- Tool inputs will be dynamically added here -->
          </div>
          <div class="mb-3">
            <label class="form-label">Output:</label>
            <div id="toolOutput" class="border rounded p-3 bg-light overflow-auto" style="min-height: 100px; max-height: 400px;">
              <!-- Tool output will appear here -->
            </div>
          </div>
          <div id="outputTableContainer" style="display: none;"></div>
        </form>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="submit" class="btn btn-primary" id="testToolBtn">Test</button>
      </div>
    </div>
  </div>
</div>


{% endblock content %}
{% block extrastyle %}
  {{ block.super }}
  
<style>
  /* Ensure modal doesn't exceed viewport height */
  .modal-dialog-scrollable {
    max-height: 90vh;
    margin-top: 5vh;
    margin-bottom: 5vh;
  }
  
  /* Make modal wider on larger screens */
  @media (min-width: 1200px) {
    .modal-xl {
      max-width: 1140px;
    }
  }

  /* For extra large screens */
  @media (min-width: 1400px) {
    .modal-xl {
      max-width: 1320px;
    }
  }
  
  /* Style for pre-formatted output */
  #toolOutput pre {
    margin: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  /* Custom scrollbar styling for better visibility */
  #toolOutput::-webkit-scrollbar {
    width: 8px;
  }
  
  #toolOutput::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  
  #toolOutput::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
  }
  
  #toolOutput::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
  </style>
{% endblock extrastyle %}
{% block extra_js %}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#tools-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 50,
      perPageSelect: [25, 50, 100, 200]
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const toolInputs = document.getElementById('toolInputs');
      const toolOutput = document.getElementById('toolOutput');
      const testToolBtn = document.getElementById('testToolBtn');
      const testToolModal = document.getElementById('testToolModal');
      const toolTestForm = document.getElementById('toolTestForm');
      let currentToolId = null;

      // Helper function to check if string is JSON
      function isJSON(str) {
        try {
          JSON.parse(str);
          return true;
        } catch (e) {
          return false;
        }
      }

      // Helper function to parse JSON safely
      function parseJSON(jsonStr) {
        try {
          return JSON.parse(jsonStr);
        } catch (e) {
          return null;
        }
      }

      // Helper function to check if string is CSV
      function isCSV(str) {
        return str.includes(',') && str.includes('\n') && !str.includes('{') && !str.includes('[');
      }

      // Helper function to parse CSV
      function parseCSV(csv) {
        const lines = csv.trim().split('\n');
        const headers = lines[0].split(',').map(h => h.trim());
        const rows = lines.slice(1).map(line => {
          const values = line.split(',').map(v => v.trim());
          return headers.reduce((obj, header, i) => {
            obj[header] = values[i];
            return obj;
          }, {});
        });
        return rows;
      }

      // Function to create a table from data
      function createTable(data, tableName) {
        if (!Array.isArray(data) || data.length === 0) return null;
        
        // Get all unique keys from all objects
        const keys = [...new Set(data.flatMap(obj => Object.keys(obj)))];
        
        const table = document.createElement('table');
        table.className = 'table table-striped table-bordered mt-3';
        
        // Create table header
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        keys.forEach(key => {
          const th = document.createElement('th');
          th.textContent = key;
          th.className = 'text-xs font-weight-bold';
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);
        
        // Create table body
        const tbody = document.createElement('tbody');
        data.forEach(row => {
          const tr = document.createElement('tr');
          keys.forEach(key => {
            const td = document.createElement('td');
            const value = row[key];
            if (value === undefined || value === null) {
              td.textContent = '';
            } else if (typeof value === 'object') {
              if (Array.isArray(value)) {
                td.textContent = value.map(item => {
                  if (typeof item === 'object') {
                    return JSON.stringify(item, null, 2);
                  }
                  return item;
                }).join(', ');
              } else {
                td.textContent = JSON.stringify(value, null, 2);
              }
            } else {
              td.textContent = value.toString();
            }
            td.className = 'text-xs';
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        
        // Add table title
        const titleDiv = document.createElement('div');
        titleDiv.className = 'h6 mb-2';
        titleDiv.textContent = tableName;
        
        const container = document.createElement('div');
        container.appendChild(titleDiv);
        container.appendChild(table);
        
        return container;
      }

      // Function to display multiple tables
      function displayMultipleTables(data) {
        const container = document.getElementById('outputTableContainer');
        container.innerHTML = '';
        container.style.display = 'block';
        
        if (Array.isArray(data)) {
          if (data.length > 0 && typeof data[0] === 'object') {
            const table = createTable(data, 'Data Table');
            if (table) container.appendChild(table);
          }
        } else if (typeof data === 'object') {
          for (const [key, value] of Object.entries(data)) {
            if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
              const table = createTable(value, key);
              if (table) container.appendChild(table);
            } else if (typeof value === 'object' && value !== null) {
              // Handle nested objects
              for (const [nestedKey, nestedValue] of Object.entries(value)) {
                if (Array.isArray(nestedValue) && nestedValue.length > 0 && typeof nestedValue[0] === 'object') {
                  const table = createTable(nestedValue, `${key}.${nestedKey}`);
                  if (table) container.appendChild(table);
                }
              }
            }
          }
        }
      }

      // Function to fetch tool schema
      async function fetchToolSchema(toolId) {
        try {
          const response = await fetch(`/agents/tool-schema/${toolId}/`, {
            headers: {
              'Accept': 'application/json',
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const contentType = response.headers.get("content-type");
          if (!contentType || !contentType.includes("application/json")) {
            throw new TypeError("Oops, we haven't got JSON!");
          }
          
          const data = await response.json();
          console.log('Received schema:', data);  // Debug log
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          toolInputs.innerHTML = '';
          
          // Create input fields based on schema
          Object.entries(data.properties || {}).forEach(([key, prop]) => {
            const div = document.createElement('div');
            div.className = 'mb-3';
            
            const label = document.createElement('label');
            label.className = 'form-label';
            label.textContent = prop.title || key;
            
            if (prop.description) {
              const description = document.createElement('small');
              description.className = 'form-text text-muted d-block';
              description.textContent = prop.description;
              div.appendChild(label);
              div.appendChild(description);
            } else {
              div.appendChild(label);
            }
            
            const input = document.createElement('input');
            input.className = 'form-control';
            input.name = key;
            input.type = prop.type === 'number' ? 'number' : 'text';
            input.required = (data.required || []).includes(key);
            
            div.appendChild(input);
            toolInputs.appendChild(div);
          });
          
          toolOutput.innerHTML = '';
        } catch (error) {
          console.error('Error fetching schema:', error);
          toolInputs.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }

      // Handle test button click in the table
      document.querySelectorAll('.test-tool-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          currentToolId = this.dataset.toolId;
          fetchToolSchema(currentToolId);
        });
      });

      // Function to run tool test
      async function runToolTest(e) {
        e.preventDefault();
        if (!currentToolId) return;
        
        const formData = new FormData(toolTestForm);
        toolOutput.innerHTML = `
          <div class="d-flex align-items-center">
            <div class="spinner-border text-primary me-2" role="status">
              <span class="visually-hidden">Loading...</span>
            </div>
            <span>Testing tool...</span>
          </div>
        `;
        
        try {
          const response = await fetch(`/agents/test-tool/${currentToolId}/`, {
            method: 'POST',
            body: formData,
            headers: {
              'X-Requested-With': 'XMLHttpRequest'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          if (data.task_id) {
            pollStatus(data.task_id);
          } else {
            toolOutput.innerHTML = `<pre>${JSON.stringify(data.result, null, 2)}</pre>`;
          }
        } catch (error) {
          console.error('Error testing tool:', error);
          toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }

      // Handle form submission (both button click and Enter key)
      toolTestForm.addEventListener('submit', runToolTest);
      testToolBtn.addEventListener('click', runToolTest);

      // Function to poll task status
      async function pollStatus(taskId) {
        try {
          const response = await fetch(`/agents/tool-status/${taskId}/`);
          const data = await response.json();
          
          if (data.error) {
            throw new Error(data.error);
          }
          
          if (data.status === 'PENDING' || data.status === 'STARTED') {
            toolOutput.innerHTML = `
              <div class="d-flex align-items-center">
                <div class="spinner-border text-primary me-2" role="status">
                  <span class="visually-hidden">Loading...</span>
                </div>
                <span>Tool is running...</span>
              </div>
            `;
            setTimeout(() => pollStatus(taskId), 1000);
          } else if (data.status === 'SUCCESS') {
            const result = data.result;
            
            // Clear any previous output
            toolOutput.innerHTML = '';
            const outputTableContainer = document.getElementById('outputTableContainer');
            outputTableContainer.innerHTML = '';
            outputTableContainer.style.display = 'none';
            
            // Handle different types of output
            if (typeof result === 'string') {
              if (isJSON(result)) {
                const jsonData = parseJSON(result);
                displayMultipleTables(jsonData);
                toolOutput.textContent = result;
              } else if (isCSV(result)) {
                const csvData = parseCSV(result);
                displayTable(csvData);
                toolOutput.textContent = result;
              } else {
                toolOutput.textContent = result;
              }
            } else if (result && typeof result === 'object') {
              displayMultipleTables(result);
              toolOutput.textContent = JSON.stringify(result, null, 2);
            } else {
              toolOutput.textContent = 'Task completed successfully';
            }
          } else if (data.status === 'FAILURE') {
            throw new Error(data.error || 'Task failed');
          }
        } catch (error) {
          console.error('Error polling status:', error);
          toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
        }
      }
    });
  </script>
{% endblock %}

================
File: apps/agents/templates/agents/task_form.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} {% if task %}Edit Task{% else %}Add Task{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6 class="mb-0">{% if task %}Edit Task{% else %}Add Task{% endif %}</h6>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.description.id_for_label }}" class="form-control-label">Description</label>
                                    {{ form.description }}
                                    {% if form.description.errors %}
                                        <div class="text-danger">
                                            {{ form.description.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.agent.id_for_label }}" class="form-control-label">Agent</label>
                                    {{ form.agent }}
                                    {% if form.agent.errors %}
                                        <div class="text-danger">
                                            {{ form.agent.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.expected_output.id_for_label }}" class="form-control-label">Expected Output</label>
                                    {{ form.expected_output }}
                                    {% if form.expected_output.errors %}
                                        <div class="text-danger">
                                            {{ form.expected_output.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.tools.id_for_label }}" class="form-control-label">Tools</label>
                                    {{ form.tools }}
                                    {% if form.tools.errors %}
                                        <div class="text-danger">
                                            {{ form.tools.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-12">
                                <div class="form-group">
                                    <label for="{{ form.context.id_for_label }}" class="form-control-label">Context</label>
                                    {{ form.context }}
                                    {% if form.context.errors %}
                                        <div class="text-danger">
                                            {{ form.context.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.config.id_for_label }}" class="form-control-label">Config (JSON)</label>
                                    {{ form.config }}
                                    {% if form.config.errors %}
                                        <div class="text-danger">
                                            {{ form.config.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-group">
                                    <label for="{{ form.converter_cls.id_for_label }}" class="form-control-label">Converter Class</label>
                                    {{ form.converter_cls }}
                                    {% if form.converter_cls.errors %}
                                        <div class="text-danger">
                                            {{ form.converter_cls.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_json.id_for_label }}" class="form-control-label">Output JSON</label>
                                    {{ form.output_json }}
                                    {% if form.output_json.errors %}
                                        <div class="text-danger">
                                            {{ form.output_json.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_pydantic.id_for_label }}" class="form-control-label">Output Pydantic</label>
                                    {{ form.output_pydantic }}
                                    {% if form.output_pydantic.errors %}
                                        <div class="text-danger">
                                            {{ form.output_pydantic.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="form-group">
                                    <label for="{{ form.output_file.id_for_label }}" class="form-control-label">Output File Path</label>
                                    {{ form.output_file }}
                                    {% if form.output_file.errors %}
                                        <div class="text-danger">
                                            {{ form.output_file.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                    <small class="form-text text-muted">Enter the relative path in the media directory (e.g., 'outputs/task_result.txt')</small>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <div class="form-check form-switch">
                                    {{ form.async_execution }}
                                    <label class="form-check-label" for="{{ form.async_execution.id_for_label }}">Async Execution</label>
                                    {% if form.async_execution.errors %}
                                        <div class="text-danger">
                                            {{ form.async_execution.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="form-check form-switch">
                                    {{ form.human_input }}
                                    <label class="form-check-label" for="{{ form.human_input.id_for_label }}">Human Input</label>
                                    {% if form.human_input.errors %}
                                        <div class="text-danger">
                                            {{ form.human_input.errors|join:", " }}
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-12 text-end">
                                <a href="{% if request.META.HTTP_REFERER %}{{ request.META.HTTP_REFERER }}{% else %}{% url 'agents:manage_tasks' %}{% endif %}" class="btn btn-secondary me-2">Cancel</a>
                                <button type="submit" class="btn bg-gradient-primary">Save Task</button>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Choices.js for select fields
        var selectFields = document.querySelectorAll('select');
        selectFields.forEach(function(select) {
            new Choices(select, {
                removeItemButton: true,
                placeholder: true,
                placeholderValue: 'Select an option'
            });
        });

        // Add classes to form elements
        var formElements = document.querySelectorAll('input:not([type="checkbox"]):not([type="radio"]), select, textarea');
        formElements.forEach(function(element) {
            element.classList.add('form-control');
        });

        var selectElements = document.querySelectorAll('select');
        selectElements.forEach(function(element) {
            element.classList.add('form-select');
        });

        var checkboxInputs = document.querySelectorAll('input[type="checkbox"], input[type="radio"]');
        checkboxInputs.forEach(function(element) {
            element.classList.add('form-check-input');
        });

        // Form validation
        const form = document.querySelector('form');
        form.addEventListener('submit', function(event) {
            const requiredFields = form.querySelectorAll('[required]');
            let isValid = true;

            requiredFields.forEach(function(field) {
                if (!field.value.trim()) {
                    isValid = false;
                    field.classList.add('is-invalid');
                } else {
                    field.classList.remove('is-invalid');
                }
            });

            if (!isValid) {
                event.preventDefault();
                alert('Please fill in all required fields.');
            }
        });

        // JSON validation for config field
        var configField = document.getElementById('{{ form.config.id_for_label }}');
        if (configField) {
            configField.addEventListener('blur', function() {
                try {
                    JSON.parse(this.value);
                    this.classList.remove('is-invalid');
                } catch (error) {
                    this.classList.add('is-invalid');
                    alert('Invalid JSON format in Config field');
                }
            });
        }
    });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/tool_form.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load markdown_filters %}

{% block title %} {% if tool %}Edit Tool{% else %}Add Tool{% endif %} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row justify-content-center">
        <div class="col-lg-12 col-xl-12">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="mb-0">{% if tool %}Edit Tool{% else %}Add Tool{% endif %}</h5>
                </div>
                <div class="card-body">
                    <form method="post" id="toolForm">
                        {% csrf_token %}
                        {% if form.errors %}
                            <div class="alert alert-danger">
                                <ul>
                                    {% for field in form %}
                                        {% for error in field.errors %}
                                            <li>{{ field.label }}: {{ error }}</li>
                                        {% endfor %}
                                    {% endfor %}
                                    {% for error in form.non_field_errors %}
                                        <li>{{ error }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                        <div class="mb-4">
                            <label for="{{ form.tool_class.id_for_label }}" class="form-label">Tool Class</label><br>
                            {{ form.tool_class }}
                        </div>
                        <div class="mb-4">
                            <label for="{{ form.tool_subclass.id_for_label }}" class="form-label">Tool Subclass</label><br>
                            {{ form.tool_subclass }}
                        </div>
                        <div class="mb-4">
                            <label class="form-label">Description</label><br>
                            <textarea id="tool_description" name="description" class="form-control" readonly rows="2"></textarea>
                        </div>
                        <div id="errorMessage" class="alert alert-danger" style="display: none;"></div>
                        <div class="d-flex justify-content-end">
                            <a href="{% url 'agents:manage_tools' %}" class="btn btn-secondary me-2">Cancel</a>
                            <button type="submit" id="submitButton" class="btn btn-primary" disabled>Save</button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
            {% if tool %}
            <div class="row">
                <div class="col-12">
                    <div class="card">
                        <div class="card-header">
                            <h5 class="mb-0">Test Tool</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-3">
                                    <div class="card">
                                        <div class="card-header">
                                            <h6 class="mb-0">Tool Inputs</h6>
                                        </div>
                                        <div class="card-body">
                                            <form id="toolTestForm">
                                                <!-- Client selection container -->
                                                <div id="clientSelectionContainer" style="display: none;" class="mb-3 p-3 bg-light border-left border-primary rounded">
                                                    <h6>Client Selection</h6>
                                                    <p class="text-muted small">This tool requires client attributes. Select a client to auto-fill fields.</p>
                                                    <div class="mb-3">
                                                        <label for="clientSelect" class="form-label">Select Client</label>
                                                        <select id="clientSelect" class="form-control">
                                                            <option value="">-- Loading Clients --</option>
                                                        </select>
                                                    </div>
                                                    <div id="clientLoadingIndicator" style="display: none;" class="text-center my-2">
                                                        <div class="spinner-border spinner-border-sm text-primary" role="status">
                                                            <span class="visually-hidden">Loading...</span>
                                                        </div>
                                                        <span class="ms-2">Loading client attributes...</span>
                                                    </div>
                                                </div>
                                                <input type="hidden" id="clientAttributes" name="client_attributes">
                                                
                                                <!-- Tool input fields will be dynamically added here -->
                                                <div id="toolInputs"></div>
                                                <button type="button" id="testToolBtn" class="btn btn-primary mt-3">Test</button>
                                            </form>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-9">
                                    <div class="card">
                                        <div class="card-header d-flex justify-content-between align-items-center">
                                            <h6 class="mb-0">Tool Output</h6>
                                            <span id="tokenCount">Token Count: 0</span>
                                            <button id="copyOutputBtn" class="btn btn-sm btn-outline-primary">Copy to clipboard</button>
                                        </div>
                                        <div class="card-body">
                                            <div id="toolOutput" class="border p-3" style="height: 300px; overflow-y: auto;"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Add this new container for output tables -->
            <div id="outputTableContainer" class="col-12 mt-4" style="display: none;">
                <!-- Tables will be dynamically inserted here -->
            </div>
            <!-- Add this new container for markdown content -->
            <div id="markdownContainer" class="col-12 mt-4" style="display: none;">
                <div class="card">
                    <div class="card-header pb-0">
                        <h6>Markdown Content</h6>
                    </div>
                    <div class="card-body">
                        <div id="markdownContent" class="markdown-content"></div>
                    </div>
                </div>
            </div>
            {% endif %}
        </div>
    </div>
</div>
{% endblock content %}

{% block extrastyle %}
{{ block.super }}
<!-- Add GitHub Markdown CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
<style>
    .card {
        box-shadow: 0 4px 6px rgba(50, 50, 93, 0.11), 0 1px 3px rgba(0, 0, 0, 0.08);
        border: 0;
    }
    .card-header {
        background-color: #f8f9fa;
        border-bottom: 1px solid rgba(0,0,0,.125);
        padding: 1rem 1.5rem;
    }
    .card-body {
        padding: 1.5rem;
    }
    .form-label {
        font-weight: 600;
        color: #344767;
        margin-bottom: 0.5rem;
        display: block;
    }
    .form-control, .form-select {
        width: 100%;
        padding: 0.5rem 0.75rem;
        font-size: 0.875rem;
        border: 1px solid #d2d6da;
        border-radius: 0.375rem;
        margin-top: 0.25rem;
    }
    .form-control:focus, .form-select:focus {
        border-color: #5e72e4;
        box-shadow: 0 0 0 0.2rem rgba(94, 114, 228, 0.25);
    }
    textarea.form-control {
        min-height: 150px;
    }
    .btn {
        font-size: 0.875rem;
        font-weight: 600;
        padding: 0.625rem 1.25rem;
        border-radius: 0.375rem;
    }
    .btn-primary {
        background-color: #5e72e4;
        border-color: #5e72e4;
    }
    .btn-secondary {
        background-color: #8392ab;
        border-color: #8392ab;
    }
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0,0,0,.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        -webkit-animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
        to { -webkit-transform: rotate(360deg); }
    }
    @-webkit-keyframes spin {
        to { -webkit-transform: rotate(360deg); }
    }
    #toolOutput {
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: monospace;
        font-size: 0.9rem;
    }
    
    /* Markdown styling */
    .markdown-content {
        font-size: 0.875rem;
        line-height: 1.6;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    }
    
    .markdown-content h1, 
    .markdown-content h2, 
    .markdown-content h3, 
    .markdown-content h4, 
    .markdown-content h5, 
    .markdown-content h6 {
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
        line-height: 1.2;
        color: #344767;
    }
    .markdown-content h1 { font-size: 1.8rem; }
    .markdown-content h2 { font-size: 1.6rem; }
    .markdown-content h3 { font-size: 1.4rem; }
    .markdown-content h4 { font-size: 1.2rem; }
    .markdown-content h5 { font-size: 1.1rem; }
    .markdown-content h6 { font-size: 1rem; }
    
    .markdown-content p {
        margin-bottom: 1rem;
        line-height: 1.5;
    }
    
    .markdown-content ul, .markdown-content ol {
        margin-bottom: 1rem;
        padding-left: 2rem;
    }
    
    .markdown-content li {
        margin-bottom: 0.25rem;
    }
    
    .markdown-content blockquote {
        padding: 0.5rem 1rem;
        margin-bottom: 1rem;
        border-left: 3px solid #5e72e4;
        background-color: #f8f9fa;
    }
    
    .markdown-content code {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        background-color: #f8f9fa;
        padding: 0.2rem 0.4rem;
        border-radius: 0.25rem;
    }
    
    .markdown-content pre {
        margin-bottom: 1rem;
        padding: 1rem;
        background-color: #f8f9fa;
        border-radius: 0.375rem;
        overflow-x: auto;
    }
    
    .markdown-content pre code {
        padding: 0;
        background-color: transparent;
    }
    
    .markdown-content table {
        width: 100%;
        margin-bottom: 1rem;
        border-collapse: collapse;
    }
    
    .markdown-content th, .markdown-content td {
        padding: 0.5rem;
        border: 1px solid #dee2e6;
    }
    
    .markdown-content th {
        background-color: #f8f9fa;
        font-weight: 600;
    }
    
    .markdown-content img {
        max-width: 100%;
        height: auto;
        margin-bottom: 1rem;
    }
    
    /* Client selection styles */
    .autofilled {
        animation: highlightField 2s;
    }
    @keyframes highlightField {
        0% { background-color: #fff; }
        50% { background-color: #d1eaff; }
        100% { background-color: #fff; }
    }
    .border-left {
        border-left: 4px solid #5e72e4 !important;
    }
</style>
{% endblock extrastyle %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<!-- Add marked.js for markdown rendering -->
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        var toolClassSelect = document.getElementById('{{ form.tool_class.id_for_label }}');
        var toolSubclassSelect = document.getElementById('{{ form.tool_subclass.id_for_label }}');
        var toolDescriptionInput = document.getElementById('tool_description');
        var submitButton = document.getElementById('submitButton');
        var errorMessageDiv = document.getElementById('errorMessage');
        var outputTableContainer = document.getElementById('outputTableContainer');
        var outputTables = [];
        const tokenCountSpan = document.getElementById('tokenCount');

        // Client selection variables
        var clientSelectionContainer = document.getElementById('clientSelectionContainer');
        var clientSelect = document.getElementById('clientSelect');
        var clientLoadingIndicator = document.getElementById('clientLoadingIndicator');
        var clientAttributes = document.getElementById('clientAttributes');
        var toolRequiresClient = false;

        function setLoading(isLoading) {
            if (isLoading) {
                toolSubclassSelect.innerHTML = '<option value="">Loading...</option>';
                toolDescriptionInput.value = 'Loading...';
                submitButton.innerHTML = '<span class="loading"></span> Loading';
            } else {
                submitButton.innerHTML = 'Save';
            }
            submitButton.disabled = isLoading;
        }

        function showError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
        }

        function hideError() {
            errorMessageDiv.style.display = 'none';
        }

        toolClassSelect.addEventListener('change', function() {
            var selectedTool = this.value;
            if (selectedTool) {
                setLoading(true);
                hideError();
                fetch(`/agents/get_tool_info/?tool_class=${selectedTool}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        toolSubclassSelect.innerHTML = '';
                        data.classes.forEach(cls => {
                            var option = document.createElement('option');
                            option.value = cls.name;
                            option.textContent = cls.name;
                            option.setAttribute('data-description', cls.description);
                            toolSubclassSelect.appendChild(option);
                        });
                        toolSubclassSelect.dispatchEvent(new Event('change'));
                        submitButton.disabled = false;
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        showError(`Failed to load tool information: ${error.message}`);
                        toolSubclassSelect.innerHTML = '';
                        toolDescriptionInput.value = '';
                        submitButton.disabled = true;
                    })
                    .finally(() => {
                        setLoading(false);
                    });
            } else {
                toolSubclassSelect.innerHTML = '';
                toolDescriptionInput.value = '';
                submitButton.disabled = true;
                hideError();
            }
        });

        toolSubclassSelect.addEventListener('change', function() {
            var selectedOption = this.options[this.selectedIndex];
            if (selectedOption) {
                toolDescriptionInput.value = selectedOption.getAttribute('data-description') || '';
            } else {
                toolDescriptionInput.value = '';
            }
        });

        // Trigger the change event on page load if a tool is already selected (for edit mode)
        if (toolClassSelect.value) {
            toolClassSelect.dispatchEvent(new Event('change'));
        }

        {% if tool %}
        // Tool testing functionality
        const toolInputs = document.getElementById('toolInputs');
        const testToolBtn = document.getElementById('testToolBtn');
        const toolOutput = document.getElementById('toolOutput');
        const copyOutputBtn = document.getElementById('copyOutputBtn');
        
        // Check if a tool requires client-related properties
        function hasClientRelatedProperties(schema) {
            if (!schema || !schema.properties) return false;
            
            const properties = schema.properties;
            const clientRelatedProps = [
                'client_id', 
                'analytics_property_id', 
                'analytics_credentials',
                'search_console_property_url',
                'search_console_credentials',
                'website_url',
                'client_name',
                'targeted_keywords'
            ];
            
            return clientRelatedProps.some(prop => prop in properties);
        }
        
        // Fetch clients for dropdown
        function fetchClients() {
            fetch('/agents/tools/clients/')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch clients: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(clients => {
                    if (clients && clients.length > 0) {
                        clientSelect.innerHTML = '<option value="">-- Select a client --</option>';
                        clients.forEach(client => {
                            const option = document.createElement('option');
                            option.value = client.id;
                            option.textContent = client.name;
                            if (client.website_url) {
                                option.textContent += ` (${client.website_url})`;
                            }
                            clientSelect.appendChild(option);
                        });
                    } else {
                        clientSelect.innerHTML = '<option value="">No clients available</option>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching clients:', error);
                    clientSelect.innerHTML = '<option value="">Failed to load clients: ' + error.message + '</option>';
                    // Show a more user-friendly error in the UI
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'alert alert-danger mt-2';
                    errorMsg.textContent = 'Failed to load clients. Please ensure you have an active organization selected.';
                    clientSelectionContainer.appendChild(errorMsg);
                });
        }
        
        // Handle client selection
        function handleClientSelection() {
            const clientId = clientSelect.value;
            
            // Clear previous attribute data
            clientAttributes.value = '';
            
            if (!clientId) return;
            
            // Show loading indicator
            clientLoadingIndicator.style.display = 'block';
            
            // Fetch client attributes
            fetch(`/agents/tools/client-attributes/${clientId}/`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch client attributes: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Store client attributes in hidden input
                    clientAttributes.value = JSON.stringify(data);
                    
                    // Auto-fill form fields with client attributes
                    autoFillClientFields(data);
                    
                    // Hide loading indicator
                    clientLoadingIndicator.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error fetching client attributes:', error);
                    clientLoadingIndicator.style.display = 'none';
                    // Show error in UI
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'alert alert-danger mt-2';
                    errorMsg.textContent = 'Failed to load client attributes: ' + error.message;
                    
                    // Remove any existing error messages
                    const existingErrors = clientSelectionContainer.querySelectorAll('.alert');
                    existingErrors.forEach(el => el.remove());
                    
                    clientSelectionContainer.appendChild(errorMsg);
                });
        }
        
        // Auto-fill form fields with client attributes
        function autoFillClientFields(attributes) {
            const inputs = toolInputs.querySelectorAll('input, textarea, select');
            
            inputs.forEach(input => {
                const fieldName = input.name;
                
                // Skip hidden fields
                if (input.type === 'hidden') return;
                
                // Map of input field names to attribute properties
                const fieldMappings = {
                    'client_id': 'client_id',
                    'client_name': 'client_name',
                    'website_url': 'website_url',
                    'analytics_property_id': 'analytics_property_id',
                    'analytics_credentials': 'analytics_credentials',
                    'search_console_property_url': 'search_console_property_url',
                    'search_console_credentials': 'search_console_credentials',
                    'targeted_keywords': 'targeted_keywords'
                };
                
                // If we have a mapping for this field
                if (fieldName in fieldMappings) {
                    const attrName = fieldMappings[fieldName];
                    
                    if (attributes[attrName] !== undefined) {
                        const value = attributes[attrName];
                        
                        // Handle different field types
                        if (typeof value === 'object') {
                            input.value = JSON.stringify(value, null, 2);
                        } else {
                            input.value = value;
                        }
                        
                        // Add highlighting effect
                        input.classList.add('autofilled');
                        setTimeout(() => {
                            input.classList.remove('autofilled');
                        }, 2000);
                    }
                }
            });
        }

        // Function to fetch tool schema and create input fields
        function fetchToolSchema() {
            fetch(`/agents/get_tool_schema/{{ tool.id }}/`)
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(err => { throw err; });
                    }
                    return response.json();
                })
                .then(schema => {
                    toolInputs.innerHTML = '';
                    if (schema.error) {
                        throw new Error(schema.error);
                    } else if (schema.properties) {
                        // Check if tool requires client-related attributes
                        toolRequiresClient = hasClientRelatedProperties(schema);
                        if (toolRequiresClient) {
                            clientSelectionContainer.style.display = 'block';
                            fetchClients();
                            
                            // Set up client selection event handler
                            if (clientSelect) {
                                clientSelect.addEventListener('change', handleClientSelection);
                            }
                        } else {
                            clientSelectionContainer.style.display = 'none';
                        }
                        
                        for (const [key, value] of Object.entries(schema.properties)) {
                            // Skip client_id if we're showing the client selection dropdown
                            if (key === 'client_id' && toolRequiresClient) continue;
                            
                            const inputGroup = document.createElement('div');
                            inputGroup.className = 'mb-3';
                            
                            const label = document.createElement('label');
                            label.className = 'form-label';
                            label.textContent = value.title || key;
                            
                            let input;
                            if (value.type === 'boolean') {
                                // Create checkbox for boolean
                                const checkDiv = document.createElement('div');
                                checkDiv.className = 'form-check';
                                
                                input = document.createElement('input');
                                input.className = 'form-check-input';
                                input.type = 'checkbox';
                                input.name = key;
                                input.id = key;
                                
                                label.className = 'form-check-label';
                                
                                checkDiv.appendChild(input);
                                checkDiv.appendChild(label);
                                inputGroup.appendChild(checkDiv);
                            } else if (value.type === 'integer' || value.type === 'number') {
                                // Create number input
                                input = document.createElement('input');
                                input.className = 'form-control';
                                input.type = 'number';
                                input.name = key;
                                input.id = key;
                                
                                inputGroup.appendChild(label);
                                inputGroup.appendChild(input);
                            } else if (value.type === 'object') {
                                // Create textarea for JSON objects
                                input = document.createElement('textarea');
                                input.className = 'form-control';
                                input.style.fontFamily = 'monospace';
                                input.style.height = '150px';
                                input.name = key;
                                input.id = key;
                                input.placeholder = 'Enter JSON object';
                                
                                inputGroup.appendChild(label);
                                inputGroup.appendChild(input);
                            } else {
                                // Default to text input
                                input = document.createElement('input');
                                input.className = 'form-control';
                                input.type = 'text';
                                input.name = key;
                                input.id = key;
                                
                                inputGroup.appendChild(label);
                                inputGroup.appendChild(input);
                            }
                            
                            // Add description if available
                            if (value.description) {
                                const helpText = document.createElement('small');
                                helpText.className = 'form-text text-muted';
                                helpText.textContent = value.description;
                                if (value.type !== 'boolean') {
                                    inputGroup.appendChild(helpText);
                                } else {
                                    inputGroup.querySelector('.form-check').appendChild(helpText);
                                }
                            }
                            
                            if (value.type !== 'boolean') {
                                toolInputs.appendChild(inputGroup);
                            } else {
                                toolInputs.appendChild(inputGroup);
                            }
                        }
                    } else {
                        throw new Error('Invalid schema structure');
                    }
                })
                .catch(error => {
                    console.error('Error fetching tool schema:', error);
                    toolInputs.innerHTML = `<p class="text-danger">Error loading tool inputs: ${error.message}</p>`;
                });
        }

        // Fetch tool schema on page load
        fetchToolSchema();

        function isJSON(str) {
            try {
                JSON.parse(str);
                return true;
            } catch (e) {
                return false;
            }
        }

        function parseJSON(jsonStr) {
            return JSON.parse(jsonStr);
        }

        function createTable(data, tableName) {
            if (!Array.isArray(data) || data.length === 0) return null;
            
            const tableContainer = document.createElement('div');
            tableContainer.className = 'col-12 mt-4';
            
            // Get all unique keys from all objects
            const keys = [...new Set(data.flatMap(obj => Object.keys(obj)))];
            
            tableContainer.innerHTML = `
                <div class="card mb-4">
                    <div class="card-header pb-0">
                        <h6>${tableName}</h6>
                    </div>
                    <div class="card-body px-0 pt-0 pb-2">
                        <div class="table-responsive p-0">
                            <table class="table align-items-center mb-0" id="${tableName.replace(/\s+/g, '-').toLowerCase()}">
                                <thead>
                                    <tr>
                                        ${keys.map(key => `<th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">${key}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${data.map(row => `
                                        <tr>
                                            ${keys.map(key => {
                                                const value = row[key];
                                                let displayValue = '';
                                                if (value === undefined || value === null) {
                                                    displayValue = '';
                                                } else if (typeof value === 'object') {
                                                    displayValue = JSON.stringify(value, null, 2);
                                                } else {
                                                    displayValue = value.toString();
                                                }
                                                return `<td class="text-sm font-weight-normal"><pre style="white-space: pre-wrap;">${displayValue}</pre></td>`;
                                            }).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
            return tableContainer;
        }

        function flattenObject(obj, prefix = '') {
            let tables = {};
            for (const [key, value] of Object.entries(obj)) {
                const newKey = prefix ? `${prefix}.${key}` : key;
                if (Array.isArray(value)) {
                    if (value.length > 0) {
                        if (typeof value[0] === 'object') {
                            // Handle array of objects that have nested arrays
                            const flattenedData = value.map(item => {
                                const flattened = {};
                                for (const [k, v] of Object.entries(item)) {
                                    if (Array.isArray(v)) {
                                        if (v.length > 0 && typeof v[0] === 'object') {
                                            flattened[k] = v.map(obj => JSON.stringify(obj, null, 2)).join('\n');
                                        } else {
                                            flattened[k] = v.join(', ');
                                        }
                                    } else {
                                        flattened[k] = v;
                                    }
                                }
                                return flattened;
                            });
                            tables[newKey] = flattenedData;
                        }
                    }
                } else if (typeof value === 'object' && value !== null) {
                    Object.assign(tables, flattenObject(value, newKey));
                }
            }
            return tables;
        }

        function displayMultipleTables(data) {
            console.log('Displaying multiple tables. Data:', data);
            if (!outputTableContainer) {
                outputTableContainer = document.getElementById('outputTableContainer');
                if (!outputTableContainer) {
                    console.error('Output table container not found');
                    return;
                }
            }
            outputTableContainer.innerHTML = '';

            // Get all possible tables from the nested structure
            const tables = flattenObject(data);
            
            for (const [key, value] of Object.entries(tables)) {
                if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
                    const table = createTable(value, key);
                    if (table) {
                        outputTableContainer.appendChild(table);

                        const tableId = `#${key.replace(/\s+/g, '-').toLowerCase()}`;
                        try {
                            const tableElement = document.querySelector(tableId);
                            if (tableElement) {
                                outputTables.push(new simpleDatatables.DataTable(tableId, {
                                    searchable: true,
                                    fixedHeight: false,
                                    perPage: 10
                                }));
                            }
                        } catch (error) {
                            console.warn(`Failed to initialize DataTable for ${tableId}:`, error);
                        }
                    }
                }
            }

            outputTableContainer.style.display = 'block';
        }

        function isCSV(str) {
            const lines = str.trim().split('\n');
            return lines.length > 1 && lines[0].includes(',') && lines[1].includes(',');
        }

        function parseCSV(csv) {
            const lines = csv.trim().split('\n');
            return lines.map(line => line.split(',').map(cell => cell.trim()));
        }

        // Function to check if content is likely markdown
        function isMarkdown(str) {
            // Check if the string has common markdown patterns
            const markdownPatterns = [
                /^#+\s+.+$/m,                // Headers (# Header)
                /^\s*[\*\-\+]\s+.+$/m,       // Unordered lists (* Item)
                /^\s*\d+\.\s+.+$/m,          // Ordered lists (1. Item)
                /\*\*.+\*\*/,                // Bold text (**bold**)
                /\*.+\*/,                    // Italic text (*italic*)
                /\[.+\]\(.+\)/,              // Links [text](url)
                /^>\s+.+$/m,                 // Blockquotes (> quote)
                /^={3,}$|^-{3,}$/m,          // Horizontal rules (===, ---)
                /`{1,3}[^`]+`{1,3}/,         // Code (inline or blocks)
                /!\[.+\]\(.+\)/              // Images ![alt](url)
            ];

            return markdownPatterns.some(pattern => pattern.test(str));
        }

        // Function to recursively check if an object contains markdown
        function findMarkdownInObject(obj) {
            // If it's a string, check if it's markdown
            if (typeof obj === 'string') {
                return isMarkdown(obj) ? obj : null;
            }
            
            // If it's an object, check all its values
            if (obj && typeof obj === 'object') {
                for (const key in obj) {
                    const value = obj[key];
                    const markdown = findMarkdownInObject(value);
                    if (markdown) return markdown;
                }
            }
            
            return null;
        }

        // Function to render markdown content
        function renderMarkdown(content) {
            try {
                return marked.parse(content);
            } catch (e) {
                console.error('Error rendering markdown:', e);
                return content;
            }
        }

        // Function to display markdown in a separate container
        function displayMarkdown(content) {
            const markdownContainer = document.getElementById('markdownContainer');
            const markdownContent = document.getElementById('markdownContent');
            
            if (!markdownContainer || !markdownContent) {
                console.error('Markdown container elements not found');
                return;
            }
            
            // First we'll try client-side rendering with marked.js
            try {
                markdownContent.innerHTML = renderMarkdown(content);
                markdownContainer.style.display = 'block';
            } catch (e) {
                console.error('Error rendering markdown:', e);
                markdownContent.textContent = content;
                markdownContainer.style.display = 'block';
            }
        }

        function displayTable(data, tableName = 'CSV Data') {
            if (!outputTableContainer) {
                console.error('Output table container not found');
                return;
            }
            outputTableContainer.innerHTML = '';

            const tableData = data.slice(1).map(row => {
                const obj = {};
                data[0].forEach((header, index) => {
                    obj[header] = row[index];
                });
                return obj;
            });

            const table = createTable(tableData, tableName);
            outputTableContainer.appendChild(table);

            outputTables.push(new simpleDatatables.DataTable(`#${tableName.replace(/\s+/g, '-').toLowerCase()}`, {
                searchable: true,
                fixedHeight: false,
                perPage: 10
            }));

            outputTableContainer.style.display = 'block';
        }

        testToolBtn.addEventListener('click', function() {
            console.log('Test button clicked');
            const formData = new FormData(document.getElementById('toolTestForm'));
            
            // Add client attributes if any
            if (clientAttributes && clientAttributes.value) {
                formData.set('client_attributes', clientAttributes.value);
            }
            
            // Clear previous output containers
            toolOutput.innerHTML = `
                <div class="d-flex align-items-center">
                    <div class="spinner-border text-primary me-2" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <span>Testing tool...</span>
                </div>
            `;
            outputTableContainer.style.display = 'none';
            markdownContainer.style.display = 'none';
            
            // Destroy any existing datatables to prevent memory leaks
            outputTables.forEach(table => {
                if (table && typeof table.destroy === 'function') {
                    table.destroy();
                }
            });
            outputTables = [];
            
            fetch(`/agents/test_tool/{{ tool.id }}/`, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Tool execution started successfully
                console.log('Tool execution started:', data);
                const taskId = data.task_id;
                
                // Function to check task status
                function checkStatus() {
                    fetch(`/agents/tool-status/${taskId}/`)
                        .then(response => response.json())
                        .then(statusData => {
                            console.log('Received status update:', statusData);
                            if (statusData.error) {
                                throw new Error(statusData.error);
                            }
                            
                            if (statusData.status === 'PENDING' || statusData.status === 'STARTED') {
                                // Show progress information if available
                                let statusHtml = `
                                    <div class="d-flex align-items-center mb-2">
                                        <div class="spinner-border text-primary me-2" role="status">
                                            <span class="visually-hidden">Loading...</span>
                                        </div>
                                        <span>Tool is running...</span>
                                    </div>`;

                                // Add progress information if available
                                if (statusData.status) {
                                    const progressInfo = [];
                                    
                                    // Add status message if available
                                    if (statusData.progress_status) {
                                        progressInfo.push(`Status: ${statusData.progress_status}`);
                                    }
                                    
                                    // Add progress if available
                                    if (typeof statusData.current !== 'undefined' && typeof statusData.total !== 'undefined') {
                                        progressInfo.push(`Progress: ${statusData.current}/${statusData.total}`);
                                    }
                                    
                                    // Add any additional status information
                                    Object.entries(statusData).forEach(([key, value]) => {
                                        // Skip standard fields we've already handled
                                        if (!['status', 'progress_status', 'current', 'total', 'token_count', 'result', 'error'].includes(key)) {
                                            if (typeof value !== 'object' && value !== null) {
                                                progressInfo.push(`${key}: ${value}`);
                                            }
                                        }
                                    });
                                    
                                    if (progressInfo.length > 0) {
                                        statusHtml += `
                                            <div class="progress-info mt-2">
                                                ${progressInfo.map(info => `<div>${info}</div>`).join('')}
                                            </div>`;
                                    }
                                }
                                
                                toolOutput.innerHTML = statusHtml;
                                setTimeout(checkStatus, 1000);
                            } else if (statusData.status === 'SUCCESS') {
                                console.log('Token count received:', statusData.token_count);
                                tokenCountSpan.textContent = `Token Count: ${statusData.token_count}`;
                                
                                // Existing output handling remains unchanged
                                const result = statusData.result;
                                
                                // Clear any previous output
                                toolOutput.innerHTML = '';
                                
                                // Handle different types of output
                                if (typeof result === 'string') {
                                    if (isJSON(result)) {
                                        try {
                                            const jsonData = parseJSON(result);
                                            
                                            // First display the raw text in the output area
                                            toolOutput.textContent = result;
                                            
                                            // Check if the JSON contains markdown content
                                            const markdownContent = findMarkdownInObject(jsonData);
                                            if (markdownContent) {
                                                // Display the markdown content in a separate card
                                                displayMarkdown(markdownContent);
                                            }
                                            
                                            // Also try to display tables if they exist
                                            displayMultipleTables(jsonData);
                                        } catch (e) {
                                            console.error('Error processing JSON:', e);
                                            toolOutput.textContent = result;
                                        }
                                    } else if (isCSV(result)) {
                                        // Display raw CSV text in output area
                                        toolOutput.textContent = result;
                                        const csvData = parseCSV(result);
                                        displayTable(csvData);
                                    } else if (isMarkdown(result)) {
                                        // Display raw text in output area
                                        toolOutput.textContent = result;
                                        // Also display rendered markdown in a separate card
                                        displayMarkdown(result);
                                    } else {
                                        toolOutput.textContent = result;
                                    }
                                } else if (result && typeof result === 'object') {
                                    // Display the raw JSON in the output area
                                    toolOutput.textContent = JSON.stringify(result, null, 2);
                                    
                                    // Check if any of the object properties contain markdown
                                    const markdownContent = findMarkdownInObject(result);
                                    if (markdownContent) {
                                        // Display rendered markdown in a separate card
                                        displayMarkdown(markdownContent);
                                    }
                                    
                                    // Also try to display tables
                                    displayMultipleTables(result);
                                } else {
                                    toolOutput.textContent = 'Task completed successfully';
                                }
                            } else if (statusData.status === 'FAILURE') {
                                throw new Error(statusData.error || 'Task failed');
                            }
                        })
                        .catch(error => {
                            toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
                        });
                }
                
                // Start checking status
                checkStatus();
            })
            .catch(error => {
                toolOutput.innerHTML = `<div class="alert alert-danger">${error.message}</div>`;
            });
        });

        // Copy output to clipboard
        copyOutputBtn.addEventListener('click', function() {
            navigator.clipboard.writeText(toolOutput.textContent)
                .then(() => {
                    alert('Output copied to clipboard!');
                })
                .catch(err => {
                    console.error('Failed to copy text: ', err);
                });
        });

        {% endif %}
    });
</script>
{% endblock extra_js %}

================
File: apps/agents/templates/agents/tool_test.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %}Test Tool{% endblock %}

{% block extra_css %}
<style>
    .form-group {
        margin-bottom: 1.5rem;
    }
    .form-group label {
        font-weight: 600;
        margin-bottom: 0.5rem;
        display: block;
    }
    .form-group .form-text {
        font-size: 0.875rem;
        color: #6c757d;
        margin-top: 0.25rem;
    }
    #result-container {
        margin-top: 2rem;
        max-height: 500px;
        overflow-y: auto;
    }
    #loading-indicator {
        display: none;
        text-align: center;
        margin: 20px 0;
    }
    .autofilled {
        animation: highlightField 2s;
    }
    @keyframes highlightField {
        0% { background-color: #fff; }
        50% { background-color: #d1eaff; }
        100% { background-color: #fff; }
    }
    #client-selection-container {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        border-left: 4px solid #0d6efd;
    }
    .object-field {
        font-family: monospace;
        height: 150px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <h1>Test Tool: {{ tool.name }}</h1>
            <p class="text-muted">{{ tool.description }}</p>
            
            <div id="client-selection-container" style="display: none;">
                <h5>Client Selection</h5>
                <p class="text-muted">This tool requires client attributes. Select a client to auto-fill the required fields.</p>
                <div class="form-group">
                    <label for="client-select">Select Client</label>
                    <select id="client-select" class="form-control">
                        <option value="">-- Loading Clients --</option>
                    </select>
                </div>
                <div id="loading-indicator">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p>Loading client attributes...</p>
                </div>
            </div>
            
            <form id="tool-test-form" action="{% url 'agents:test_tool' tool.id %}" method="post">
                {% csrf_token %}
                <input type="hidden" name="client_attributes" id="client-attributes">
                
                <div id="tool-inputs">
                    <div class="text-center my-3">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p>Loading tool schema...</p>
                    </div>
                </div>
                
                <div class="form-group">
                    <button type="submit" class="btn btn-primary">Run Tool</button>
                </div>
            </form>
            
            <div id="result-container" style="display: none;">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Tool Results</h5>
                        <span id="status-badge" class="badge bg-secondary">Waiting</span>
                    </div>
                    <div class="card-body">
                        <div id="tool-result-loading" class="text-center">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading...</span>
                            </div>
                            <p>Running tool...</p>
                        </div>
                        <pre id="tool-result" class="my-3" style="display: none;"></pre>
                        <div id="result-footer" class="d-flex justify-content-between align-items-center mt-3" style="display: none;">
                            <small class="text-muted">Token count: <span id="token-count">0</span></small>
                            <button id="copy-result" class="btn btn-sm btn-outline-primary">Copy Result</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    // Store the tool schema globally
    window.toolSchema = null;
    
    // Function to fetch tool schema
    function fetchToolSchema() {
        fetch("{% url 'agents:get_tool_schema' tool.id %}")
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    document.getElementById('tool-inputs').innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                    return;
                }
                
                window.toolSchema = data;
                renderToolInputs(data);
            })
            .catch(error => {
                console.error('Error fetching tool schema:', error);
                document.getElementById('tool-inputs').innerHTML = '<div class="alert alert-danger">Failed to load tool schema</div>';
            });
    }
    
    // Function to render tool inputs based on schema
    function renderToolInputs(schema) {
        const inputsContainer = document.getElementById('tool-inputs');
        inputsContainer.innerHTML = '';
        
        const properties = schema.properties || {};
        
        // Sort properties to ensure consistent order
        const sortedProperties = Object.entries(properties).sort((a, b) => {
            // Put client_id at the top if it exists
            if (a[0] === 'client_id') return -1;
            if (b[0] === 'client_id') return 1;
            return a[0].localeCompare(b[0]);
        });
        
        for (const [name, property] of sortedProperties) {
            // Skip client_id as we're handling it separately
            if (name === 'client_id' && document.getElementById('client-selection-container').style.display !== 'none') {
                continue;
            }
            
            const formGroup = document.createElement('div');
            formGroup.className = 'form-group';
            
            const label = document.createElement('label');
            label.setAttribute('for', name);
            label.textContent = property.title || name;
            
            let input;
            
            // Handle different property types
            if (property.type === 'boolean') {
                // Create checkbox for boolean
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'form-check-input';
                input.id = name;
                input.name = name;
                
                // Wrap in a div for better styling
                const wrapper = document.createElement('div');
                wrapper.className = 'form-check';
                wrapper.appendChild(input);
                label.className = 'form-check-label';
                wrapper.appendChild(label);
                formGroup.appendChild(wrapper);
            } else if (property.type === 'integer' || property.type === 'number') {
                // Create number input
                input = document.createElement('input');
                input.type = 'number';
                input.className = 'form-control';
                input.id = name;
                input.name = name;
                formGroup.appendChild(label);
                formGroup.appendChild(input);
            } else if (property.type === 'object') {
                // Create textarea for JSON objects
                input = document.createElement('textarea');
                input.className = 'form-control object-field';
                input.id = name;
                input.name = name;
                input.placeholder = 'Enter JSON object';
                formGroup.appendChild(label);
                formGroup.appendChild(input);
            } else {
                // Default to text input
                input = document.createElement('input');
                input.type = 'text';
                input.className = 'form-control';
                input.id = name;
                input.name = name;
                formGroup.appendChild(label);
                formGroup.appendChild(input);
            }
            
            // Add description if available
            if (property.description) {
                const helpText = document.createElement('small');
                helpText.className = 'form-text';
                helpText.textContent = property.description;
                formGroup.appendChild(helpText);
            }
            
            // Only append if not already appended (for boolean case)
            if (property.type !== 'boolean') {
                inputsContainer.appendChild(formGroup);
            } else {
                inputsContainer.appendChild(formGroup);
            }
        }
    }
    
    // Function to handle tool status polling
    function pollToolStatus(taskId) {
        const resultContainer = document.getElementById('result-container');
        const toolResult = document.getElementById('tool-result');
        const toolResultLoading = document.getElementById('tool-result-loading');
        const statusBadge = document.getElementById('status-badge');
        const resultFooter = document.getElementById('result-footer');
        const tokenCount = document.getElementById('token-count');
        
        resultContainer.style.display = 'block';
        
        const pollInterval = setInterval(() => {
            fetch(`{% url 'agents:get_tool_status' 'TASK_ID' %}`.replace('TASK_ID', taskId))
                .then(response => response.json())
                .then(data => {
                    // Update status badge
                    statusBadge.textContent = data.status;
                    statusBadge.className = `badge ${getStatusClass(data.status)}`;
                    
                    if (data.status === 'SUCCESS') {
                        clearInterval(pollInterval);
                        
                        // Show result
                        toolResultLoading.style.display = 'none';
                        toolResult.style.display = 'block';
                        resultFooter.style.display = 'flex';
                        
                        // Format and display result
                        try {
                            const result = typeof data.result === 'string' ? data.result : JSON.stringify(data.result, null, 2);
                            toolResult.textContent = result;
                            
                            // Update token count
                            tokenCount.textContent = data.token_count || '0';
                        } catch (e) {
                            toolResult.textContent = `Error formatting result: ${e.message}`;
                        }
                    } else if (data.status === 'FAILURE') {
                        clearInterval(pollInterval);
                        
                        // Show error
                        toolResultLoading.style.display = 'none';
                        toolResult.style.display = 'block';
                        toolResult.textContent = `Error: ${data.error || 'Unknown error'}`;
                        toolResult.className = 'my-3 text-danger';
                    }
                })
                .catch(error => {
                    console.error('Error polling tool status:', error);
                });
        }, 2000);
    }
    
    // Helper function to get status badge class
    function getStatusClass(status) {
        switch (status) {
            case 'PENDING':
                return 'bg-warning';
            case 'STARTED':
            case 'PROGRESS':
                return 'bg-info';
            case 'SUCCESS':
                return 'bg-success';
            case 'FAILURE':
                return 'bg-danger';
            default:
                return 'bg-secondary';
        }
    }
    
    // Initialize the page
    document.addEventListener('DOMContentLoaded', function() {
        fetchToolSchema();
        
        const toolForm = document.getElementById('tool-test-form');
        
        // Handle form submission
        toolForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const formData = new FormData(toolForm);
            
            fetch(toolForm.action, {
                method: 'POST',
                body: formData,
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    alert(`Error: ${data.error}`);
                    return;
                }
                
                if (data.task_id) {
                    pollToolStatus(data.task_id);
                }
            })
            .catch(error => {
                console.error('Error submitting form:', error);
                alert('Error submitting form');
            });
        });
        
        // Handle copy result button
        document.getElementById('copy-result').addEventListener('click', function() {
            const result = document.getElementById('tool-result').textContent;
            navigator.clipboard.writeText(result).then(() => {
                alert('Result copied to clipboard');
            }).catch(err => {
                console.error('Failed to copy result:', err);
                alert('Failed to copy result');
            });
        });
    });
</script>
<script src="{% static 'agents/js/tool_tester.js' %}"></script>
{% endblock %}

================
File: apps/agents/templatetags/__init__.py
================
# Empty file to make the directory a Python package

================
File: apps/agents/templatetags/agent_filters.py
================
from django import template

register = template.Library()

@register.filter
def has_force_output_enabled(agent, tool):
    """Template filter to check if force output is enabled for a tool."""
    if not agent:
        return False
    tool_setting = agent.tool_settings.filter(tool=tool).first()
    return tool_setting.force_output_as_result if tool_setting else False

================
File: apps/agents/templatetags/agent_tags.py
================
from django import template

register = template.Library()

@register.filter
def get_item(dictionary, key):
    return dictionary.get(key)

================
File: apps/agents/tests/integration/test_callback_flow.py
================


================
File: apps/agents/tests/test_file_writer_tool.py
================
import os
import sys
import logging
import json
from unittest.mock import patch, MagicMock
from functools import wraps
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process
from crewai.agents.crew_agent_executor import CrewAgentExecutor
from apps.agents.tools.file_writer_tool.file_writer_tool import FileWriterTool
from apps.agents.tools.file_read_tool.file_read_tool import FileReadTool

# Load environment variables first
load_dotenv()

# Add the project root directory to Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..'))
sys.path.append(project_root)

# Set up Django environment
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
import django
django.setup()

# Reset to default OpenAI API and clear proxy token
os.environ['OPENAI_API_BASE'] = 'https://api.openai.com/v1'
os.environ['LITELLM_MASTER_KEY'] = ''

# Configure logging
logging.basicConfig(level=logging.DEBUG)  # Set to DEBUG for maximum verbosity
logger = logging.getLogger(__name__)

def debug_crew_executor(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            # Get the instance (self) from args
            instance = args[0] if args else None
            
            # Log entry point
            logger.debug(f"→ Entering {func.__name__}")
            
            # Special logging for specific methods
            if func.__name__ == '_format_answer':
                logger.debug(f"Raw answer to parse: {args[1]}")  # args[1] is the answer string
            elif func.__name__ == '_execute_tool_and_check_finality':
                agent_action = args[1]  # args[1] is AgentAction
                logger.debug(f"Tool to execute: {agent_action.tool}")
                logger.debug(f"Tool input (raw): {repr(agent_action.tool_input)}")
                logger.debug(f"Tool input (type): {type(agent_action.tool_input)}")
            
            result = func(*args, **kwargs)
            
            # Special logging for results
            if func.__name__ == '_format_answer':
                logger.debug(f"Parsed result type: {type(result)}")
                if hasattr(result, 'tool_input'):
                    logger.debug(f"Parsed tool_input: {repr(result.tool_input)}")
            elif func.__name__ == '_execute_tool_and_check_finality':
                logger.debug(f"Tool execution result: {result}")
            
            return result
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {str(e)}", exc_info=True)
            raise
    return wrapper

def create_file_handling_crew():
    # Patch the critical methods in CrewAgentExecutor
    patches = [
        patch('crewai.agents.crew_agent_executor.CrewAgentExecutor._format_answer'),
        patch('crewai.agents.crew_agent_executor.CrewAgentExecutor._execute_tool_and_check_finality'),
        patch('crewai.agents.crew_agent_executor.CrewAgentParser.parse'),
        patch('crewai.agents.crew_agent_executor.ToolUsage.parse'),
        patch('crewai.agents.crew_agent_executor.ToolUsage.use')
    ]
    
    with patch.multiple('crewai.agents.crew_agent_executor.CrewAgentExecutor',
                       _format_answer=debug_crew_executor(CrewAgentExecutor._format_answer),
                       _execute_tool_and_check_finality=debug_crew_executor(CrewAgentExecutor._execute_tool_and_check_finality)):
        
        # Initialize tools
        file_reader = FileReadTool()
        file_writer = FileWriterTool()
        
        # Create the agent with both tools
        file_handler_agent = Agent(
            role="File Handler",
            goal="Read and write files accurately",
            backstory="I am a specialized agent that handles file operations with precision and care.",
            tools=[file_reader, file_writer],
            verbose=True
        )

        # Create tasks (keep existing task definitions)
        read_task = Task(
            description="Read the content of the file '{input_file}'",
            expected_output="The complete content of the {input_file} file",
            agent=file_handler_agent,
        )

        write_task = Task(
            description="Write the content to a new file named '{output_file}'",
            expected_output="Confirmation that the file was written successfully",
            agent=file_handler_agent,
        )

        # Create the crew
        crew = Crew(
            agents=[file_handler_agent],
            tasks=[read_task, write_task],
            process=Process.sequential,
            verbose=True
        )

        try:
            result = crew.kickoff(
                inputs={
                    "input_file": "fluffy.txt",
                    "output_file": "fluffy1.txt",
                    "user_id": 1
                }
            )
            logger.info("File operations completed successfully")
            return result
        except Exception as e:
            logger.error(f"Error during file operations: {str(e)}", exc_info=True)
            raise

if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # Set specific loggers to DEBUG
    logging.getLogger('crewai.agents.crew_agent_executor').setLevel(logging.DEBUG)
    logging.getLogger('crewai.agents.agent_executor').setLevel(logging.DEBUG)
    
    result = create_file_handling_crew()
    print("\nResult:", result)

================
File: apps/agents/tools/agent_delegation_tool/__init__.py
================
from .agent_delegation_tool import AgentDelegationTool

__all__ = ['AgentDelegationTool']

================
File: apps/agents/tools/agent_delegation_tool/agent_delegation_tool.py
================
import logging
from typing import Type, Any, Optional
from pydantic import BaseModel, Field, ConfigDict
from django.core.exceptions import ObjectDoesNotExist
from django.conf import settings
import json

from apps.agents.tools.base_tool import BaseTool
# Import necessary components for agent execution
from apps.agents.models import Agent as AgentModel, Tool as ToolModel
from apps.common.utils import get_llm
# Use load_tool from tool_utils for consistency
from apps.agents.utils.tool_utils import load_tool
from langchain.agents import AgentExecutor, create_structured_chat_agent
from langchain.memory import ConversationBufferMemory
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_core.messages import SystemMessage, HumanMessage
# Import LangChain tool types for conversion
from langchain.tools import Tool, StructuredTool

logger = logging.getLogger(__name__)

class AgentDelegationInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )

    agent_id: int = Field(description="The database ID of the agent to delegate the task to.")
    prompt: str = Field(description="The specific task, question, or instruction for the delegated agent.")
    # include_parent_history: bool = Field(default=False, description="Flag to include parent agent\'s history.") # Keep it simple for now

class AgentDelegationTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )

    name: str = "Agent Delegation Tool"
    # Define description using Field to satisfy Pydantic initialization
    description: str = Field(default="Delegates a task or question to another specified agent (by ID) and returns its response. Use the agent_id parameter to specify the target agent.")
    args_schema: Type[BaseModel] = AgentDelegationInput
    # parent_agent_id: Optional[int] = None # Potentially needed for recursion check later

    def _run(self, agent_id: int, prompt: str, **kwargs: Any) -> Any:
        """Use the tool to delegate a task to another agent."""
        logger.info(f"AgentDelegationTool invoked: Delegating prompt \'{prompt[:50]}...\' to agent ID {agent_id}")

        # --- Implementation Steps (from PRD) ---
        # 1. Basic Recursion Check (Future enhancement, placeholder)
        # parent_agent_id = kwargs.get('parent_agent_id', None) # How to get parent ID? Needs passing maybe.
        # if parent_agent_id and agent_id == parent_agent_id:
        #     logger.warning(f"Recursion detected: Agent {parent_agent_id} attempted to delegate back to itself via agent {agent_id}.")
        #     return "Error: Recursive delegation detected. Cannot delegate task back to the calling agent."

        # 2. Call helper function _execute_delegated_agent
        try:
            # Pass necessary context if needed in future, e.g., parent_agent_id
            result = self._execute_delegated_agent(agent_id, prompt)
            logger.info(f"AgentDelegationTool completed for agent ID {agent_id}. Result: {str(result)[:100]}...")
            return result
        except ObjectDoesNotExist:
            logger.error(f"AgentDelegationTool Error: Agent with ID {agent_id} not found.")
            return f"Error: Agent with ID {agent_id} not found."
        except Exception as e:
            logger.error(f"Error executing AgentDelegationTool for agent ID {agent_id}: {e}", exc_info=True)
            return f"Error: Failed to execute delegated task for agent {agent_id}. Reason: {e}"

    def _execute_delegated_agent(self, agent_id: int, prompt: str) -> str:
        """
        Helper function to set up and run the delegated agent synchronously.
        """
        logger.debug(f"Executing delegated agent ID: {agent_id} with prompt: \'{prompt[:50]}...\'")

        # 1. Fetch Agent model (synchronously)
        try:
            agent_model = AgentModel.objects.get(id=agent_id)
            logger.debug(f"Successfully fetched agent model: {agent_model.name} (ID: {agent_id})")
        except AgentModel.DoesNotExist:
            # This specific exception is caught and re-raised for handling in _run
            raise ObjectDoesNotExist(f"Agent with ID {agent_id} not found.")
        except Exception as e:
            logger.error(f"Unexpected error fetching agent {agent_id}: {e}", exc_info=True)
            return f"Error: Could not fetch agent details for ID {agent_id}."

        # 2. Load LLM
        try:
            # We don't need token tracking callback here for the tool execution
            child_llm, _ = get_llm(agent_model.llm)
            if not child_llm:
                 raise ValueError("Failed to load LLM specified for the agent.")
            logger.debug(f"Successfully loaded LLM for agent {agent_id}")
        except Exception as e:
            logger.error(f"Error loading LLM for agent {agent_id}: {e}", exc_info=True)
            return f"Error: Could not load LLM for agent {agent_id}."

        # 3. Load Tools synchronously
        tools = []
        try:
            for tool_model in agent_model.tools.all():
                try:
                    # Use load_tool which handles instantiation from the model
                    loaded_tool = load_tool(tool_model)
                    if loaded_tool:
                        # TODO: Potentially apply AgentToolSetting overrides like in create_crewai_agents if needed
                        # For now, load the basic tool
                        tools.append(loaded_tool)
                        logger.debug(f"Loaded tool '{tool_model.name}' for agent {agent_id}")
                    else:
                        logger.warning(f"Failed to load tool instance for '{tool_model.name}' (ID: {tool_model.id}) for agent {agent_id}")
                except Exception as tool_load_error:
                    logger.error(f"Error loading tool '{tool_model.name}' (ID: {tool_model.id}) for agent {agent_id}: {tool_load_error}", exc_info=True)
                    # Decide whether to proceed without the tool or fail the whole delegation
                    # For now, let's skip the failing tool and log a warning
                    logger.warning(f"Skipping tool '{tool_model.name}' due to loading error.")
            logger.info(f"Loaded {len(tools)} tools for agent {agent_id}")
        except Exception as e:
            logger.error(f"Error accessing or iterating tools for agent {agent_id}: {e}", exc_info=True)
            return f"Error: Could not load tools for agent {agent_id}."

        # 3.5 Convert loaded tools to LangChain format
        langchain_tools = []
        for tool_instance in tools:
            try:
                if hasattr(tool_instance, 'args_schema') and tool_instance.args_schema:
                    # Use StructuredTool if args_schema is present
                    lc_tool = StructuredTool(
                        name=tool_instance.name,
                        description=tool_instance.description, # Use instance description
                        func=tool_instance.run, # Use the synchronous run method
                        coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None,
                        args_schema=tool_instance.args_schema
                    )
                else:
                    # Use standard Tool if no args_schema
                    lc_tool = Tool(
                        name=tool_instance.name,
                        description=tool_instance.description, # Use instance description
                        func=tool_instance.run,
                        coroutine=tool_instance.arun if hasattr(tool_instance, 'arun') else None
                    )
                langchain_tools.append(lc_tool)
            except Exception as conversion_error:
                logger.error(f"Error converting tool '{tool_instance.name}' to LangChain format: {conversion_error}", exc_info=True)
                logger.warning(f"Skipping tool '{tool_instance.name}' due to conversion error.")
        logger.info(f"Converted {len(langchain_tools)} tools to LangChain format for agent {agent_id}")

        # 4. Build LangChain prompt, agent, and AgentExecutor
        try:
            # Construct a simple system message from agent details
            base_system_content = f"Role: {agent_model.role}\nGoal: {agent_model.goal}\nBackstory: {agent_model.backstory}"
            if agent_model.system_template:
                # If a specific system template exists, prioritize it
                base_system_content = f"{agent_model.system_template}\n\n{base_system_content}"

            # --- Add Credentials Context --- 
            sc_credentials_json = "null" # Default if not found
            sc_instructions = ""
            try:
                # Fetch SC credentials (adjust setting names if needed)
                sc_client_id = getattr(settings, 'GOOGLE_OAUTH_SC_CLIENT_ID', None)
                sc_client_secret = getattr(settings, 'GOOGLE_OAUTH_SC_CLIENT_SECRET', None)
                
                if sc_client_id and sc_client_secret:
                    sc_credentials = {
                        # Include necessary fields expected by the tool, 
                        # e.g., client_id, client_secret. Add refresh/access tokens if needed and available.
                        "client_id": sc_client_id,
                        "client_secret": sc_client_secret,
                        # Placeholder: Add refresh_token etc. if needed by the tool's auth flow
                    }
                    sc_credentials_json = json.dumps(sc_credentials)
                    sc_instructions = f"""\n\nIMPORTANT OAUTH CREDENTIALS:
*   **Search Console Credentials:** ```json
{sc_credentials_json}
```
*   When using Google Search Console tools (like GoogleRankingsTool), you MUST provide the full Search Console Credentials dictionary shown above in the 'search_console_credentials' parameter of your tool input JSON blob."""
                else:
                    logger.warning(f"AgentDelegationTool: Search Console Client ID or Secret not found in settings. Child agent {agent_id} may fail on SC tools.")
            except Exception as cred_e:
                 logger.error(f"AgentDelegationTool: Error fetching SC credentials for child agent {agent_id}: {cred_e}", exc_info=True)
                 sc_instructions = "\n\nWarning: Could not automatically fetch Search Console credentials. Tool calls may fail."
            # --- End Credentials Context ---

            # Format tools for prompt using the LangChain-formatted tools
            tool_descriptions = [f"{lc_tool.name}: {lc_tool.description}" for lc_tool in langchain_tools]
            tool_names = [lc_tool.name for lc_tool in langchain_tools]
            
            # Create the structured chat prompt template with proper JSON formatting
            system_template = f'''{base_system_content}

You have access to the following tools:

{{tools}}

Use a json blob to specify a tool by providing an action key (tool name) and an action_input key (tool input).

Valid "action" values: "Final Answer" or {{tool_names}}

Provide only ONE action per $JSON_BLOB, as shown:

```
{{{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}}}
```

Follow this format:

Question: input question to answer
Thought: consider previous and subsequent steps
Action:
$JSON_BLOB

Observation: action result
... (repeat Thought/Action/Observation N times)
Thought: I know what to respond
Action:
{{{{
"action": "Final Answer",
"action_input": "Final response to human"
}}}}


Begin! Reminder to ALWAYS respond with a valid json blob of a single action. Use tools if necessary. Respond directly if appropriate.

{sc_instructions} # Add credential instructions here
'''

            # Create the prompt with the system template
            prompt = ChatPromptTemplate.from_messages([
                ("system", system_template),
                MessagesPlaceholder(variable_name="chat_history", optional=True),
                ("human", "{input}\n\n{agent_scratchpad}")
            ])
            
            # Partially fill system-level variables
            prompt = prompt.partial(
                tools="\n".join(tool_descriptions),
                tool_names=", ".join(tool_names)
            )

            # Create the agent using LangChain-formatted tools
            structured_agent = create_structured_chat_agent(
                llm=child_llm,
                tools=langchain_tools,
                prompt=prompt
            )

            # Create the AgentExecutor using LangChain-formatted tools
            agent_executor = AgentExecutor.from_agent_and_tools(
                agent=structured_agent,
                tools=langchain_tools,
                verbose=agent_model.verbose, # Use agent's verbosity setting
                max_iterations=agent_model.max_iter or 10, # Use agent's max_iter or default to 10
                handle_parsing_errors=True, # Handle potential output parsing errors
                # No memory needed for single-shot tool execution
                # No complex callbacks needed here
            )
            logger.debug(f"Created agent executor for agent {agent_id}")

        except Exception as e:
            logger.error(f"Error creating agent execution components for agent {agent_id}: {e}", exc_info=True)
            return f"Error: Failed to set up execution environment for agent {agent_id}."

        # 5. Invoke executor.invoke()
        try:
            logger.info(f"Invoking agent {agent_id} executor with prompt: '{prompt[:50]}...'")
            response = agent_executor.invoke({"input": prompt})
            output = response.get('output', None)

            if output is None:
                logger.error(f"Agent {agent_id} execution finished but produced no output. Response: {response}")
                return f"Error: Agent {agent_id} finished execution but produced no output."

            logger.info(f"Agent {agent_id} execution successful. Output: {str(output)[:100]}...")
            return str(output) # Ensure output is a string

        except Exception as e:
            logger.error(f"Error during agent {agent_id} execution: {e}", exc_info=True)
            # Provide a more informative error message if possible
            error_message = f"Error: Agent {agent_id} failed during execution. Reason: {e}"
            # Check for specific common errors if needed (e.g., max iterations)
            if "Agent stopped due to max iterations" in str(e):
                error_message = f"Error: Agent {agent_id} stopped due to reaching the maximum iteration limit."
            return error_message

        # Placeholder return until implementation is complete
        # return f"Placeholder: Agent {agent_id} ({agent_model.name}) fetched with LLM and {len(tools)} tools. Ready to process prompt: \'{prompt}\'"

    async def _arun(self, agent_id: int, prompt: str, **kwargs: Any) -> Any:
        """Asynchronous execution (Not Implemented)."""
        logger.warning("Asynchronous execution (_arun) is not implemented for AgentDelegationTool.")
        raise NotImplementedError("AgentDelegationTool does not support async execution yet.")

================
File: apps/agents/tools/business_credibility_tool/business_credibility_tool.py
================
from typing import Dict, Any, Type, List
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import json
import logging
from django.conf import settings
from langchain.prompts import ChatPromptTemplate
from langchain.schema import StrOutputParser
from apps.common.utils import get_llm
import re
from bs4 import BeautifulSoup
from datetime import datetime

logger = logging.getLogger(__name__)

class BusinessCredibilityToolSchema(BaseModel):
    """Input schema for BusinessCredibilityTool."""
    text_content: str = Field(..., description="The text content to analyze")
    html_content: str = Field(..., description="The HTML content to analyze")

class BusinessCredibilityTool(BaseTool):
    name: str = "Business Credibility Detector Tool"
    description: str = """
    Analyzes website content to detect business credibility signals including
    contact information, years in business, certifications, reviews, and services.
    """
    args_schema: Type[BaseModel] = BusinessCredibilityToolSchema

    def _extract_schema(self, html_content: str) -> Dict[str, Any]:
        """Extracts structured data (JSON-LD, potentially Microdata later) from HTML."""
        extracted_data = {
            "json-ld": []
            # Add keys for microdata, etc. later
        }
        try:
            soup = BeautifulSoup(html_content, 'html.parser')
            
            # Extract JSON-LD
            json_ld_scripts = soup.find_all('script', type='application/ld+json')
            for script in json_ld_scripts:
                try:
                    data = json.loads(script.string)
                    if data:
                        # Store as list if top-level is list, else wrap in list
                        if isinstance(data, list):
                            extracted_data["json-ld"].extend(data)
                        else:
                            extracted_data["json-ld"].append(data)
                except json.JSONDecodeError as e:
                    logger.warning(f"Failed to parse JSON-LD: {e} - Content: {script.string[:100]}...")
                except Exception as e:
                     logger.warning(f"Error processing JSON-LD script: {e}")

            # Placeholder for Microdata extraction later

        except Exception as e:
            logger.error(f"Error during schema extraction: {e}", exc_info=True)
            
        logger.debug(f"Extracted Schema.org Data (JSON-LD): {json.dumps(extracted_data['json-ld'])[:300]}...")
        return extracted_data

    def _process_schema(self, extracted_schema: Dict[str, Any]) -> Dict[str, List[Dict[str, Any]]]:
        """Processes extracted schema data to identify relevant types."""
        processed_data = {
            "LocalBusiness": [],
            "Service": [],
            "Product": [],
            "Review": [],
            "AggregateRating": [],
            # Add other relevant types if needed
        }
        target_types = set(processed_data.keys())

        # Process JSON-LD
        for item in extracted_schema.get("json-ld", []):
            item_types = item.get("@type", [])
            # Ensure item_types is a list
            if isinstance(item_types, str):
                item_types = [item_types]
            
            found_target_type = None
            for item_type in item_types:
                if item_type in target_types:
                    found_target_type = item_type
                    break # Found a relevant type for this item
            
            if found_target_type:
                processed_data[found_target_type].append(item)
                logger.debug(f"Found relevant schema type: {found_target_type}")

        # Placeholder for processing Microdata later

        logger.debug(f"Processed Schema Results: Found { {k: len(v) for k, v in processed_data.items() if v} }")
        return processed_data

    def _preprocess_content(self, text_content: str, html_content: str) -> Dict[str, Any]:
        """Pre-process content to detect common business information patterns."""
        # Phone number patterns
        phone_patterns = [
            r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b',  # 123-456-7890 or 1234567890
            r'\(\d{3}\)\s*\d{3}[-.]?\d{4}',     # (123) 456-7890
            r'\b\d{3}\s+\d{3}\s+\d{4}\b'        # 123 456 7890
        ]
        
        # Address patterns
        address_patterns = [
            r'\d+\s+[A-Za-z0-9\s,]+(?:Road|Rd|Street|St|Avenue|Ave|Boulevard|Blvd|Drive|Dr|Lane|Ln|Court|Ct|Way|Circle|Cir|Trail|Trl|Highway|Hwy|Route|Rte)[,.\s]+(?:[A-Za-z\s]+,\s*)?[A-Z]{2}\s+\d{5}(?:-\d{4})?',
            r'\d+\s+[A-Za-z\s]+(?:Road|Rd|Street|St|Avenue|Ave|Boulevard|Blvd|Drive|Dr|Lane|Ln|Court|Ct|Way|Circle|Cir|Trail|Trl|Highway|Hwy|Route|Rte)'
        ]
        
        # Business hours patterns
        hours_patterns = [
            r'\b(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)[a-z]*(?:day)?[-:\s]+(?:\d{1,2}(?::\d{2})?\s*(?:am|pm|AM|PM)[-\s]+\d{1,2}(?::\d{2})?\s*(?:am|pm|AM|PM))',
            r'\b(?:\d{1,2}:\d{2}|(?:1[0-2]|0?[1-9])(?::\d{2})?\s*(?:am|pm|AM|PM))[-\s]+(?:\d{1,2}:\d{2}|(?:1[0-2]|0?[1-9])(?::\d{2})?\s*(?:am|pm|AM|PM))'
        ]

        # Initialize results
        results = {
            "has_phone": False,
            "has_address": False,
            "has_hours": False,
            "found_patterns": {
                "phones": [],
                "addresses": [],
                "hours": []
            }
        }

        # Check footer and contact sections first
        if html_content:
            soup = BeautifulSoup(html_content, 'html.parser')
            footer = soup.find('footer')
            contact_section = soup.find(id=lambda x: x and 'contact' in x.lower()) or \
                            soup.find(class_=lambda x: x and 'contact' in x.lower())
            
            priority_sections = []
            if footer:
                priority_sections.append(footer.get_text())
            if contact_section:
                priority_sections.append(contact_section.get_text())
            
            # Check priority sections first
            for section in priority_sections:
                # Check phone patterns
                for pattern in phone_patterns:
                    phones = re.findall(pattern, section)
                    if phones:
                        results["has_phone"] = True
                        results["found_patterns"]["phones"].extend(phones)
                
                # Check address patterns
                for pattern in address_patterns:
                    addresses = re.findall(pattern, section)
                    if addresses:
                        results["has_address"] = True
                        results["found_patterns"]["addresses"].extend(addresses)
                
                # Check hours patterns
                for pattern in hours_patterns:
                    hours = re.findall(pattern, section)
                    if hours:
                        results["has_hours"] = True
                        results["found_patterns"]["hours"].extend(hours)

        # If not found in priority sections, check entire content
        if not (results["has_phone"] and results["has_address"] and results["has_hours"]):
            # Check phone patterns
            for pattern in phone_patterns:
                phones = re.findall(pattern, text_content)
                if phones:
                    results["has_phone"] = True
                    results["found_patterns"]["phones"].extend(phones)
            
            # Check address patterns
            for pattern in address_patterns:
                addresses = re.findall(pattern, text_content)
                if addresses:
                    results["has_address"] = True
                    results["found_patterns"]["addresses"].extend(addresses)
            
            # Check hours patterns
            for pattern in hours_patterns:
                hours = re.findall(pattern, text_content)
                if hours:
                    results["has_hours"] = True
                    results["found_patterns"]["hours"].extend(hours)

        # Remove duplicates
        results["found_patterns"]["phones"] = list(set(results["found_patterns"]["phones"]))
        results["found_patterns"]["addresses"] = list(set(results["found_patterns"]["addresses"]))
        results["found_patterns"]["hours"] = list(set(results["found_patterns"]["hours"]))

        return results

    def _run(
        self,
        text_content: str,
        html_content: str
    ) -> str:
        try:
            # --- Initialization ---
            credibility_signals = {
                "business_info": False,
                "years_in_business": False,
                "customer_reviews": False,
                "services_list": False,
                "certifications": False # Assuming certifications is a desired signal
            }
            signal_details = {
                "business_info": {"phones": [], "addresses": [], "hours": []},
                "years_in_business": None,
                "customer_reviews": {"reviews": [], "aggregate": None},
                "services_list": [],
                "certifications": []
            }
            
            # --- 1. Schema Extraction and Processing ---
            extracted_schema = self._extract_schema(html_content)
            processed_schema = self._process_schema(extracted_schema)

            # --- 2. Populate Signals/Details from Processed Schema ---
            # LocalBusiness Check
            if processed_schema["LocalBusiness"]:
                lb = processed_schema["LocalBusiness"][0] # Assume first one is primary
                phone = lb.get("telephone")
                address = lb.get("address") # Can be text or PostalAddress object
                hours = lb.get("openingHoursSpecification") or lb.get("openingHours")
                founding_date_str = lb.get("foundingDate") or lb.get("startDate")
                awards = lb.get("award") or lb.get("awards") # Handle plurals
                memberships = lb.get("memberOf")
                offers = lb.get("makesOffer") or lb.get("hasOfferCatalog")

                if phone:
                    credibility_signals["business_info"] = True
                    signal_details["business_info"]["phones"].append(str(phone))
                if address:
                    credibility_signals["business_info"] = True
                    # Extract address string representation
                    if isinstance(address, dict):
                         addr_parts = [address.get('streetAddress'), address.get('addressLocality'), address.get('addressRegion'), address.get('postalCode')]
                         signal_details["business_info"]["addresses"].append(", ".join(filter(None, addr_parts)))
                    else:
                         signal_details["business_info"]["addresses"].append(str(address))
                if hours:
                    credibility_signals["business_info"] = True
                    signal_details["business_info"]["hours"].append(str(hours)) # Store raw schema for now
                
                if founding_date_str:
                    try:
                        founding_year = int(datetime.strptime(founding_date_str, '%Y-%m-%d').year) # Assuming YYYY-MM-DD
                        current_year = datetime.now().year
                        years = current_year - founding_year
                        if years >= 0:
                             credibility_signals["years_in_business"] = True
                             signal_details["years_in_business"] = f"{years} years (since {founding_year})"
                    except ValueError: # Handle other date formats or just year
                         try: 
                              founding_year = int(founding_date_str) # Check if it's just YYYY
                              current_year = datetime.now().year
                              years = current_year - founding_year
                              if years >= 0:
                                   credibility_signals["years_in_business"] = True
                                   signal_details["years_in_business"] = f"{years} years (since {founding_year})"
                         except ValueError:
                              logger.warning(f"Could not parse foundingDate: {founding_date_str}")
                              signal_details["years_in_business"] = f"Date found: {founding_date_str}" # Store raw if unparseable

                if awards:
                    credibility_signals["certifications"] = True
                    signal_details["certifications"].extend([str(a) for a in awards] if isinstance(awards, list) else [str(awards)])
                if memberships:
                    credibility_signals["certifications"] = True
                    # memberships can be Organization or ProgramMembership
                    member_details = []
                    members_list = memberships if isinstance(memberships, list) else [memberships]
                    for member in members_list:
                         if isinstance(member, dict):
                              member_details.append(member.get('name') or member.get('programName') or str(member))
                         else:
                              member_details.append(str(member))
                    signal_details["certifications"].extend(filter(None, member_details))
                
                if offers:
                     credibility_signals["services_list"] = True
                     # Extract offer names/details if possible
                     offer_details = []
                     offers_list = offers if isinstance(offers, list) else [offers]
                     for offer in offers_list:
                          if isinstance(offer, dict):
                               item_offered = offer.get('itemOffered')
                               if isinstance(item_offered, dict):
                                    offer_details.append(item_offered.get('name') or str(item_offered))
                               elif item_offered:
                                    offer_details.append(str(item_offered))
                               elif offer.get('name'): 
                                    offer_details.append(offer.get('name'))
                               else:
                                    offer_details.append(str(offer))
                          else:
                               offer_details.append(str(offer))
                     signal_details["services_list"].extend(filter(None, offer_details))

            # Service/Product Check
            if processed_schema["Service"] or processed_schema["Product"]:
                credibility_signals["services_list"] = True
                for service in processed_schema["Service"]:
                    signal_details["services_list"].append(service.get("name") or str(service))
                for product in processed_schema["Product"]:
                     signal_details["services_list"].append(product.get("name") or str(product))

            # Review/AggregateRating Check
            if processed_schema["Review"]:
                credibility_signals["customer_reviews"] = True
                signal_details["customer_reviews"]["reviews"] = processed_schema["Review"] # Store full review objects
            if processed_schema["AggregateRating"]:
                agg = processed_schema["AggregateRating"][0] # Assume one
                if agg.get("reviewCount", 0) > 0 or agg.get("ratingValue") is not None:
                     credibility_signals["customer_reviews"] = True
                     signal_details["customer_reviews"]["aggregate"] = agg
            
            # --- 3. Regex Fallback for Business Info ---
            if not credibility_signals["business_info"]:
                 logger.debug("Schema did not contain business info, running regex preprocessing...")
                 preprocessed = self._preprocess_content(text_content, html_content)
                 if preprocessed["has_phone"] or preprocessed["has_address"] or preprocessed["has_hours"]:
                      credibility_signals["business_info"] = True
                      # Merge regex findings if schema was empty for these
                      if not signal_details["business_info"]["phones"]:
                           signal_details["business_info"]["phones"] = preprocessed["found_patterns"]["phones"]
                      if not signal_details["business_info"]["addresses"]:
                           signal_details["business_info"]["addresses"] = preprocessed["found_patterns"]["addresses"]
                      if not signal_details["business_info"]["hours"]:
                           signal_details["business_info"]["hours"] = preprocessed["found_patterns"]["hours"]
                      logger.debug("Found business info via regex fallback.")
                 else:
                      logger.debug("Regex preprocessing did not find business info either.")

            # --- 4. Determine Missing Signals ---
            missing_signals = [k for k, v in credibility_signals.items() if not v and k != "business_info"] # Exclude business_info here, handle it differently
            # Check if specific parts of business_info are missing even if flag is True
            if credibility_signals["business_info"]:
                 if not signal_details["business_info"]["phones"]:
                      missing_signals.append("business_info_phone")
                 if not signal_details["business_info"]["addresses"]:
                      missing_signals.append("business_info_address")
                 if not signal_details["business_info"]["hours"]:
                      missing_signals.append("business_info_hours")
            elif not credibility_signals["business_info"]: # If business_info is completely False
                 missing_signals.extend(["business_info_phone", "business_info_address", "business_info_hours"]) 

            # --- 5. Conditional LLM Call ---
            if missing_signals:
                logger.debug(f"Signals missing after Schema/Regex: {missing_signals}. Querying {settings.BUSINESS_CREDIBILITY_MODEL}...")
                # Get LLM
                llm, _ = get_llm(model_name=settings.BUSINESS_CREDIBILITY_MODEL, temperature=0.0)

                # Define signal mapping for prompt
                signal_prompt_map = {
                    "years_in_business": "- Years in business/establishment date",
                    "customer_reviews": "- Customer reviews/testimonials",
                    "services_list": "- Services/products offered",
                    "certifications": "- Professional certifications/licenses/awards/memberships",
                    "business_info_phone": "- Business phone number",
                    "business_info_address": "- Business physical address",
                    "business_info_hours": "- Business operating hours"
                }
                missing_signals_text = "\n".join([signal_prompt_map[s] for s in missing_signals if s in signal_prompt_map])

                # Create tailored prompt
                llm_prompt = ChatPromptTemplate.from_messages([
                    ("system", """You are an expert business analyst detecting specific missing credibility signals from website content.
                    You will be told which signals were already found via structured data or regex. Focus ONLY on finding the signals listed under 'Signals to Find'.
                    Analyze the HTML and Text content provided, paying attention to navigation, footers, contact/about sections, and common page structures.
                    Return your analysis ONLY for the requested missing signals as a clean JSON object. Do not include markdown formatting."""),
                    ("human", """\n                    Signals already found: {found_signals_summary}\n                    \n                    Signals to Find:\n                    {missing_signals_list}\n                    \n                    Analyze the website content below to find the missing signals listed above.\n                    \n                    Text Content:\n                    {text_content}\n                    \n                    HTML Content:\n                    {html_content}\n                    """)
                ])
                
                found_signals_summary = {k: v for k,v in credibility_signals.items() if v}
                
                llm_chain = llm_prompt | llm | StrOutputParser()
                llm_result_str = llm_chain.invoke({
                    "found_signals_summary": json.dumps(found_signals_summary),
                    "missing_signals_list": missing_signals_text,
                    "text_content": text_content,
                    "html_content": html_content
                })
                
                # Clean and parse LLM result
                llm_result_str = llm_result_str.strip().removeprefix("```json").removesuffix("```").strip()
                try:
                    llm_data = json.loads(llm_result_str)
                    logger.debug(f"LLM Analysis Result for Missing Signals: {llm_data}")

                    # Merge LLM findings
                    merged_business_info = False
                    # Map LLM response keys (descriptive) back to internal signal keys
                    llm_key_to_signal_map = {
                        "Years in business/establishment date": "years_in_business",
                        "Customer reviews/testimonials": "customer_reviews",
                        "Services/products offered": "services_list",
                        "Professional certifications/licenses/awards/memberships": "certifications",
                        "Business phone number": "business_info_phone",
                        "Business physical address": "business_info_address",
                        "Business operating hours": "business_info_hours"
                    }

                    # Iterate through the keys the LLM actually returned
                    for llm_key, detail_value in llm_data.items():
                        # Find the corresponding internal signal key
                        internal_signal = llm_key_to_signal_map.get(llm_key)
                        
                        # Proceed if we have a mapping and the LLM provided a non-False value
                        if internal_signal and detail_value is not False:
                            # Check if this signal was originally one of the missing ones we asked for
                            if internal_signal in missing_signals or (internal_signal.startswith("business_info_") and internal_signal in missing_signals):
                                if internal_signal.startswith("business_info_"):
                                    part = internal_signal.split("_")[-1] + "s" # e.g., phones, addresses, hours
                                    # Ensure detail_value is treated as a list for business info parts
                                    value_to_append = detail_value if isinstance(detail_value, list) else [str(detail_value)]
                                    if part in signal_details["business_info"] and not signal_details["business_info"][part]:
                                        signal_details["business_info"][part].extend(value_to_append)
                                        credibility_signals["business_info"] = True
                                        merged_business_info = True
                                elif internal_signal in credibility_signals:
                                    credibility_signals[internal_signal] = True
                                    if internal_signal in signal_details and not signal_details[internal_signal]: # Avoid overwriting schema/regex details unless empty
                                        # Special handling for years_in_business to extract from list if needed
                                        if internal_signal == "years_in_business":
                                            if isinstance(detail_value, list) and detail_value:
                                                signal_details[internal_signal] = str(detail_value[0]) # Take first item
                                            elif isinstance(detail_value, str):
                                                signal_details[internal_signal] = detail_value
                                            else:
                                                 signal_details[internal_signal] = "Found by LLM (Format unclear)"
                                        # For lists like services or certifications, ensure it's a list
                                        elif internal_signal in ["services_list", "certifications", "customer_reviews"]:
                                            if isinstance(detail_value, list):
                                                 signal_details[internal_signal] = detail_value
                                            elif detail_value: # Allow single strings for reviews too? Maybe not ideal.
                                                 signal_details[internal_signal] = [str(detail_value)] # Wrap single item in list
                                            # else: # Don't add fallback if LLM returned empty list []
                                            #     signal_details[internal_signal] = ["Found by LLM (Empty)"]
                                        elif detail_value:
                                            signal_details[internal_signal] = detail_value
                                        # else: # Don't add fallback if LLM returned empty value
                                        #    signal_details[internal_signal] = "Found by LLM (Empty)" 

                    if merged_business_info:
                        logger.debug("Updated business_info details based on LLM findings.")
                    
                except json.JSONDecodeError as e:
                    logger.error(f"Failed to parse LLM response for missing signals: {e} - Response: {llm_result_str[:200]}...")
                except Exception as e:
                    # Corrected f-string syntax below
                    logger.error(f"Error processing LLM response for missing signals: {e}", exc_info=True)
            else:
                 logger.debug("No missing signals found after Schema/Regex check. Skipping LLM.")

            # --- 6. Combine Results ---
            final_result = {
                "credibility_signals": credibility_signals,
                "signal_details": signal_details
            }
            
            logger.debug(f"Final Business credibility analysis result: {json.dumps(final_result)[:300]}..." )
            return json.dumps(final_result)

        except Exception as e:
            logger.error(f"Error in BusinessCredibilityTool _run: {str(e)}", exc_info=True)
            error_response = {
                "credibility_signals": {k: False for k in credibility_signals},
                "signal_details": {k: None for k in signal_details},
                "error": "Credibility analysis failed",
                "message": str(e)
            }
            return json.dumps(error_response)

================
File: apps/agents/tools/client_profile_tool/__init__.py
================
from .client_profile_tool import ClientProfileTool
from .org_aware_client_profile_tool import OrganizationAwareClientProfileTool

__all__ = ['ClientProfileTool', 'OrganizationAwareClientProfileTool']

================
File: apps/agents/tools/client_profile_tool/client_profile_tool.py
================
import logging
from typing import Type, Optional
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.tools.website_distiller_tool.website_distiller_tool import WebsiteDistillerTool
from apps.common.utils import get_llm
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
import json
from django.conf import settings
from markdown_it import MarkdownIt


logger = logging.getLogger(__name__)

class ClientProfileToolSchema(BaseModel):
    """Input schema for ClientProfileTool."""
    website_url: str = Field(..., description="The website URL to analyze for profile generation")
    client_name: str = Field(..., description="The name of the client for logging purposes")

    model_config = {
        "extra": "ignore"
    }

class ClientProfileTool(BaseTool):
    name: str = "Client Profile Generator Tool"
    description: str = """
    Analyzes a website to generate a comprehensive client profile by crawling the site,
    processing its content, and using AI to create a structured profile.
    """
    args_schema: Type[BaseModel] = ClientProfileToolSchema

    def _run(
        self,
        website_url: str,
        client_name: str,
    ) -> str:
        try:
            # Step 1: Log the operation
            logger.info(f"Generating profile for client: {client_name} from website: {website_url}")
            
            # Step 2: Get website content using WebsiteDistillerTool
            logger.info(f"Getting website content for: {website_url}")
            distiller = WebsiteDistillerTool()
            distilled_content = distiller._run(website_url=website_url)
            
            if not distilled_content:
                return json.dumps({
                    "error": "Content extraction failed",
                    "message": "No content was retrieved from the website"
                })

            # Parse the distilled content
            content_data = json.loads(distilled_content)
            if "error" in content_data:
                return json.dumps({
                    "error": "Content processing failed",
                    "message": content_data["message"]
                })

            website_text = content_data.get("processed_content", "")

            # Step 3: Generate profile using LLM
            logger.info("Generating client profile")
            model_name=settings.GENERAL_MODEL
            llm, _ = get_llm(model_name=model_name,temperature=0.0)  # Lower temperature for more focused output

            profile_prompt = ChatPromptTemplate.from_messages([
                ("system", "You are a business analyst creating detailed company profiles."),
                ("human", """
                <context>
                {text}
                </context>

                Generate Company Profile - Process the provided website crawl data to create a comprehensive yet concise company profile suitable for use as background context for LLM agents. The profile should provide a detailed and accurate overview of the company, its operations, mission, values, target audience, and unique selling propositions (USPs). The information must be factual, objective, and readily usable.

                Specific Instructions:

                Key Information Extraction: Identify and extract crucial details from the website text, including:

                Company Mission and Vision: Summarize the company's mission statement and long-term vision.

                Products/Services: Provide a clear and concise description of the company's offerings, highlighting key features and benefits. Categorize and organize these effectively.

                Target Audience: Describe the company's ideal customer profile(s), including demographics, psychographics, and needs.

                Unique Selling Propositions (USPs): Identify what sets the company apart from competitors and articulates its value proposition to customers.

                Company History (optional): If available, include a brief overview of the company's history and milestones.

                Company Culture and Values (optional): If evident on the website, describe the company's culture and values. This might be inferred from its communication style and messaging.

                Brand Voice and Tone: Analyze the website's overall tone and writing style to determine the appropriate voice for future communications.

                Concise and Structured Output: The profile should be well-organized and easy to read, using clear headings and bullet points where appropriate to improve readability and usability for the subsequent writing agent. Avoid unnecessary details and focus on delivering crucial information efficiently.

                Factual Accuracy: Ensure all information is factual and accurately reflects the content of the provided website data.
                
                Refrain from appending commentary. Be pithy.
                
                """)
            ])

            profile_chain = profile_prompt | llm | StrOutputParser()
            profile_content = profile_chain.invoke({"text": website_text})

            # Generate HTML version of profile content
            md=MarkdownIt()
            profile_content_html = md.render(profile_content)
            
            return json.dumps({
                "success": True,
                "profile": profile_content,
                "profile_html": profile_content_html,
                "website_url": website_url,
                "client_name": client_name,
                "website_text": website_text  # Include the distilled content for saving at the view level
            })

        except Exception as e:
            logger.error(f"Error in ClientProfileTool: {str(e)}")
            return json.dumps({
                "error": "Profile generation failed",
                "message": str(e)
            })

================
File: apps/agents/tools/client_profile_tool/org_aware_client_profile_tool.py
================
import logging
from typing import Type, Optional
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.tools.website_distiller_tool.website_distiller_tool import WebsiteDistillerTool
from apps.common.utils import get_llm
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
import json
from django.conf import settings
from django.core.exceptions import PermissionDenied
from markdown_it import MarkdownIt
from contextlib import contextmanager

# Import organization context utilities
from apps.organizations.utils import OrganizationContext, get_current_organization

# Import Client model - using Django's get_object_or_404 which you've modified to be organization-aware
from django.shortcuts import get_object_or_404
from apps.seo_manager.models import Client

logger = logging.getLogger(__name__)

class OrganizationAwareClientProfileToolSchema(BaseModel):
    """Input schema for OrganizationAwareClientProfileTool."""
    client_id: int = Field(..., description="The ID of the client to generate a profile for")

    model_config = {
        "extra": "ignore"
    }

class OrganizationAwareClientProfileTool(BaseTool):
    name: str = "Organization-Aware Client Profile Generator Tool"
    description: str = """
    Generates a comprehensive client profile by analyzing the client's website.
    This tool is organization-aware and can only access clients that the current user has permission to access.
    """
    args_schema: Type[BaseModel] = OrganizationAwareClientProfileToolSchema
    
    def _run(
        self,
        client_id: str,
    ) -> str:
        try:
            # Step 1: Log the operation start
            logger.info(f"Generating profile for client ID: {client_id}")
            
            # Step 2: Get the organization context
            organization = get_current_organization()
            if not organization:
                error_msg = "No active organization context found"
                logger.error(error_msg)
                return json.dumps({
                    "error": "Organization context error",
                    "message": error_msg
                })
            
            # Step 3: Get the client securely - this will automatically filter by organization
            # due to your organization-aware model managers and get_object_or_404 implementation
            try:
                client = get_object_or_404(Client, id=client_id)
                client_name = client.name
                website_url = client.website_url
                
                # Validate that we have a website URL
                if not website_url:
                    error_msg = f"Client {client_name} (ID: {client_id}) does not have a website URL"
                    logger.error(error_msg)
                    return json.dumps({
                        "error": "Missing website URL",
                        "message": error_msg
                    })
                
                logger.info(f"Retrieved client: {client_name}, website: {website_url}")
                
            except PermissionDenied:
                error_msg = f"Permission denied: You don't have access to client with ID {client_id}"
                logger.error(error_msg)
                return json.dumps({
                    "error": "Permission denied",
                    "message": error_msg
                })
            except Exception as e:
                error_msg = f"Error retrieving client with ID {client_id}: {str(e)}"
                logger.error(error_msg)
                return json.dumps({
                    "error": "Client retrieval error",
                    "message": error_msg
                })
            
            # Step 4: Get website content using WebsiteDistillerTool
            logger.info(f"Getting website content for: {website_url}")
            distiller = WebsiteDistillerTool()
            distilled_content = distiller._run(website_url=website_url)
            
            if not distilled_content:
                return json.dumps({
                    "error": "Content extraction failed",
                    "message": "No content was retrieved from the website"
                })

            # Parse the distilled content
            content_data = json.loads(distilled_content)
            if "error" in content_data:
                return json.dumps({
                    "error": "Content processing failed",
                    "message": content_data["message"]
                })

            website_text = content_data.get("processed_content", "")

            # Step 5: Generate profile using LLM
            logger.info("Generating client profile")
            model_name = settings.GENERAL_MODEL
            llm, _ = get_llm(model_name=model_name, temperature=0.0)  # Lower temperature for more focused output

            profile_prompt = ChatPromptTemplate.from_messages([
                ("system", "You are a business analyst creating detailed company profiles."),
                ("human", """
                <context>
                {text}
                </context>

                Generate Company Profile - Process the provided website crawl data to create a comprehensive yet concise company profile suitable for use as background context for LLM agents. The profile should provide a detailed and accurate overview of the company, its operations, mission, values, target audience, and unique selling propositions (USPs). The information must be factual, objective, and readily usable.

                Specific Instructions:

                Key Information Extraction: Identify and extract crucial details from the website text, including:

                Company Mission and Vision: Summarize the company's mission statement and long-term vision.

                Products/Services: Provide a clear and concise description of the company's offerings, highlighting key features and benefits. Categorize and organize these effectively.

                Target Audience: Describe the company's ideal customer profile(s), including demographics, psychographics, and needs.

                Unique Selling Propositions (USPs): Identify what sets the company apart from competitors and articulates its value proposition to customers.

                Company History (optional): If available, include a brief overview of the company's history and milestones.

                Company Culture and Values (optional): If evident on the website, describe the company's culture and values. This might be inferred from its communication style and messaging.

                Brand Voice and Tone: Analyze the website's overall tone and writing style to determine the appropriate voice for future communications.

                Concise and Structured Output: The profile should be well-organized and easy to read, using clear headings and bullet points where appropriate to improve readability and usability for the subsequent writing agent. Avoid unnecessary details and focus on delivering crucial information efficiently.

                Factual Accuracy: Ensure all information is factual and accurately reflects the content of the provided website data.
                
                Refrain from appending commentary. Be pithy.
                
                """)
            ])

            profile_chain = profile_prompt | llm | StrOutputParser()
            profile_content = profile_chain.invoke({"text": website_text})

            # Generate HTML version of profile content
            md = MarkdownIt()
            profile_content_html = md.render(profile_content)
            
            # Return the profile with client and organization context
            return json.dumps({
                "success": True,
                "profile": profile_content,
                "profile_html": profile_content_html,
                "client_id": client_id,
                "client_name": client_name,
                "website_url": website_url,
                "organization_id": str(organization.id),
                "organization_name": organization.name,
                "website_text": website_text  # Include the distilled content for saving at the view level
            })

        except Exception as e:
            logger.error(f"Error in OrganizationAwareClientProfileTool: {str(e)}")
            return json.dumps({
                "error": "Profile generation failed",
                "message": str(e)
            })

================
File: apps/agents/tools/code_interpreter_tool/code_interpreter_tool.py
================
import importlib.util
import os
from typing import List, Optional, Type
import json
import logging
from django.conf import settings

import docker
from pydantic import BaseModel, Field

from apps.agents.tools.base_tool import BaseTool

logger = logging.getLogger(__name__)


class CodeInterpreterSchema(BaseModel):
    """Input for CodeInterpreterTool."""
    code: str = Field(
        ...,
        description="Python3 code used to be interpreted in the Docker container. ALWAYS PRINT the final result and the output of the code",
    )

    libraries_used: List[str] = Field(
        ...,
        description="List of libraries used in the code with proper installing names separated by commas. Example: numpy,pandas,beautifulsoup4",
    )


class CodeInterpreterTool(BaseTool):
    name: str = "Code Interpreter"
    description: str = "Interprets Python3 code strings with a final print statement."
    args_schema: Type[BaseModel] = CodeInterpreterSchema
    default_image_tag: str = "code-interpreter:latest"
    code: Optional[str] = None
    user_dockerfile_path: Optional[str] = None

    @staticmethod
    def _get_installed_package_path():
        spec = importlib.util.find_spec("crewai_tools")
        return os.path.dirname(spec.origin)

    def _verify_docker_image(self) -> None:
        """
        Verify if the Docker image is available. Optionally use a user-provided Dockerfile.
        """
        client = docker.from_env()

        try:
            client.images.get(self.default_image_tag)

        except docker.errors.ImageNotFound:
            if self.user_dockerfile_path and os.path.exists(self.user_dockerfile_path):
                dockerfile_path = self.user_dockerfile_path
            else:
                package_path = self._get_installed_package_path()
                dockerfile_path = os.path.join(
                    package_path, "tools/code_interpreter_tool"
                )
                if not os.path.exists(dockerfile_path):
                    raise FileNotFoundError(
                        f"Dockerfile not found in {dockerfile_path}"
                    )

            client.images.build(
                path=dockerfile_path,
                tag=self.default_image_tag,
                rm=True,
            )

    def _run(self, code: str = None, libraries_used: List[str] = None) -> str:
        """Run code in Docker container with explicit parameters"""
        try:
            # Log raw input for debugging
            logger.debug(f"CodeInterpreterTool received: code={type(code)}, libraries={type(libraries_used)}")
            
            # Comprehensive input validation and normalization
            if code is None:
                return "Error: No code provided to execute"
            
            # Handle various input formats that might cause the ConverterError
            # Case 1: If code is a list, we need special handling
            if isinstance(code, list):
                if len(code) > 0:
                    first_item = code[0]
                    # Case 1a: List containing a dict with 'code' key
                    if isinstance(first_item, dict) and 'code' in first_item:
                        libraries_used = first_item.get('libraries_used', [])
                        code = first_item['code']
                    # Case 1b: List containing the code as a string
                    elif isinstance(first_item, str):
                        code = "\n".join(str(item) for item in code)
                    # Case 1c: Other list format - convert to string
                    else:
                        code = str(code)
            
            # Case 2: If code is a dict with 'code' key
            elif isinstance(code, dict) and 'code' in code:
                libraries_used = code.get('libraries_used', libraries_used or [])
                code = code['code']
            
            # Case 3: Ensure code is a string
            if not isinstance(code, str):
                code = str(code)
            
            # Case 4: Ensure libraries_used is a list of strings
            if libraries_used is None:
                libraries_used = []
            elif isinstance(libraries_used, str):
                libraries_used = [lib.strip() for lib in libraries_used.split(',') if lib.strip()]
            elif not isinstance(libraries_used, list):
                libraries_used = [str(libraries_used)]
            
            # Sanitize libraries to ensure they're all strings
            libraries_used = [str(lib) for lib in libraries_used]
            
            # Log the processed inputs
            logger.debug(f"Processed code (first 100 chars): {code[:100]}...")
            logger.debug(f"Processed libraries: {libraries_used}")
            
            # Execute the code in Docker
            return self.run_code_in_docker(code, libraries_used)
            
        except Exception as e:
            logger.error(f"Error in CodeInterpreterTool._run: {str(e)}", exc_info=True)
            return f"Error executing code: {str(e)}"

    def _install_libraries(
        self, container: docker.models.containers.Container, libraries: List[str]
    ) -> None:
        """
        Install missing libraries in the Docker container
        """
        for library in libraries:
            container.exec_run(f"pip install {library}")

    def _init_docker_container(self) -> docker.models.containers.Container:
        container_name = "code-interpreter"
        client = docker.from_env()
        current_path = os.getcwd()

        # Check if the container is already running
        try:
            existing_container = client.containers.get(container_name)
            existing_container.stop()
            existing_container.remove()
        except docker.errors.NotFound:
            pass  # Container does not exist, no need to remove

        return client.containers.run(
            self.default_image_tag,
            detach=True,
            tty=True,
            working_dir="/workspace",
            name=container_name,
            volumes={current_path: {"bind": "/workspace", "mode": "rw"}},  # type: ignore
        )

    def run_code_in_docker(self, code: str, libraries_used: List[str]) -> str:
        try:
            # Additional validation before running in Docker
            if not code or not isinstance(code, str):
                return "Error: Empty or invalid code provided"
                
            self._verify_docker_image()
            container = self._init_docker_container()
            
            # Install libraries with error handling
            for library in libraries_used:
                try:
                    logger.debug(f"Installing library: {library}")
                    result = container.exec_run(f"pip install {library}")
                    if result.exit_code != 0:
                        logger.warning(f"Failed to install library {library}: {result.output.decode('utf-8')}")
                except Exception as e:
                    logger.warning(f"Error installing library {library}: {str(e)}")
            
            # Escape code for proper execution in shell
            escaped_code = code.replace('"', '\\"').replace('$', '\\$')
            
            # Write code to a file instead of executing directly to avoid shell escaping issues
            file_path = "/tmp/code_to_execute.py"
            write_cmd = f'echo "{escaped_code}" > {file_path}'
            container.exec_run(write_cmd)
            
            # Execute the file instead of passing code directly
            cmd_to_run = f'python3 {file_path}'
            
            logger.debug(f"Executing code in container using file: {file_path}")
            exec_result = container.exec_run(cmd_to_run)
            
            # Clean up
            try:
                container.exec_run(f'rm {file_path}')
                container.stop()
                container.remove()
            except Exception as e:
                logger.warning(f"Error cleaning up container: {str(e)}")
            
            output = exec_result.output.decode("utf-8", errors="replace")
            if exec_result.exit_code != 0:
                logger.warning(f"Code execution failed with exit code {exec_result.exit_code}")
                return f"Something went wrong while running the code (exit code {exec_result.exit_code}): \n{output}"
            
            return output
        except Exception as e:
            logger.error(f"Error in run_code_in_docker: {str(e)}", exc_info=True)
            return f"Docker execution error: {str(e)}"

================
File: apps/agents/tools/competitor_tools/competitor_tools.py
================
import os
import requests
from typing import Any, Type, List, Dict, Optional
from pydantic import BaseModel, Field, ConfigDict
from apps.agents.tools.base_tool import BaseTool
import logging
import pandas as pd
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

BASE_URL = os.getenv('DATAFORSEO_BASE_URL', 'https://api.dataforseo.com')

class CompetitorsDomainInput(BaseModel):
    model_config = ConfigDict(
        extra='ignore',
        arbitrary_types_allowed=True
    )
    
    website_url: str = Field(description="Fully qualified domain name (FQDN) for competitor analysis")
    # location_code: int = Field(default=2840, description="Location code for the analysis")
    # language_code: str = Field(default="en", description="Language code for the analysis")
    # min_intersection_percentile: float = Field(
    #     default=25.0,
    #     description="Minimum percentile for keyword intersections (0-100)",
    #     ge=0.0,
    #     le=100.0
    # )
    # max_traffic_ratio: float = Field(
    #     default=100.0,
    #     description="Maximum ratio of competitor's traffic value to target site's traffic value",
    #     gt=0.0
    # )

class CompetitorsDomainTool(BaseTool):
    model_config = ConfigDict(
        extra='ignore',
        arbitrary_types_allowed=True
    )
    
    name: str = "Competitors Domain"
    description: str = "Provides a list of competitor domains with various metrics"
    args_schema: Type[BaseModel] = CompetitorsDomainInput

    @staticmethod
    def get_fqdn(url: str) -> str:
        parsed_url = urlparse(url)
        domain = parsed_url.netloc or parsed_url.path
        
        # Remove www. prefix if present
        if domain.startswith('www.'):
            domain = domain[4:]
            
        return domain

    def _run(self, website_url: str, location_code: int = 2840, language_code: str = "en", 
             min_intersection_percentile: float = 25.0, max_traffic_ratio: float = 100.0, **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/dataforseo_labs/google/competitors_domain/live"
        
        # Extract FQDN from the provided URL
        fqdn = self.get_fqdn(website_url)
        
        payload = [
            {
                "target": fqdn,
                "location_code": location_code,
                "language_code": language_code,
                "exclude_top_domains": False,
                "include_clickstream_data": False,
                "item_types": ["organic"],
                "limit": 100,
                "order_by": ["intersections,desc"]
            }
        ]
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(url, json=payload, headers=headers, auth=cred)
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error making request to DataForSEO: {e}")
            raise e

        try:
            results = self._transform_competitor_data(
                response.json(), 
                website_url, 
                min_intersection_percentile, 
                max_traffic_ratio
            )
        except Exception as e:
            logger.error(f"Error transforming competitor data: {e}")
            raise e

        return results

    def _transform_competitor_data(self, data: Dict, website_url: str, 
                                  min_intersection_percentile: float = 25.0, 
                                  max_traffic_ratio: float = 100.0) -> str:
        try:
            if data.get('tasks_error', 0) > 0:
                error_message = data.get('tasks', [{}])[0].get('status_message', 'Unknown error')
                return f"Error: {error_message}"

            all_results = data.get('tasks', [])[0].get('result', [])[0].get('items', [])
            if not all_results:
                return "Error: No results found in the response"

            # Create a DataFrame from the results
            df = pd.DataFrame(all_results)

            # Extract necessary fields and calculate additional metrics
            df['avg_position'] = df['avg_position'].round(2)
            df['etv'] = df['full_domain_metrics'].apply(lambda x: x['organic']['etv'])
            df['estimated_paid_traffic_cost'] = df['full_domain_metrics'].apply(lambda x: x['organic']['estimated_paid_traffic_cost'])
            df['rank_distribution_top_10'] = df['full_domain_metrics'].apply(lambda x: x['organic']['pos_4_10'])
            df['rank_distribution_11_20'] = df['full_domain_metrics'].apply(lambda x: x['organic']['pos_11_20'])
            df['rank_distribution_21_100'] = df['full_domain_metrics'].apply(lambda x: sum(x['organic'][f'pos_{i}_{i+9}'] for i in range(21, 100, 10)))

            # Get target site's metrics
            target_domain = self.get_fqdn(website_url)
            target_df = df[df['domain'] == target_domain]
            
            if target_df.empty:
                return f"Error: Target domain '{target_domain}' not found in the API results. Please verify the domain is correct."
            
            target_site = target_df.iloc[0]
            target_etv = target_site['etv']

            # Calculate intersection percentile threshold
            min_intersections = df['intersections'].quantile(min_intersection_percentile / 100)

            # Filter for relevant competitors
            df = df[
                # Must have meaningful intersection (keyword overlap)
                (df['intersections'] >= min_intersections) &
                # Filter based on relative traffic value
                (df['etv'] <= target_etv * max_traffic_ratio)
            ]

            # Sort by relevance (using intersections as primary metric)
            df = df.sort_values('intersections', ascending=False)

            # Define the columns to include in the output
            columns = [
                'domain', 'avg_position', 'intersections', 'etv', 
                'estimated_paid_traffic_cost', 'rank_distribution_top_10', 
                'rank_distribution_11_20', 'rank_distribution_21_100'
            ]
            result_df = df[columns]

            # Convert the DataFrame to CSV format
            csv_output = result_df.to_csv(index=False)
            return csv_output

        except Exception as e:
            logger.error(f"Error transforming competitor data: {e}")
            return f"Error: {str(e)}"

class KeywordTools:
    @staticmethod
    def _dataforseo_credentials():
        login = os.environ["DATAFORSEO_EMAIL"]
        password = os.environ["DATAFORSEO_PASSWORD"]
        return login, password

================
File: apps/agents/tools/compression_tool/__init__.py
================
from .compression_tool import CompressionTool, CompressionToolSchema

__all__ = ['CompressionTool', 'CompressionToolSchema']

================
File: apps/agents/tools/compression_tool/compression_tool.py
================
import os
from typing import Any, Type, List, Dict, Optional
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.common.utils import get_llm, tokenize
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain.text_splitter import RecursiveCharacterTextSplitter
import tiktoken
from django.conf import settings
import json
import logging

logger = logging.getLogger(__name__)

class CompressionToolSchema(BaseModel):
    """Input schema for CompressionTool."""
    content: str = Field(..., description="The text content to process and organize")
    max_tokens: int = Field(default=16384, description="Maximum number of tokens in the processed output")
    detail_level: str = Field(
        default="comprehensive",
        description="Detail level: 'comprehensive' (preserve all details), 'detailed' (preserve most details), or 'focused' (key details only)"
    )

class CompressionTool(BaseTool):
    name: str = "Advanced Text Processing and Organization Tool"
    description: str = """
    Processes and organizes text content while preserving important information using advanced NLP techniques.
    Features semantic chunking, intelligent note-taking, and configurable detail levels.
    """
    args_schema: Type[BaseModel] = CompressionToolSchema
    
    modelname: str = Field(default=settings.SUMMARIZER)
    llm: Optional[Any] = Field(default=None)
    token_counter_callback: Optional[Any] = Field(default=None)
    tokenizer: Any = Field(default_factory=lambda: tiktoken.get_encoding("cl100k_base"))

    def __init__(self, **data):
        super().__init__(**data)
        self.llm, self.token_counter_callback = get_llm(self.modelname, temperature=0.0)

    def _create_semantic_chunks(self, content: str, chunk_size: int) -> List[str]:
        """Split content into semantic chunks using recursive character splitting."""
        splitter = RecursiveCharacterTextSplitter(
            chunk_size=chunk_size,
            chunk_overlap=100,
            length_function=lambda x: len(self.tokenizer.encode(x)),
            separators=["\n\n", "\n", ". ", ", ", " "]
        )
        return splitter.split_text(content)

    def _get_processing_prompt(self, detail_level: str) -> str:
        """Get the appropriate processing prompt based on detail level."""
        prompts = {
            "comprehensive": """
            You are a meticulous note-taker with perfect recall. Your task is to process this text into detailed, organized notes:

            Guidelines:
            - Capture EVERY piece of information, no matter how small
            - Maintain all technical details, numbers, and specific examples
            - Preserve exact terminology and domain-specific language
            - Keep all dates, names, and references
            - Structure information in a clear, hierarchical format
            - Use bullet points and sub-bullets for organization
            - Remove ONLY exact duplicates of information
            - Keep all nuances and contextual details
            - Maintain the original meaning and implications
            - Include ALL supporting evidence and explanations
            
            Text to process:
            ```{content}```
            """,
            
            "detailed": """
            You are a thorough note-taker with excellent attention to detail. Your task is to process this text into well-organized notes:

            Guidelines:
            - Capture all significant information and supporting details
            - Maintain technical details and specific examples
            - Keep all important terminology and domain-specific language
            - Preserve relevant dates, names, and references
            - Structure information in a clear, logical format
            - Use bullet points and sub-bullets for organization
            - Remove only clearly redundant information
            - Maintain important nuances and context
            - Keep the original meaning and key implications
            - Include relevant supporting evidence
            
            Text to process:
            ```{content}```
            """,
            
            "focused": """
            You are a precise note-taker focusing on key information. Your task is to process this text into clear, focused notes:

            Guidelines:
            - Capture all key information and essential details
            - Maintain critical technical details and examples
            - Keep important terminology and specialized language
            - Preserve crucial dates, names, and references
            - Structure information in a clear, concise format
            - Use bullet points and sub-bullets for organization
            - Remove redundant information while keeping unique details
            - Maintain critical nuances and context
            - Preserve the core meaning and implications
            - Include key supporting evidence
            
            Text to process:
            ```{content}```
            """
        }
        return prompts.get(detail_level, prompts["comprehensive"])

    def _process_chunk(self, chunk: str, detail_level: str) -> str:
        """Process a single chunk of text into detailed notes."""
        process_prompt = ChatPromptTemplate.from_messages([
            ("system", "You are a detail-oriented note-taker who never loses information. Your notes should be thorough and well-organized."),
            ("human", self._get_processing_prompt(detail_level))
        ])
        
        process_chain = process_prompt | self.llm | StrOutputParser()
        return process_chain.invoke({'content': chunk})

    def _deduplicate_content(self, chunks: List[str]) -> List[str]:
        """Remove exact duplicates while preserving unique information."""
        dedup_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a detail-preserving content organizer. Your task is to:
            1. Identify and remove ONLY exact duplicates of information
            2. Preserve ALL unique details, even if similar
            3. Maintain ALL specific examples, numbers, and technical details
            4. Keep ALL contextual information and nuances
            5. Ensure no information is lost in the process
            6. Organize related information together logically
            """),
            ("human", "Text sections to organize:\n{chunks}")
        ])
        
        dedup_chain = dedup_prompt | self.llm | StrOutputParser()
        combined_chunks = "\n=====\n".join(chunks)
        result = dedup_chain.invoke({'chunks': combined_chunks})
        return result.split("\n=====\n")

    def _run(
        self,
        content: str,
        max_tokens: int = 16384,
        detail_level: str = "comprehensive",
        **kwargs: Any
    ) -> str:
        try:
            # Validate input
            if not content or not isinstance(content, str):
                return json.dumps({
                    "error": "Invalid input",
                    "message": "Content must be a non-empty string"
                })

            content_tokens = tokenize(content, self.tokenizer)
            logger.info(f"Original content tokens: {content_tokens}")

            if content_tokens <= max_tokens:
                processed_content = self._process_chunk(content, detail_level)
                final_tokens = tokenize(processed_content, self.tokenizer)
                logger.info(f"Processed content tokens (single chunk): {final_tokens}")
                return json.dumps({
                    "processed_content": processed_content,
                    "original_tokens": content_tokens,
                    "final_tokens": final_tokens,
                    "reduction_ratio": final_tokens / content_tokens,
                    "llm_input_tokens": self.token_counter_callback.input_tokens,
                    "llm_output_tokens": self.token_counter_callback.output_tokens
                })

            # Calculate chunk size based on max_tokens
            chunk_size = max_tokens 
            
            # Create semantic chunks
            chunks = self._create_semantic_chunks(content, chunk_size)
            logger.info(f"Created {len(chunks)} semantic chunks")
            
            # Process chunks
            processed_chunks = []
            for i, chunk in enumerate(chunks):
                logger.info(f"Processing chunk {i+1}/{len(chunks)}")
                processed_chunk = self._process_chunk(chunk, detail_level)
                processed_chunks.append(processed_chunk)
                logger.info(f"Chunk {i+1} tokens: {tokenize(processed_chunk, self.tokenizer)}")
            
            # Deduplicate if needed
            if len(processed_chunks) > 1:
                logger.info("Deduplicating chunks")
                processed_chunks = self._deduplicate_content(processed_chunks)
            
            # Join chunks and check final token count
            processed_content = "\n\n".join(processed_chunks)
            final_tokens = tokenize(processed_content, self.tokenizer)
            logger.info(f"Final tokens after joining chunks: {final_tokens}")
            
            # If still too long, process again with focused detail level
            if final_tokens > max_tokens:
                logger.info("Performing second processing pass")
                processed_content = self._process_chunk(processed_content, "focused")
                final_tokens = tokenize(processed_content, self.tokenizer)
                logger.info(f"Final tokens after second pass: {final_tokens}")
            
            result = {
                "processed_content": processed_content,
                "original_tokens": content_tokens,
                "final_tokens": final_tokens,
                "reduction_ratio": final_tokens / content_tokens,
                "llm_input_tokens": self.token_counter_callback.input_tokens,
                "llm_output_tokens": self.token_counter_callback.output_tokens
            }
            
            # Reset the token counter for the next run
            self.token_counter_callback.input_tokens = 0
            self.token_counter_callback.output_tokens = 0
            
            return json.dumps(result)

        except Exception as e:
            logger.error(f"Error in CompressionTool: {str(e)}")
            return json.dumps({
                "error": "Processing failed",
                "message": str(e)
            })

================
File: apps/agents/tools/content_expertise_tool/content_expertise_tool.py
================
from typing import Dict, Any, Type
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import json
import logging
from django.conf import settings
from langchain.prompts import ChatPromptTemplate
from langchain.schema import StrOutputParser
from apps.common.utils import get_llm

logger = logging.getLogger(__name__)

class ContentExpertiseToolSchema(BaseModel):
    """Input schema for ContentExpertiseTool."""
    text_content: str = Field(..., description="The text content to analyze")
    html_content: str = Field(..., description="The HTML content to analyze")
    content_type: str = Field(..., description="Type of content (blog, article, news)")
    url: str = Field(..., description="URL of the content")

class ContentExpertiseTool(BaseTool):
    name: str = "Content Expertise Detector Tool"
    description: str = """
    Analyzes content to detect expertise, authority, and trust signals including
    author expertise, content quality, citations, factual accuracy, and more.
    """
    args_schema: Type[BaseModel] = ContentExpertiseToolSchema

    def _run(
        self,
        text_content: str,
        html_content: str,
        content_type: str,
        url: str
    ) -> str:
        try:
            # Get LLM
            llm, _ = get_llm(model_name=settings.GENERAL_MODEL, temperature=0.0)

            # Create prompt for expertise analysis
            expertise_prompt = ChatPromptTemplate.from_messages([
                ("system", """You are an expert content analyst evaluating content quality and expertise signals.
                Return your analysis as a clean JSON object without any markdown formatting."""),
                ("human", """
                Analyze the provided content for expertise, authority, and trust signals.
                Return a JSON object with two sections:
                1. expertise_signals: Dictionary of boolean indicators for each signal
                2. signal_details: Specific details found for each signal

                Focus on:
                - Author Information (name, bio, credentials, links to profile)
                - Content Quality (depth, comprehensiveness, technical accuracy)
                - Citations and References (academic citations, expert quotes, data sources)
                - Factual Accuracy (fact-checking elements, source attribution)
                - Content Structure (organization, table of contents, section headers)
                - Topic Coverage (depth vs. superficial)
                - Schema Markup (Article, BlogPosting, NewsArticle)
                - Content Freshness (publish/update dates)
                
                Content Type: {content_type}
                URL: {url}
                
                Text Content:
                {text_content}
                
                HTML Content:
                {html_content}
                """)
            ])

            # Run analysis
            analysis_chain = expertise_prompt | llm | StrOutputParser()
            result = analysis_chain.invoke({
                "content_type": content_type,
                "url": url,
                "text_content": text_content,
                "html_content": html_content
            })
            
            # Clean the result of any markdown formatting
            result = result.strip()
            if result.startswith("```json"):
                result = result[7:]  # Remove ```json prefix
            if result.endswith("```"):
                result = result[:-3]  # Remove ``` suffix
            result = result.strip()
            
            logger.debug(f"Content expertise analysis result: {result[:200]}...")
            
            # Validate JSON before returning
            json.loads(result)  # This will raise an exception if invalid
            return result

        except Exception as e:
            logger.error(f"Error in ContentExpertiseTool: {str(e)}")
            return json.dumps({
                "error": "Expertise analysis failed",
                "message": str(e)
            })

================
File: apps/agents/tools/crawl_website_tool/__init__.py
================
from .crawl_website_tool import CrawlWebsiteTool, CrawlWebsiteToolSchema, OutputType, CacheMode

__all__ = ['CrawlWebsiteTool', 'CrawlWebsiteToolSchema', 'OutputType', 'CacheMode']

================
File: apps/agents/tools/crawl_website_tool/crawl_website_tool.py
================
"""
Tool for crawling websites using the new scraper architecture.
"""
import logging
import json
import re
from typing import Optional, Dict, Any, Type, List, Union
from urllib.parse import urlparse
from enum import Enum
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from django.conf import settings
from apps.agents.utils.scrape_url import crawl_website, is_excluded_url

logger = logging.getLogger(__name__)

class OutputType(str, Enum):
    """Enum for output types."""
    HTML = "html"
    CLEANED_HTML = "cleaned_html"
    MARKDOWN = "markdown"
    TEXT = "text"
    METADATA = "metadata"
    FULL = "full"

class CacheMode(str, Enum):
    """Enum for cache modes."""
    ENABLED = "enabled"
    DISABLED = "disabled"
    READ_ONLY = "read_only"
    WRITE_ONLY = "write_only"
    BYPASS = "bypass"

class CrawlWebsiteToolSchema(BaseModel):
    """Schema for the Crawl Website Tool."""
    website_url: str = Field(
        ...,
        description="URL of the website to crawl"
    )
    max_pages: int = Field(
        100,
        description="Maximum number of pages to crawl (default: 100)"
    )
    max_depth: int = Field(
        3,
        description="Maximum depth to crawl (default: 3)"
    )
    output_type: str = Field(
        "markdown",
        description="Type of output to return (html, cleaned_html, markdown, text, metadata, full)"
    )
    include_patterns: Optional[List[str]] = Field(
        None,
        description="URL patterns to include in crawl (e.g., ['/blog/.*'])"
    )
    exclude_patterns: Optional[List[str]] = Field(
        None,
        description="URL patterns to exclude from crawl (e.g., ['/admin/.*'])"
    )
    wait_for: Optional[str] = Field(
        None,
        description="Wait for element or time in milliseconds"
    )
    css_selector: Optional[str] = Field(
        None,
        description="CSS selector to extract content from"
    )

class CrawlWebsiteTool(BaseTool):
    """Tool for crawling websites."""
    name: str = "Crawl and Read Website Content"
    description: str = """A tool that can crawl websites and extract content in various formats (HTML, cleaned HTML, metadata, or markdown)."""
    args_schema: Type[BaseModel] = CrawlWebsiteToolSchema

    def _run(self, website_url: str, user_id: Optional[int] = None, max_pages: int = 100, max_depth: int = 3,
             wait_for: Optional[str] = None, css_selector: Optional[str] = None,
             include_patterns: Optional[List[str]] = None, exclude_patterns: Optional[List[str]] = None,
             output_type: str = "markdown",
             progress_callback: Optional[callable] = None,
             **kwargs: Any) -> str:
        """Run the website crawling tool."""
        try:
            # Get current task if available (keep for compatibility if needed, but prefer callback)
            current_task = kwargs.get('task', None)

            # Ensure output_type is valid
            try:
                output_type_enum = OutputType(output_type.lower())
            except ValueError:
                output_type_enum = OutputType.MARKDOWN

            # Parse URLs
            parsed_url = urlparse(website_url)
            domain = parsed_url.netloc

            # Check if URL should be excluded
            if is_excluded_url(website_url):
                logger.info(f"URL {website_url} is in the exclusion list, skipping crawl")
                return json.dumps({
                    "status": "error",
                    "message": f"URL {website_url} is in the exclusion list, skipping crawl"
                })

            # Normalize output type
            output_format = output_type_enum.value

            # Map output format to the format expected by crawl_website
            format_mapping = {
                "html": "html",
                "cleaned_html": "html",
                "markdown": "text",
                "text": "text",
                "metadata": "metadata",
                "links": "links",
                "full": "full"
            }

            # Default to text if format not found
            crawl_format = format_mapping.get(output_format, "text")

            # Update progress if task exists or callback is provided
            if progress_callback:
                progress_callback(0, 100, "Starting crawl")
            elif current_task:
                # Fallback to old method if no callback provided
                try:
                    current_task.update_progress(0, 100, "Starting crawl")
                except AttributeError:
                    logger.warning("Task object does not have update_progress, cannot report initial progress.")

            # Log the request for debugging
            logger.info(f"Crawl request for URL: {website_url}, max_pages: {max_pages}, max_depth: {max_depth}, format: {crawl_format}")

            # Convert wait_for to milliseconds if it's a number
            wait_for_ms = None
            if wait_for:
                if wait_for.isdigit():
                    wait_for_ms = int(wait_for)
                else:
                    # For non-numeric wait_for, we'll pass it as is and let the adapter handle it
                    wait_for_ms = wait_for

            # Use the crawl_website function from our new architecture
            result = crawl_website(
                url=website_url,
                output_type=crawl_format,
                max_pages=max_pages,
                max_depth=max_depth,
                include_patterns=include_patterns,
                exclude_patterns=exclude_patterns,
                stay_within_domain=True,
                cache=True,
                stealth=True,
                timeout=60000,  # 60 seconds
                wait_for=wait_for_ms,
                css_selector=css_selector,
                device="desktop"
            )

            # Check if crawl was successful
            if result is None:
                return json.dumps({
                    "status": "error",
                    "message": "Failed to crawl website"
                })

            # Update progress to 100%
            if progress_callback:
                progress_callback(100, 100, "Crawl completed")
            elif current_task:
                try:
                    current_task.update_progress(100, 100, "Crawl completed")
                except AttributeError:
                    logger.warning("Task object does not have update_progress, cannot report final progress.")

            # Process the result based on the requested output format
            if output_format == "html":
                # Return HTML content
                pages_html = []
                for page in result.get('pages', []):
                    if page.get('content'):
                        pages_html.append({
                            'url': page.get('url'),
                            'title': page.get('title', ''),
                            'content': page.get('content')
                        })

                return json.dumps({
                    "status": "success",
                    "pages": pages_html,
                    "total_pages": len(pages_html)
                })

            elif output_format == "cleaned_html":
                # Return cleaned HTML content (same as HTML for now)
                pages_html = []
                for page in result.get('pages', []):
                    if page.get('content'):
                        pages_html.append({
                            'url': page.get('url'),
                            'title': page.get('title', ''),
                            'content': page.get('content')
                        })

                return json.dumps({
                    "status": "success",
                    "pages": pages_html,
                    "total_pages": len(pages_html)
                })

            elif output_format == "markdown" or output_format == "text":
                # Return text content
                pages_text = []
                for page in result.get('pages', []):
                    if page.get('textContent'):
                        pages_text.append({
                            'url': page.get('url'),
                            'title': page.get('title', ''),
                            'content': page.get('textContent')
                        })

                return json.dumps({
                    "status": "success",
                    "pages": pages_text,
                    "total_pages": len(pages_text)
                })

            elif output_format == "metadata":
                # Return metadata
                pages_metadata = []
                for page in result.get('pages', []):
                    if page.get('metadata'):
                        pages_metadata.append({
                            'url': page.get('url'),
                            'title': page.get('title', ''),
                            'metadata': page.get('metadata'),
                            'links': page.get('links', [])
                        })

                return json.dumps({
                    "status": "success",
                    "pages": pages_metadata,
                    "total_pages": len(pages_metadata)
                })

            elif output_format == "full":
                # Return all content
                return json.dumps({
                    "status": "success",
                    "result": result,
                    "total_pages": len(result.get('pages', []))
                })

            else:
                # Default to text
                pages_text = []
                for page in result.get('pages', []):
                    if page.get('textContent'):
                        pages_text.append({
                            'url': page.get('url'),
                            'title': page.get('title', ''),
                            'content': page.get('textContent')
                        })

                return json.dumps({
                    "status": "success",
                    "pages": pages_text,
                    "total_pages": len(pages_text)
                })

        except Exception as e:
            logger.error(f"Error crawling website: {str(e)}")
            return json.dumps({
                "status": "error",
                "message": f"Error crawling website: {str(e)}"
            })

================
File: apps/agents/tools/crawl_website_tool/test_crawl_endpoint.py
================
#!/usr/bin/env python3
import requests
import json
import time
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
CRAWL4AI_URL = "https://crawl4ai.neuralami.com"
CRAWL4AI_API_KEY = "crawl4aiNeuralami1"

def test_crawl():
    # Headers
    headers = {
        "Authorization": f"Bearer {CRAWL4AI_API_KEY}",
        "Content-Type": "application/json"
    }

    # Basic request data
    request_data = {
        "urls": "https://neuralami.com",
        "priority": 10,
        "extraction_config": {
            "type": "basic",
            "params": {
                "output_format": "markdown_v2",  # Changed to markdown
                "word_count_threshold": 0,
                "only_text": False,
                "bypass_cache": True,
                "process_iframes": True,
                "excluded_tags": ["script", "style", "noscript"],
                "html2text": {
                    "ignore_links": False,
                    "ignore_images": False,
                    "body_width": 0,
                    "unicode_snob": True,
                    "protect_links": True,
                    "bypass_tables": False,
                    "single_line_break": True
                },
                "markdown": {
                    "enabled": True,
                    "gfm": True,
                    "tables": True,
                    "breaks": True,
                    "smartLists": True,
                    "smartypants": True,
                    "xhtml": True
                }
            }
        },
        "crawler_params": {
            "headless": True,
            "page_timeout": 30000,
            "simulate_user": True,
            "magic": True,
            "semaphore_count": 5,
            "remove_overlay_elements": True,
            "override_navigator": True,
            "wait_for": "main, #main, .main, #content, .content, article, .post-content",
            "delay_before_return_html": 5.0,
            "wait_until": "networkidle0",
            "javascript": True,
            "scroll": True,
            "wait_for_selector_timeout": 10000,
            "verbose": True
        }
    }

    try:
        # Submit crawl task
        logger.info("Submitting crawl task...")
        response = requests.post(
            f"{CRAWL4AI_URL}/crawl",
            headers=headers,
            json=request_data
        )
        response.raise_for_status()
        task_data = response.json()
        task_id = task_data["task_id"]
        logger.info(f"Task submitted successfully. Task ID: {task_id}")

        # Poll for results
        logger.info("Polling for results...")
        timeout = 300
        start_time = time.time()
        while True:
            if time.time() - start_time > timeout:
                raise TimeoutError(f"Task {task_id} timed out")

            result_response = requests.get(
                f"{CRAWL4AI_URL}/task/{task_id}",
                headers=headers
            )
            result_response.raise_for_status()
            status = result_response.json()

            if status["status"] == "completed":
                logger.info("Task completed successfully!")
                result = status.get("result", {})
                
                # Log available keys
                logger.info(f"Available content keys: {list(result.keys())}")
                
                # Log markdown content
                logger.info("\n=== MARKDOWN CONTENT ===")
                markdown_v2 = result.get("markdown_v2", {})
                if isinstance(markdown_v2, dict):
                    markdown_content = markdown_v2.get("raw_markdown", "")
                else:
                    markdown_content = str(markdown_v2)
                
                if not markdown_content:
                    markdown = result.get("markdown", "")
                    if isinstance(markdown, dict):
                        markdown_content = markdown.get("raw_markdown", "")
                    else:
                        markdown_content = str(markdown)
                
                logger.info(markdown_content)
                logger.info("=== END MARKDOWN CONTENT ===\n")
                
                # Save markdown to file
                with open("crawl_markdown.md", "w", encoding='utf-8') as f:
                    f.write(markdown_content)
                logger.info("Full markdown saved to crawl_markdown.md")
                
                # Save full response to file for inspection
                with open("crawl_response.json", "w", encoding='utf-8') as f:
                    json.dump(status, f, indent=2)
                logger.info("Full response saved to crawl_response.json")
                
                break
            elif status["status"] == "failed":
                raise Exception(f"Task failed: {status.get('error', 'Unknown error')}")
            
            logger.info("Still waiting for results...")
            time.sleep(2)

    except Exception as e:
        logger.error(f"Error: {str(e)}", exc_info=True)

if __name__ == "__main__":
    test_crawl()

================
File: apps/agents/tools/crawl_website_tool/utils.py
================
from core.storage import SecureFileStorage
from django.core.files.base import ContentFile
from django.contrib.auth.models import User
from datetime import datetime
import re
import os
import logging
from typing import List
from apps.crawl_website.models import CrawlResult

logger = logging.getLogger(__name__)

# Instantiate SecureFileStorage mirroring usage in crawl_website/views.py
# Assuming private access, no specific collection as user ID is part of path
crawl_tool_storage = SecureFileStorage(private=True, collection='')

def sanitize_url(url: str) -> str:
    """Sanitize the URL to create a valid folder name."""
    url = re.sub(r'^https?://(www\.)?', '', url)
    return re.sub(r'[^a-zA-Z0-9]', '_', url)

def get_crawl_result_url(relative_path: str) -> str:
    """Get the URL for accessing a crawl result file using SecureFileStorage."""
    try:
        if relative_path:
            # Use SecureFileStorage url method
            return crawl_tool_storage.url(relative_path)
        return None
    except Exception as e:
        logger.error(f"Error getting URL for crawl result: {str(e)}")
        return None

def ensure_crawl_directory_exists(user_id: int) -> str:
    """Ensure the crawl directory exists in cloud storage."""
    try:
        # For S3/B2, we don't need to create directory markers
        relative_path = os.path.join(str(user_id), 'crawled_websites')
        logger.debug(f"Using crawl directory path: {relative_path}")
        return relative_path
        
    except Exception as e:
        logger.error(f"Error with crawl directory path: {str(e)}")
        raise

def get_crawl_results(user_id: int) -> List[str]:
    """Get list of crawl results from cloud storage using SecureFileStorage."""
    try:
        directory_path = ensure_crawl_directory_exists(user_id)
        results = []
        
        # Use the underlying storage object for listing capabilities
        underlying_storage = crawl_tool_storage.storage 
        
        # Use S3/B2 style listing via the underlying storage object
        prefix = f"{directory_path}/"
        
        # Check if the underlying storage has a 'bucket' attribute (like S3/MinIO)
        if hasattr(underlying_storage, 'bucket') and hasattr(underlying_storage.bucket, 'objects'):
            for obj in underlying_storage.bucket.objects.filter(Prefix=prefix):
                # Check for .json and .csv files based on updated saving logic
                if obj.key.endswith('.json') or obj.key.endswith('.csv'): 
                    results.append(obj.key)
        else:
            # Fallback to listdir if no bucket/objects interface (e.g., local storage)
            try:
                 _dirs, files = underlying_storage.listdir(prefix)
                 for filename in files:
                      # Check for .json and .csv files
                      if filename.endswith('.json') or filename.endswith('.csv'):
                           results.append(os.path.join(prefix, filename))
            except Exception as list_err:
                 logger.error(f"Could not list directory {prefix} using listdir: {list_err}")
                 # Return empty list or raise error?
                 return []

        # Sort by last modified time using SecureFileStorage's get_modified_time
        # Handle potential errors during sorting
        def get_mtime_safe(key):
            try:
                return crawl_tool_storage.get_modified_time(key)
            except Exception as mtime_err:
                logger.error(f"Could not get modified time for {key}: {mtime_err}")
                # Return a default old datetime to sort problematic files last?
                return datetime.min.replace(tzinfo=datetime.timezone.utc) # Make timezone aware

        results.sort(key=get_mtime_safe, reverse=True)
        return results
        
    except Exception as e:
        logger.error(f"Error getting crawl results: {str(e)}")
        return []

================
File: apps/agents/tools/crewai_file_writer/crewai_file_writer.py
================
import os
from distutils.util import strtobool
from typing import Any, Optional, Type

from apps.agents.tools.base_tool import BaseTool
from pydantic import BaseModel


class FileWriterToolInput(BaseModel):
    filename: str
    directory: Optional[str] = "./"
    overwrite: str = "False"
    content: str


class FileWriterTool(BaseTool):
    name: str = "File Writer Tool"
    description: str = "A tool to write content to a specified file. Accepts filename, content, and optionally a directory path and overwrite flag as input."
    args_schema: Type[BaseModel] = FileWriterToolInput

    def _run(self, **kwargs: Any) -> str:
        try:
            # Create the directory if it doesn't exist
            if kwargs.get("directory") and not os.path.exists(kwargs["directory"]):
                os.makedirs(kwargs["directory"])

            # Construct the full path
            filepath = os.path.join(kwargs.get("directory") or "", kwargs["filename"])

            # Convert overwrite to boolean
            kwargs["overwrite"] = bool(strtobool(kwargs["overwrite"]))

            # Check if file exists and overwrite is not allowed
            if os.path.exists(filepath) and not kwargs["overwrite"]:
                return f"File {filepath} already exists and overwrite option was not passed."

            # Write content to the file
            mode = "w" if kwargs["overwrite"] else "x"
            with open(filepath, mode) as file:
                file.write(kwargs["content"])
            return f"Content successfully written to {filepath}"
        except FileExistsError:
            return (
                f"File {filepath} already exists and overwrite option was not passed."
            )
        except KeyError as e:
            return f"An error occurred while accessing key: {str(e)}"
        except Exception as e:
            return f"An error occurred while writing to the file: {str(e)}"

================
File: apps/agents/tools/csv_search_tool/csv_search_tool.py
================
from typing import Any, Optional, Type

from embedchain.models.data_type import DataType
from pydantic import BaseModel, Field

from ..rag.rag_tool import RagTool


class FixedCSVSearchToolSchema(BaseModel):
    """Input for CSVSearchTool."""

    search_query: str = Field(
        ...,
        description="Mandatory search query you want to use to search the CSV's content",
    )


class CSVSearchToolSchema(FixedCSVSearchToolSchema):
    """Input for CSVSearchTool."""

    csv: str = Field(..., description="Mandatory csv path you want to search")


class CSVSearchTool(RagTool):
    name: str = "Search a CSV's content"
    description: str = (
        "A tool that can be used to semantic search a query from a CSV's content."
    )
    args_schema: Type[BaseModel] = CSVSearchToolSchema

    def __init__(self, csv: Optional[str] = None, **kwargs):
        super().__init__(**kwargs)
        if csv is not None:
            self.add(csv)
            self.description = f"A tool that can be used to semantic search a query the {csv} CSV's content."
            self.args_schema = FixedCSVSearchToolSchema
            self._generate_description()

    def add(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        kwargs["data_type"] = DataType.CSV
        super().add(*args, **kwargs)

    def _before_run(
        self,
        query: str,
        **kwargs: Any,
    ) -> Any:
        if "csv" in kwargs:
            self.add(kwargs["csv"])

    def _run(
        self,
        search_query: str,
        **kwargs: Any,
    ) -> Any:
        return super()._run(query=search_query, **kwargs)

================
File: apps/agents/tools/deep_research_tool/deep_research_tool.py
================
import os
from typing import Any, Type, List, Dict, Optional
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.tools.searxng_tool.searxng_tool import SearxNGSearchTool
from apps.agents.tools.scrapper_tool.scrapper_tool import ScrapperTool
from apps.agents.tools.compression_tool.compression_tool import CompressionTool
from apps.common.utils import get_llm as utils_get_llm
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from django.conf import settings
import json
import logging
from celery.exceptions import Ignore
from datetime import datetime
from apps.research.models import Research  # Import here to avoid circular imports

logger = logging.getLogger(__name__)
# DO NOT REMOVE BELOW COMMENTS - FOR USE LATER
# You are an expert in information retrieval and research strategy.  You are assisting a user who is using a tool called the "DeepResearchTool". This tool performs web research based on a user's query. It has two key parameters:

# *   **`breadth` (integer, 2-10):** Controls the number of different search queries generated at each step.  Higher breadth means more diverse initial searches.
# *   **`depth` (integer, 1-5):** Controls the number of recursive research iterations.  Higher depth means more in-depth follow-up on initial results.

# The user provides a research query.  Your task is to analyze the query and recommend appropriate values for `breadth` and `depth`.  Consider the following:

# **Factors for `breadth`:**

# *   **Query Complexity:** How broad or narrow is the topic? Broader topics need higher breadth.
# *   **Synonyms/Variations:** How many different ways could the query be phrased? More variations suggest higher breadth.
# *   **Exhaustiveness:** Does the user need a comprehensive list ("find all...") or a focused set of results? Comprehensive needs higher breadth.
# *   **Subtopics:** Are there multiple related subtopics to explore?  If so, higher breadth.
# *   **Specificity:** How specific are the search terms. More specific terms generally suggest lower breadth.

# **Factors for `depth`:**

# *   **Layered Information:** Are there multiple layers of information (e.g., find a list, then explore items on that list)? If so, higher depth.
# *   **Context/Background:** Does the user need to understand the context around the results, or just find the results?  Context requires higher depth.
# *   **Discovery vs. Verification:** Is the goal to discover new information (higher depth) or verify existing information (lower depth)?
# *   **Refinement:** Are follow-up queries likely needed to refine the initial results? If so, higher depth.
# *   **Direct Answers:** Is a simple, direct answer possible (lower depth), or will deeper investigation be required (higher depth)?

# **Output Format:**

# Provide your recommendations in the following JSON format:

# ```json
# {
#   "query": "[User's Query Here]",
#   "recommended_breadth": [Integer Value],
#   "recommended_depth": [Integer Value],
#   "reasoning": "[Concise explanation of your choices, referencing the factors above]"
# }
# Log settings at module level
#logger.info(f"Module level - GENERAL_MODEL from settings: {settings.GENERAL_MODEL}")

class DeepResearchToolSchema(BaseModel):
    """Input schema for DeepResearchTool."""

    model_config = {
        "use_enum_values": True,
        "extra": "forbid",
        "json_schema_extra": {
            "examples": [
                {
                    "query": "What are the latest developments in quantum computing?",
                    "breadth": 4,
                    "depth": 2,
                    "user_id": 1,
                    "guidance": "Focus on practical applications and industry adoption"
                }
            ]
        }
    }

    query: str = Field(
        ...,
        description="The query to research deeply.",
        examples=["What are the latest developments in quantum computing?"]
    )
    breadth: int = Field(
        ...,
        description="Number of parallel search queries to make (recommended 2-10)",
        ge=1,
        le=10,
        examples=[4]
    )
    depth: int = Field(
        ...,
        description="Number of recursive research iterations (recommended 1-5)",
        ge=1,
        le=5,
        examples=[2]
    )
    user_id: int = Field(
        ...,
        description="ID of the user initiating the research"
    )
    guidance: Optional[str] = Field(
        None,
        description="Optional guidance to influence content processing"
    )

class DeepResearchTool(BaseTool):
    name: str = "Deep Research Tool"
    description: str = "Performs deep recursive research on a topic by generating multiple search queries and analyzing content from multiple sources."
    args_schema: Type[BaseModel] = DeepResearchToolSchema

    search_tool: SearxNGSearchTool = Field(default_factory=SearxNGSearchTool)
    scrapper_tool: ScrapperTool = Field(default_factory=ScrapperTool)
    compression_tool: CompressionTool = Field(default_factory=CompressionTool)
    llm: Any = None
    token_counter_callback: Any = None
    # Define token tracking fields as proper Pydantic fields with default values
    total_input_tokens: int = Field(0, description="Total input tokens used")
    total_output_tokens: int = Field(0, description="Total output tokens used")

    def __init__(self, **data):
        super().__init__(**data)
        model_name = data.get('llm_model', settings.GENERAL_MODEL)
        self.llm, self.token_counter_callback = utils_get_llm(model_name, temperature=0.7)
        # Token tracking is now handled by the Pydantic fields above, so no need to initialize here

    def _update_token_counters(self):
        """Update total token counts from the token counter callback"""
        if hasattr(self, 'token_counter_callback') and self.token_counter_callback:
            current_input = getattr(self.token_counter_callback, 'input_tokens', 0)
            current_output = getattr(self.token_counter_callback, 'output_tokens', 0)
            
            # Calculate incremental usage since last check
            input_diff = current_input - self.total_input_tokens
            output_diff = current_output - self.total_output_tokens
            
            if input_diff > 0 or output_diff > 0:
                logger.debug(f"Token usage - Input: +{input_diff}, Output: +{output_diff}")
                
            # Update totals
            self.total_input_tokens = current_input
            self.total_output_tokens = current_output
        
        return self.total_input_tokens, self.total_output_tokens

    def send_update(self, update_type: str, data: Dict):
        """Send update through progress tracker."""
        if hasattr(self, 'progress_tracker'):
            # Send update through progress tracker
            self.progress_tracker.send_update(update_type, data)
            logger.debug(f"Sent {update_type} update: {data.get('title', 'No title')}")

    def _clean_llm_response(self, response: str) -> str:
        """Clean LLM response by removing markdown formatting."""
        # Remove markdown code block markers
        response = response.replace("```json", "").replace("```", "")
        # Strip whitespace
        response = response.strip()
        #logger.debug(f"Cleaned response: {response[:200]}...")
        return response

    def _generate_serp_queries(self, query: str, num_queries: int, learnings: List[str] = None, guidance: Optional[str] = None) -> List[Dict]:
        """Generate search queries based on the input query and previous learnings."""
        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("reasoning", {
                "step": "query_planning",
                "title": "Planning Search Strategy",
                "explanation": "Analyzing query to determine optimal search approach",
                "details": {
                    "query": query,
                    "context": "Previous learnings" if learnings else "Initial research",
                    "num_queries_planned": num_queries
                }
            })

        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert researcher on {current_date}. Generate specific search queries to research the given topic.
            Each query should focus on a unique aspect of the topic. Make queries specific and targeted.

            IMPORTANT: Your response must be a valid JSON array of objects with this exact structure:
            [
                {{
                    "query": "specific search query here",
                    "research_goal": "what we want to learn from this query"
                }}
            ]

            Do not wrap the JSON in markdown code blocks or add any other formatting."""),
            ("human", """Generate {num_queries} unique search queries for researching: {query}
            Use this guidance to generate the search queries: {guidance}
            Previous learnings to build upon:
            {previous_learnings}

            Return ONLY a JSON array of objects with 'query' and 'research_goal' fields.
            Do not include any other text, explanation, or markdown formatting.""")
        ])

        previous_learnings = ""
        if learnings:
            previous_learnings = f"Previous learnings to build upon:\n" + "\n".join(f"- {learning}" for learning in learnings)

        chain = prompt | self.llm | StrOutputParser()

        try:
            result = chain.invoke({
                'query': query,
                'num_queries': num_queries,
                'guidance': guidance or "",
                'previous_learnings': previous_learnings,
                'current_date': datetime.now().strftime("%Y-%m-%d")
            })
            
            # Update token counters after LLM call
            self._update_token_counters()

            # Clean the response
            cleaned_result = self._clean_llm_response(result)

            # Try to parse JSON response
            try:
                parsed_result = json.loads(cleaned_result)
                # Validate the structure
                if not isinstance(parsed_result, list):
                    raise ValueError("Result must be a JSON array")
                for item in parsed_result:
                    if not isinstance(item, dict) or 'query' not in item or 'research_goal' not in item:
                        raise ValueError("Each item must have 'query' and 'research_goal' fields")

                # After generating queries, explain the reasoning
                if hasattr(self, 'progress_tracker'):
                    self.progress_tracker.send_update("reasoning", {
                        "step": "search_queries",
                        "title": "Generated Search Queries",
                        "explanation": "Created targeted queries to explore different aspects",
                        "details": {
                            "queries": [q['query'] for q in parsed_result],
                            "goals": [q['research_goal'] for q in parsed_result],
                            "reasoning": "Each query targets a specific aspect of the research topic to ensure comprehensive coverage"
                        }
                    })

                return parsed_result
            except json.JSONDecodeError as je:
                logger.error(f"JSON parsing error: {str(je)}\nCleaned response was: {cleaned_result[:200]}...")
                raise

        except Exception as e:
            logger.error(f"Error generating SERP queries: {str(e)}")
            # Enhanced fallback with multiple queries
            return [
                {'query': query, 'research_goal': 'Understand the topic broadly'},
                {'query': f"latest developments in {query}", 'research_goal': 'Find recent information'},
                {'query': f"detailed analysis of {query}", 'research_goal': 'Get in-depth understanding'}
            ]

    def _extract_compression_tool_tokens(self, compression_result: str) -> tuple:
        """Extract token usage information from CompressionTool result."""
        try:
            result_data = json.loads(compression_result)
            input_tokens = result_data.get("llm_input_tokens", 0)
            output_tokens = result_data.get("llm_output_tokens", 0)
            logger.debug(f"Extracted token usage from CompressionTool - Input: {input_tokens}, Output: {output_tokens}")
            return input_tokens, output_tokens
        except Exception as e:
            logger.error(f"Error extracting token usage from CompressionTool: {str(e)}")
            return 0, 0
            
    def _extract_searxng_tool_tokens(self, search_results: str) -> tuple:
        """Extract token usage information from SearxNGTool result."""
        try:
            # Search for token usage information in the search results
            token_info_marker = "Relevance filtering token usage - Input:"
            if token_info_marker in search_results:
                # Extract the token usage line
                lines = search_results.split('\n')
                for line in lines:
                    if token_info_marker in line:
                        # Parse the token information
                        # Format: "Relevance filtering token usage - Input: X, Output: Y, Total: Z"
                        parts = line.split(',')
                        input_tokens = int(parts[0].split(':')[-1].strip())
                        output_tokens = int(parts[1].split(':')[-1].strip())
                        logger.debug(f"Extracted token usage from SearxNGTool - Input: {input_tokens}, Output: {output_tokens}")
                        return input_tokens, output_tokens
            return 0, 0
        except Exception as e:
            logger.error(f"Error extracting token usage from SearxNGTool: {str(e)}")
            return 0, 0
            
    def _update_token_counters_from_subtool(self, input_tokens: int, output_tokens: int):
        """Update token counters with usage from a sub-tool."""
        self.total_input_tokens += input_tokens
        self.total_output_tokens += output_tokens
        logger.debug(f"Added sub-tool token usage - Input: +{input_tokens}, Output: +{output_tokens}")
        logger.debug(f"Updated cumulative totals - Input: {self.total_input_tokens}, Output: {self.total_output_tokens}")

    def _process_content(self, query: str, content: str, num_learnings: int = 3, guidance: Optional[str] = None) -> Dict:
        """Process content to extract learnings and follow-up questions using the CompressionTool."""
        # Log content size and type information
        logger.info(f"_process_content called with query: {query[:50]}...")
        logger.info(f"Content type: {type(content)}, length: {len(content) if isinstance(content, str) else 'not string'}")
        
        # Use CompressionTool to extract key learnings with 'focused' detail level
        try:
            # Run the compression tool with focused detail
            compression_result = self.compression_tool._run(
                content=content,
                max_tokens=8192,  # Use a reasonable token limit
                detail_level="focused"  # Use focused setting as requested
            )
            
            # Extract and add token usage from CompressionTool
            input_tokens, output_tokens = self._extract_compression_tool_tokens(compression_result)
            self._update_token_counters_from_subtool(input_tokens, output_tokens)
            
            # Parse the JSON result
            parsed_compression = json.loads(compression_result)
            
            if "error" in parsed_compression:
                logger.error(f"CompressionTool error: {parsed_compression['error']}")
                raise ValueError(f"CompressionTool error: {parsed_compression.get('message', 'Unknown error')}")
                
            # Get the processed content
            processed_content = parsed_compression.get("processed_content", "")
            
            if not processed_content:
                logger.error("No processed content returned from CompressionTool")
                raise ValueError("No processed content returned from CompressionTool")
            
            logger.info(f"Successfully processed content with CompressionTool, length: {len(processed_content)}")
            
            # Now we need to generate follow-up questions using LLM
            follow_up_prompt = ChatPromptTemplate.from_messages([
                ("system", """You are an expert researcher. Based on the provided notes, suggest follow-up questions
                for deeper research. Focus on gaps in knowledge, unexplored areas, and potential new directions.
                
                IMPORTANT: Your response must be a valid JSON array of strings containing only the follow-up questions.
                Do not wrap the JSON in markdown code blocks or add any other formatting."""),
                ("human", """For the research query: {query}
                
                Based on these notes:
                {processed_content}
                
                Use this guidance to generate follow-up questions:
                {guidance}
                
                Generate {num_questions} follow-up questions for deeper research.
                
                Return ONLY a JSON array of strings.
                Do not include any other text, explanation, or markdown formatting.""")
            ])
            
            follow_up_chain = follow_up_prompt | self.llm | StrOutputParser()
            
            follow_up_result = follow_up_chain.invoke({
                'query': query,
                'processed_content': processed_content,
                'guidance': guidance or "",
                'num_questions': 3  # Generate 3 follow-up questions
            })
            
            # Update token counters after LLM call
            self._update_token_counters()
            
            # Clean and parse the follow-up questions
            cleaned_follow_up = self._clean_llm_response(follow_up_result)
            follow_up_questions = json.loads(cleaned_follow_up)
            
            # Use the entire processed content as the learning
            # The CompressionTool with 'focused' setting already gives us what we need
            learnings = [processed_content]
            
            # Log extracted learnings
            logger.info(f"Successfully extracted learning from content using CompressionTool")
            logger.info(f"Learning: {processed_content[:100]}...")
            
            return {
                'learnings': learnings,
                'follow_up_questions': follow_up_questions if isinstance(follow_up_questions, list) else []
            }

        except Exception as e:
            logger.error(f"Error processing content with CompressionTool: {str(e)}", exc_info=True)
            # Enhanced fallback that preserves context
            return {
                'learnings': [
                    f"Unable to extract specific learnings from content about: {query}",
                    "Content processing encountered technical difficulties"
                ],
                'follow_up_questions': [
                    f"What are the key aspects of {query}?",
                    "What are the most recent developments in this area?"
                ]
            }

    def _extract_urls(self, search_results: str) -> List[str]:
        """Extract URLs from search results."""
        urls = []
        for line in search_results.split('\n'):
            if line.startswith('Link: '):
                urls.append(line.replace('Link: ', '').strip())
        #return the first 5 urls
        return urls[:5]

    def _deep_research(self, query: str, breadth: int, depth: int, user_id: int, guidance: Optional[str] = None, learnings: List[str] = None, visited_urls: set = None) -> Dict:
        """Recursive function to perform deep research."""
        if learnings is None:
            learnings = []
        if visited_urls is None:
            visited_urls = set()

        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("reasoning", {
                "step": "research_phase",
                "title": f" {depth}",
                "explanation": "Starting new research iteration",
                "details": {
                    "depth_level": depth,
                    "breadth": breadth,
                    "context": "Using previous findings to guide deeper research" if learnings else "Initial research phase",
                    "strategy": "Exploring broader topics" if depth == 1 else "Diving deeper into specific areas"
                }
            })

        urls_per_query = 5
        expected_urls = breadth * urls_per_query
        total_operations = expected_urls
        current_operation = 0

        # Check for cancellation before starting
        if hasattr(self, 'progress_tracker') and self.progress_tracker.check_cancelled():
            raise Ignore()

        serp_queries = self._generate_serp_queries(query, breadth, learnings, guidance)
        logger.debug(f"SERP queries: {serp_queries}")
        all_learnings = learnings.copy()
        all_urls = visited_urls.copy()
        
        # Log initial state
        logger.info(f"_deep_research initial state: local learnings={len(learnings)}, all_learnings={len(all_learnings)}")

        for query_index, serp_query in enumerate(serp_queries, 1):
            if hasattr(self, 'progress_tracker') and self.progress_tracker.check_cancelled():
                raise Ignore()

            try:
                # Use the new relevant_results_only parameter
                search_results = self.search_tool._run(
                    search_query=serp_query['query'],
                    relevant_results_only=True  # Filter for relevant results only
                )
                
                # Extract and add token usage from SearxNGTool
                input_tokens, output_tokens = self._extract_searxng_tool_tokens(search_results)
                self._update_token_counters_from_subtool(input_tokens, output_tokens)
                
                urls = self._extract_urls(search_results)
                #logger.debug(f"Search results: {search_results[:100]}")

                new_urls = [url for url in urls if url not in all_urls]
                if not new_urls:
                    continue
                
                for url in new_urls:
                    try:
                        # Use ScrapperTool instead of CrawlWebsiteTool
                        scrape_result = self.scrapper_tool._run(
                            url=url,
                            user_id=user_id,
                            output_type="text",
                            cache=True,
                            stealth=True
                        )

                        result_data = json.loads(scrape_result)
                        if not result_data.get("success", False):
                            logger.warning(f"Failed to scrape URL: {url} - {result_data.get('error')}")
                            continue

                        content = result_data.get("text", "")

                        if not content or len(content) < 100:
                            logger.warning(f"Insufficient content found for {url}")
                            continue

                        if len(content) > 400000:
                            logger.warning(f"Content too large ({len(content)} chars) for {url}, skipping")
                            continue

                        all_urls.add(url)

                        try:
                            # Notify about analyzing this source
                            if hasattr(self, 'progress_tracker'):
                                self.progress_tracker.send_update("reasoning", {
                                    "step": "content_analysis",
                                    "title": "Analyzing Source Content",
                                    "explanation": f"Phase {depth}\n{url}",
                                    "details": {
                                        "url": url,
                                        "depth": depth
                                    }
                                })

                            content_length = len(content)
                            logger.info(f"Processing {content_length/1024:.1f} KB from {url}")

                            if hasattr(self, 'progress_tracker'):
                                self.progress_tracker.send_update("reasoning", {
                                    "step": "content_analysis",
                                    "title": "Analyzing Source Content",
                                    "explanation": f"Phase {depth}\n{url}",
                                    "details": {
                                        "url": url,
                                        "source_length": content_length,
                                        "depth": depth
                                    }
                                })

                            # Store current URL for subclasses to access
                            self._current_url = url
                            
                            # Process the content
                            result = self._process_content(query, content, guidance=guidance)
                            
                            # Clear current URL after processing
                            self._current_url = None
                            
                            new_learnings = result.get('learnings', [])

                            if not new_learnings or new_learnings[0].startswith("Unable to extract"):
                                logger.error(f"Failed to extract learnings from {url}")
                                continue

                            # Log learnings being added
                            logger.info(f"Adding {len(new_learnings)} new learnings from {url}")
                            logger.debug(f"First learning sample: {new_learnings[0][:100]}...")
                            
                            learnings.extend(new_learnings)
                            # Add new learnings to all_learnings as well
                            all_learnings.extend(new_learnings)
                            logger.info(f"After adding: local learnings={len(learnings)}, all_learnings={len(all_learnings)}")

                            # Handle follow-up questions for deeper research
                            if depth > 1 and result.get('follow_up_questions'):
                                next_query = f"""
                                Previous research goal: {serp_query['research_goal']}
                                Follow-up questions:
                                {chr(10).join(f'- {q}' for q in result['follow_up_questions'])}
                                """.strip()

                                deeper_results = self._deep_research(
                                    query=next_query,
                                    breadth=max(2, breadth // 2),
                                    depth=depth - 1,
                                    user_id=user_id,
                                    guidance=guidance,
                                    learnings=all_learnings,
                                    visited_urls=all_urls
                                )

                                all_learnings = list(set(all_learnings + deeper_results['learnings']))
                                all_urls.update(deeper_results['visited_urls'])
                                
                                # Log after recursive call
                                logger.info(f"After recursive call: local learnings={len(learnings)}, all_learnings={len(all_learnings)}")

                        except Exception as e:
                            logger.error(f"Error processing URL {url}: {str(e)}", exc_info=True)
                            continue

                    except Exception as e:
                        logger.error(f"Error scraping URL {url}: {str(e)}")
                        continue

            except Exception as e:
                logger.error(f"Error processing query {serp_query['query']}: {str(e)}")
                continue
            
        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("reasoning", {
                "step": "depth_complete",
                "title": f"Completed Depth Level {depth}",
                "explanation": "Finished current research iteration",
                "details": {
                    "new_learnings": len(all_learnings) - (len(learnings) if learnings else 0),
                    "new_urls": len(all_urls) - (len(visited_urls) if visited_urls else 0)
                }
            })

        # Log the state of learnings before return
        logger.info(f"Depth {depth} complete - Collected {len(all_learnings)} total learnings")
        if all_learnings:
            logger.debug(f"Sample learnings: {all_learnings[0][:100]}...")
            
        # Before deduplication
        logger.info(f"Before deduplication: {len(all_learnings)} learnings")
        if len(all_learnings) == 0:
            logger.error("No learnings collected - check processing or content extraction!")
        
        deduplicated_learnings = list(set(all_learnings))  # Deduplicate learnings
        logger.info(f"After deduplication: {len(deduplicated_learnings)} learnings")
        
        # Check if any learnings were lost during deduplication
        if len(deduplicated_learnings) < len(all_learnings):
            logger.warning(f"Lost {len(all_learnings) - len(deduplicated_learnings)} learnings during deduplication")

        return {
            'learnings': deduplicated_learnings,  # Using the tracked deduplicated list
            'visited_urls': list(all_urls)
            }

    def _write_final_report(self, query: str, guidance: str, learnings: List[str], visited_urls: List[str], start_time: datetime, end_time: datetime, breadth: int, depth: int) -> str:
        # Log the incoming data
        logger.info(f"_write_final_report received {len(learnings) if learnings else 0} learnings and {len(visited_urls) if visited_urls else 0} URLs")
        
        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("reasoning", {
                "step": "report_generation",
                "title": "Generating Final Report",
                "explanation": "Synthesizing research findings into a comprehensive report",
                "details": {
                    "total_learnings": len(learnings) if learnings else 0,
                    "total_sources": len(visited_urls) if visited_urls else 0,
                    "research_duration": f"{(end_time - start_time).total_seconds() / 60.0:.2f} minutes"
                }
            })

        duration_minutes = (end_time - start_time).total_seconds() / 60.0
        
        # Check if we have any learnings
        if not learnings or len(learnings) == 0:
            logger.error("No learnings found for report generation")
            return "Error: No research findings were collected. The research process did not yield any usable results. This could be due to:\n\n" \
                   "1. Limited information available on the topic\n" \
                   "2. Issues with content extraction from web pages\n" \
                   "3. The search terms may need to be refined\n\n" \
                   "Please try again with different parameters or a different query."
        
        # Log the learnings for debugging
        logger.info(f"Generating report with {len(learnings)} learnings")
        for i, learning in enumerate(learnings[:5]):  # Log first 5 learnings for debugging
            logger.info(f"Learning {i+1}: {learning[:100]}...")
        
        # Get current token usage before generating the report
        input_tokens, output_tokens = self._update_token_counters()
        
        metadata_section = f"""
## Research Metadata

- **Query:** {query}
- **Parameters:**
  - Breadth: {breadth}
  - Depth: {depth}
- **Timing Information:**
  - Start Time: {start_time.strftime("%Y-%m-%d %H:%M:%S")}
  - End Time: {end_time.strftime("%Y-%m-%d %H:%M:%S")}
  - Duration: {round(duration_minutes, 2)} minutes
- **Statistics:**
  - Sources Analyzed: {len(visited_urls)}
  - Key Learnings: {len(learnings)}
- **Token Usage (Comprehensive):**
  - Input Tokens: {input_tokens:,}
  - Output Tokens: {output_tokens:,}
  - Total Tokens: {input_tokens + output_tokens:,}
  - Note: Includes all LLM calls, sub-tools, and filtering operations
"""

        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert analyst synthesizing research findings into comprehensive reports that are easy to understand with structure appropriate for the query and guidance.
Your analysis should:
- Present information in a clear, logical narrative
- Support claims with evidence from provided research
- Balance depth with accessibility
- Consider practical implications
- Evaluate relevant trade-offs

Format using clean markdown with:
- Clear section hierarchy (### for main sections, #### for subsections)
- Minimal formatting for readability
- Appropriate use of technical notation when needed"""),

("human", """Analyze the following query: {query}

Using these research findings:
{learnings}

Following this guidance:
{guidance}

Provide a response that is easy to understand with structure appropriate for the query and guidance.  Develop bespoke sections for the report based on the query and guidance.  If asked a question, summarize key findings and recommendations, analyze critical factors, evaluate practical aspects, and examine relevant implications and outcomes.
Otherwise provide a resposne that is resposive to the query and guidance (i.e. if guidance says write a long form article, then write a long form article, if guidance says find a list of things, then provide a list).

Conclude with actionable insights based on the analysis.  Above all make sure you follow the instructions given in the guidance.""")
        ])

        chain = prompt | self.llm | StrOutputParser()

        try:
            report = chain.invoke({
                'query': query,
                'learnings': "\n".join(f"- {learning}" for learning in learnings),
                'guidance': guidance or "",
                'current_date': datetime.now().strftime("%Y-%m-%d")
            })
            
            # Update token counters after generating report
            final_input_tokens, final_output_tokens = self._update_token_counters()
            
            # Get tokens used specifically for report generation
            report_input_tokens = final_input_tokens - input_tokens
            report_output_tokens = final_output_tokens - output_tokens
            
            logger.info(f"Report generation token usage - Input: {report_input_tokens}, Output: {report_output_tokens}")
            
            # Update metadata section with final token counts
            metadata_section = f"""
## Research Metadata

- **Query:** {query}
- **Parameters:**
  - Breadth: {breadth}
  - Depth: {depth}
- **Timing Information:**
  - Start Time: {start_time.strftime("%Y-%m-%d %H:%M:%S")}
  - End Time: {end_time.strftime("%Y-%m-%d %H:%M:%S")}
  - Duration: {round(duration_minutes, 2)} minutes
- **Statistics:**
  - Sources Analyzed: {len(visited_urls)}
  - Key Learnings: {len(learnings)}
- **Token Usage (Comprehensive):**
  - Input Tokens: {final_input_tokens:,}
  - Output Tokens: {final_output_tokens:,}
  - Total Tokens: {final_input_tokens + final_output_tokens:,}
  - Report Generation: {report_input_tokens + report_output_tokens:,} tokens
  - Note: Includes all LLM calls, sub-tools, and filtering operations
"""

            # Log the generated report for debugging
            logger.info(f"Generated report length: {len(report)}")
            logger.debug(f"Report preview: {report[:500]}...")

            sources_section = "\n\n## Sources\n\n" + "\n".join(f"- {url}" for url in visited_urls)
            final_report = report + sources_section + "\n\n" + metadata_section

            # Check if the report contains fabrication disclaimer
            fabrication_indicators = [
                "unfortunately, are missing from the prompt",
                "I will proceed by making reasonable assumptions",
                "I will fabricate plausible research",
                "no research findings were provided",
                "missing from the input"
            ]
            
            for indicator in fabrication_indicators:
                if indicator.lower() in report.lower():
                    logger.error(f"Report contains fabrication indicator: {indicator}")
                    return "Error: The report generation system detected that it was attempting to fabricate research findings. This indicates an issue with the research process. Please try again with different parameters or a different query."

            # After generating the report
            if hasattr(self, 'progress_tracker'):
                self.progress_tracker.send_update("reasoning", {
                    "step": "complete",
                    "title": "Research Complete",
                    "explanation": "Research process has finished",
                    "details": {
                        "total_time": f"{(end_time - start_time).total_seconds() / 60.0:.2f} minutes",
                        "total_sources": len(visited_urls),
                        "total_learnings": len(learnings),
                        "total_tokens": final_input_tokens + final_output_tokens
                    }
                })

            return final_report

        except Exception as e:
            logger.error(f"Error writing final report: {str(e)}")
            return "Error generating report"

    def _run(
        self,
        **kwargs: Any
    ) -> Any:
        try:
            start_time = datetime.now()
            params = self.args_schema(**kwargs)
            logger.info(f"Running deep research tool with params: {params}")
            
            # Reset token counters at the start of each run
            self.total_input_tokens = 0
            self.total_output_tokens = 0
            if hasattr(self, 'token_counter_callback') and self.token_counter_callback:
                self.token_counter_callback.input_tokens = 0
                self.token_counter_callback.output_tokens = 0

            # Send initial timing update
            if hasattr(self, 'progress_tracker'):
                self.progress_tracker.send_update("timing", {
                    "start_time": start_time.strftime("%Y-%m-%d %H:%M:%S"),
                    "message": "Starting deep research process"
                })

            results = self._deep_research(
                query=params.query,
                breadth=params.breadth,
                depth=params.depth,
                user_id=params.user_id,
                guidance=params.guidance
            )
            
            # Log the results received from _deep_research
            logger.info(f"_run received results from _deep_research with {len(results.get('learnings', []))} learnings")
            if 'learnings' in results and results['learnings']:
                logger.debug(f"First learning received: {results['learnings'][0][:100]}...")
            else:
                logger.error("No learnings were returned from _deep_research!")

            end_time = datetime.now()
            
            report = self._write_final_report(
                query=params.query,
                guidance=params.guidance,
                learnings=results['learnings'],
                visited_urls=results['visited_urls'],
                start_time=start_time,
                end_time=end_time,
                breadth=params.breadth,
                depth=params.depth
            )

            duration_minutes = (end_time - start_time).total_seconds() / 60.0

            # Format times for display
            start_time_str = start_time.strftime("%Y-%m-%d %H:%M:%S")
            end_time_str = end_time.strftime("%Y-%m-%d %H:%M:%S")
            
            # Get final token counts
            final_input_tokens, final_output_tokens = self._update_token_counters()

            # Send final timing information and report
            if hasattr(self, 'progress_tracker'):
                # First update with the report
                self.progress_tracker.send_update("report", {
                    "report": report
                })
                
                # Then update status to completed
                self.progress_tracker.send_update("status", {
                    "status": "completed",
                    "progress_percent": 100,
                    "start_time": start_time_str,
                    "end_time": end_time_str,
                    "duration_minutes": round(duration_minutes, 2),
                    "message": "Research process completed",
                    "tokens": {
                        "input": final_input_tokens,
                        "output": final_output_tokens,
                        "total": final_input_tokens + final_output_tokens
                    }
                })

            # Log report structure before returning
            logger.info(f"Returning report of type {type(report).__name__} and length {len(report)}")
            logger.debug(f"Report preview: {report[:200]}...")
            logger.info(f"Total token usage - Input: {final_input_tokens}, Output: {final_output_tokens}, Total: {final_input_tokens + final_output_tokens}")

            return {
                'success': True,
                'deep_research_data': {
                    "query": params.query,
                    'report': report,
                    "num_sources": len(results['visited_urls']),
                    "num_learnings": len(results['learnings']),
                    "sources": results['visited_urls'],
                    "learnings": results['learnings'],
                    "timing": {
                        "start_time": start_time_str,
                        "end_time": end_time_str,
                        "duration_minutes": round(duration_minutes, 2)
                    },
                    "parameters": {
                        "breadth": params.breadth,
                        "depth": params.depth
                    },
                    "token_usage": {
                        "input_tokens": final_input_tokens,
                        "output_tokens": final_output_tokens,
                        "total_tokens": final_input_tokens + final_output_tokens,
                        "note": "Includes all LLM calls, sub-tools, and filtering operations"
                    }
                }
            }

        except Ignore:
            raise

        except Exception as e:
            end_time = datetime.now()
            duration_minutes = (end_time - start_time).total_seconds() / 60.0
            logger.debug(f"Duration: {duration_minutes}")
            # Send timing information even in case of error
            if hasattr(self, 'progress_tracker'):
                self.progress_tracker.send_update("timing", {
                    "start_time": start_time.strftime("%Y-%m-%d %H:%M:%S"),
                    "end_time": end_time.strftime("%Y-%m-%d %H:%M:%S"),
                    "duration_minutes": round(duration_minutes, 2)
                })
                
            logger.error(f"Deep Research tool error: {str(e)}", exc_info=True)
            return {
                'success': False,
                'error': str(e),
                'deep_research_data': {
                    "timing": {
                        "start_time": start_time.strftime("%Y-%m-%d %H:%M:%S"),
                        "end_time": end_time.strftime("%Y-%m-%d %H:%M:%S"),
                        "duration_minutes": round(duration_minutes, 2)
                    }
                }
            }

================
File: apps/agents/tools/directory_read_tool/directory_read_tool.py
================
import os
from typing import Any, Optional, Type
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import logging
from apps.file_manager.storage import PathManager

logger = logging.getLogger(__name__)


class DirectoryReadToolSchema(BaseModel):
    """Input for DirectoryReadTool."""
    directory: str = Field(default="/", description="Directory to list content within user's media directory")
    user_id: int = Field(..., description="The ID of the user making the request")


class DirectoryReadTool(BaseTool):
    name: str = "List files in directory"
    description: str = (
        "A tool that can be used to list contents within user's media directory."
    )
    args_schema: Type[BaseModel] = DirectoryReadToolSchema

    def _run(self, directory: str, user_id: int) -> str:
        try:
            path_manager = PathManager(user_id=user_id)
            
            # Get directory contents using storage system
            contents = path_manager.list_contents(directory)
            
            if not contents:
                return f"No files or directories found in {directory}"
            
            # Format directory listing
            formatted = []
            for item in contents:
                entry = f"{item['path']}/" if item['type'] == 'directory' else item['path']
                formatted.append(entry)
            
            return "Directory contents:\n- " + "\n- ".join(sorted(formatted))
            
        except Exception as e:
            error_msg = f"Error listing directory: {str(e)}"
            logger.error(error_msg)
            return error_msg

================
File: apps/agents/tools/directory_search_tool/directory_search_tool.py
================
from typing import Any, Optional, Type

from embedchain.loaders.directory_loader import DirectoryLoader
from pydantic import BaseModel, Field

from ..rag.rag_tool import RagTool


class FixedDirectorySearchToolSchema(BaseModel):
    """Input for DirectorySearchTool."""

    search_query: str = Field(
        ...,
        description="Mandatory search query you want to use to search the directory's content",
    )


class DirectorySearchToolSchema(FixedDirectorySearchToolSchema):
    """Input for DirectorySearchTool."""

    directory: str = Field(..., description="Mandatory directory you want to search")


class DirectorySearchTool(RagTool):
    name: str = "Search a directory's content"
    description: str = (
        "A tool that can be used to semantic search a query from a directory's content."
    )
    args_schema: Type[BaseModel] = DirectorySearchToolSchema

    def __init__(self, directory: Optional[str] = None, **kwargs):
        super().__init__(**kwargs)
        if directory is not None:
            self.add(directory)
            self.description = f"A tool that can be used to semantic search a query the {directory} directory's content."
            self.args_schema = FixedDirectorySearchToolSchema
            self._generate_description()

    def add(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        kwargs["loader"] = DirectoryLoader(config=dict(recursive=True))
        super().add(*args, **kwargs)

    def _before_run(
        self,
        query: str,
        **kwargs: Any,
    ) -> Any:
        if "directory" in kwargs:
            self.add(kwargs["directory"])

    def _run(
        self,
        search_query: str,
        **kwargs: Any,
    ) -> Any:
        return super()._run(query=search_query, **kwargs)

================
File: apps/agents/tools/docx_search_tool/docx_search_tool.py
================
from typing import Any, Optional, Type

from embedchain.models.data_type import DataType
from pydantic import BaseModel, Field

from ..rag.rag_tool import RagTool


class FixedDOCXSearchToolSchema(BaseModel):
    """Input for DOCXSearchTool."""

    docx: Optional[str] = Field(
        ..., description="Mandatory docx path you want to search"
    )
    search_query: str = Field(
        ...,
        description="Mandatory search query you want to use to search the DOCX's content",
    )


class DOCXSearchToolSchema(FixedDOCXSearchToolSchema):
    """Input for DOCXSearchTool."""

    search_query: str = Field(
        ...,
        description="Mandatory search query you want to use to search the DOCX's content",
    )


class DOCXSearchTool(RagTool):
    name: str = "Search a DOCX's content"
    description: str = (
        "A tool that can be used to semantic search a query from a DOCX's content."
    )
    args_schema: Type[BaseModel] = DOCXSearchToolSchema

    def __init__(self, docx: Optional[str] = None, **kwargs):
        super().__init__(**kwargs)
        if docx is not None:
            self.add(docx)
            self.description = f"A tool that can be used to semantic search a query the {docx} DOCX's content."
            self.args_schema = FixedDOCXSearchToolSchema
            self._generate_description()

    def add(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        kwargs["data_type"] = DataType.DOCX
        super().add(*args, **kwargs)

    def _before_run(
        self,
        query: str,
        **kwargs: Any,
    ) -> Any:
        if "docx" in kwargs:
            self.add(kwargs["docx"])

    def _run(
        self,
        **kwargs: Any,
    ) -> Any:
        search_query = kwargs.get("search_query")
        if search_query is None:
            search_query = kwargs.get("query")

        docx = kwargs.get("docx")
        if docx is not None:
            self.add(docx)
        return super()._run(query=search_query, **kwargs)

================
File: apps/agents/tools/file_read_tool/file_read_tool.py
================
from typing import Any, Type
from pydantic import BaseModel, Field
from langchain.schema import StrOutputParser
from apps.agents.tools.base_tool import BaseTool
import logging
from django.conf import settings
from django.core.files.storage import default_storage
from apps.file_manager.storage import PathManager

logger = logging.getLogger(__name__)

class FileReadToolSchema(BaseModel):
    """Input schema for FileReadTool."""
    file_path: str = Field(..., description="File path within user's media directory")
    user_id: int = Field(..., description="The ID of the user making the request")

class FileReadTool(BaseTool):
    name: str = "File Read Tool"
    description: str = "A tool that can be used to read a file's content within user's media directory."
    args_schema: Type[BaseModel] = FileReadToolSchema

    def _run(self, file_path: str, user_id: int) -> str:
        try:
            # Initialize PathManager with user_id
            path_manager = PathManager(user_id=user_id)
            logger.debug("reading file with file_reader")
            
            # Get full path using PathManager
            full_path = path_manager._get_full_path(file_path)
            logger.debug(f"Reading from path: {full_path}")
            
            # Check if file exists
            if not default_storage.exists(full_path):
                error_msg = f"File {file_path} does not exist"
                logger.error(error_msg)
                return error_msg
            
            # Read content using default_storage
            with default_storage.open(full_path, 'r') as file:
                content = file.read()
                
            logger.debug(f"Successfully read file: {file_path}")
            return content
            
        except Exception as e:
            error_msg = f"Failed to read the file {file_path}. Error: {str(e)}"
            logger.error(error_msg)
            return error_msg

================
File: apps/agents/tools/file_writer_tool/file_writer_tool.py
================
import os
from typing import Any, Optional, Type, Dict
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import logging
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from apps.file_manager.storage import PathManager
from distutils.util import strtobool

logger = logging.getLogger(__name__)


class FileWriterToolSchema(BaseModel):
    """Input schema for the FileWriterTool."""
    filename: str = Field(..., description="The name of the file to write to.")
    content: str = Field(..., description="The content to write to the file.")
    user_id: int = Field(..., description="The ID of the user making the request.")
    directory: Optional[str] = Field(None, description="Optional directory path within user's media directory.")
    overwrite: str = "False" # String type, default "False"


class FileWriterTool(BaseTool):
    name: str = "File Writer Tool"
    description: str = (
        "A tool to write content to a specified file within user's media directory. "
        "Accepts filename, content, and optionally a directory path and overwrite flag as input."
        "Returns a success message if the file is written successfully, otherwise returns an error message."
    )
    args_schema: Type[FileWriterToolSchema] = FileWriterToolSchema

    def _run(self, **kwargs: Any) -> str:
        logger.debug(f"FileWriterTool received RAW kwargs: {repr(kwargs)}") # Log RAW kwargs
        logger.debug(f"FileWriterTool received kwargs TYPE: {type(kwargs)}") # Log kwargs type
        logger.debug(f"FileWriterTool received kwargs KEYS: {kwargs.keys()}") # Log the keys
        try:
            filename = kwargs["filename"]
            content = kwargs["content"]
            user_id = kwargs["user_id"]
            directory = kwargs.get('directory', '/')  # Default to '/' if not provided
            
            # Handle cases where directory is explicitly 'None' as string
            if directory is None or directory == 'None':
                directory = '/'
                
            overwrite_str = kwargs["overwrite"]
            overwrite = bool(strtobool(overwrite_str))

            # Log the input parameters
            logger.debug(f"Writing file: {filename}, directory: {directory}, user_id: {user_id}, overwrite: {overwrite}")
            logger.debug(f"Content preview: {content[:100]}...")

            # Initialize PathManager with user_id
            path_manager = PathManager(user_id=user_id)

            # Construct the file path
            filepath = os.path.join(str(directory), str(filename)).lstrip('/')
            full_path = path_manager._get_full_path(filepath)

            logger.debug(f"Writing to path: {full_path}")

            # Check if file exists and overwrite is not allowed
            if default_storage.exists(full_path) and not overwrite:
                logger.error(f"File {filename} already exists and overwrite option was not passed.")
                return f"Error: File {filename} already exists and overwrite option was not passed."

            # Write content to the file using default_storage
            try:
                content_file = ContentFile(content.encode('utf-8'))
                if overwrite and default_storage.exists(full_path):
                    default_storage.delete(full_path)

                saved_path = default_storage.save(full_path, content_file)
                logger.debug(f"Successfully wrote content to {saved_path}")
                return f"SUCCESS: File '{filename}' written to {saved_path} (Length: {len(content)} chars)"

            except UnicodeEncodeError as ue:
                error_msg = f"Error encoding content: {str(ue)}"
                logger.error(error_msg)
                return f"ERROR: {error_msg}"

        except KeyError as ke:
            error_msg = f"Missing required key in input: {str(ke)}"
            logger.error(error_msg)
            return f"Error: {error_msg}"
        except Exception as e:
            error_msg = f"An error occurred while writing to the file: {str(e)}"
            logger.error(error_msg)
            return f"Error: {error_msg}"

================
File: apps/agents/tools/firecrawl_crawl_tool/__init__.py
================
from apps.agents.tools.firecrawl_crawl_tool.firecrawl_crawl_tool import (
    FireCrawlTool,
    FireCrawlToolSchema,
    FireCrawlOutputFormat
)

__all__ = [
    'FireCrawlTool',
    'FireCrawlToolSchema',
    'FireCrawlOutputFormat'
]

================
File: apps/agents/tools/firecrawl_crawl_tool/firecrawl_crawl_tool.py
================
import logging
import json
from typing import Optional, List, Type, Dict, Any, Union
from enum import Enum
from pydantic import BaseModel, Field, field_validator
from apps.agents.tools.base_tool import BaseTool
from django.conf import settings
from urllib.parse import urlparse
import time
from celery import shared_task
from apps.agents.tasks.base import ProgressTask
from celery.contrib.abortable import AbortableTask
import inspect # Keep inspect for task deserialization if needed

# Import the crawl_url functionality
from apps.agents.utils.crawl_url import crawl_url, check_crawl_status

logger = logging.getLogger(__name__)

class FireCrawlOutputFormat(str, Enum):
    MARKDOWN = "markdown"
    HTML = "html"
    BOTH = "both"

class FireCrawlToolSchema(BaseModel):
    """Input schema for FireCrawlTool."""
    url: str = Field(..., description="URL to start crawling from")
    limit: int = Field(default=100, description="Maximum number of pages to crawl")
    max_depth: int = Field(default=10, description="Maximum depth for crawling relative to base URL")
    max_discovery_depth: Optional[int] = Field(
        default=None, 
        description="Maximum depth to crawl based on discovery order. Root site and sitemapped pages have depth 0."
    )
    output_format: str = Field(
        default=FireCrawlOutputFormat.MARKDOWN, 
        description="Format of the output content (markdown, html, both)"
    )
    include_paths: Optional[List[str]] = Field(
        default=None,
        description="URL pathname regex patterns to include in crawl"
    )
    exclude_paths: Optional[List[str]] = Field(
        default=None,
        description="URL pathname regex patterns to exclude from crawl"
    )
    ignore_sitemap: bool = Field(
        default=False,
        description="Ignore the website sitemap when crawling"
    )
    ignore_query_parameters: bool = Field(
        default=False,
        description="Do not re-scrape the same path with different query parameters"
    )
    allow_backward_links: bool = Field(
        default=False,
        description="Enable crawler to navigate from a specific URL to previously linked pages"
    )
    allow_external_links: bool = Field(
        default=False,
        description="Allow crawler to follow links to external websites"
    )
    wait_for_completion: bool = Field(
        default=True,
        description="Wait for crawl to complete before returning results"
    )
    timeout: int = Field(
        default=3600,
        description="Maximum seconds to wait for crawl completion"
    )
    poll_interval: int = Field(
        default=30,
        description="Seconds between status checks when waiting for completion"
    )
    # Additional scrape options for each page
    only_main_content: bool = Field(
        default=False,
        description="Only extract the main content of each page, ignoring headers, footers, etc."
    )
    timeout_ms: int = Field(
        default=30000,
        description="Timeout in milliseconds for each page request"
    )
    remove_base64_images: bool = Field(
        default=True,
        description="Remove base64-encoded images from HTML content"
    )
    block_ads: bool = Field(
        default=True,
        description="Block ads and trackers when scraping pages"
    )
    
    @field_validator('url')
    def validate_url(cls, v):
        """Validate URL format."""
        if not v.startswith(('http://', 'https://')):
            raise ValueError("URL must start with http:// or https://")
        return v
        
    @field_validator('output_format')
    def normalize_output_format(cls, v):
        """Handle any format of output format specification."""
        try:
            logger.debug(f"Normalizing output_format: {repr(v)}")
            
            # Convert any input to a string first for consistency
            input_str = str(v)
            
            # Remove all quotes (both single and double)
            cleaned = input_str.replace('"', '').replace("'", '')
            cleaned = cleaned.lower().strip()
            
            # Check for valid values
            if cleaned == "both" or cleaned == "markdown,html" or cleaned == "html,markdown":
                return FireCrawlOutputFormat.BOTH
            elif cleaned == "markdown":
                return FireCrawlOutputFormat.MARKDOWN
            elif cleaned == "html":
                return FireCrawlOutputFormat.HTML
            else:
                logger.warning(f"Invalid output format: {cleaned}, defaulting to MARKDOWN")
                return FireCrawlOutputFormat.MARKDOWN
            
        except Exception as e:
            logger.error(f"Error normalizing output_format {repr(v)}: {str(e)}")
            # Default to MARKDOWN if there's an error
            logger.warning(f"Defaulting to MARKDOWN output_format due to validation error")
            return FireCrawlOutputFormat.MARKDOWN

class FireCrawlAbortableTask(AbortableTask, ProgressTask):
    """Abortable task that supports progress reporting"""
    pass

class FireCrawlTool(BaseTool):
    """
    A tool that crawls websites using FireCrawl's API starting from a URL,
    following links up to a specified depth, and extracting content in markdown and/or HTML format.
    Can be configured to include/exclude URL patterns and other crawl settings.
    """
    name: str = "FireCrawl Tool"
    description: str = """
    A tool that crawls websites using FireCrawl's powerful crawling capabilities.
    It starts from a URL, recursively follows links based on your configuration,
    and extracts content in markdown and/or HTML format.
    
    You can configure:
    - Maximum pages to crawl
    - Maximum crawl depth
    - URL patterns to include or exclude
    - Whether to stay within domain or follow external links
    - Whether to use the sitemap or ignore it
    - And more advanced options
    
    This tool is especially useful for comprehensive data collection from websites.
    """
    args_schema: Type[BaseModel] = FireCrawlToolSchema
    
    def _run(self, url: str, limit: int = 100, max_depth: int = 10,
             max_discovery_depth: Optional[int] = None, output_format: str = "markdown",
             include_paths: Optional[List[str]] = None, exclude_paths: Optional[List[str]] = None,
             ignore_sitemap: bool = False, ignore_query_parameters: bool = False,
             allow_backward_links: bool = False, allow_external_links: bool = False,
             wait_for_completion: bool = True, timeout: int = 3600, poll_interval: int = 30,
             only_main_content: bool = True, timeout_ms: int = 30000,
             remove_base64_images: bool = True, block_ads: bool = True,
             **kwargs) -> str:
        """
        Run the FireCrawl crawling tool.
        
        Args:
            url: URL to start crawling from
            limit: Maximum number of pages to crawl
            max_depth: Maximum depth for crawling
            max_discovery_depth: Maximum depth based on discovery order
            output_format: Format of output content (markdown, html, both)
            include_paths: URL pathname regex patterns to include
            exclude_paths: URL pathname regex patterns to exclude
            ignore_sitemap: Whether to ignore the sitemap
            ignore_query_parameters: Whether to ignore query parameters
            allow_backward_links: Whether to allow backward links
            allow_external_links: Whether to allow external links
            wait_for_completion: Wait for crawl to complete before returning
            timeout: Maximum seconds to wait for crawl completion
            poll_interval: Seconds between status checks
            only_main_content: Only extract the main content of each page
            timeout_ms: Timeout in milliseconds for each page request
            remove_base64_images: Remove base64-encoded images from HTML content
            block_ads: Block ads and trackers when scraping pages
            
        Returns:
            JSON string with crawling results
        """
        try:
            # Debug logging for parameters
            logger.debug(f"FireCrawlTool._run called with: url={url}, limit={limit}, max_depth={max_depth}, output_format={repr(output_format)}")
            logger.debug(f"Scrape options args: only_main_content={only_main_content}, timeout_ms={timeout_ms}, remove_base64_images={remove_base64_images}, block_ads={block_ads}")
            
            # Get current task if available
            current_task = kwargs.get('task', None)
            
            # Prepare scrape options based on output format
            include_html = False
            include_markdown = False
            
            # Ensure output_format is validated enum value or string
            try:
                # Validate directly from the input string
                validated_output_format = FireCrawlToolSchema(url="http://example.com", output_format=output_format).output_format
                logger.debug(f"Validated output_format using schema: {validated_output_format}")
            except Exception as e:
                logger.warning(f"Could not validate output_format '{output_format}' via schema: {e}. Using raw value.")
                # Attempt manual normalization as fallback
                cleaned = str(output_format).replace('"', '').replace("'", '').lower().strip()
                if cleaned == "both" or cleaned == "markdown,html" or cleaned == "html,markdown":
                     validated_output_format = FireCrawlOutputFormat.BOTH
                elif cleaned == "html":
                    validated_output_format = FireCrawlOutputFormat.HTML
                else:
                    # Default to markdown if any issue
                    if cleaned != "markdown":
                        logger.warning(f"Defaulting to MARKDOWN for output_format: {output_format}")
                    validated_output_format = FireCrawlOutputFormat.MARKDOWN
            
            if validated_output_format == FireCrawlOutputFormat.MARKDOWN:
                include_markdown = True
            elif validated_output_format == FireCrawlOutputFormat.HTML:
                include_html = True
            elif validated_output_format == FireCrawlOutputFormat.BOTH:
                include_html = True
                include_markdown = True
            
            # Prepare scrape options dictionary
            scrape_options = {
                "formats": []
            }
            
            if include_markdown:
                scrape_options["formats"].append("markdown")
                logger.debug("Added 'markdown' to scrape formats.")
            if include_html:
                scrape_options["formats"].append("html")
                logger.debug("Added 'html' to scrape formats.")
                
            # Ensure formats list is not empty; default to markdown if it is
            if not scrape_options["formats"]:
                 logger.warning("Formats list was empty, defaulting to include markdown.")
                 scrape_options["formats"].append("markdown")
                 include_markdown = True
            
            scrape_options["onlyMainContent"] = only_main_content
            scrape_options["timeout"] = timeout_ms
            scrape_options["removeBase64Images"] = remove_base64_images
            scrape_options["blockAds"] = block_ads
            
            logger.debug(f"Final scrape_options passed to crawl_url: {json.dumps(scrape_options)}")
            
            # Update progress if task is provided
            if current_task:
                current_task.update_progress(0, 100, "Starting crawl", url=url)
            
            # Call the crawl_url function
            result_dict = crawl_url(
                url=url,
                limit=limit,
                exclude_paths=exclude_paths,
                include_paths=include_paths,
                max_depth=max_depth,
                max_discovery_depth=max_discovery_depth,
                ignore_sitemap=ignore_sitemap,
                ignore_query_parameters=ignore_query_parameters,
                allow_backward_links=allow_backward_links,
                allow_external_links=allow_external_links,
                scrape_options=scrape_options,
                include_html=include_html,
                include_markdown=include_markdown,
                poll_interval=poll_interval,
                wait_for_completion=wait_for_completion,
                timeout=timeout
            )
            
            # Log the result structure
            if result_dict:
                logger.debug(f"Result keys from crawl_url: {list(result_dict.keys() if isinstance(result_dict, dict) else [])}")
                if isinstance(result_dict, dict) and 'pages' in result_dict:
                    logger.debug(f"Total pages in result: {len(result_dict['pages'])}")
                    if result_dict['pages']:
                        first_page = result_dict['pages'][0]
                        logger.debug(f"First page keys: {list(first_page.keys())}")
                        logger.debug(f"First page content length: {len(first_page.get('content', ''))}, textContent length: {len(first_page.get('textContent', ''))}")
            
            # Update task progress
            if current_task and result_dict and wait_for_completion:
                current_task.update_progress(
                    100, 100, 
                    "Crawl completed successfully", 
                    url=url, 
                    total_pages=result_dict.get("total_pages", 0)
                )
            
            # Convert result to JSON string
            if result_dict:
                if isinstance(result_dict, dict) and result_dict.get("success") and "pages" in result_dict and result_dict["pages"]:
                    if not result_dict["pages"][0].get("content") and not result_dict["pages"][0].get("textContent"):
                        logger.warning("Result has pages but the first page has empty content/textContent.")
                        
                return json.dumps(result_dict, indent=2)
            else:
                return json.dumps({"status": "error", "message": "Crawl failed or returned no results"})
                
        except Exception as e:
            logger.error(f"Error in FireCrawlTool: {str(e)}", exc_info=True)
            if current_task:
                current_task.update_progress(100, 100, f"Error: {str(e)}", url=url, error=str(e))
            return json.dumps({"status": "error", "message": str(e)})

# Add model_config for pydantic v2 compatibility
model_config = {
    "arbitrary_types_allowed": True,
    "extra": "forbid"
}

================
File: apps/agents/tools/google_analytics_tool/generic_google_analytics_tool.py
================
import os
import json
import logging
import sys
from typing import Any, Type, List, Optional, Dict, Union
from pydantic import BaseModel, Field, field_validator
from google.analytics.data_v1beta.types import DateRange, Metric, Dimension, RunReportRequest, OrderBy, RunReportResponse
from datetime import datetime
from apps.agents.tools.base_tool import BaseTool
from google.analytics.data_v1beta import BetaAnalyticsDataClient
from google.analytics.data_v1beta.types import CheckCompatibilityRequest
from enum import Enum
from typing import Optional, List, Union
import pandas as pd
from datetime import datetime, timedelta
from apps.common.utils import DateProcessor

from django.core.exceptions import ObjectDoesNotExist
from apps.seo_manager.models import GoogleAnalyticsCredentials

logger = logging.getLogger(__name__)

"""
Generic Google Analytics Tool for fetching customizable GA4 data.

Example usage:
    tool = GenericGoogleAnalyticsTool()
    
    # Basic usage with required parameters
    result = tool._run(
        analytics_property_id="123456789",
        analytics_credentials={
            "access_token": "your_access_token",
            "refresh_token": "your_refresh_token",
            "ga_client_id": "your_client_id",
            "client_secret": "your_client_secret"
        }
    )
    
    # Custom query
    result = tool._run(
        analytics_property_id="123456789",
        analytics_credentials=credentials_dict,
        start_date="7daysAgo",
        end_date="today", 
        metrics="totalUsers,sessions,bounceRate",
        dimensions="date,country,deviceCategory",
        dimension_filter="country==United States",
        metric_filter="sessions>100",
        currency_code="USD",
        limit=2000
    )
"""

class TimeGranularity(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    AUTO = "auto"

class DataFormat(str, Enum):
    RAW = "raw"
    SUMMARY = "summary"
    COMPACT = "compact"

class MetricAggregation(str, Enum):
    SUM = "sum"
    AVERAGE = "average"
    MIN = "min"
    MAX = "max"

class GoogleAnalyticsRequest(BaseModel):
    """Input schema for the generic Google Analytics Request tool."""
    start_date: Optional[str] = Field(
        default="28daysAgo",
        description="""
        Start date in one of these formats:
        - YYYY-MM-DD (e.g., 2024-03-15)
        - Relative days: 'today', 'yesterday', 'NdaysAgo' (e.g., 7daysAgo)
        - Relative months: 'NmonthsAgo' (e.g., 3monthsAgo)
        
        Note: While GA4 API only supports days, this tool automatically converts
        month-based dates to the appropriate day format.
        """
    )
    end_date: Optional[str] = Field(
        default="yesterday",
        description="""
        End date in one of these formats:
        - YYYY-MM-DD (e.g., 2024-03-15)
        - Relative days: 'today', 'yesterday', 'NdaysAgo' (e.g., 7daysAgo)
        - Relative months: 'NmonthsAgo' (e.g., 3monthsAgo)
        """
    )
    analytics_property_id: str = Field(
        ...,
        description="The Google Analytics property ID to use for fetching data."
    )
    analytics_credentials: Dict[str, Any] = Field(
        ...,
        description="The credentials needed to authenticate with Google Analytics."
    )

    metrics: Optional[str] = Field(
        default="totalUsers,sessions",
        description="Comma-separated list of metric names."
    )
    dimensions: Optional[str] = Field(
        default="date",
        description="Comma-separated list of dimension names (e.g., 'date,country,deviceCategory')."
    )
    dimension_filter: Optional[str] = Field(
        default=None,
        description="Filter expression for dimensions (e.g., 'country==United States')."
    )
    metric_filter: Optional[str] = Field(
        default=None,
        description="Filter expression for metrics (e.g., 'sessions>100')."
    )
    currency_code: Optional[str] = Field(
        default=None,
        description="The currency code for metrics involving currency (e.g., 'USD')."
    )
    keep_empty_rows: Optional[bool] = Field(
        default=False,
        description="Whether to keep empty rows in the response."
    )
    limit: Optional[int] = Field(
        default=1000,
        description="Optional limit on the number of rows to return (default 1000, max 100000)."
    )
    offset: Optional[int] = Field(
        default=None,
        description="Optional offset for pagination."
    )
    data_format: Optional[DataFormat] = Field(
        default=DataFormat.RAW,
        description="""
        How to format the returned data:
        - 'raw': Returns all data points (use for detailed analysis)
        - 'summary': Returns statistical summary (min/max/mean/median) - best for high-level insights
        - 'compact': Returns top N results (good for finding top performers)
        
        Example use cases:
        - For trend analysis: use 'raw' with date dimension
        - For performance overview: use 'summary'
        - For top traffic sources: use 'compact' with top_n=5
        """
    )
    top_n: Optional[int] = Field(
        default=None,
        description="""
        Return only top N results by primary metric.
        
        Example use cases:
        - top_n=5 with dimensions="country" → top 5 countries
        - top_n=10 with dimensions="pagePath" → top 10 pages
        - top_n=3 with dimensions="sessionSource" → top 3 traffic sources
        """
    )
    time_granularity: Optional[TimeGranularity] = Field(
        default=TimeGranularity.AUTO,
        description="""
        Time period to aggregate data by:
        - 'daily': Keep daily granularity (best for 1-7 day ranges)
        - 'weekly': Group by weeks (best for 8-60 day ranges)
        - 'monthly': Group by months (best for 60+ day ranges)
        - 'auto': Automatically choose based on date range
        
        Example use cases:
        - For last week analysis: use 'daily'
        - For quarterly trends: use 'monthly'
        - For year-over-year: use 'monthly'
        """
    )
    aggregate_by: Optional[List[str]] = Field(
        default=None,
        description="""
        Dimensions to group data by. Combines all other dimensions.
        
        Example use cases:
        - ['country'] → aggregate all metrics by country
        - ['deviceCategory'] → combine data across all devices
        - ['sessionSource', 'country'] → group by both source and country
        
        Common combinations:
        - Traffic analysis: ['sessionSource', 'sessionMedium']
        - Geographic insights: ['country', 'city']
        - Device analysis: ['deviceCategory', 'browser']
        """
    )
    metric_aggregation: Optional[MetricAggregation] = Field(
        default=MetricAggregation.SUM,
        description="How to aggregate metrics when grouping data"
    )
    include_percentages: Optional[bool] = Field(
        default=False,
        description="""
        Add percentage calculations relative to totals.
        Adds '_pct' suffix to metric names (e.g., 'sessions_pct').
        
        Example use cases:
        - Traffic distribution: see % of sessions by country
        - Device share: % of users by deviceCategory
        - Source attribution: % of conversions by source
        """
    )
    normalize_metrics: Optional[bool] = Field(
        default=False,
        description="""
        Scale numeric metrics to 0-1 range for easier comparison.
        Adds '_normalized' suffix to metric names.
        
        Use when:
        - Comparing metrics with different scales
        - Looking for relative performance
        - Creating visualizations
        """
    )
    round_digits: Optional[int] = Field(
        default=None,
        description="Round numeric values to specified digits"
    )
    include_period_comparison: Optional[bool] = Field(
        default=False,
        description="""
        Include comparison with previous period.
        
        Example use cases:
        - Month-over-month growth
        - Year-over-year comparison
        - Week-over-week performance
        
        Returns additional fields:
        - previous_period_value
        - percentage_change
        """
    )
    detect_anomalies: Optional[bool] = Field(
        default=False,
        description="Identify significant deviations from normal patterns"
    )
    moving_average_window: Optional[int] = Field(
        default=None,
        description="""
        Calculate moving averages over specified number of periods.
        Only applies when data includes the 'date' dimension.
        
        Example use cases:
        - 7-day moving average for smoothing daily fluctuations
        - 30-day moving average for trend analysis
        - 90-day moving average for long-term patterns
        
        Adds '_ma{window}' suffix to metric names (e.g., 'sessions_ma7')
        """
    )

    @field_validator("start_date", "end_date", mode='before')
    @classmethod
    def validate_dates(cls, value: Optional[str]) -> str:
        # Handle None case for dates, returning default if None
        if value is None or (isinstance(value, str) and value.lower() == 'none'):
            # Need to know which field this is to return the correct default
            # Inspect the validation info (if available) or handle based on context
            # For now, let's assume start_date default. This logic needs refinement.
            # A better approach might be separate validators or checking validation_info
            # For simplicity here, we'll just return a known default, but this isn't robust.
            # Let's try using the default from the Field definition directly if possible.
            # Pydantic v2: info.field_name
            # Fallback: Just return the start_date default for now
             return "28daysAgo" # Placeholder - needs better default handling
        return DateProcessor.process_relative_date(value)
        
    @field_validator("analytics_property_id")
    @classmethod
    def ensure_property_id_is_string(cls, value) -> str:
        """Ensure the property ID is always a string."""
        if value is None:
            raise ValueError("Analytics property ID cannot be None")
        
        # Convert to string if it's not already
        return str(value)

    @field_validator('time_granularity', mode='before')
    @classmethod
    def handle_none_time_granularity(cls, v):
        """If time_granularity is explicitly passed as None, use the default."""
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return TimeGranularity.AUTO
        return v

    @field_validator('data_format', mode='before')
    @classmethod
    def handle_none_data_format(cls, v):
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return DataFormat.RAW
        return v

    @field_validator('metric_aggregation', mode='before')
    @classmethod
    def handle_none_metric_aggregation(cls, v):
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return MetricAggregation.SUM
        return v

    # Validators for boolean fields with defaults
    @field_validator('include_percentages', 'normalize_metrics', 'include_period_comparison', 'detect_anomalies', mode='before')
    @classmethod
    def handle_none_bool_defaults(cls, v):
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return False # Default for these bools is False
        return v
        
    # Validators for string fields with defaults
    @field_validator('metrics', mode='before')
    @classmethod
    def handle_none_metrics(cls, v):
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return "totalUsers,sessions" # Default metrics
        return v

    @field_validator('dimensions', mode='before')
    @classmethod
    def handle_none_dimensions(cls, v):
        if v is None or (isinstance(v, str) and v.lower() == 'none'):
            return "date" # Default dimension
        return v

class GenericGoogleAnalyticsTool(BaseTool):
    name: str = "GA4 Analytics Data Tool"
    description: str = """
    Fetches data from Google Analytics 4 (GA4) with powerful data processing capabilities.
    
    Required Parameters:
    - start_date: The start date for the data range
    - end_date: The end date for the data range
    - analytics_property_id: The GA4 property ID to fetch data from
    - analytics_credentials: Dictionary containing the required OAuth2 credentials:
        - access_token
        - refresh_token
        - ga_client_id
        - client_secret
    
    Key Features:
    - Flexible date ranges (e.g., '7daysAgo', '3monthsAgo', 'YYYY-MM-DD')
    - Common metrics: sessions, users, pageviews, bounce rate, etc.
    - Dimensions: date, country, device, source, medium, etc.
    - Data processing: aggregation, filtering, summaries
    
    Example Commands:
    1. Basic traffic data:
       tool._run(
           analytics_property_id="123456789",
           analytics_credentials=credentials_dict,
           metrics="sessions,users",
           dimensions="date"
       )
    
    2. Top countries by sessions:
       tool._run(
           analytics_property_id="123456789",
           analytics_credentials=credentials_dict,
           metrics="sessions",
           dimensions="country",
           data_format="compact",
           top_n=5
       )
    
    3. Monthly trend with comparisons:
       tool._run(
           analytics_property_id="123456789",
           analytics_credentials=credentials_dict,
           start_date="6monthsAgo",
           time_granularity="monthly",
           include_period_comparison=True
       )
    """
    args_schema: Type[BaseModel] = GoogleAnalyticsRequest
    
    def __init__(self, **kwargs):
        super().__init__()
        logger.info("GenericGoogleAnalyticsTool initialized")
        self._initialize_dimensions_metrics()

    def _initialize_dimensions_metrics(self):
        """Initialize the available dimensions and metrics"""
        self._available_metrics = [
            "totalUsers",
            "sessions",
            "averageSessionDuration",
            "screenPageViews",
            "screenPageViewsPerSession",
            "newUsers",
            "firstVisit",
            "bounceRate",
            "engagedSessions",
            "engagementRate",
            "activeUsers",
            "eventCount",
            "eventsPerSession",
            "keyEvents",
            "conversions",
            "userEngagementDuration",
            "grossPurchaseRevenue",
            "averagePurchaseRevenuePerPayingUser",
            "averageRevenuePerUser",
            "addToCarts",
            "ecommercePurchases",
            "advertiserAdCost",
            "advertiserAdCostPerClick",
            "advertiserAdImpressions",
            "advertiserAdClicks",
            "totalRevenue"
        ]
        
        # Add metric type classifications
        self._summable_metrics = {
            "totalUsers",
            "sessions",
            "screenPageViews",
            "newUsers",
            "firstVisit",
            "engagedSessions",
            "activeUsers",
            "eventCount",
            "keyEvents",
            "conversions",
            "userEngagementDuration",
            "totalRevenue",
            "advertiserAdClicks",
            "advertiserAdImpressions",
            "advertiserAdCost",
            "grossPurchaseRevenue",
            "totalRevenue",
 

        }
        
        self._averaged_metrics = {
            "averageSessionDuration",
            "screenPageViewsPerSession",
            "bounceRate",
            "engagementRate",
            "eventsPerSession",
            "averagePurchaseRevenuePerPayingUser",
            "averageRevenuePerUser",
            "advertiserAdCostPerClick",
            "averageSessionDuration"
        }

        self._available_dimensions = [
            "date",
            "deviceCategory",
            "platform",
            "sessionSource",
            "sessionMedium",
            "sessionCampaignName",
            "sessionDefaultChannelGroup",
            "country",
            "city",
            "landingPage",
            "pagePath",
            "browser",
            "operatingSystem",
            "sessionCampaignName",
            "sessionGoogleAdsAdGroupName",
            "firstUserGoogleAdsGroupName",
            "defaultChannelGroup",
            "sessionSourceMedium",
            "userGender",
            "city",
            "country",
            "continent",
            "region",
            "metro",
            "brandingInterests",
            "dayOfWeek",
            "dayofWeekName",
            "Hour",
            "newVsReturning",
            "userAgeBracket",
            "eventName",
            "landingPage",
            "firstUserSourceMedium",
            "firstUserMedium",
            "firstUserPrimaryChannelGroup",
            "firstUserDefaultChannelGroup",
            "firstUserSource",
            "firstUserSourcePlatform",
            "firstUserCampaignName",
            "sessiongoogleAdsAdGroupName",
            "firstUserGoogleAdsKeyword",
            "firstuserGoogleAdsQuery",
            "googleAdsKeyword",
            "googleAdsQuery"
        ]

    def _check_compatibility(self, service, property_id: str, metrics: List[str], dimensions: List[str]) -> tuple[bool, str]:
        """
        Check if the requested metrics and dimensions are compatible.
        Returns a tuple of (is_compatible: bool, error_message: str)
        """
        try:
            # Create separate metric and dimension objects
            metric_objects = [Metric(name=m.strip()) for m in metrics]
            dimension_objects = [Dimension(name=d.strip()) for d in dimensions]

            request = CheckCompatibilityRequest(
                property=f"properties/{property_id}",
                metrics=metric_objects,
                dimensions=dimension_objects
            )
            
            response = service.check_compatibility(request=request)

            # Check for dimension errors
            if response.dimension_compatibilities:
                for dim_compat in response.dimension_compatibilities:
                    dim_name = getattr(dim_compat.dimension_metadata, 'api_name', 'unknown')
                    if dim_name in dimensions:
                        if dim_compat.compatibility == 'INCOMPATIBLE':
                            error_msg = f"Incompatible dimension: {dim_name}"
                            logger.error(error_msg)
                            return False, error_msg
            
            # Check for metric errors
            if response.metric_compatibilities:
                for metric_compat in response.metric_compatibilities:
                    metric_name = getattr(metric_compat.metric_metadata, 'api_name', 'unknown')
                    if metric_name in metrics:
                        if metric_compat.compatibility == 'INCOMPATIBLE':
                            error_msg = f"Incompatible metric: {metric_name}"
                            logger.error(error_msg)
                            return False, error_msg
            
            return True, "Compatible"

        except Exception as e:
            logger.error(f"Error checking compatibility: {str(e)}", exc_info=True)
            # Return a more graceful fallback - assume compatible if check fails
            return True, "Compatibility check failed, proceeding with request"

    def _run(
        self,
        start_date="28daysAgo",
        end_date="yesterday",
        analytics_property_id=None,
        analytics_credentials=None,
        metrics="totalUsers,sessions",
        dimensions="date",
        dimension_filter=None,
        metric_filter=None,
        currency_code=None,
        keep_empty_rows=False,
        limit=1000,
        offset=None,
        data_format="raw",
        top_n=None,
        time_granularity="auto",
        aggregate_by=None,
        metric_aggregation="sum",
        include_percentages=False,
        normalize_metrics=False,
        round_digits=None,
        include_period_comparison=False,
        detect_anomalies=False,
        moving_average_window=None
    ) -> dict:
        """
        Run the Google Analytics tool.
        """
        try:
            # Detailed input parameter logging
            logger.info("=" * 80)
            logger.info("GOOGLE ANALYTICS TOOL RECEIVED PARAMETERS:")
            logger.info(f"analytics_property_id present: {analytics_property_id is not None}")
            if analytics_property_id is not None:
                logger.info(f"analytics_property_id value: {analytics_property_id}")
            logger.info(f"analytics_credentials present: {analytics_credentials is not None}")
            if analytics_credentials is not None:
                if isinstance(analytics_credentials, dict):
                    credential_keys = list(analytics_credentials.keys())
                    logger.info(f"analytics_credentials keys: {credential_keys}")
                    # Check for essential fields
                    required_fields = ['access_token', 'refresh_token', 'ga_client_id', 'client_secret']
                    missing_fields = [field for field in required_fields if field not in credential_keys]
                    if missing_fields:
                        logger.warning(f"Missing credential fields: {missing_fields}")
                else:
                    logger.warning(f"analytics_credentials is not a dict, it's a {type(analytics_credentials)}")
            logger.info(f"start_date: {start_date}")
            logger.info(f"end_date: {end_date}")
            logger.info(f"metrics: {metrics}")
            logger.info(f"dimensions: {dimensions}")
            logger.info("=" * 80)
            
            # Convert to DataFormat enum
            if isinstance(data_format, str):
                data_format = DataFormat(data_format.lower())
                
            # Convert to MetricAggregation enum
            if isinstance(metric_aggregation, str):
                metric_aggregation = MetricAggregation(metric_aggregation.lower())
                
            # Convert to TimeGranularity enum
            if isinstance(time_granularity, str):
                time_granularity = TimeGranularity(time_granularity.lower())
            
            # Validate required parameters
            if not analytics_property_id:
                return {
                    'success': False,
                    'error': "Missing required parameter: analytics_property_id",
                    'analytics_data': []
                }
                
            if not analytics_credentials:
                return {
                    'success': False,
                    'error': "Missing required parameter: analytics_credentials",
                    'analytics_data': []
                }
            
            # Validate credentials before attempting to use them
            required_fields = ['access_token', 'refresh_token', 'ga_client_id', 'client_secret']
            missing_fields = [field for field in required_fields if not analytics_credentials.get(field)]
            if missing_fields:
                missing_fields_str = ', '.join(missing_fields)
                logger.error(f"Missing required credential fields: {missing_fields_str}")
                raise ValueError(f"Incomplete Google Analytics credentials. Missing: {missing_fields_str}")

            # Create the request params object
            request_params = GoogleAnalyticsRequest(
                start_date=start_date,
                end_date=end_date,
                analytics_property_id=analytics_property_id,
                analytics_credentials=analytics_credentials,
                metrics=metrics,
                dimensions=dimensions,
                dimension_filter=dimension_filter,
                metric_filter=metric_filter,
                currency_code=currency_code,
                keep_empty_rows=keep_empty_rows,
                limit=limit,
                offset=offset,
                data_format=data_format,
                top_n=top_n,
                time_granularity=time_granularity,
                aggregate_by=aggregate_by,
                metric_aggregation=metric_aggregation,
                include_percentages=include_percentages,
                normalize_metrics=normalize_metrics,
                round_digits=round_digits,
                include_period_comparison=include_period_comparison,
                detect_anomalies=detect_anomalies,
                moving_average_window=moving_average_window
            )
            
            # Create the Google Analytics client from credentials
            from google.analytics.data_v1beta import BetaAnalyticsDataClient
            from google.oauth2.credentials import Credentials
            from google.auth.transport.requests import Request
            
            # Log incoming credentials for debugging
            logger.debug(f"Analytics property ID: {analytics_property_id}")
            logger.debug(f"Credential fields available: {list(analytics_credentials.keys())}")
            
            # Create credentials object from the provided dictionary
            credentials = Credentials(
                token=analytics_credentials.get('access_token'),
                refresh_token=analytics_credentials.get('refresh_token'),
                token_uri=analytics_credentials.get('token_uri', 'https://oauth2.googleapis.com/token'),
                client_id=analytics_credentials.get('ga_client_id'),
                client_secret=analytics_credentials.get('client_secret'),
                scopes=analytics_credentials.get('scopes', [
                    'https://www.googleapis.com/auth/analytics.readonly',
                    'https://www.googleapis.com/auth/userinfo.email'
                ])
            )
            
            # Try to refresh the token if we have a refresh token
            if credentials.refresh_token:
                try:
                    logger.debug("Attempting to refresh credentials token")
                    request = Request()
                    credentials.refresh(request)
                    logger.debug("Successfully refreshed credentials token")
                except Exception as e:
                    logger.error(f"Failed to refresh token: {str(e)}")
                    if 'invalid_grant' in str(e).lower():
                        raise ValueError("Google Analytics credentials have expired. Please reconnect your Google Analytics account.")
            
            # Create the analytics service
            service = BetaAnalyticsDataClient(credentials=credentials)
            
            # Validate metrics and dimensions against available lists
            metrics_list = [m.strip() for m in request_params.metrics.split(',')]
            dimensions_list = [d.strip() for d in request_params.dimensions.split(',')]
            
            for metric in metrics_list:
                if metric not in self._available_metrics:
                    return {
                        'success': False,
                        'error': f"Invalid metric: {metric}. Available metrics: {', '.join(self._available_metrics)}",
                        'analytics_data': []
                    }
            
            for dimension in dimensions_list:
                if dimension not in self._available_dimensions:
                    return {
                        'success': False,
                        'error': f"Invalid dimension: {dimension}. Available dimensions: {', '.join(self._available_dimensions)}",
                        'analytics_data': []
                    }
            
            # Check compatibility before running the report
            is_compatible, error_message = self._check_compatibility(
                service, 
                analytics_property_id, 
                metrics_list, 
                dimensions_list
            )
            
            if not is_compatible:
                return {
                    'success': False,
                    'error': error_message,
                    'analytics_data': []
                }

            # Log the request parameters for debugging
            logger.debug("Creating RunReportRequest with parameters: %s", {
                "property": f"properties/{analytics_property_id}",
                "date_ranges": [{
                    "start_date": request_params.start_date,
                    "end_date": request_params.end_date
                }],
                "metrics": [{"name": m.strip()} for m in request_params.metrics.split(',')],
                "dimensions": [{"name": d.strip()} for d in request_params.dimensions.split(',')],
                "dimension_filter": request_params.dimension_filter,
                "metric_filter": request_params.metric_filter,
                "currency_code": request_params.currency_code,
                "keep_empty_rows": request_params.keep_empty_rows,
                "limit": request_params.limit,
                "offset": request_params.offset,
                "order_bys": [
                    {
                        "dimension": {
                            "dimension_name": "date"
                        },
                        "desc": False
                    }
                ] if "date" in dimensions_list else None,
                "return_property_quota": True
            })

            # Create the RunReportRequest
            request = RunReportRequest({
                "property": f"properties/{analytics_property_id}",
                "date_ranges":[DateRange(
                    start_date=request_params.start_date,
                    end_date=request_params.end_date
                )],
                "metrics": [{"name": m.strip()} for m in request_params.metrics.split(',')],
                "dimensions": [{"name": d.strip()} for d in request_params.dimensions.split(',')],
                "dimension_filter": self._parse_filter(request_params.dimension_filter) if request_params.dimension_filter else None,
                "metric_filter": self._parse_filter(request_params.metric_filter) if request_params.metric_filter else None,
                "currency_code": request_params.currency_code,
                "keep_empty_rows": request_params.keep_empty_rows,
                "limit": request_params.limit,
                "offset": request_params.offset,
                "order_bys": [
                    {
                        "dimension": {
                            "dimension_name": "date"
                        },
                        "desc": False
                    }
                ] if "date" in dimensions_list else None,
                "return_property_quota": True
            })

            # Get the raw response
            response = service.run_report(request)
            
            # Format the raw response
            raw_data = self._format_response(response, 
                                           request_params.metrics.split(','), 
                                           request_params.dimensions.split(','))
            
            # Process the data according to the request parameters
            if raw_data['success']:
                processed_data = DataProcessor.process_data(
                    raw_data['analytics_data'], 
                    request_params,
                    self._averaged_metrics
                )
                
                # Handle period comparison format
                if isinstance(processed_data, dict) and 'period_comparison' in processed_data:
                    return {
                        'success': True,
                        'analytics_data': processed_data['data'],
                        'period_comparison': processed_data['period_comparison'],
                        'property_id': analytics_property_id,
                        'start_date': start_date,
                        'end_date': end_date
                    }
                
                return {
                    'success': True,
                    'analytics_data': processed_data,
                    'property_id': analytics_property_id,
                    'start_date': start_date,
                    'end_date': end_date
                }
            
            return raw_data
        except Exception as e:
            error_str = str(e)
            logger.error(f"Error in GenericGoogleAnalyticsTool: {error_str}")
            logger.error("Full error details:", exc_info=True)
            
            # Provide more specific error messages
            if 'invalid_grant' in error_str.lower() or 'invalid authentication credentials' in error_str.lower() or '401' in error_str:
                error_message = "Google Analytics credentials have expired or are invalid. Please reconnect your Google Analytics account."
            elif 'quota' in error_str.lower() or 'rate limit' in error_str.lower() or '429' in error_str:
                error_message = "Google Analytics API quota exceeded. Please try again later."
            elif 'permission' in error_str.lower() or '403' in error_str:
                error_message = "Insufficient permissions to access Google Analytics data. Please check your account permissions."
            elif not analytics_credentials.get('access_token'):
                error_message = "Missing access token in Google Analytics credentials."
            elif not analytics_credentials.get('refresh_token'):
                error_message = "Missing refresh token in Google Analytics credentials."
            elif not analytics_credentials.get('ga_client_id') or not analytics_credentials.get('client_secret'):
                error_message = "Missing client credentials in Google Analytics configuration."
            elif 'property' in error_str.lower() and ('not found' in error_str.lower() or 'invalid' in error_str.lower()):
                error_message = f"Invalid Google Analytics property ID: {analytics_property_id}. Please verify your property ID."
            else:
                error_message = f"Error fetching Google Analytics data: {error_str}"
            
            return {
                'success': False,
                'error': error_message,
                'error_details': str(e),
                'analytics_data': []
            }

    def _parse_filter(self, filter_string: str) -> dict:
        """
        Parse filter string into GA4 filter object.
        Examples:
            - "country==United States" -> exact string match
            - "sessions>100" -> numeric greater than
        """
        try:
            if '==' in filter_string:
                field, value = filter_string.split('==')
                return {
                    "filter": {
                        "field_name": field.strip(),
                        "string_filter": {
                            "value": value.strip(),
                            "match_type": "EXACT",
                            "case_sensitive": False
                        }
                    }
                }
            elif '>' in filter_string:
                field, value = filter_string.split('>')
                return {
                    "filter": {
                        "field_name": field.strip(),
                        "numeric_filter": {
                            "operation": "GREATER_THAN",
                            "value": {
                                "int64_value": int(float(value.strip()))
                            }
                        }
                    }
                }
            
            raise ValueError(f"Unsupported filter format: {filter_string}")
        except Exception as e:
            logger.error(f"Error parsing filter: {str(e)}")
            return None
        
    def _format_response(self, response, metrics: List[str], dimensions: List[str]) -> dict:
        try:
            analytics_data = []
            # Clean dimension names - strip whitespace
            dimensions = [d.strip() for d in dimensions]



            if not hasattr(response, 'rows'):
                return {
                    'success': False,
                    'error': 'No rows in response',
                    'analytics_data': []
                }

            for row in response.rows:
                data_point = {}
                for i, dim in enumerate(dimensions):
                    value = row.dimension_values[i].value
                    if dim == 'date':
                        value = f"{value[:4]}-{value[4:6]}-{value[6:]}"
                    data_point[dim] = value
                for i, metric in enumerate(metrics):
                    try:
                        data_point[metric] = float(row.metric_values[i].value) if row.metric_values[i].value else 0
                    except (ValueError, TypeError):
                        data_point[metric] = 0
                analytics_data.append(data_point)

            return {
                'success': True,
                'analytics_data': analytics_data
            }
        except Exception as e:
            logger.error(f"Error formatting response: {str(e)}", exc_info=True)
            return {
                'success': False,
                'error': f"Failed to format response: {str(e)}",
                'analytics_data': []
            }

class DataProcessor:
    @staticmethod
    def determine_granularity(start_date: str, end_date: str) -> TimeGranularity:
        """Automatically determine appropriate time granularity"""
        try:
            start = datetime.strptime(start_date[:10], "%Y-%m-%d")
            end = datetime.strptime(end_date[:10], "%Y-%m-%d")
            days_difference = (end - start).days
            
            if days_difference <= 7:
                return TimeGranularity.DAILY
            elif days_difference <= 60:
                return TimeGranularity.WEEKLY
            return TimeGranularity.MONTHLY
        except ValueError:
            return TimeGranularity.DAILY

    @staticmethod
    def _calculate_moving_averages(df: pd.DataFrame, window: int, metrics: List[str]) -> pd.DataFrame:
        """Calculate moving averages for specified metrics"""
        if 'date' not in df.columns:
            return df
            
        # Ensure date is datetime for proper sorting
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        for metric in metrics:
            if metric in df.columns:
                df[f'{metric}_ma{window}'] = df[metric].rolling(
                    window=window,
                    min_periods=1  # Allow partial windows at the start
                ).mean()
        
        return df

    @staticmethod
    def _add_period_comparison(df: pd.DataFrame, metrics: List[str]) -> pd.DataFrame:
        """Add period-over-period comparison metrics"""
        if 'date' not in df.columns:
            return df
        
        # Ensure date is datetime for proper sorting
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Calculate the period length
        total_days = (df['date'].max() - df['date'].min()).days
        period_length = total_days // 2
        
        # Create a cutoff date for splitting current and previous periods
        cutoff_date = df['date'].max() - pd.Timedelta(days=period_length)
        
        # Split into current and previous periods
        current_period = df[df['date'] > cutoff_date].copy()
        previous_period = df[df['date'] <= cutoff_date].copy()
        
        # Calculate metrics for both periods
        comparison_data = {}
        
        for metric in metrics:
            if metric in df.columns:
                current_value = float(current_period[metric].mean())  # Convert to float
                previous_value = float(previous_period[metric].mean())  # Convert to float
                
                # Add comparison metrics
                df[f'{metric}_previous'] = previous_value
                df[f'{metric}_change'] = ((current_value - previous_value) / previous_value * 100 
                                        if previous_value != 0 else 0)
                
                comparison_data[metric] = {
                    'current_period': current_value,
                    'previous_period': previous_value,
                    'percent_change': float((current_value - previous_value) / previous_value * 100 
                                         if previous_value != 0 else 0)
                }
        
        # Add comparison summary to the DataFrame
        df.attrs['period_comparison'] = comparison_data
        
        return df

    @staticmethod
    def process_data(data: List[dict], params: GoogleAnalyticsRequest, averaged_metrics: set) -> List[dict]:
        """Process the analytics data based on request parameters"""
        if not data:
            return data

        df = pd.DataFrame(data)

        # Convert date column to datetime if it exists and isn't already datetime
        if 'date' in df.columns and not pd.api.types.is_datetime64_any_dtype(df['date']):
            df['date'] = pd.to_datetime(df['date'])

        # Apply time granularity aggregation if needed
        if params.time_granularity != TimeGranularity.DAILY and 'date' in df.columns:
            df = DataProcessor._aggregate_by_time(df, params.time_granularity, averaged_metrics)

        # Calculate moving averages if requested
        if params.moving_average_window and 'date' in df.columns:
            df = DataProcessor._calculate_moving_averages(
                df,
                params.moving_average_window,
                params.metrics.split(',')
            )

        # Add period comparison if requested
        if params.include_period_comparison and 'date' in df.columns:
            df = DataProcessor._add_period_comparison(
                df,
                params.metrics.split(',')
            )

        # Apply dimension aggregation if specified
        if params.aggregate_by:
            df = DataProcessor._aggregate_by_dimensions(
                df, 
                params.aggregate_by, 
                params.metric_aggregation
            )

        # Apply top N filter
        if params.data_format == DataFormat.COMPACT and params.top_n:
            primary_metric = params.metrics.split(',')[0]
            df = df.nlargest(params.top_n, primary_metric)

        # Add percentages if requested
        if params.include_percentages:
            DataProcessor._add_percentages(df, params.metrics.split(','))

        # Normalize metrics if requested
        if params.normalize_metrics:
            DataProcessor._normalize_metrics(df, params.metrics.split(','))

        # Round values if specified
        if params.round_digits is not None:
            numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns
            df[numeric_cols] = df[numeric_cols].round(params.round_digits)

        # Generate summary if requested
        if params.data_format == DataFormat.SUMMARY:
            return DataProcessor._generate_summary(df, params)

        # Before returning, convert datetime objects to strings if they exist
        if 'date' in df.columns:
            if pd.api.types.is_datetime64_any_dtype(df['date']):
                df['date'] = df['date'].dt.strftime('%Y-%m-%d')
            elif isinstance(df['date'].iloc[0], str) and 'W' in df['date'].iloc[0]:
                # Already in week format, leave as is
                pass
            elif isinstance(df['date'].iloc[0], str) and len(df['date'].iloc[0].split('-')) == 2:
                # Already in month format, leave as is
                pass
            else:
                # Try to format as date string if possible
                try:
                    df['date'] = pd.to_datetime(df['date']).dt.strftime('%Y-%m-%d')
                except:
                    pass  # Keep original format if conversion fails

        # Format the response to include period comparison data if it exists
        result = df.to_dict('records')
        if params.include_period_comparison and hasattr(df, 'attrs') and 'period_comparison' in df.attrs:
            # Ensure datetime objects in comparison data are converted to strings
            comparison_data = df.attrs['period_comparison']
            for metric, values in comparison_data.items():
                if isinstance(values.get('current_period'), pd.Timestamp):
                    values['current_period'] = values['current_period'].strftime('%Y-%m-%d')
                if isinstance(values.get('previous_period'), pd.Timestamp):
                    values['previous_period'] = values['previous_period'].strftime('%Y-%m-%d')
            
            return {
                'data': result,
                'period_comparison': comparison_data
            }
        
        return result

    @staticmethod
    def _aggregate_by_time(df: pd.DataFrame, granularity: TimeGranularity, 
                          averaged_metrics: set) -> pd.DataFrame:
        """
        Aggregate time-based data with proper handling of averaged metrics.
        
        Args:
            df: DataFrame to aggregate
            granularity: TimeGranularity enum value
            averaged_metrics: Set of metrics that should be averaged (weighted)
        """
        # Ensure date is datetime
        df = df.copy()  # Create a copy to avoid modifying original
        df['date'] = pd.to_datetime(df['date'])
        
        # Get all non-date columns that should be preserved in grouping
        group_cols = [col for col in df.columns if col != 'date' and not pd.api.types.is_numeric_dtype(df[col])]
        
        # Create a grouping date column while preserving original
        if granularity == TimeGranularity.WEEKLY:
            df['grouping_date'] = df['date'].dt.strftime('%Y-W%W')
        elif granularity == TimeGranularity.MONTHLY:
            df['grouping_date'] = df['date'].dt.strftime('%Y-%m')
        else:
            df['grouping_date'] = df['date'].dt.strftime('%Y-%m-%d')
        
        # Add grouping_date to group columns
        group_cols.append('grouping_date')
        
        # Create aggregation dictionary based on metric type
        agg_dict = {}
        
        for col in df.select_dtypes(include=['float64', 'int64']).columns:
            # For metrics like bounceRate, we need to calculate weighted average
            if col in averaged_metrics:
                # For bounce rate and engagement rate, weight by sessions
                if col in ['bounceRate', 'engagementRate']:
                    # Calculate weighted sum
                    df[f'{col}_weighted'] = df[col] * df['sessions']
                    agg_dict[f'{col}_weighted'] = 'sum'
                    agg_dict['sessions'] = 'sum'
                # For averageSessionDuration, weight by number of sessions
                elif col == 'averageSessionDuration':
                    df[f'{col}_weighted'] = df[col] * df['sessions']
                    agg_dict[f'{col}_weighted'] = 'sum'
                    agg_dict['sessions'] = 'sum'
                # For screenPageViewsPerSession, weight by sessions
                elif col == 'screenPageViewsPerSession':
                    df[f'{col}_weighted'] = df[col] * df['sessions']
                    agg_dict[f'{col}_weighted'] = 'sum'
                    agg_dict['sessions'] = 'sum'
            else:
                # For regular summable metrics, just sum
                agg_dict[col] = 'sum'
        
        # Perform the grouping
        grouped_df = df.groupby(group_cols).agg(agg_dict).reset_index()
        
        # Calculate final weighted averages
        for col in averaged_metrics:
            if col in df.columns:
                if col in ['bounceRate', 'engagementRate', 'averageSessionDuration', 'screenPageViewsPerSession']:
                    grouped_df[col] = grouped_df[f'{col}_weighted'] / grouped_df['sessions']
                    grouped_df.drop(f'{col}_weighted', axis=1, inplace=True)
        
        # Rename grouping_date back to date
        grouped_df = grouped_df.rename(columns={'grouping_date': 'date'})
        
        # Sort by date
        grouped_df = grouped_df.sort_values('date')
        
        return grouped_df

    @staticmethod
    def _aggregate_by_dimensions(df: pd.DataFrame, dimensions: List[str], 
                               agg_method: MetricAggregation) -> pd.DataFrame:
        numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns
        
        if agg_method == MetricAggregation.SUM:
            return df.groupby(dimensions)[numeric_cols].sum().reset_index()
        elif agg_method == MetricAggregation.AVERAGE:
            return df.groupby(dimensions)[numeric_cols].mean().reset_index()
        elif agg_method == MetricAggregation.MIN:
            return df.groupby(dimensions)[numeric_cols].min().reset_index()
        elif agg_method == MetricAggregation.MAX:
            return df.groupby(dimensions)[numeric_cols].max().reset_index()

    @staticmethod
    def _add_percentages(df: pd.DataFrame, metrics: List[str]):
        for metric in metrics:
            if metric in df.columns:
                total = df[metric].sum()
                if total > 0:
                    df[f'{metric}_pct'] = (df[metric] / total) * 100

    @staticmethod
    def _normalize_metrics(df: pd.DataFrame, metrics: List[str]):
        for metric in metrics:
            if metric in df.columns:
                min_val = df[metric].min()
                max_val = df[metric].max()
                if max_val > min_val:
                    df[f'{metric}_normalized'] = (df[metric] - min_val) / (max_val - min_val)

    @staticmethod
    def _generate_summary(df: pd.DataFrame, params: GoogleAnalyticsRequest) -> dict:
        metrics = params.metrics.split(',')
        summary = {
            'summary_stats': {},
            'total_rows': len(df)
        }

        for metric in metrics:
            if metric in df.columns:
                summary['summary_stats'][metric] = {
                    'min': float(df[metric].min()),
                    'max': float(df[metric].max()),
                    'mean': float(df[metric].mean()),
                    'median': float(df[metric].median()),
                    'total': float(df[metric].sum())
                }

        return summary

================
File: apps/agents/tools/google_analytics_tool/google_analytics_tool.py
================
import os
import json
import logging
import sys
from typing import Any, Type, List, Optional, Dict, Union
from pydantic import BaseModel, Field, field_validator
from apps.agents.tools.base_tool import BaseTool
from google.analytics.data_v1beta.types import DateRange, Metric, Dimension, RunReportRequest, OrderBy
from datetime import datetime

# Import only what's necessary
from django.core.exceptions import ObjectDoesNotExist

logger = logging.getLogger(__name__)

class GoogleAnalyticsToolInput(BaseModel):
    """Input schema for GoogleAnalyticsTool."""
    start_date: str = Field(
        default="28daysAgo",
        description="Start date (YYYY-MM-DD) or relative date ('today', 'yesterday', 'NdaysAgo', etc)."
    )
    end_date: str = Field(
        default="today",
        description="End date (YYYY-MM-DD) or relative date ('today', 'yesterday', 'NdaysAgo', etc)."
    )
    analytics_property_id: Union[str, int] = Field(
        description="The Google Analytics property ID to use for fetching data."
    )
    analytics_credentials: Dict[str, Any] = Field(
        description="The credentials needed to authenticate with Google Analytics."
    )
    client_id: Optional[str] = Field(
        None, 
        description="Optional client ID for reference purposes only."
    )

    @field_validator("start_date", "end_date")
    @classmethod
    def validate_dates(cls, value: str) -> str:
        # Allow relative dates
        relative_dates = ['today', 'yesterday', '7daysAgo', '14daysAgo', '28daysAgo', '30daysAgo', '90daysAgo']
        if value in relative_dates or cls.is_relative_date(value):
            return value
        
        # Validate actual dates
        try:
            datetime.strptime(value, "%Y-%m-%d")
            return value
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD or relative dates (today, yesterday, NdDaysAgo, etc)")

    @field_validator("analytics_property_id")
    @classmethod
    def ensure_property_id_is_string(cls, value) -> str:
        """Ensure the property ID is always a string."""
        if value is None:
            raise ValueError("Analytics property ID cannot be None")
        
        # Convert to string if it's not already
        return str(value)
            
    @classmethod
    def is_relative_date(cls, value: str) -> bool:
        """Check if the value is in the format of NdDaysAgo."""
        if len(value) > 8 and value.endswith("daysAgo"):
            try:
                int(value[:-8])  # Check if the prefix is an integer
                return True
            except ValueError:
                return False
        return False
    
class GoogleAnalyticsTool(BaseTool):
    name: str = "Google Analytics Data Fetcher"
    description: str = "Fetches Google Analytics data for a specified date range using provided credentials."
    args_schema: Type[BaseModel] = GoogleAnalyticsToolInput
    
    def __init__(self, **kwargs):
        super().__init__()
        logger.info("GoogleAnalyticsTool initialized")
        self._initialize_dimensions_metrics()

    def _initialize_dimensions_metrics(self):
        """Initialize the dimensions and metrics for GA4 reporting"""
        self._dimensions = [
            Dimension(name="date")
        ]
        
        self._metrics = [
            Metric(name="totalUsers"),
            Metric(name="sessions"),
            Metric(name="averageSessionDuration"),
            Metric(name="screenPageViews"),
            Metric(name="screenPageViewsPerSession"),
            Metric(name="newUsers"),
            Metric(name="bounceRate"),
            Metric(name="engagedSessions"),
            Metric(name="keyEvents")
        ]

    def _run(
        self, 
        start_date: str, 
        end_date: str, 
        analytics_property_id: Union[str, int],
        analytics_credentials: Dict[str, Any]
    ) -> dict:
        try:
            # No need to fetch client, use the provided credentials directly
            if not analytics_property_id:
                raise ValueError("Missing Google Analytics property ID")
            
            # Convert property_id to string if it's not already
            analytics_property_id = str(analytics_property_id)
            
            if not analytics_credentials:
                raise ValueError("Missing Google Analytics credentials")
            
            # Validate credentials before attempting to use them
            required_fields = ['access_token', 'refresh_token', 'ga_client_id', 'client_secret']
            missing_fields = [field for field in required_fields if not analytics_credentials.get(field)]
            if missing_fields:
                missing_fields_str = ', '.join(missing_fields)
                logger.error(f"Missing required credential fields: {missing_fields_str}")
                raise ValueError(f"Incomplete Google Analytics credentials. Missing: {missing_fields_str}")
            
            # Create analytics service from credentials
            from google.analytics.data_v1beta import BetaAnalyticsDataClient
            from google.oauth2.credentials import Credentials
            from google.auth.transport.requests import Request
            
            # Log incoming credentials for debugging
            logger.debug(f"Analytics property ID: {analytics_property_id}")
            logger.debug(f"Credential fields available: {list(analytics_credentials.keys())}")
            
            # Create credentials object from the provided dictionary
            # Match the format expected by Google's API
            credentials = Credentials(
                token=analytics_credentials.get('access_token'),
                refresh_token=analytics_credentials.get('refresh_token'),
                token_uri=analytics_credentials.get('token_uri', 'https://oauth2.googleapis.com/token'),
                client_id=analytics_credentials.get('ga_client_id'),
                client_secret=analytics_credentials.get('client_secret'),
                scopes=analytics_credentials.get('scopes', [
                    'https://www.googleapis.com/auth/analytics.readonly',
                    'https://www.googleapis.com/auth/userinfo.email'
                ])
            )
            
            # Try to refresh the token if we have a refresh token
            if credentials.refresh_token:
                try:
                    logger.debug("Attempting to refresh credentials token")
                    request = Request()
                    credentials.refresh(request)
                    logger.debug("Successfully refreshed credentials token")
                except Exception as e:
                    logger.error(f"Failed to refresh token: {str(e)}")
                    if 'invalid_grant' in str(e).lower():
                        raise ValueError("Google Analytics credentials have expired. Please reconnect your Google Analytics account.")
                    # Continue with the possibly expired token and let the API call handle any auth errors
            
            # Log what we're doing for debugging
            logger.debug(f"Creating Google Analytics client with property ID: {analytics_property_id}")
            
            # Create the analytics service
            service = BetaAnalyticsDataClient(credentials=credentials)
            
            request = RunReportRequest(
                property=f"properties/{analytics_property_id}",
                dimensions=self._dimensions,
                metrics=self._metrics,
                date_ranges=[DateRange(
                    start_date=start_date,
                    end_date=end_date
                )],
                order_bys=[
                    OrderBy(
                        dimension=OrderBy.DimensionOrderBy(
                            dimension_name="date"
                        ),
                        desc=False
                    )
                ]
            )

            response = service.run_report(request)
            analytics_data = []
            
            for row in response.rows:
                date_str = row.dimension_values[0].value
                formatted_date = f"{date_str[:4]}-{date_str[4:6]}-{date_str[6:]}"
                
                try:
                    data_point = {
                        'date': formatted_date,
                        'active_users': int(float(row.metric_values[0].value or 0)),
                        'sessions': int(float(row.metric_values[1].value or 0)),
                        'avg_session_duration': float(row.metric_values[2].value or 0),
                        'page_views': int(float(row.metric_values[3].value or 0)),
                        'pages_per_session': float(row.metric_values[4].value or 0),
                        'new_users': int(float(row.metric_values[5].value or 0)),
                        'bounce_rate': float(row.metric_values[6].value or 0) * 100,
                        'engaged_sessions': int(float(row.metric_values[7].value or 0))
                    }
                    analytics_data.append(data_point)
                except (ValueError, IndexError) as e:
                    logger.error(f"Error processing row {date_str}: {str(e)}")
                    continue

            analytics_data.sort(key=lambda x: x['date'])

            return {
                'success': True,
                'analytics_data': analytics_data,
                'start_date': start_date,
                'end_date': end_date,
                'property_id': analytics_property_id
            }

        except Exception as e:
            error_str = str(e)
            logger.error(f"Error fetching GA4 data: {error_str}")
            logger.error("Full error details:", exc_info=True)
            
            # Provide more specific error messages
            if 'invalid_grant' in error_str.lower() or 'invalid authentication credentials' in error_str.lower():
                error_message = "Google Analytics credentials have expired or are invalid. Please reconnect your Google Analytics account."
            elif 'quota' in error_str.lower():
                error_message = "Google Analytics API quota exceeded. Please try again later."
            elif 'permission' in error_str.lower() or 'access' in error_str.lower():
                error_message = "Insufficient permissions to access Google Analytics data. Please check your account permissions."
            elif not analytics_credentials.get('access_token'):
                error_message = "Missing access token in Google Analytics credentials."
            elif not analytics_credentials.get('refresh_token'):
                error_message = "Missing refresh token in Google Analytics credentials."
            elif not analytics_credentials.get('ga_client_id') or not analytics_credentials.get('client_secret'):
                error_message = "Missing client credentials in Google Analytics configuration."
            else:
                error_message = f"Error fetching Google Analytics data: {error_str}"
                
            return {
                'success': False,
                'error': error_message,
                'analytics_data': []
            }

================
File: apps/agents/tools/google_overview_tool/google_overview_tool.py
================
import json
import logging
from datetime import datetime, timedelta

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google.analytics.data_v1beta import BetaAnalyticsDataClient
from google.analytics.data_v1beta.types import (
    DateRange, Dimension, Filter, FilterExpression, Metric, RunReportRequest
)
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request

from apps.agents.tools.base_tool import BaseTool
from apps.agents.tools.google_analytics_tool.generic_google_analytics_tool import GenericGoogleAnalyticsTool
from apps.agents.tools.google_search_console_tool.generic_google_search_console_tool import GenericGoogleSearchConsoleTool
from typing import Any, Type, List, Optional, Dict, Union
from pydantic import BaseModel, Field, field_validator

logger = logging.getLogger(__name__)

class GoogleOverviewToolInput(BaseModel):
    """Input schema for GoogleOverviewTool."""
    days_ago: int = Field(
        default=90,
        description="Number of days to look back (default: 90)",
        ge=1,
        le=365
    )
    analytics_property_id: Union[str, int] = Field(
        description="The Google Analytics property ID"
    )
    analytics_credentials: Dict[str, Any] = Field(
        description="Credentials for Google Analytics API"
    )
    search_console_property_url: str = Field(
        description="The Search Console property URL"
    )
    search_console_credentials: Dict[str, Any] = Field(
        description="Credentials for Search Console API"
    )
    client_id: Optional[str] = Field(
        None,
        description="Optional client ID for reference"
    )

class GoogleOverviewTool(BaseTool):
    name: str = "Google Analytics and Search Console Overview Tool"
    description: str = "Fetches comprehensive overview reports from Google Analytics and Search Console."
    args_schema: Type[BaseModel] = GoogleOverviewToolInput
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Don't initialize tools here as they may not be called
        # when the tool is loaded dynamically
        self._analytics_tool = None
        self._search_console_tool = None
        logger.info("GoogleOverviewTool initialized")

    @property
    def analytics_tool(self):
        """Lazy loading of the analytics tool to ensure it's only created when needed"""
        if self._analytics_tool is None:
            self._analytics_tool = GenericGoogleAnalyticsTool()
            logger.info("GenericGoogleAnalyticsTool lazily initialized")
        return self._analytics_tool
        
    @property
    def search_console_tool(self):
        """Lazy loading of the search console tool to ensure it's only created when needed"""
        if self._search_console_tool is None:
            self._search_console_tool = GenericGoogleSearchConsoleTool()
            logger.info("GenericGoogleSearchConsoleTool lazily initialized")
        return self._search_console_tool

    def _run(
        self, 
        days_ago: int = 90,
        analytics_property_id: Union[str, int] = None,
        analytics_credentials: Dict[str, Any] = None,
        search_console_property_url: str = None,
        search_console_credentials: Dict[str, Any] = None,
        client_id: Optional[str] = None
    ) -> str:
        try:
            # Calculate dates
            end_date = datetime.now().strftime("%Y-%m-%d")
            start_date = (datetime.now() - timedelta(days=days_ago)).strftime("%Y-%m-%d")

            # Validate inputs
            if not analytics_property_id or not analytics_credentials:
                raise ValueError("Missing Google Analytics property ID or credentials")
                
            if not search_console_property_url or not search_console_credentials:
                raise ValueError("Missing Search Console property URL or credentials")
            
            # Validate credentials have the required fields
            ga_required_fields = ['access_token', 'refresh_token', 'ga_client_id', 'client_secret']
            ga_missing_fields = [field for field in ga_required_fields if not analytics_credentials.get(field)]
            if ga_missing_fields:
                ga_missing_fields_str = ', '.join(ga_missing_fields)
                logger.error(f"Missing required Analytics credential fields: {ga_missing_fields_str}")
                raise ValueError(f"Incomplete Google Analytics credentials. Missing: {ga_missing_fields_str}")
                
            # Search Console credentials validation is now handled by the GenericGoogleSearchConsoleTool
            # We'll check for required fields to provide a better error message earlier
            sc_required_fields = ['access_token', 'refresh_token', 'sc_client_id', 'client_secret']
            sc_missing_fields = [field for field in sc_required_fields if not search_console_credentials.get(field)]
            if sc_missing_fields:
                sc_missing_fields_str = ', '.join(sc_missing_fields)
                logger.error(f"Missing required Search Console credential fields: {sc_missing_fields_str}")
                raise ValueError(f"Incomplete Search Console credentials. Missing: {sc_missing_fields_str}")

            # 1. Device & Engagement Analysis
            device_engagement = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "deviceCategory",
                "sessions,bounceRate,engagementRate,averageSessionDuration"
            )

            # 2. Traffic Sources Analysis
            traffic_sources = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "sessionSource,sessionMedium",
                "sessions,newUsers,engagementRate"
            )

            # 3. Page Performance Analysis
            page_performance = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "pagePath",
                "screenPageViews,averageSessionDuration,bounceRate"
            )

            # 4. Geographic Performance
            geo_performance = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "country",
                "sessions,newUsers,engagementRate,averageSessionDuration"
            )

            # 5. Daily Trend Analysis
            daily_trends = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "date",
                "sessions,newUsers,activeUsers,engagementRate"
            )

            # 6. Landing Page Performance
            landing_performance = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "landingPage",
                "sessions,bounceRate,engagementRate,screenPageViews"
            )

            # 7. Browser & Platform Analysis
            tech_analysis = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "browser,operatingSystem",
                "sessions,screenPageViews,bounceRate"
            )

            # 8. Channel Performance
            channel_performance = self._fetch_analytics_report(
                analytics_property_id,
                analytics_credentials,
                start_date,
                end_date,
                "sessionDefaultChannelGroup",
                "sessions,newUsers,engagementRate,averageSessionDuration"
            )

            # 9. Search Console Overview Report
            keyword_data = self._fetch_search_console_report(
                search_console_property_url,
                search_console_credentials,
                start_date,
                end_date,
                ["query", "country"],
                row_limit=50
            )

            # 10. Search Performance by Page Report
            landing_page_data = self._fetch_search_console_report(
                search_console_property_url,
                search_console_credentials,
                start_date,
                end_date,
                ["page"]
            )

            # 11. Search Performance by Device Report
            device_performance_sc = self._fetch_search_console_report(
                search_console_property_url,
                search_console_credentials,
                start_date,
                end_date,
                ["device"]
            )

            # Return all data in a structured format
            return json.dumps({
                'success': True,
                'device_engagement': device_engagement,
                'traffic_sources': traffic_sources,
                'page_performance': page_performance,
                'geo_performance': geo_performance,
                'daily_trends': daily_trends,
                'landing_performance': landing_performance,
                'tech_analysis': tech_analysis,
                'channel_performance': channel_performance,
                'keyword_data': keyword_data,
                'landing_page_data': landing_page_data,
                'device_performance_sc': device_performance_sc,
                'start_date': start_date,
                'end_date': end_date,
                'analytics_property_id': analytics_property_id,
                'search_console_property_url': search_console_property_url,
                'client_id': client_id
            })
        except Exception as e:
            logger.error(f"Error in GoogleOverviewTool: {str(e)}")
            return json.dumps({
                'success': False,
                'error': str(e),
                'error_details': str(e)
            })

    def _fetch_analytics_report(self, property_id: Union[str, int], credentials: Dict[str, Any], 
                             start_date: str, end_date: str, 
                             dimensions: str, metrics: str) -> List[dict]:
        """
        Use GenericGoogleAnalyticsTool to fetch analytics data
        """
        try:
            # Call the GenericGoogleAnalyticsTool._run method
            result = self.analytics_tool._run(
                analytics_property_id=property_id,
                analytics_credentials=credentials,
                start_date=start_date,
                end_date=end_date,
                dimensions=dimensions,
                metrics=metrics,
                limit=1000,
                data_format="raw"  # Use raw format to get all data points
            )
            
            # Check if the call was successful
            if result.get('success', False):
                # Return the analytics_data from the result
                return result.get('analytics_data', [])
            else:
                # Log the error and return an empty list
                logger.error(f"Error fetching analytics report: {result.get('error', 'Unknown error')}")
                return []
                
        except Exception as e:
            logger.error(f"Error fetching analytics report: {str(e)}")
            return []

    def _fetch_search_console_report(self, property_url: str, credentials: Dict[str, Any],
                                   start_date: str, end_date: str, 
                                   dimensions: List[str], row_limit: int = 100) -> List[dict]:
        """
        Use GenericGoogleSearchConsoleTool to fetch search console data
        """
        try:
            # Parse response from GenericGoogleSearchConsoleTool
            result_str = self.search_console_tool._run(
                search_console_property_url=property_url,
                search_console_credentials=credentials,
                start_date=start_date,
                end_date=end_date,
                dimensions=dimensions,
                row_limit=row_limit,
                data_format="raw"  # Use raw format to get all data points
            )
            
            # Parse the JSON string result
            result = json.loads(result_str)
            
            # Check if the call was successful
            if result.get('success', False):
                # Return the search_console_data from the result
                return result.get('search_console_data', [])
            else:
                # Log the error and return an empty list
                logger.error(f"Error fetching search console report: {result.get('error', 'Unknown error')}")
                return []
                
        except Exception as e:
            logger.error(f"Error fetching search console report: {str(e)}")
            return []

================
File: apps/agents/tools/google_report_tool/__init__.py
================
# Empty file to make the directory a Python package

================
File: apps/agents/tools/google_report_tool/google_rankings_tool.py
================
import logging
from typing import Any, Type, List, Optional, Dict, Union
from pydantic import BaseModel, Field, field_validator
from apps.agents.tools.base_tool import BaseTool
from datetime import datetime, timedelta
import json
import re
from googleapiclient.errors import HttpError
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from apps.common.utils import DateProcessor

logger = logging.getLogger(__name__)

# --- Constants for Categorization ---
MIN_CLICKS = 1
MIN_IMPRESSIONS = 10
STRIKING_DISTANCE_MIN_POS = 5
STRIKING_DISTANCE_MAX_POS = 20
LOW_CTR_THRESHOLD = 2.0  # Percentage
LOW_RANK_THRESHOLD = 20
TOP_N = 50  # Default value for top N keywords
# --- End Constants ---

# Question-based query patterns
QUESTION_PATTERNS = [
    r'\b(what|how|why|where|when|who|which)\b',  # Question words
    r'\b(best|top|vs|versus|compare|difference|review)\b',  # Comparison/evaluation terms
    r'\b(guide|tutorial|steps|instructions|tips)\b',  # Instructional terms
    r'\?',  # Actual question marks
]

class GoogleRankingsToolInput(BaseModel):
    """Input schema for GoogleRankingsTool."""
    start_date: Optional[str] = Field(
        None,
        description="The start date for the analytics data (YYYY-MM-DD or relative like '90daysAgo'). If None, defaults to 90 days ago."
    )
    end_date: Optional[str] = Field(
        None,
        description="The end date for the analytics data (YYYY-MM-DD or relative like 'yesterday'). If None, defaults to yesterday."
    )
    search_console_property_url: str = Field(
        description="The Search Console property URL"
    )
    search_console_credentials: Dict[str, Any] = Field(
        description="Credentials for Search Console API"
    )
    top_n: Optional[int] = Field(
        TOP_N,
        description=f"Number of top keywords to include in topN categories. Default is {TOP_N}."
    )

    @field_validator("start_date", "end_date")
    @classmethod
    def validate_dates(cls, value: Optional[str]) -> Optional[str]:
        if value is None:
            return value
        try:
            return DateProcessor.process_relative_date(value)
        except ValueError as e:
            raise ValueError(str(e))

    @field_validator("top_n")
    @classmethod
    def validate_top_n(cls, value: Optional[int]) -> int:
        if value is None:
            return TOP_N
        if value <= 0:
            raise ValueError("top_n must be a positive integer")
        return value

class GoogleRankingsTool(BaseTool):
    name: str = "Google Search Console Categorized Rankings Fetcher"
    description: str = (
        "Fetches and categorizes Google Search Console ranking data for a specified property and date range. "
        "Categories include 'striking_distance_keywords', 'high_impression_low_ctr', 'high_impression_low_rank', "
        "'question_based_queries', 'top_n_by_impressions', and 'top_n_by_rank'. "
        f"Filters data for Clicks > {MIN_CLICKS} and Impressions > {MIN_IMPRESSIONS}. "
        f"The top_n parameter (default: {TOP_N}) controls how many keywords to include in the topN categories. "
        "Supports both YYYY-MM-DD date format and relative date formats like '7daysAgo', '30daysAgo', 'yesterday', etc. "
        "Default date range is 90 days ago to yesterday if not specified."
    )
    args_schema: Type[BaseModel] = GoogleRankingsToolInput

    def _run(
        self,
        start_date: Optional[str],
        end_date: Optional[str],
        search_console_property_url: str,
        search_console_credentials: Dict[str, Any],
        top_n: Optional[int] = TOP_N,
        **kwargs: Any
    ) -> str:
        """
        Fetch, filter, and categorize ranking data from Google Search Console.
        Returns the categorized data in JSON format.
        """
        try:
            # Use the provided top_n or the default
            top_n = top_n or TOP_N

            # Validate credentials
            sc_required_fields = ['sc_client_id', 'client_secret', 'refresh_token']
            sc_missing_fields = [field for field in sc_required_fields if field not in search_console_credentials]

            if sc_missing_fields:
                sc_missing_fields_str = ', '.join(sc_missing_fields)
                logger.error(f"Missing required Search Console credential fields: {sc_missing_fields_str}")
                raise ValueError(f"Incomplete Search Console credentials. Missing: {sc_missing_fields_str}")

            # Create Search Console service
            search_console_service = self._create_search_console_service(search_console_credentials)
            if not search_console_service:
                raise ValueError("Failed to initialize Search Console service")

            if not search_console_property_url:
                raise ValueError("Missing or invalid Search Console property URL")

            # Determine date range (default to last 90 days if none provided)
            try:
                today = datetime.now().date()
                default_end_date = today - timedelta(days=1)  # GSC data lags
                default_start_date = default_end_date - timedelta(days=89)  # 90 days total
                
                # Process start_date
                if start_date is None:
                    final_start_date_str = default_start_date.strftime('%Y-%m-%d')
                else:
                    final_start_date_str = DateProcessor.process_relative_date(start_date)
                
                # Process end_date
                if end_date is None:
                    final_end_date_str = default_end_date.strftime('%Y-%m-%d')
                else:
                    final_end_date_str = DateProcessor.process_relative_date(end_date)
                
                logger.info(f"Using date range: {final_start_date_str} to {final_end_date_str}")
            except ValueError as e:
                raise ValueError(f"Date processing error: {str(e)}")

            # Fetch raw data for the single period
            raw_keyword_data = self._get_search_console_data(
                search_console_service,
                search_console_property_url,
                final_start_date_str,
                final_end_date_str,
                'query'
            )

            # Filter and Categorize Data
            categorized_data = {
                "striking_distance_keywords": [],
                "high_impression_low_ctr": [],
                "high_impression_low_rank": [],
                "question_based_queries": [],
                "top_n_by_impressions": [],
                "top_n_by_rank": [],
            }

            # Apply base filters first (for all categories except topN)
            filtered_data = []
            for item in raw_keyword_data:
                clicks = item.get('Clicks', 0)
                impressions = item.get('Impressions', 0)

                if clicks >= MIN_CLICKS and impressions >= MIN_IMPRESSIONS:
                    filtered_data.append(item)

            # Create topN categories first (these don't use the processed_keywords tracking)
            # Top N by Impressions
            by_impressions = sorted(raw_keyword_data, key=lambda x: x.get('Impressions', 0), reverse=True)
            categorized_data["top_n_by_impressions"] = by_impressions[:top_n]

            # Top N by Rank (lowest position number = best rank)
            by_rank = sorted(raw_keyword_data, key=lambda x: x.get('Avg Position', 999))
            categorized_data["top_n_by_rank"] = by_rank[:top_n]

            # Now process the other categories with mutual exclusivity
            processed_keywords = set()  # Track keywords already categorized

            # Process question-based queries first (these can be important for content strategy)
            for item in filtered_data:
                keyword = item.get('Keyword', '')

                # Check if it's a question-based query
                is_question = any(re.search(pattern, keyword, re.IGNORECASE) for pattern in QUESTION_PATTERNS)

                if is_question and keyword not in processed_keywords:
                    categorized_data["question_based_queries"].append(item)
                    processed_keywords.add(keyword)

            # Now process the remaining categories
            for item in filtered_data:
                keyword = item.get('Keyword', '')
                if keyword in processed_keywords:
                    continue  # Skip if already categorized

                position = item.get('Avg Position', 999)
                ctr = item.get('CTR (%)', 0)

                # Striking Distance
                if STRIKING_DISTANCE_MIN_POS < position <= STRIKING_DISTANCE_MAX_POS:
                    categorized_data["striking_distance_keywords"].append(item)
                    processed_keywords.add(keyword)
                    continue

                # High Impression, Low CTR
                if ctr < LOW_CTR_THRESHOLD:
                    categorized_data["high_impression_low_ctr"].append(item)
                    processed_keywords.add(keyword)
                    continue

                # High Impression, Low Rank
                if position > LOW_RANK_THRESHOLD:
                    categorized_data["high_impression_low_rank"].append(item)
                    processed_keywords.add(keyword)
                    continue

            # Build the response structure
            response = {
                'success': True,
                'property_url': search_console_property_url,
                'start_date': final_start_date_str,
                'end_date': final_end_date_str,
                'filters_applied': {
                    'min_clicks': MIN_CLICKS,
                    'min_impressions': MIN_IMPRESSIONS,
                    'top_n': top_n
                },
                'categorization_criteria': {
                    'striking_distance': f"Position > {STRIKING_DISTANCE_MIN_POS} and <= {STRIKING_DISTANCE_MAX_POS}",
                    'high_impression_low_ctr': f"CTR < {LOW_CTR_THRESHOLD}%",
                    'high_impression_low_rank': f"Position > {LOW_RANK_THRESHOLD}",
                    'question_based_queries': "Contains question words, comparison terms, or question marks",
                    'top_n_by_impressions': f"Top {top_n} keywords by impression volume",
                    'top_n_by_rank': f"Top {top_n} keywords by position (lowest position number first)"
                },
                'category_counts': {
                    category: len(keywords) for category, keywords in categorized_data.items()
                },
                'categorized_data': categorized_data,
                'total_keywords_fetched': len(raw_keyword_data),
                'total_keywords_filtered': len(filtered_data),
                'total_unique_keywords_categorized': len(processed_keywords) + top_n * 2,  # Approximate, may have overlap
                'error': None
            }

            if len(raw_keyword_data) == 0:
                response['message'] = "No keyword data returned from Search Console for the specified period."
                response['success'] = False
            elif len(filtered_data) == 0:
                response['message'] = f"Data fetched, but no keywords met the minimum criteria of {MIN_CLICKS} clicks and {MIN_IMPRESSIONS} impressions."
                response['success'] = True  # Still successful, just no data met criteria

            return json.dumps(response, indent=2)

        except Exception as e:
            logger.error(f"Error in categorized ranking tool: {str(e)}")
            error_response = {
                'success': False,
                'error': str(e),
                'property_url': search_console_property_url,
                'start_date': start_date,
                'end_date': end_date,
                'top_n': top_n
            }
            return json.dumps(error_response, indent=2)

    def _create_search_console_service(self, credentials: Dict[str, Any]):
        """Create Search Console service from credentials dictionary"""
        try:
            credentials_obj = Credentials(
                None,
                refresh_token=credentials.get('refresh_token'),
                token_uri='https://oauth2.googleapis.com/token',
                client_id=credentials.get('sc_client_id'),
                client_secret=credentials.get('client_secret')
            )
            credentials_obj.refresh(Request())
            search_console_service = build('searchconsole', 'v1', credentials=credentials_obj)
            return search_console_service
        except Exception as e:
            logger.error(f"Error creating Search Console service: {str(e)}")
            if 'invalid_grant' in str(e) or 'expired' in str(e):
                raise ValueError(f"Search Console authentication error: {str(e)}") from e
            return None

    def _get_search_console_data(self, service, property_url, start_date, end_date, dimension):
        """Fetch data from Google Search Console API"""
        try:
            # Simplified URL handling assuming it's usually just the URL string
            site_url = property_url
            logger.info(f"Using Search Console property URL: {site_url} for {start_date} to {end_date}")

            # Increase rowLimit to get more data before filtering
            ROW_LIMIT = 5000  # Fetch more rows initially

            response = service.searchanalytics().query(
                siteUrl=site_url,
                body={
                    'startDate': start_date,
                    'endDate': end_date,
                    'dimensions': [dimension],
                    'rowLimit': ROW_LIMIT,
                    'dataState': 'all'  # Include fresh data if available
                }
            ).execute()

            search_console_data = []
            for row in response.get('rows', []):
                search_console_data.append({
                    'Keyword': row['keys'][0],
                    'Clicks': row.get('clicks', 0),
                    'Impressions': row.get('impressions', 0),
                    'CTR (%)': round(row.get('ctr', 0) * 100, 2),
                    'Avg Position': round(row.get('position', 999), 1)
                })

            logger.info(f"Fetched {len(search_console_data)} rows from Search Console.")
            return search_console_data

        except HttpError as error:
            logger.error(f"An HTTP error occurred while fetching Search Console data: {error.resp.status} {error.content}")
            error_details = f"HTTP {error.resp.status}"
            try:
                content = json.loads(error.content)
                error_details += f": {content.get('error', {}).get('message', 'No specific message')}"
            except json.JSONDecodeError:
                error_details += f": {error.content.decode('utf-8', errors='ignore')}"

            if error.resp.status in [403, 404]:
                raise ValueError(f"Search Console API Error: Check property URL ('{site_url}') and permissions. Details: {error_details}") from error
            else:
                raise RuntimeError(f"Search Console API Error: {error_details}") from error

        except Exception as e:
            logger.error(f"Unexpected error fetching Search Console data: {str(e)}")
            raise RuntimeError(f"Unexpected error during Search Console fetch: {str(e)}") from e

================
File: apps/agents/tools/google_report_tool/google_report_tool.py
================
import logging
from typing import Any, Type, List, Optional, Dict, Union
from pydantic import BaseModel, Field, field_validator
from apps.agents.tools.base_tool import BaseTool
# Removed direct Google API imports:
# from google.analytics.data_v1beta import BetaAnalyticsDataClient
# from google.analytics.data_v1beta.types import (
#     DateRange,
#     Metric,
#     Dimension,
#     RunReportRequest,
#     OrderBy,
#     FilterExpression,
#     Filter,
#     MetricAggregation,
# )
from datetime import datetime
import json
# Removed direct Google API client build imports:
# from googleapiclient.errors import HttpError
# from googleapiclient.discovery import build
# from google.oauth2.credentials import Credentials
# from google.auth.transport.requests import Request
# Removed pandas import, handled by generic tool
# import pandas as pd

# Import the generic tools
from apps.agents.tools.google_analytics_tool.generic_google_analytics_tool import GenericGoogleAnalyticsTool, GoogleAnalyticsRequest, TimeGranularity, DataFormat
from apps.agents.tools.google_search_console_tool.generic_google_search_console_tool import GenericGoogleSearchConsoleTool, GoogleSearchConsoleRequest

# Remove direct Django model imports if not needed
# from django.core.exceptions import ObjectDoesNotExist

logger = logging.getLogger(__name__)

class GoogleReportToolInput(BaseModel):
    """Input schema for GoogleReportTool."""
    start_date: str = Field(description="The start date for the analytics data (YYYY-MM-DD).")
    end_date: str = Field(description="The end date for the analytics data (YYYY-MM-DD).")
    analytics_property_id: Union[str, int] = Field(
        description="The Google Analytics property ID to use for fetching data."
    )
    analytics_credentials: Dict[str, Any] = Field(
        description="The credentials needed to authenticate with Google Analytics. Must contain access_token, refresh_token, ga_client_id, client_secret."
    )
    search_console_property_url: str = Field(
        description="The Search Console property URL"
    )
    search_console_credentials: Dict[str, Any] = Field(
        description="Credentials for Search Console API. Must contain access_token, refresh_token, sc_client_id, client_secret."
    )
    client_id: Optional[Union[str, int]] = Field(
        None,
        description="Optional client ID for reference purposes only."
    )

    # Keep date validation if needed, generic tools also validate
    @field_validator("start_date", "end_date")
    @classmethod
    def validate_dates(cls, value: str) -> str:
        try:
            # Allow relative dates handled by generic tool
            if not any(suffix in value for suffix in ['daysAgo', 'monthsAgo', 'today', 'yesterday']):
                datetime.strptime(value, "%Y-%m-%d")
            return value
        except ValueError:
            raise ValueError("Invalid date format. Use YYYY-MM-DD or relative format (e.g., 7daysAgo).")

    @field_validator("analytics_property_id")
    @classmethod
    def ensure_property_id_is_string(cls, value) -> str:
        if value is None:
            raise ValueError("Analytics property ID cannot be None")
        return str(value)

    @field_validator("client_id")
    @classmethod
    def ensure_client_id_is_string(cls, value) -> Optional[str]:
        # If None, keep it None
        if value is None:
            return None
        # Convert int to string if needed
        return str(value)

class GoogleReportTool(BaseTool):
    name: str = "Google Analytics and Search Console Report Fetcher"
    description: str = "Fetches a predefined set of Google Analytics and Search Console reports for a specified client and date range."
    args_schema: Type[BaseModel] = GoogleReportToolInput

    def _run(
        self,
        start_date: str,
        end_date: str,
        analytics_property_id: Union[str, int],
        analytics_credentials: Dict[str, Any],
        search_console_property_url: str,
        search_console_credentials: Dict[str, Any],
        client_id: Optional[Union[str, int]] = None
    ) -> str:
        # Validate input using Pydantic schema
        try:
            input_data = GoogleReportToolInput(
                start_date=start_date,
                end_date=end_date,
                analytics_property_id=analytics_property_id,
                analytics_credentials=analytics_credentials,
                search_console_property_url=search_console_property_url,
                search_console_credentials=search_console_credentials,
                client_id=client_id  # This will be converted to str by the validator
            )
            # Convert property ID back to string after validation if needed
            analytics_property_id_str = str(input_data.analytics_property_id)
            # Ensure client_id is a string if not None
            client_id_str = str(input_data.client_id) if input_data.client_id is not None else None
        except ValueError as e:
            logger.error(f"Input validation error: {e}", exc_info=True)
            return json.dumps({'success': False, 'error': f"Input validation failed: {e}"})

        # Instantiate generic tools within _run
        ga_tool = GenericGoogleAnalyticsTool()
        sc_tool = GenericGoogleSearchConsoleTool()

        analytics_reports = {}
        analytics_error = None
        keyword_data = []
        landing_page_data = []
        search_console_error = None

        # --- Define GA Reports ---
        reports_config = [
            {
                "name": "traffic_sources",
                "metrics": "sessions,engagementRate,conversions",
                "dimensions": "sessionSource,sessionMedium",
                "limit": 10,
            },
            {
                "name": "page_performance",
                "metrics": "screenPageViews,engagementRate",
                "dimensions": "pagePath",
                "limit": 10,
            },
            {
                "name": "device_usage",
                "metrics": "sessions,engagementRate",
                "dimensions": "deviceCategory",
                "limit": 10,
            },
            {
                "name": "geographic_analysis_florida",
                "metrics": "sessions,engagementRate",
                "dimensions": "city,region",
                "dimension_filter": "region==Florida", # String format for generic tool
                "limit": 10,
            },
            {
                "name": "channel_performance",
                "metrics": "sessions,engagementRate,conversions",
                "dimensions": "sessionDefaultChannelGroup",
                "limit": 10,
            },
            {
                "name": "overall_traffic_trend",
                "metrics": "sessions,totalUsers,screenPageViews,conversions",
                "dimensions": "date",
                "time_granularity": TimeGranularity.WEEKLY, # Use enum for generic tool
                "limit": 366 # Let generic tool handle aggregation limit
            },
        ]

        # --- Fetch GA Reports using Generic Tool ---
        logger.info(f"Starting GA report fetching for property: {analytics_property_id_str}")
        for config in reports_config:
            report_name = config["name"]
            logger.info(f"Fetching GA report: {report_name}")
            try:
                # Map config to generic tool parameters
                ga_params = {
                    "analytics_property_id": analytics_property_id_str,
                    "analytics_credentials": analytics_credentials,
                    "start_date": start_date,
                    "end_date": end_date,
                    "metrics": config["metrics"],
                    "dimensions": config["dimensions"],
                    "limit": config.get("limit", 1000),
                    "dimension_filter": config.get("dimension_filter"),
                    "time_granularity": config.get("time_granularity", TimeGranularity.AUTO), # Pass granularity
                    "data_format": DataFormat.RAW # Get raw data, processing handled by generic tool if needed later
                }

                # Run the generic GA tool using the local variable
                ga_result_json = ga_tool._run(**ga_params)
                
                # Process result (could be dict or JSON string)
                try:
                    # Check if result is already a dict (not a JSON string)
                    if isinstance(ga_result_json, dict):
                        ga_result = ga_result_json
                    else:
                        # Try to parse as JSON string if it's not already a dict
                        ga_result = json.loads(ga_result_json)
                except (TypeError, json.JSONDecodeError) as e:
                    logger.error(f"Error processing GA tool result for {report_name}: {str(e)}")
                    ga_result = {
                        'success': False, 
                        'error': f"Failed to process GA tool result: {str(e)}",
                        'analytics_data': []
                    }

                if ga_result.get('success'):
                    analytics_reports[report_name] = ga_result.get('analytics_data', [])
                    logger.info(f"Successfully fetched GA report: {report_name} ({len(analytics_reports[report_name])} rows)")
                else:
                    error_msg = ga_result.get('error', 'Unknown GA tool error')
                    logger.error(f"Error fetching GA report '{report_name}': {error_msg}")
                    analytics_reports[report_name] = {"error": error_msg}
                    # If one report fails, store the error and continue? Or stop?
                    # Let's store the first critical error and potentially stop GA fetches
                    if not analytics_error: # Store first error
                        analytics_error = f"GA report '{report_name}': {error_msg}"
                    if "credentials" in error_msg or "permission" in error_msg or "quota" in error_msg:
                        logger.warning(f"Stopping further GA report fetches due to critical error: {error_msg}")
                        break # Stop fetching more GA reports on critical errors

            except Exception as e:
                error_msg = f"Exception calling GenericAnalyticsTool for report '{report_name}': {str(e)}"
                logger.error(error_msg, exc_info=True)
                analytics_reports[report_name] = {"error": error_msg}
                if not analytics_error: # Store first error
                    analytics_error = error_msg
                # Decide whether to break on general exceptions too
                # break

        # --- Fetch SC Reports using Generic Tool ---
        logger.info(f"Starting SC report fetching for property: {search_console_property_url}")
        sc_dimensions_to_fetch = ["query", "page"]
        sc_data_map = {"query": keyword_data, "page": landing_page_data}

        for dim in sc_dimensions_to_fetch:
            logger.info(f"Fetching SC report for dimension: {dim}")
            try:
                sc_params = {
                    "search_console_property_url": search_console_property_url,
                    "search_console_credentials": search_console_credentials,
                    "start_date": start_date,
                    "end_date": end_date,
                    "dimensions": [dim],
                    "row_limit": 50, # Fetch top 50
                    "data_format": DataFormat.RAW # Get raw data
                }

                # Run the generic SC tool using the local variable
                sc_result_json = sc_tool._run(**sc_params)
                
                # Process result (could be dict or JSON string)
                try:
                    # Check if result is already a dict (not a JSON string)
                    if isinstance(sc_result_json, dict):
                        sc_result = sc_result_json
                    else:
                        # Try to parse as JSON string if it's not already a dict
                        sc_result = json.loads(sc_result_json)
                except (TypeError, json.JSONDecodeError) as e:
                    logger.error(f"Error processing SC tool result for dimension '{dim}': {str(e)}")
                    sc_result = {
                        'success': False, 
                        'error': f"Failed to process SC tool result: {str(e)}",
                        'search_console_data': []
                    }

                if sc_result.get('success'):
                    fetched_data = sc_result.get('search_console_data', [])
                    if dim == "query":
                        keyword_data.extend(fetched_data)
                    elif dim == "page":
                        landing_page_data.extend(fetched_data)
                    logger.info(f"Successfully fetched SC report for dimension: {dim} ({len(fetched_data)} rows)")
                else:
                    error_msg = sc_result.get('error', 'Unknown SC tool error')
                    logger.error(f"Error fetching SC report for dimension '{dim}': {error_msg}")
                    # Store the first SC error
                    if not search_console_error:
                        search_console_error = f"SC dimension '{dim}': {error_msg}"
                    if "credentials" in error_msg or "permission" in error_msg or "quota" in error_msg:
                        logger.warning(f"Stopping further SC report fetches due to critical error: {error_msg}")
                        break # Stop fetching more SC reports

            except Exception as e:
                error_msg = f"Exception calling GenericSearchConsoleTool for dimension '{dim}': {str(e)}"
                logger.error(error_msg, exc_info=True)
                if not search_console_error: # Store first error
                    search_console_error = error_msg
                # break


        # --- Consolidate Results and Check Status ---
        final_analytics_reports = {k: v for k, v in analytics_reports.items() if not (isinstance(v, dict) and 'error' in v)}
        has_analytics_data = any(isinstance(v, list) and v for v in final_analytics_reports.values())
        has_search_console_data = bool(keyword_data or landing_page_data)

        combined_error_message = ""
        if analytics_error: combined_error_message += f"Analytics Error Summary: {analytics_error}. "
        if search_console_error: combined_error_message += f"Search Console Error Summary: {search_console_error}"
        combined_error_message = combined_error_message.strip()

        # Include detailed errors per report if available
        ga_report_errors = {k: v['error'] for k, v in analytics_reports.items() if isinstance(v, dict) and 'error' in v}

        final_payload = {
            'analytics_reports': final_analytics_reports,
            'keyword_data': keyword_data,
            'landing_page_data': landing_page_data,
            'start_date': start_date,
            'end_date': end_date,
            'analytics_property_id': analytics_property_id_str,
            'search_console_property_url': search_console_property_url,
            'client_id': client_id_str,
            # Include detailed GA errors if any occurred
            'analytics_errors': ga_report_errors if ga_report_errors else None
        }


        if not has_analytics_data and not has_search_console_data:
            if combined_error_message:
                # No data AND errors occurred
                final_payload['success'] = False
                final_payload['error'] = f"No data collected. Errors: {combined_error_message}"
                # Remove None error fields before returning
                final_payload = {k: v for k, v in final_payload.items() if v is not None}
                return json.dumps(final_payload)

            else:
                # No data and no specific errors reported (maybe just empty results)
                final_payload['success'] = True
                final_payload['message'] = "No data found for the specified criteria in Google Analytics or Search Console."
                # Remove None error fields before returning
                final_payload = {k: v for k, v in final_payload.items() if v is not None}
                return json.dumps(final_payload)

        # --- Format Final Success Output ---
        final_payload['success'] = True
        if combined_error_message:
            final_payload['partial_error'] = f"Operation partially succeeded. Errors: {combined_error_message}"

        # Remove None error fields before returning
        final_payload = {k: v for k, v in final_payload.items() if v is not None}
        return json.dumps(final_payload)

    # --- Remove Old Helper Methods ---
    # def _validate_credentials(...): removed
    # def _create_analytics_service(...): removed
    # def _create_search_console_service(...): removed
    # def _fetch_multiple_analytics_reports(...): removed
    # def _process_report_response(...): removed
    # def _aggregate_trend_to_weekly(...): removed
    # def _get_search_console_data(...): removed

================
File: apps/agents/tools/google_search_console_tool/generic_google_search_console_tool.py
================
import logging
from typing import Any, Type, List, Optional, ClassVar, Dict
from pydantic import (
    BaseModel, 
    ConfigDict, 
    Field, 
    field_validator,
    BaseModel as PydanticBaseModel
)
from apps.agents.tools.base_tool import BaseTool
from datetime import datetime
import json
from googleapiclient.errors import HttpError
from enum import Enum
import pandas as pd
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

# Import Django models
from django.core.exceptions import ObjectDoesNotExist
from apps.seo_manager.models import SearchConsoleCredentials

from apps.common.utils import DateProcessor

logger = logging.getLogger(__name__)

"""
Generic Google Search Console Tool for fetching search performance data.

Example usage:
    tool = GenericGoogleSearchConsoleTool()
    
    # Basic usage with required parameters
    result = tool._run(
        search_console_property_url="https://www.example.com/",
        search_console_credentials={
            "access_token": "your_access_token",
            "refresh_token": "your_refresh_token",
            "sc_client_id": "your_client_id",
            "client_secret": "your_client_secret"
        },
        start_date="7daysAgo",
        end_date="today"
    )
    
    # Custom query with filters
    result = tool._run(
        search_console_property_url="https://www.example.com/",
        search_console_credentials=credentials_dict,
        start_date="28daysAgo",
        end_date="today",
        dimensions=["query", "page", "device"],
        search_type="web",
        dimension_filters=[{
            "dimension": "country",
            "operator": "equals",
            "expression": "usa"
        }],
        row_limit=1000
    )
"""

class TimeGranularity(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    AUTO = "auto"

class DataFormat(str, Enum):
    RAW = "raw"
    SUMMARY = "summary"
    COMPACT = "compact"

class MetricAggregation(str, Enum):
    SUM = "sum"
    AVERAGE = "average"
    MIN = "min"
    MAX = "max"

class GoogleSearchConsoleRequest(BaseModel):
    """Schema for Google Search Console data requests."""
    
    model_config = {
        "use_enum_values": True,
        "extra": "ignore"
    }
    
    # Required credential fields
    search_console_credentials: Dict[str, Any] = Field(
        ...,
        description="Search Console credential dictionary containing required OAuth2 credentials: access_token, refresh_token, sc_client_id, client_secret"
    )
    
    search_console_property_url: str = Field(
        ...,
        description="Search Console property URL to fetch data from"
    )
    
    start_date: str = Field(
        default="28daysAgo",
        description="Start date (YYYY-MM-DD or relative like '7daysAgo')"
    )
    end_date: str = Field(
        default="yesterday",
        description="End date (YYYY-MM-DD or relative like 'today')"
    )
    dimensions: List[str] = Field(
        default=["query"],
        description="Dimensions to fetch (query, page, country, device, date)"
    )
    search_type: str = Field(
        default="web",
        description="Type of search results (web, discover, news, etc.)"
    )
    row_limit: int = Field(
        default=250,
        description="Number of rows to return (1-25000)"
    )
    start_row: int = Field(
        default=0,
        description="Starting row for pagination"
    )
    aggregation_type: str = Field(
        default="auto",
        description="How to aggregate results (auto, byPage, byProperty)"
    )
    data_state: str = Field(
        default="final",
        description="Data state to return (all, final)"
    )
    dimension_filters: Optional[List[dict]] = Field(
        default=None,
        description="List of dimension filters"
    )

    # Data Processing Options
    data_format: DataFormat = Field(
        default=DataFormat.RAW,
        description="""
        How to format the returned data:
        - 'raw': Returns all data points (use for detailed analysis)
        - 'summary': Returns statistical summary (min/max/mean/median) - best for high-level insights
        - 'compact': Returns top N results (good for finding top performers)
        
        Example use cases:
        - For keyword analysis: use 'raw' with query dimension
        - For performance overview: use 'summary'
        - For top pages: use 'compact' with top_n=10
        """
    )

    top_n: Optional[int] = Field(
        default=None,
        description="""
        Return only top N results by clicks or impressions.
        
        Example use cases:
        - top_n=10 with dimensions=['query'] → top 10 keywords
        - top_n=5 with dimensions=['page'] → top 5 pages
        - top_n=3 with dimensions=['country'] → top 3 countries
        """
    )

    time_granularity: TimeGranularity = Field(
        default=TimeGranularity.AUTO,
        description="""
        Time period to aggregate data by:
        - 'daily': Keep daily granularity (best for 1-7 day ranges)
        - 'weekly': Group by weeks (best for 8-60 day ranges)
        - 'monthly': Group by months (best for 60+ day ranges)
        - 'auto': Automatically choose based on date range
        
        Example use cases:
        - For daily CTR fluctuations: use 'daily'
        - For weekly performance trends: use 'weekly'
        - For long-term position changes: use 'monthly'
        """
    )

    metric_aggregation: MetricAggregation = Field(
        default=MetricAggregation.SUM,
        description="""
        How to aggregate metrics when grouping data.
        
        Note: 
        - 'sum' for clicks and impressions
        - 'average' for CTR and position
        """
    )

    include_percentages: bool = Field(
        default=False,
        description="""
        Add percentage calculations relative to totals.
        Adds '_pct' suffix to metrics (e.g., 'clicks_pct').
        
        Example use cases:
        - Click distribution across pages
        - Impression share by country
        - CTR comparison across devices
        """
    )

    normalize_metrics: bool = Field(
        default=False,
        description="""
        Scale numeric metrics to 0-1 range for easier comparison.
        Adds '_normalized' suffix to metrics.
        
        Use when:
        - Comparing high-impression vs low-impression queries
        - Analyzing position vs CTR correlation
        - Creating visualizations
        """
    )

    round_digits: Optional[int] = Field(
        default=2,
        description="Round numeric values to specified digits"
    )

    include_period_comparison: bool = Field(
        default=False,
        description="""
        Include comparison with previous period.
        
        Example use cases:
        - Month-over-month ranking changes
        - Year-over-year click growth
        - Week-over-week CTR improvement
        
        Returns additional fields:
        - previous_period_value
        - percentage_change
        """
    )

    moving_average_window: Optional[int] = Field(
        default=None,
        description="""
        Calculate moving averages over specified number of periods.
        Only applies when data includes the 'date' dimension.
        
        Example use cases:
        - 7-day moving average for smoothing daily fluctuations
        - 30-day moving average for trend analysis
        - 90-day moving average for long-term patterns
        
        Adds '_ma{window}' suffix to metric names (e.g., 'sessions_ma7')
        """
    )

    @field_validator("start_date", "end_date")
    @classmethod
    def validate_dates(cls, value: str) -> str:
        return DateProcessor.process_relative_date(value)

    @field_validator("dimensions")
    @classmethod
    def validate_dimensions(cls, value: List[str]) -> List[str]:
        valid_dimensions = ["country", "device", "page", "query", "searchAppearance", "date"]
        for dim in value:
            if dim not in valid_dimensions:
                raise ValueError(f"Invalid dimension: {dim}. Must be one of {valid_dimensions}")
        return value

    @field_validator("search_type")
    @classmethod
    def validate_search_type(cls, value: str) -> str:
        valid_types = ["web", "discover", "googleNews", "news", "image", "video"]
        if value not in valid_types:
            raise ValueError(f"Invalid search type. Must be one of {valid_types}")
        return value

    @field_validator("row_limit")
    @classmethod
    def validate_row_limit(cls, value: int) -> int:
        if not 1 <= value <= 25000:
            raise ValueError("Row limit must be between 1 and 25000")
        return value

class SearchConsoleDataProcessor:
    @staticmethod
    def _add_period_comparison(df: pd.DataFrame) -> pd.DataFrame:
        """Add period-over-period comparison metrics"""
        if 'date' not in df.columns:
            return df
            
        # Ensure date is datetime for proper sorting
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Calculate the period length
        total_days = (df['date'].max() - df['date'].min()).days
        period_length = total_days // 2
        
        # Create a cutoff date for splitting current and previous periods
        cutoff_date = df['date'].max() - pd.Timedelta(days=period_length)
        
        # Split into current and previous periods
        current_period = df[df['date'] > cutoff_date].copy()
        previous_period = df[df['date'] <= cutoff_date].copy()
        
        # Calculate metrics for both periods
        metrics = ['clicks', 'impressions', 'ctr', 'position']
        comparison_data = {}
        
        for metric in metrics:
            if metric in df.columns:
                current_value = current_period[metric].mean()
                previous_value = previous_period[metric].mean()
                
                # Add comparison metrics
                df[f'{metric}_previous'] = previous_value
                df[f'{metric}_change'] = ((current_value - previous_value) / previous_value * 100 
                                        if previous_value != 0 else 0)
                
                comparison_data[metric] = {
                    'current_period': current_value,
                    'previous_period': previous_value,
                    'percent_change': ((current_value - previous_value) / previous_value * 100 
                                     if previous_value != 0 else 0)
                }
        
        # Add comparison summary to the DataFrame
        df.attrs['period_comparison'] = comparison_data
        
        return df

    @staticmethod
    def process_data(data: List[dict], params: GoogleSearchConsoleRequest) -> List[dict]:
        """Process the search console data based on request parameters"""
        if not data:
            return data

        df = pd.DataFrame(data)

        # Apply time granularity aggregation if needed
        if params.time_granularity != TimeGranularity.DAILY and 'date' in df.columns:
            df = SearchConsoleDataProcessor._aggregate_by_time(df, params.time_granularity)

        # Calculate moving averages if requested
        if params.moving_average_window and 'date' in df.columns:
            df = SearchConsoleDataProcessor._calculate_moving_averages(
                df,
                params.moving_average_window
            )

        # Add period comparison if requested
        if params.include_period_comparison and 'date' in df.columns:
            df = SearchConsoleDataProcessor._add_period_comparison(df)

        # Apply top N filter
        if params.data_format == DataFormat.COMPACT and params.top_n:
            df = df.nlargest(params.top_n, 'clicks')  # Default to sorting by clicks

        # Add percentages if requested
        if params.include_percentages:
            for metric in ['clicks', 'impressions']:
                total = df[metric].sum()
                if total > 0:
                    df[f'{metric}_pct'] = (df[metric] / total) * 100

        # Normalize metrics if requested
        if params.normalize_metrics:
            for metric in ['clicks', 'impressions', 'position']:
                min_val = df[metric].min()
                max_val = df[metric].max()
                if max_val > min_val:
                    df[f'{metric}_normalized'] = (df[metric] - min_val) / (max_val - min_val)

        # Round values
        if params.round_digits is not None:
            numeric_cols = df.select_dtypes(include=['float64', 'int64']).columns
            df[numeric_cols] = df[numeric_cols].round(params.round_digits)

        # Generate summary if requested
        if params.data_format == DataFormat.SUMMARY:
            return SearchConsoleDataProcessor._generate_summary(df)

        # Format the response to include period comparison data if it exists
        result = df.to_dict('records')
        if params.include_period_comparison and hasattr(df, 'attrs') and 'period_comparison' in df.attrs:
            return {
                'data': result,
                'period_comparison': df.attrs['period_comparison']
            }
        
        return result

    @staticmethod
    def _aggregate_by_time(df: pd.DataFrame, granularity: TimeGranularity) -> pd.DataFrame:
        df['date'] = pd.to_datetime(df['date'])
        
        # Get all non-date columns that should be preserved in grouping
        group_cols = [col for col in df.columns if col != 'date' and not pd.api.types.is_numeric_dtype(df[col])]
        
        if granularity == TimeGranularity.WEEKLY:
            df['date'] = df['date'].dt.strftime('%Y-W%W')
        elif granularity == TimeGranularity.MONTHLY:
            df['date'] = df['date'].dt.strftime('%Y-%m')
        
        # Add date back to group columns
        group_cols.append('date')
        
        # Define aggregation rules for different metric types
        agg_dict = {
            'clicks': 'sum',
            'impressions': 'sum',
            'ctr': 'mean',
            'position': 'mean'
        }
        
        # Group by all dimension columns including date
        return df.groupby(group_cols).agg(agg_dict).reset_index()

    @staticmethod
    def _generate_summary(df: pd.DataFrame) -> dict:
        """Generate statistical summary of the data"""
        metrics = ['clicks', 'impressions', 'ctr', 'position']
        summary = {
            'summary_stats': {},
            'total_rows': len(df)
        }

        for metric in metrics:
            summary['summary_stats'][metric] = {
                'min': float(df[metric].min()),
                'max': float(df[metric].max()),
                'mean': float(df[metric].mean()),
                'median': float(df[metric].median()),
                'total': float(df[metric].sum()) if metric in ['clicks', 'impressions'] else None
            }

        return summary

    @staticmethod
    def _calculate_moving_averages(df: pd.DataFrame, window: int) -> pd.DataFrame:
        """Calculate moving averages for core metrics"""
        if 'date' not in df.columns:
            return df
            
        # Ensure date is datetime for proper sorting
        df['date'] = pd.to_datetime(df['date'])
        df = df.sort_values('date')
        
        # Calculate moving averages for all numeric metrics
        metrics = ['clicks', 'impressions', 'ctr', 'position']
        for metric in metrics:
            if metric in df.columns:
                df[f'{metric}_ma{window}'] = df[metric].rolling(
                    window=window,
                    min_periods=1  # Allow partial windows at the start
                ).mean()
        
        return df

class GenericGoogleSearchConsoleTool(BaseTool):
    """Google Search Console data fetching tool."""
    name: str = "Search Console Data Tool"
    description: str = """
    Fetches data from Google Search Console with advanced processing capabilities.
    
    Required Parameters:
    - search_console_property_url: The property URL to fetch data from
    - search_console_credentials: Dictionary containing the required OAuth2 credentials:
        - access_token
        - refresh_token
        - sc_client_id
        - client_secret
    
    Optional Parameters (with defaults):
    - start_date: Start date for data range (default: "28daysAgo")
    - end_date: End date for data range (default: "yesterday")
    - dimensions: List of dimensions to fetch (default: ["query"])
    - search_type: Type of search results (default: "web")
    
    Key Features:
    - Flexible date ranges (e.g., '7daysAgo', '3monthsAgo', 'YYYY-MM-DD')
    - Core metrics: clicks, impressions, CTR, position
    - Dimensions: query, page, country, device, date
    - Data processing: aggregation, filtering, summaries
    
    Example Commands:
    1. Basic performance data:
       tool._run(
           search_console_property_url="https://www.example.com/",
           search_console_credentials=credentials_dict
       )
    
    2. Top queries analysis:
       tool._run(
           search_console_property_url="https://www.example.com/",
           search_console_credentials=credentials_dict,
           dimensions=["query"],
           data_format="compact",
           top_n=10
       )
    
    3. Device performance:
       tool._run(
           search_console_property_url="https://www.example.com/",
           search_console_credentials=credentials_dict,
           dimensions=["device"],
           include_period_comparison=True
       )
    """
    
    args_schema: Type[BaseModel] = GoogleSearchConsoleRequest

    def _run(
        self,
        start_date: str,
        end_date: str,
        dimensions: List[str] = ["query"],
        search_type: str = "web",
        row_limit: int = 250,
        start_row: int = 0,
        aggregation_type: str = "auto",
        data_state: str = "final",
        dimension_filters: Optional[List[dict]] = None,
        data_format: DataFormat = DataFormat.RAW,
        top_n: Optional[int] = None,
        time_granularity: TimeGranularity = TimeGranularity.AUTO,
        metric_aggregation: MetricAggregation = MetricAggregation.SUM,
        include_percentages: bool = False,
        normalize_metrics: bool = False,
        round_digits: Optional[int] = None,
        include_period_comparison: bool = False,
        moving_average_window: Optional[int] = None,
        search_console_credentials: Optional[Dict[str, Any]] = None,
        search_console_property_url: Optional[str] = None,
    ) -> str:
        """Execute the tool with validated parameters"""
        try:
            # Create a dictionary of all parameters to validate with Pydantic
            params_dict = {
                "start_date": start_date,
                "end_date": end_date,
                "dimensions": dimensions,
                "search_type": search_type,
                "row_limit": row_limit,
                "start_row": start_row,
                "aggregation_type": aggregation_type,
                "data_state": data_state,
                "dimension_filters": dimension_filters,
                "data_format": data_format,
                "top_n": top_n,
                "time_granularity": time_granularity,
                "metric_aggregation": metric_aggregation,
                "include_percentages": include_percentages,
                "normalize_metrics": normalize_metrics,
                "round_digits": round_digits,
                "include_period_comparison": include_period_comparison,
                "moving_average_window": moving_average_window,
                "search_console_credentials": search_console_credentials,
                "search_console_property_url": search_console_property_url
            }
            
            # Validate parameters using the schema
            params = self.args_schema(**params_dict)
            
            # Validate required parameters
            if not params.search_console_credentials:
                raise ValueError("Missing required parameter: search_console_credentials")
                
            if not params.search_console_property_url:
                raise ValueError("Missing required parameter: search_console_property_url")
            
            # Create service using provided credentials
            try:
                logger.debug("Creating credentials object")
                creds = Credentials(
                    token=params.search_console_credentials.get('access_token'),
                    refresh_token=params.search_console_credentials.get('refresh_token'),
                    token_uri=params.search_console_credentials.get('token_uri', 'https://oauth2.googleapis.com/token'),
                    client_id=params.search_console_credentials.get('sc_client_id'),
                    client_secret=params.search_console_credentials.get('client_secret'),
                    scopes=params.search_console_credentials.get('scopes', ['https://www.googleapis.com/auth/webmasters.readonly'])
                )
                
                # Try to refresh token if needed
                if creds.refresh_token:
                    try:
                        logger.debug("Attempting to refresh token")
                        request = Request()
                        creds.refresh(request)
                        logger.debug("Successfully refreshed token")
                    except Exception as refresh_error:
                        error_message = str(refresh_error)
                        logger.error(f"Failed to refresh token: {error_message}")
                        if "invalid_grant" in error_message.lower():
                            raise ValueError("Credentials have expired or are invalid. Please reconnect the account.")
                
                # Create service
                logger.debug("Building Search Console service")
                service = build('searchconsole', 'v1', credentials=creds)
                property_url = params.search_console_property_url
                
            except Exception as cred_error:
                logger.error(f"Failed to create Search Console service: {str(cred_error)}")
                raise ValueError(f"Failed to initialize Search Console service: {str(cred_error)}")

            # Prepare the request body
            request_body = {
                'startDate': params.start_date,
                'endDate': params.end_date,
                'dimensions': params.dimensions,
                'type': params.search_type,
                'rowLimit': params.row_limit,
                'startRow': params.start_row,
                'aggregationType': params.aggregation_type,
                'dataState': params.data_state
            }

            # Add dimension filters if provided
            if params.dimension_filters:
                filters = []
                for filter_dict in params.dimension_filters:
                    if isinstance(filter_dict['expression'], list):
                        # For notEquals/notContains, create an OR group of NOT conditions
                        if filter_dict['operator'] in ['notEquals', 'notContains']:
                            filters.append({
                                'groupType': 'or',
                                'filters': [{
                                    'dimension': filter_dict['dimension'],
                                    'operator': 'notContains' if filter_dict['operator'] == 'notContains' else 'notEquals',
                                    'expression': expr.lower()  # Case-insensitive matching
                                } for expr in filter_dict['expression']]
                            })
                        else:
                            # For other operators, create individual filters
                            for expr in filter_dict['expression']:
                                filters.append({
                                    'dimension': filter_dict['dimension'],
                                    'operator': filter_dict['operator'],
                                    'expression': expr.lower()  # Case-insensitive matching
                                })
                    else:
                        filters.append({
                            'dimension': filter_dict['dimension'],
                            'operator': filter_dict['operator'],
                            'expression': filter_dict['expression'].lower()  # Case-insensitive matching
                        })

                # Create the final filter group structure
                request_body['dimensionFilterGroups'] = [{
                    'groupType': 'and',
                    'filters': filters
                }]

            # Execute the request
            try:
                logger.debug(f"Executing Search Console query with dimensions: {params.dimensions}")
                response = service.searchanalytics().query(
                    siteUrl=property_url,
                    body=request_body
                ).execute()
                logger.debug(f"Received response with {len(response.get('rows', []))} rows")
            except HttpError as http_error:
                error_message = str(http_error)
                logger.error(f"HTTP error in Search Console API: {error_message}")
                
                # Create detailed error message based on exception content
                detailed_message = "Failed to execute Search Console query"
                
                if "403" in error_message or "permission" in error_message.lower():
                    detailed_message = "Permission denied. Ensure you have the correct access permissions."
                elif "429" in error_message or "quota" in error_message.lower():
                    detailed_message = "API quota exceeded. Please try again later."
                elif "401" in error_message or "unauthorized" in error_message.lower():
                    detailed_message = "Authentication failed. Please check your credentials."
                
                result = {
                    'success': False,
                    'error': detailed_message,
                    'error_details': error_message,
                    'property_url': property_url
                }
                
                # Convert to JSON string to match other working tools
                return json.dumps(result)

            # Process the response
            raw_data = self._format_response(response, params.dimensions)
            
            if raw_data['success']:
                processed_data = SearchConsoleDataProcessor.process_data(
                    raw_data['search_console_data'],
                    params
                )
                
                # Handle period comparison format
                if isinstance(processed_data, dict) and 'period_comparison' in processed_data:
                    result = {
                        'success': True,
                        'search_console_data': processed_data['data'],
                        'period_comparison': processed_data['period_comparison'],
                        'property_url': property_url,
                        'start_date': params.start_date,
                        'end_date': params.end_date
                    }
                else:
                    result = {
                    'success': True,
                        'search_console_data': processed_data,
                        'property_url': property_url,
                        'start_date': params.start_date,
                        'end_date': params.end_date
                }
            else:
                # Add property reference to raw data
                raw_data['property_url'] = property_url
                result = raw_data
            
            # Convert to JSON string to match other working tools
            return json.dumps(result)

        except Exception as e:
            logger.error(f"Search Console tool error: {str(e)}", exc_info=True)
            
            # Create detailed error message based on exception content
            error_message = str(e)
            detailed_message = "Failed to execute Search Console tool"
            
            if "credentials" in error_message.lower() or "authentication" in error_message.lower():
                detailed_message = "Authentication failed. Please check your credentials."
                if "expired" in error_message.lower() or "invalid_grant" in error_message.lower():
                    detailed_message = "Credentials have expired. Please reconnect your accounts."
            elif "quota" in error_message.lower() or "rate limit" in error_message.lower():
                detailed_message = "API quota exceeded. Please try again later."
            elif "permission" in error_message.lower() or "403" in error_message:
                detailed_message = "Permission denied. Ensure you have the correct access permissions."
            
            result = {
                'success': False,
                'error': detailed_message,
                'error_details': str(e),
                'search_console_data': []
            }
            
            # Convert to JSON string to match other working tools
            return json.dumps(result)

    def _format_response(self, response: dict, dimensions: List[str]) -> dict:
        """Format the Search Console API response into a structured format."""
        search_console_data = []
        
        # Clean dimension names - strip whitespace
        dimensions = [d.strip() for d in dimensions]
        
        for row in response.get('rows', []):
            data_point = {}
            
            # Process dimension values
            for i, dimension in enumerate(dimensions):
                value = row['keys'][i]
                data_point[dimension] = value
            
            # Add metrics
            data_point.update({
                'clicks': row.get('clicks', 0),
                'impressions': row.get('impressions', 0),
                'ctr': round(row.get('ctr', 0) * 100, 2),
                'position': round(row.get('position', 0), 2)
            })
            
            search_console_data.append(data_point)

        return {
            'success': True,
            'search_console_data': search_console_data
        }

================
File: apps/agents/tools/google_suggestions_tool/__init__.py
================
from .google_suggestions_tool import GoogleSuggestionsTool

================
File: apps/agents/tools/google_suggestions_tool/google_suggestions_tool.py
================
from typing import Any, Type, Optional
from pydantic import BaseModel, Field, ConfigDict
from apps.agents.tools.base_tool import BaseTool
import requests
import xml.etree.ElementTree as ET
import logging

logger = logging.getLogger(__name__)

class GoogleSuggestionsInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    keyword: str = Field(description="The keyword to get suggestions for")
    country_code: str = Field(default="us", description="The country code for localized suggestions")

class GoogleSuggestionsTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Google Suggestions Fetcher"
    description: str = "Retrieves Google search suggestions for a given keyword."
    args_schema: Type[BaseModel] = GoogleSuggestionsInput

    def _run(self, keyword: str, country_code: str = "us", **kwargs: Any) -> Any:
        """Use the tool to get Google search suggestions."""
        logger.debug(f"Running GoogleSuggestionsTool with keyword: '{keyword}', country_code: '{country_code}'")

        # Use default country code if an empty string is provided
        effective_country_code = country_code if country_code else "us"
        logger.debug(f"Effective country code: '{effective_country_code}'")

        # Build the Google Search query URL - Removed "is " prefix
        search_query = keyword # Corrected search query
        google_search_url = f"http://google.com/complete/search?output=toolbar&gl={effective_country_code}&q={search_query}"
        logger.debug(f"Requesting Google Suggestions URL: {google_search_url}")

        suggestions = []
        try:
            # Call the URL and read the data
            result = requests.get(google_search_url, timeout=10) # Added timeout
            logger.debug(f"Google Suggestions response status code: {result.status_code}")

            if result.status_code == 200:
                logger.debug(f"Raw response content: {result.content}")
                # Check if content is valid XML before parsing
                if result.content and result.content.strip():
                    try:
                        tree = ET.ElementTree(ET.fromstring(result.content))
                        root = tree.getroot()

                        # Extract the suggestions from the XML response
                        for suggestion in root.findall('CompleteSuggestion'):
                            suggestion_data = suggestion.find('suggestion').attrib.get('data')
                            if suggestion_data:
                                suggestions.append(suggestion_data)
                        logger.debug(f"Extracted suggestions: {suggestions}")
                    except ET.ParseError as e:
                        logger.error(f"Error parsing XML response: {e}")
                        logger.error(f"Response content that failed parsing: {result.content}")
                        return f"Error: Could not parse suggestions response from Google. Invalid XML received."
                else:
                    logger.warning("Received empty or whitespace-only response from Google Suggestions API.")
                    return "Received empty response from Google Suggestions API."
            else:
                logger.error(f"Google Suggestions API request failed with status code {result.status_code}. Response: {result.text}")
                return f"Error: Google Suggestions request failed with status {result.status_code}."

        except requests.exceptions.RequestException as e:
            logger.error(f"Error during Google Suggestions API request: {e}")
            return f"Error: Could not connect to Google Suggestions API. {e}"
        except Exception as e:
            logger.error(f"An unexpected error occurred in GoogleSuggestionsTool: {e}")
            return f"Error: An unexpected error occurred. {e}"

        # Return the suggestions as a comma-separated string
        output = ", ".join(suggestions)
        logger.info(f"GoogleSuggestionsTool finished successfully. Output: '{output[:100]}...'") # Log truncated output
        return output

    async def _arun(self, keyword: str, country_code: str = "us", **kwargs: Any) -> Any:
        """Use the tool asynchronously."""
        raise NotImplementedError("GoogleSuggestionsTool does not support async")

================
File: apps/agents/tools/keyword_tools/__init__.py
================
from .keyword_tools import (
    KeywordsForSiteTool, KeywordSuggestionsTool, 
    KeywordIdeasTool, SearchVolumeTool, 
    KeywordsForSiteInput, KeywordSuggestionsInput, 
    KeywordIdeasInput, SearchVolumeInput
)
from .ranked_keywords_tool import RankedKeywordsTool, RankedKeywordsInput

__all__ = [
    'KeywordsForSiteTool', 'KeywordSuggestionsTool', 
    'KeywordIdeasTool', 'SearchVolumeTool',
    'KeywordsForSiteInput', 'KeywordSuggestionsInput',
    'KeywordIdeasInput', 'SearchVolumeInput',
    'RankedKeywordsTool', 'RankedKeywordsInput'
]

================
File: apps/agents/tools/keyword_tools/keyword_tools.py
================
import os
import requests
from typing import Any, Type, List, Dict, Tuple, Optional, Union
from pydantic import BaseModel, Field, ConfigDict, field_validator
from apps.agents.tools.base_tool import BaseTool
import logging
import json
import csv
import io
import pandas as pd
import numpy as np
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

BASE_URL = os.getenv('DATAFORSEO_BASE_URL', 'https://api.dataforseo.com')

class KeywordsForSiteInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    website_url: str = Field(description="Fully qualified domain name (FQDN) for keyword analysis")

    @classmethod
    def get_fqdn(cls, url: str) -> str:
        parsed_url = urlparse(url)
        return parsed_url.netloc or parsed_url.path

class KeywordSuggestionsInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    seed_keyword: str = Field(description="Seed keyword for suggestions")
    filters: List[Tuple[str, str, float]] = Field(description="List of filters", default=[])

class KeywordIdeasInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    keywords: List[str] = Field(description="Single keyword or list of keywords")
    filters: List[Tuple[str, str, float]] = Field(description="List of filters", default=[])

    @field_validator('keywords', mode='before')
    @classmethod
    def validate_keywords(cls, value):
        if isinstance(value, str):
            return [value]
        return value

class SearchVolumeInput(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    keywords: List[str] = Field(description="Single keyword or list of keywords to get search volume for")
    sort_by: str = Field(default="relevance", description="Sort results by this field")

    @field_validator('keywords', mode='before')
    @classmethod
    def validate_keywords(cls, value):
        if isinstance(value, str):
            return [value]
        return value

class KeywordsForSiteTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Keywords for Site"
    description: str = "Provides a list of keywords relevant to the target domain. Each keyword is supplied with relevant categories, search volume data for the last month, cost-per-click, competition, and search volume trend values for the past 12 months"
    args_schema: Type[BaseModel] = KeywordsForSiteInput

    def _run(self, website_url: str, **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/keywords_data/google_ads/keywords_for_site/live"
        
        fqdn = KeywordsForSiteInput.get_fqdn(website_url)
        
        payload = [
            {
                "target": fqdn,
                "language_code": "en",
                "location_code": 2840,
            }
        ]
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(url, json=payload, headers=headers, auth=cred)
            response.raise_for_status()

        except Exception as e:
            logger.error(f"Error making request to DataForSEO: {e}")
            raise e

        try:
            results = KeywordTools._transform_keyword_data(response.json())
        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            raise e

        return results

    async def _arun(self, target: str, **kwargs: Any) -> Any:
        raise NotImplementedError("KeywordsForSiteTool does not support async")

class KeywordSuggestionsTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Keyword Suggestions"
    description: str = "Provides a list of keywords relevant to the target domain. Each keyword is supplied with relevant categories, search volume data for the last month, cost-per-click, competition, and search volume trend values for the past 12 months"
    args_schema: Type[BaseModel] = KeywordSuggestionsInput

    def _run(self, seed_keyword: str, filters: List = None, **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/dataforseo_labs/google/keyword_suggestions/live"
        payload = [
            {
                "keyword": seed_keyword,
                "location_code": 2840,
                "language_code": "en",
                "include_serp_info": True,
                "include_seed_keyword": True,
                "limit": 50,
            }
        ]
        if filters:
            payload[0]["filters"] = filters
        headers = {"Content-Type": "application/json"}
        response = requests.post(url, json=payload, headers=headers, auth=cred)
        response.raise_for_status()
        
        try:
            results = KeywordTools._transform_keyword_data(response.json())
        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            raise e
        
        return results

    async def _arun(self, seed_keyword: str, filters: List = None, **kwargs: Any) -> Any:
        raise NotImplementedError("KeywordSuggestionsTool does not support async")

class KeywordIdeasTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Keyword Ideas"
    description: str = "The Keyword Ideas endpoint provides search terms that are relevant to the product or service categories of the specified keywords. The algorithm selects the keywords which fall into the same categories as the seed keywords specified in a POST array. As a result, you will get a list of relevant keyword ideas for up to 200 seed keywords. Along with each keyword idea, you will get its search volume rate for the last month, search volume trend for the previous 12 months, as well as current cost-per-click and competition values. Moreover, this endpoint supplies minimum, maximum and average values of daily impressions, clicks and CPC for each result."
    args_schema: Type[BaseModel] = KeywordIdeasInput

    def _run(self, keywords: List[str], filters: List[Tuple[str, str, float]] = None, **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/dataforseo_labs/google/keyword_ideas/live"
        payload = [
            {
                "keywords": keywords,
                "location_code": 2840,
                "language_code": "en",
                "include_serp_info": True,
                "limit": 100,
            }
        ]
        if filters:
            payload[0]["filters"] = filters
        headers = {"Content-Type": "application/json"}
        response = requests.post(url, json=payload, headers=headers, auth=cred)
        response.raise_for_status()

        try:
            results = KeywordTools._transform_keyword_data(response.json())
        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            raise e
        return results

    async def _arun(self, keywords: List[str], filters: List[Tuple[str, str, float]] = None, **kwargs: Any) -> Any:
        raise NotImplementedError("KeywordIdeasTool does not support async")

class SearchVolumeTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Search Volume"
    description: str = "Provides search volume data for a list of keywords"
    args_schema: Type[BaseModel] = SearchVolumeInput

    def _run(self, keywords: List[str], sort_by: str = "relevance", **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/keywords_data/google_ads/search_volume/live"
        payload = [
            {
                "keywords": keywords,
                "sort_by": sort_by
            }
        ]
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(url, json=payload, headers=headers, auth=cred)
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error making request to DataForSEO: {e}")
            raise e

        try:
            results = KeywordTools._transform_keyword_data(response.json())
        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            raise e
        return results

    async def _arun(self, keywords: List[str], sort_by: str = "relevance", **kwargs: Any) -> Any:
        raise NotImplementedError("SearchVolumeTool does not support async")

class KeywordTools:
    @staticmethod
    def tools():
        return [KeywordsForSiteTool(), KeywordSuggestionsTool(), KeywordIdeasTool(), SearchVolumeTool()]

    @staticmethod
    def _dataforseo_credentials():
        login = os.environ["DATAFORSEO_EMAIL"]
        password = os.environ["DATAFORSEO_PASSWORD"]
        return login, password

    @staticmethod
    def _transform_keyword_data(data: Dict) -> str:
        try:
            if data.get('tasks_error', 0) > 0:
                error_message = data.get('tasks', [{}])[0].get('status_message', 'Unknown error')
                return f"Error: {error_message}"

            path = data.get('tasks', [{}])[0].get('path', [])
            if len(path) >= 4:
                tool_type = path[3]
            else:
                return "Error: Unable to determine tool type from response"

            if tool_type == "keywords_for_site":
                all_results = data.get('tasks', [])[0].get('result', [])
            elif tool_type in ["keyword_suggestions", "keyword_ideas"]:
                result = data.get('tasks', [])[0].get('result', [])
                if result:
                    all_results = result[0].get('items', [])
                else:
                    return "Error: No results found in the response"
            elif tool_type == "search_volume":
                all_results = data.get('tasks', [])[0].get('result', [])
            else:
                return f"Error: Unknown tool type: {tool_type}"

            if not all_results:
                return "Error: No results found in the response"

            df = pd.DataFrame(all_results)

            columns = ['keyword', 'search_volume', 'cpc', 'competition']
            if 'keyword_info' in df.columns:
                df['search_volume'] = df['keyword_info'].apply(lambda x: x.get('search_volume', 0))
                df['cpc'] = df['keyword_info'].apply(lambda x: x.get('cpc', 0))
                df['competition'] = df['keyword_info'].apply(lambda x: x.get('competition', 0))
            if 'keyword_properties' in df.columns:
                df['keyword_difficulty'] = df['keyword_properties'].apply(lambda x: x.get('keyword_difficulty', 0))
                columns.append('keyword_difficulty')
            if 'low_top_of_page_bid' in df.columns:
                columns.extend(['low_top_of_page_bid', 'high_top_of_page_bid'])

            result_df = df[columns]
            result_df = result_df.rename(columns={
                'search_volume': 'avg_search_volume',
                'keyword_difficulty': 'difficulty',
                'low_top_of_page_bid': 'low_top_bid',
                'high_top_of_page_bid': 'high_top_bid'
            })

            if 'competition' in result_df.columns and result_df['competition'].dtype == 'object':
                competition_map = {'LOW': 0, 'MEDIUM': 0.5, 'HIGH': 1}
                result_df['competition'] = result_df['competition'].map(competition_map)

            fill_values = {col: 0 for col in result_df.columns if col != 'keyword'}
            fill_values['keyword'] = 'N/A'
            result_df = result_df.fillna(fill_values)

            result_df = result_df.sort_values('cpc', ascending=False)
            result_df = result_df[result_df['avg_search_volume'] >= 500]

            csv_output = result_df.to_csv(index=False)
            return csv_output

        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            return f"Error: {str(e)}"

================
File: apps/agents/tools/keyword_tools/ranked_keywords_tool.py
================
import os
import requests
from typing import Any, Type, List, Dict
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import logging
import pandas as pd
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

BASE_URL = os.getenv('DATAFORSEO_BASE_URL', 'https://api.dataforseo.com')

class RankedKeywordsInput(BaseModel):
    """Input model for ranked keywords tool"""
    website_url: str = Field(description="Domain or webpage for keyword ranking analysis")
    model_config = {
        "arbitrary_types_allowed": True
    }

    @classmethod
    def get_fqdn(cls, url: str) -> str:
        parsed_url = urlparse(url)
        return parsed_url.netloc or parsed_url.path

class RankedKeywordsTool(BaseTool):
    name: str = "Ranked Keywords"
    description: str = "Provides a list of ranked keywords with various metrics"
    args_schema: Type[BaseModel] = RankedKeywordsInput

    def _run(self, website_url: str, location_code: int = 2840, language_code: str = "en", **kwargs: Any) -> Any:
        login, password = KeywordTools._dataforseo_credentials()
        cred = (login, password)
        url = f"{BASE_URL}/v3/dataforseo_labs/google/ranked_keywords/live"
        fqdn = RankedKeywordsInput.get_fqdn(website_url)

        payload = [
            {
                "target": fqdn,
                "location_code": location_code,
                "language_code": language_code,
                "limit": 100,
                "order_by": ["keyword_data.keyword_info.search_volume,desc"]
            }
        ]
        headers = {"Content-Type": "application/json"}
        try:
            response = requests.post(url, json=payload, headers=headers, auth=cred)
            response.raise_for_status()
        except Exception as e:
            logger.error(f"Error making request to DataForSEO: {e}")
            raise e

        try:
            results = self._transform_keyword_data(response.json())
        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            raise e

        return results

    def _transform_keyword_data(self, data: Dict) -> str:
        try:
            if data.get('tasks_error', 0) > 0:
                error_message = data.get('tasks', [{}])[0].get('status_message', 'Unknown error')
                return f"Error: {error_message}"

            all_results = data.get('tasks', [])[0].get('result', [])[0].get('items', [])
            if not all_results:
                return "Error: No results found in the response"

            # Create a DataFrame from the results
            df = pd.DataFrame(all_results)

            # Extract necessary fields and calculate additional metrics
            df['keyword'] = df['keyword_data'].apply(lambda x: x.get('keyword', 'N/A'))
            df['search_volume'] = df['keyword_data'].apply(lambda x: x.get('keyword_info', {}).get('search_volume', 0))
            df['keyword_difficulty'] = df['keyword_data'].apply(lambda x: x.get('keyword_properties', {}).get('keyword_difficulty', 0))
            df['competition_level'] = df['keyword_data'].apply(lambda x: x.get('keyword_info', {}).get('competition_level', 'N/A'))
            df['main_intent'] = df['keyword_data'].apply(lambda x: x.get('search_intent_info', {}).get('main_intent', 'N/A'))
            df['absolute_rank'] = df['ranked_serp_element'].apply(lambda x: x.get('serp_item', {}).get('rank_absolute', 0))
            df['etv'] = df['ranked_serp_element'].apply(lambda x: x.get('serp_item', {}).get('etv', 0))
            df['cpc'] = df['keyword_data'].apply(lambda x: x.get('keyword_info', {}).get('cpc', 0))

            # Define the columns to include in the output
            columns = [
                'keyword', 'search_volume', 'keyword_difficulty', 'competition_level',
                'main_intent', 'absolute_rank', 'etv'
            ]
            result_df = df[columns]

            # Convert the DataFrame to CSV format
            csv_output = result_df.to_csv(index=False, lineterminator='\n')
            return csv_output

        except Exception as e:
            logger.error(f"Error transforming keyword data: {e}")
            return f"Error: {str(e)}"

class KeywordTools:
    @staticmethod
    def _dataforseo_credentials():
        login = os.environ["DATAFORSEO_EMAIL"]
        password = os.environ["DATAFORSEO_PASSWORD"]
        return login, password

================
File: apps/agents/tools/neuralami_api_tool/neuralami_api_tool.py
================
import os
from typing import Any, Type, Set, Dict, Optional, List
import logging
from tenacity import retry, stop_after_attempt, wait_exponential
import requests
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import dotenv
import json

dotenv.load_dotenv()
logger = logging.getLogger(__name__)

class AgentSchema(BaseModel):
    """Schema for Agent operations"""
    name: str = Field(..., description="Name of the agent")
    role: str = Field(..., description="Role of the agent")
    goal: str = Field(..., description="Goal of the agent")
    backstory: str = Field(..., description="Backstory of the agent")
    llm: Optional[str] = Field(None, description="LLM model to use")
    verbose: Optional[bool] = Field(False, description="Enable verbose mode")

class TaskSchema(BaseModel):
    """Schema for Task operations"""
    description: str = Field(..., description="Description of the task")
    agent_id: Optional[int] = Field(None, description="ID of the agent assigned to this task")
    expected_output: str = Field(..., description="Expected output of the task")
    async_execution: Optional[bool] = Field(False, description="Enable async execution")

class CrewSchema(BaseModel):
    """Schema for Crew operations"""
    name: str = Field(..., description="Name of the crew")
    agent_ids: List[int] = Field(..., description="List of agent IDs in the crew")
    process: str = Field("sequential", description="Process type: 'sequential' or 'hierarchical'")
    verbose: Optional[bool] = Field(False, description="Enable verbose mode")

class ToolSchema(BaseModel):
    """Schema for Tool operations"""
    tool_class: str = Field(..., description="Class of the tool")
    tool_subclass: str = Field(..., description="Subclass of the tool")
    name: str = Field(..., description="Name of the tool")
    description: str = Field("", description="Description of the tool")
    module_path: str = Field(..., description="Module path of the tool")

class NeuralAMIAPISchema(BaseModel):
    """Input schema for NeuralAMI API Tool"""
    operation: str = Field(
        ...,
        description="Operation to perform: list_agents, get_agent, create_agent, update_agent, delete_agent, "
                   "list_tasks, get_task, create_task, update_task, delete_task, "
                   "list_crews, get_crew, create_crew, update_crew, delete_crew"
                   "list_tools, get_tool, create_tool, update_tool, delete_tool"

    )
    resource_id: Optional[int] = Field(None, description="ID of the resource for get/update/delete operations")
    data: Optional[dict] = Field(None, description="Data for create/update operations")

class NeuralAMIAPITool(BaseTool):
    name: str = "NeuralAMI API Tool"
    description: str = "A tool for interacting with NeuralAMI API to manage agents, tasks, tools, and crews"
    args_schema: Type[BaseModel] = NeuralAMIAPISchema
    tags: Set[str] = {"api", "agents", "tasks", "crews", "management"}

    # Add these as Pydantic fields
    base_url: str = Field(
        default_factory=lambda: os.getenv('CSRF_TRUSTED_ORIGINS', 'https://manager.neuralami.com').rstrip('/'),
        description="Base URL for the API"
    )
    api_token: str = Field(
        default_factory=lambda: os.getenv('NEURALAMI_API_TOKEN'),
        description="API token for authentication"
    )

    def __init__(self, **data):
        super().__init__(**data)
        if not self.api_token:
            logger.error("NEURALAMI_API_TOKEN is not set in environment variables")
            raise ValueError("NEURALAMI_API_TOKEN is required")

    def _get_headers(self):
        """Get headers for API requests"""
        return {
            'Authorization': f'Token {self.api_token}',
            'Content-Type': 'application/json'
        }

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        reraise=True
    )
    def _make_request(self, method: str, endpoint: str, data: dict = None) -> Dict[str, Any]:
        """Make API request with retry mechanism"""
        url = f"{self.base_url}/api/{endpoint}"
        headers = self._get_headers()

        try:
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                json=data if data else None
            )
            response.raise_for_status()
            return response.json() if response.content else {}

        except requests.exceptions.RequestException as e:
            logger.error(f"API request failed: {str(e)}")
            if hasattr(e.response, 'text'):
                logger.error(f"Response content: {e.response.text[:500]}...")
            raise

    def _run(
        self,
        operation: str,
        resource_id: Optional[int] = None,
        data: Optional[dict] = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Execute the API operation"""

        # Map operations to HTTP methods and endpoints
        operation_map = {
            # Agent operations
            'list_agents': ('GET', 'agents/'),
            'get_agent': ('GET', f'agents/{resource_id}/'),
            'create_agent': ('POST', 'agents/'),
            'update_agent': ('PUT', f'agents/{resource_id}/'),
            'delete_agent': ('DELETE', f'agents/{resource_id}/'),

            # Task operations
            'list_tasks': ('GET', 'tasks/'),
            'get_task': ('GET', f'tasks/{resource_id}/'),
            'create_task': ('POST', 'tasks/'),
            'update_task': ('PUT', f'tasks/{resource_id}/'),
            'delete_task': ('DELETE', f'tasks/{resource_id}/'),

            # Crew operations
            'list_crews': ('GET', 'crews/'),
            'get_crew': ('GET', f'crews/{resource_id}/'),
            'create_crew': ('POST', 'crews/'),
            'update_crew': ('PUT', f'crews/{resource_id}/'),
            'delete_crew': ('DELETE', f'crews/{resource_id}/'),

            # Tool operations
            'list_tools': ('GET', 'tools/'),
            'get_tool': ('GET', f'tools/{resource_id}/'),
            'create_tool': ('POST', 'tools/'),
            'update_tool': ('PUT', f'tools/{resource_id}/'),
            'delete_tool': ('DELETE', f'tools/{resource_id}/'),
        }

        if operation not in operation_map:
            raise ValueError(f"Invalid operation: {operation}")

        method, endpoint = operation_map[operation]

        # Validate resource_id for operations that require it
        if 'get_' in operation or 'update_' in operation or 'delete_' in operation:
            if not resource_id:
                raise ValueError(f"resource_id is required for operation: {operation}")

        # Validate data for create/update operations
        if method in ['POST', 'PUT'] and not data:
            raise ValueError(f"data is required for operation: {operation}")

        return self._make_request(method, endpoint, data)

================
File: apps/agents/tools/pagespeed_tool/pagespeed_tool.py
================
import os
from typing import Any, Type, Set, Dict, Optional
import logging
from tenacity import retry, stop_after_attempt, wait_exponential
import requests
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import dotenv
import time
from django.core.cache import cache

dotenv.load_dotenv()
logger = logging.getLogger(__name__)

class PageSpeedToolSchema(BaseModel):
    """Input for PageSpeedTool."""
    url: str = Field(
        ..., 
        title="URL", 
        description="Full URL of the page to analyze",
        json_schema_extra={"example": "https://example.com"}
    )
    strategy: str = Field(
        default="mobile",
        title="Strategy",
        description="The analysis strategy: 'mobile' or 'desktop'"
    )
    categories: list = Field(
        default=["performance"],
        title="Categories",
        description="Categories to analyze: 'performance', 'accessibility', 'best-practices', 'seo', 'pwa'"
    )

class PageSpeedTool(BaseTool):
    name: str = "PageSpeed Analysis Tool"
    description: str = "A tool that analyzes web pages using Google PageSpeed Insights API to get Core Web Vitals and other performance metrics."
    args_schema: Type[BaseModel] = PageSpeedToolSchema
    tags: Set[str] = {"performance", "seo", "web vitals", "pagespeed"}
    api_key: str = Field(default=os.environ.get('PAGESPEED_API_KEY'))
    base_url: str = Field(default="https://www.googleapis.com/pagespeedonline/v5/runPagespeed")

    def __init__(self, **data):
        super().__init__(**data)
        if not self.api_key:
            logger.error("PAGESPEED_API_KEY is not set in the environment variables.")

    def _run(
        self,
        url: str,
        strategy: str = "mobile",
        categories: list = ["performance"],
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Run PageSpeed analysis."""
        # Ensure URL has a protocol
        if not url.startswith(('http://', 'https://')):
            url = f"https://{url}"
        return self.get_pagespeed_data(url, strategy, categories)

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        reraise=True
    )
    def get_pagespeed_data(
        self, 
        url: str, 
        strategy: str = "mobile",
        categories: list = ["performance"]
    ) -> Dict[str, Any]:
        """Get PageSpeed Insights data with retry mechanism."""
        if not self.api_key:
            raise ValueError("PageSpeed API key is not set")

        # Check cache first
        cache_key = f"pagespeed_{url}_{strategy}"
        cached_data = cache.get(cache_key)
        if cached_data:
            return self._process_pagespeed_data(cached_data)

        params = {
            'url': url,
            'key': self.api_key,
            'strategy': strategy,
            'category': categories
        }

        try:
            response = requests.get(
                self.base_url,
                params=params,
                timeout=None  # No timeout, wait for response
            )
            response.raise_for_status()
            data = response.json()

            # Cache the raw data
            cache.set(cache_key, data, timeout=3600)  # Cache for 1 hour

            # Process and return the data
            return self._process_pagespeed_data(data)

        except requests.exceptions.RequestException as e:
            logger.error(f"Error fetching PageSpeed data for {url}: {str(e)}")
            if hasattr(e.response, 'text'):
                logger.error(f"Response content: {e.response.text[:500]}...")
            raise

    def _process_pagespeed_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Process and structure PageSpeed data."""
        try:
            result = {
                'core_web_vitals': {
                    'lab_data': self._extract_lab_data(data),
                    'field_data': self._extract_field_data(data)
                },
                'performance_score': self._extract_performance_score(data),
                'opportunities': self._extract_opportunities(data),
                'diagnostics': self._extract_diagnostics(data),
                'passed_audits': self._extract_passed_audits(data)
            }
            # Add additional categories if present
            for category in ['accessibility', 'best-practices', 'seo', 'pwa']:
                score = self._extract_category_score(data, category)
                if score is not None:
                    result[f'{category}_score'] = score

            return result

        except Exception as e:
            logger.error(f"Error processing PageSpeed data: {str(e)}")
            return {}

    def _extract_lab_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract lab data metrics."""
        try:
            lab_data = data.get('lighthouseResult', {}).get('audits', {})
            metrics = {}
            
            metric_mapping = {
                'largest-contentful-paint': 'lcp',
                'cumulative-layout-shift': 'cls',
                'total-blocking-time': 'tbt',
                'interactive': 'tti',
                'speed-index': 'speed_index',
                'first-contentful-paint': 'fcp'
            }
            
            for audit_name, metric_name in metric_mapping.items():
                if audit_name in lab_data:
                    metrics[metric_name] = {
                        'value': lab_data[audit_name].get('numericValue'),
                        'score': lab_data[audit_name].get('score'),
                        'display_value': lab_data[audit_name].get('displayValue')
                    }
            
            return metrics
        except Exception as e:
            logger.error(f"Error extracting lab data: {str(e)}")
            return {}

    def _extract_field_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract CrUX field data if available."""
        try:
            field_data = data.get('loadingExperience', {}).get('metrics', {})
            metrics = {}
            
            metric_mapping = {
                'LARGEST_CONTENTFUL_PAINT_MS': 'lcp',
                'CUMULATIVE_LAYOUT_SHIFT_SCORE': 'cls',
                'FIRST_INPUT_DELAY_MS': 'fid',
                'INTERACTION_TO_NEXT_PAINT': 'inp'
            }
            
            for api_name, metric_name in metric_mapping.items():
                if api_name in field_data:
                    metrics[metric_name] = {
                        'percentile': field_data[api_name]['percentile'],
                        'distributions': field_data[api_name]['distributions'],
                        'category': field_data[api_name].get('category')
                    }
            
            return metrics
        except Exception as e:
            logger.error(f"Error extracting field data: {str(e)}")
            return {}

    def _extract_performance_score(self, data: Dict[str, Any]) -> Optional[float]:
        """Extract overall performance score."""
        try:
            return data.get('lighthouseResult', {}).get('categories', {}).get('performance', {}).get('score')
        except Exception:
            return None

    def _extract_category_score(self, data: Dict[str, Any], category: str) -> Optional[float]:
        """Extract score for a specific category."""
        try:
            return data.get('lighthouseResult', {}).get('categories', {}).get(category, {}).get('score')
        except Exception:
            return None

    def _extract_opportunities(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract improvement opportunities."""
        try:
            audits = data.get('lighthouseResult', {}).get('audits', {})
            opportunities = {}
            
            for audit_id, audit_data in audits.items():
                if audit_data.get('details', {}).get('type') == 'opportunity':
                    opportunities[audit_id] = {
                        'title': audit_data.get('title'),
                        'description': audit_data.get('description'),
                        'score': audit_data.get('score'),
                        'numeric_value': audit_data.get('numericValue'),
                        'display_value': audit_data.get('displayValue'),
                        'details': audit_data.get('details')
                    }
            
            return opportunities
        except Exception as e:
            logger.error(f"Error extracting opportunities: {str(e)}")
            return {}

    def _extract_diagnostics(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract diagnostic information."""
        try:
            audits = data.get('lighthouseResult', {}).get('audits', {})
            diagnostics = {}
            
            for audit_id, audit_data in audits.items():
                if audit_data.get('details', {}).get('type') == 'diagnostic':
                    diagnostics[audit_id] = {
                        'title': audit_data.get('title'),
                        'description': audit_data.get('description'),
                        'score': audit_data.get('score'),
                        'details': audit_data.get('details')
                    }
            
            return diagnostics
        except Exception as e:
            logger.error(f"Error extracting diagnostics: {str(e)}")
            return {}

    def _extract_passed_audits(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract passed audits."""
        try:
            audits = data.get('lighthouseResult', {}).get('audits', {})
            passed = {}
            
            for audit_id, audit_data in audits.items():
                if audit_data.get('score') == 1:
                    passed[audit_id] = {
                        'title': audit_data.get('title'),
                        'description': audit_data.get('description')
                    }
            
            return passed
        except Exception as e:
            logger.error(f"Error extracting passed audits: {str(e)}")
            return {}

================
File: apps/agents/tools/pandas_ai_tool/pandas_ai_tool.py
================
# apps/agents/tools/pandas_ai_tool/pandas_ai_tool.py

import os
from typing import Any, Type, List, Dict, Optional
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.common.utils import get_llm
from pandasai import Agent as PandasAgent
from pandasai.llm import BambooLLM
import pandas as pd
from django.conf import settings
import json
import logging

logger = logging.getLogger(__name__)

class PandasAIToolSchema(BaseModel):
    """Input schema for PandasAITool."""
    query: str = Field(
        ..., 
        description="The natural language query to analyze the data"
    )
    data_source: str = Field(
        ..., 
        description="Path to data file or DataFrame variable name"
    )
    data_format: str = Field(
        default="csv",
        description="Format of data source (csv, excel, parquet)"
    )
    analysis_depth: str = Field(
        default="detailed",
        description="Analysis depth: 'basic' (simple stats), 'detailed' (comprehensive analysis), or 'advanced' (complex insights)"
    )

class PandasAITool(BaseTool):
    name: str = "PandasAI Data Analysis Tool"
    description: str = """
    Analyzes data using natural language queries through PandasAI.
    Supports multiple data formats and various analysis depths.
    Features intelligent data loading, error handling, and detailed responses.
    """
    args_schema: Type[BaseModel] = PandasAIToolSchema
    
    modelname: str = Field(default=settings.PANDAS_AI_MODEL)
    llm: Optional[Any] = Field(default=None)
    pandas_agent: Optional[Any] = Field(default=None)

    def __init__(self, **data):
        super().__init__(**data)
        self.llm = BambooLLM(api_key=os.getenv("PANDASAI_API_KEY"))
        
    def _load_data(self, data_source: str, data_format: str) -> pd.DataFrame:
        """Load data from various sources with error handling."""
        try:
            loaders = {
                "csv": pd.read_csv,
                "excel": pd.read_excel,
                "parquet": pd.read_parquet
            }
            
            if data_format not in loaders:
                raise ValueError(f"Unsupported data format: {data_format}")
                
            loader = loaders[data_format]
            df = loader(data_source)
            
            logger.info(f"Successfully loaded data from {data_source}")
            logger.debug(f"DataFrame shape: {df.shape}")
            
            return df
            
        except Exception as e:
            logger.error(f"Error loading data: {str(e)}")
            raise

    def _get_analysis_prompt(self, analysis_depth: str, query: str) -> str:
        """Get the appropriate analysis prompt based on depth."""
        prompts = {
            "basic": f"""
            Perform a basic analysis of the data:
            - Focus on simple descriptive statistics
            - Provide clear, concise results
            - Answer the specific query: {query}
            """,
            
            "detailed": f"""
            Perform a comprehensive analysis of the data:
            - Include detailed statistical measures
            - Identify trends and patterns
            - Provide visualizations if relevant
            - Answer the specific query: {query}
            """,
            
            "advanced": f"""
            Perform an advanced analysis of the data:
            - Use sophisticated statistical methods
            - Conduct deep pattern analysis
            - Provide complex visualizations
            - Include predictive insights
            - Answer the specific query: {query}
            """
        }
        return prompts.get(analysis_depth, prompts["detailed"])

    def _run(
        self,
        query: str,
        data_source: str,
        data_format: str = "csv",
        analysis_depth: str = "detailed",
        **kwargs: Any
    ) -> str:
        try:
            # Input validation
            if not query or not data_source:
                return json.dumps({
                    "error": "Invalid input",
                    "message": "Query and data_source must be non-empty strings"
                })

            # Load the data
            df = self._load_data(data_source, data_format)
            
            # Initialize PandasAI agent if not already initialized
            if not self.pandas_agent:
                self.pandas_agent = PandasAgent(df, config={"llm": self.llm})
            
            # Get analysis prompt
            enhanced_query = self._get_analysis_prompt(analysis_depth, query)
            
            # Execute analysis
            logger.info(f"Executing analysis with depth: {analysis_depth}")
            response = self.pandas_agent.chat(enhanced_query)
            
            result = {
                "analysis_result": str(response),
                "data_info": {
                    "rows": df.shape[0],
                    "columns": df.shape[1],
                    "data_source": data_source,
                    "format": data_format
                },
                "analysis_depth": analysis_depth
            }
            
            return json.dumps(result)

        except Exception as e:
            logger.error(f"Error in PandasAITool: {str(e)}")
            return json.dumps({
                "error": "Analysis failed",
                "message": str(e)
            })

================
File: apps/agents/tools/pdf_extractor_tool/pdf_extractor_tool.py
================
import hashlib
import logging
from datetime import datetime
from typing import Dict, Any, Type
from urllib.parse import urlparse

import requests
from django.core.cache import cache
from django.conf import settings
from langchain.document_loaders import PyMuPDFLoader
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import tempfile
logger = logging.getLogger(__name__)

class PDFExtractorSchema(BaseModel):
    """Input schema for PDFExtractorTool."""
    
    model_config = {
        "use_enum_values": True,
        "extra": "forbid",
        "json_schema_extra": {
            "examples": [{"url": "https://example.com/sample.pdf", "use_cache": True}]
        }
    }
    
    url: str = Field(
        ..., 
        description="The URL of the PDF to extract content from",
        examples=["https://example.com/sample.pdf"]
    )
    use_cache: bool = Field(
        default=True,
        description="Whether to use cached results if available"
    )

class PDFExtractorTool(BaseTool):
    name: str = "PDF Extractor Tool"
    description: str = "Extracts and processes text content from PDF files using PyMuPDF"
    args_schema: Type[BaseModel] = PDFExtractorSchema
    cache_timeout: int = getattr(settings, 'PDF_CACHE_TIMEOUT', 60 * 60 * 24 * 7)
    
    def __init__(self, **data):
        super().__init__(**data)

    def _run(self, **kwargs: Any) -> Dict:
        """Execute the PDF extraction pipeline."""
        try:
            params = self.args_schema(**kwargs)
            
            if params.use_cache:
                cache_key = f"pdf_extract:{hashlib.md5(params.url.encode()).hexdigest()}"
                cached_result = cache.get(cache_key)
                if cached_result:
                    logger.debug(f"Cache hit for PDF: {params.url}")
                    return {
                        'success': True,
                        'pdf_data': cached_result,
                        'cached': True
                    }

            # Download PDF to temporary file
            response = requests.get(params.url)
            response.raise_for_status()
            
            with tempfile.NamedTemporaryFile(suffix='.pdf') as temp_pdf:
                temp_pdf.write(response.content)
                temp_pdf.flush()
                
                # Use PyMuPDFLoader
                loader = PyMuPDFLoader(temp_pdf.name)
                documents = loader.load()
                
                # Process the documents
                result = {
                    'content': '\n\n'.join(doc.page_content for doc in documents),
                    'num_pages': len(documents)
                }
                
                if params.use_cache:
                    cache.set(cache_key, result, timeout=self.cache_timeout)
                
                return {
                    'success': True,
                    'pdf_data': result,
                    'cached': False
                }

        except Exception as e:
            logger.error(f"PDF Extractor tool error: {str(e)}", exc_info=True)
            return {
                'success': False,
                'error': str(e),
                'pdf_data': {}
            }

================
File: apps/agents/tools/rag/rag_tool.py
================
from abc import ABC, abstractmethod
from typing import Any

from pydantic import BaseModel, Field, model_validator

from apps.agents.tools.base_tool import BaseTool


class Adapter(BaseModel, ABC):
    model_config = {
        "arbitrary_types_allowed": True,
        "extra": "forbid"
    }

    @abstractmethod
    def query(self, question: str) -> str:
        """Query the knowledge base with a question and return the answer."""

    @abstractmethod
    def add(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        """Add content to the knowledge base."""


class RagTool(BaseTool):
    class _AdapterPlaceholder(Adapter):
        def query(self, question: str) -> str:
            raise NotImplementedError

        def add(self, *args: Any, **kwargs: Any) -> None:
            raise NotImplementedError

    name: str = "Knowledge base"
    description: str = "A knowledge base that can be used to answer questions."
    summarize: bool = False
    adapter: Adapter = Field(default_factory=_AdapterPlaceholder)
    config: dict[str, Any] | None = None

    @model_validator(mode="after")
    def _set_default_adapter(self):
        if isinstance(self.adapter, RagTool._AdapterPlaceholder):
            from embedchain import App

            from crewai_tools.adapters.embedchain_adapter import EmbedchainAdapter

            app = App.from_config(config=self.config) if self.config else App()
            self.adapter = EmbedchainAdapter(
                embedchain_app=app, summarize=self.summarize
            )

        return self

    def add(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> None:
        self.adapter.add(*args, **kwargs)

    def _run(
        self,
        query: str,
        **kwargs: Any,
    ) -> Any:
        self._before_run(query, **kwargs)

        return f"Relevant Content:\n{self.adapter.query(query)}"

    def _before_run(self, query, **kwargs):
        pass

================
File: apps/agents/tools/scrapper_tool/__init__.py
================
from .scrapper_tool import ScrapperTool, ScrapperToolSchema, OutputType

# Export only the classes, not aliases
__all__ = ['ScrapperTool', 'ScrapperToolSchema', 'OutputType']

================
File: apps/agents/tools/scrapper_tool/scrapper_tool.py
================
import logging
import json
from typing import Type, Optional, Dict, Any, List, Literal, Union, ClassVar
from enum import Enum
from pydantic import BaseModel, Field, field_validator
from apps.agents.tools.base_tool import BaseTool
from django.conf import settings
from urllib.parse import urlparse

from apps.agents.utils.scrape_url import scrape_url

logger = logging.getLogger(__name__)

# Define output formats
class OutputType(str, Enum):
    HTML = "html"  # Raw HTML from full_content
    CLEANED_HTML = "cleaned_html"  # Cleaned HTML from content
    METADATA = "metadata"  # Metadata only
    TEXT = "text"  # Text content only
    LINKS = "links"  # Links only
    FULL = "full"  # All formats combined

class ScrapperToolSchema(BaseModel):
    """Input schema for ScrapperTool."""
    url: str = Field(..., description="URL to scrape")
    output_type: str = Field(
        default="text",
        description="Type(s) of output content. Can be a single value (like 'text') or a comma-separated list with or without quotes (like 'metadata,links' or 'metadata','links')"
    )
    cache: bool = Field(
        default=True,
        description="Whether to use cached results if available"
    )
    stealth: bool = Field(
        default=True,
        description="Whether to use stealth mode"
    )
    timeout: int = Field(
        default=60000,
        description="Timeout in milliseconds"
    )
    device: str = Field(
        default="desktop",
        description="Device type to emulate (desktop, mobile, tablet, or specific device name)"
    )
    wait_until: str = Field(
        default="domcontentloaded",
        description="When to consider navigation successful (domcontentloaded, load, networkidle0, networkidle2)"
    )
    css_selector: Optional[str] = Field(
        default=None,
        description="CSS selector for targeted content extraction (not yet implemented)"
    )

    @field_validator('url')
    def validate_url(cls, v):
        """Validate URL format."""
        if not v.startswith(('http://', 'https://')):
            raise ValueError("URL must start with http:// or https://")
        return v

    @field_validator('device')
    def normalize_device(cls, v):
        """Standardize device naming."""
        device_mapping = {
            'desktop': 'Desktop Chrome',
            'mobile': 'iPhone 12',
            'tablet': 'iPad Pro'
        }
        return device_mapping.get(v.lower(), v)

    @field_validator('output_type')
    def normalize_output_types(cls, v):
        """Handle any format of output type specification."""
        try:
            # Convert any input to a string first for consistency
            input_str = str(v)

            # Remove all quotes (both single and double)
            cleaned = input_str.replace('"', '').replace("'", '')

            # Split by comma and clean up
            if ',' in cleaned:
                # Multiple types specified
                types = [t.strip().lower() for t in cleaned.split(',')]
                valid_types = []
                for t in types:
                    if t:  # Skip empty strings
                        try:
                            valid_types.append(OutputType(t))
                        except ValueError:
                            logger.warning(f"Invalid output type: {t}")

                if valid_types:
                    return valid_types
            else:
                # Single type
                try:
                    single_type = OutputType(cleaned.lower())
                    return single_type
                except ValueError:
                    logger.warning(f"Invalid output type: {cleaned}")

            # Default to TEXT if parsing failed
            logger.warning(f"Using default TEXT output type")
            return OutputType.TEXT

        except Exception as e:
            logger.error(f"Error normalizing output_type {repr(v)}: {str(e)}")
            # Default to TEXT if there's an error
            logger.warning(f"Defaulting to TEXT output_type due to validation error")
            return OutputType.TEXT

    model_config = {
        "use_enum_values": True,
        "arbitrary_types_allowed": True
    }

class ScrapperTool(BaseTool):
    """
    A tool that scrapes websites and extracts content in various formats.
    Supports multiple output types that can be combined by providing a comma-separated list:
    - html: Raw HTML content
    - cleaned_html: Cleaned HTML content
    - metadata: Page metadata (title, description, etc.)
    - text: Plain text content
    - links: Links found on the page
    - full: All of the above combined
    """
    name: str = "Web Scraper Tool"
    description: str = """
    A tool that scrapes websites and extracts content in various formats.
    Supports multiple output types that can be combined by providing a comma-separated list:
    - html: Raw HTML content
    - cleaned_html: Cleaned HTML content
    - metadata: Page metadata (title, description, etc.)
    - text: Plain text content
    - links: Links found on the page
    - full: All of the above combined

    Example combinations:
    - "metadata,links" - Get both metadata and links in one response
    - "text,metadata" - Get both text content and metadata
    - "links,html" - Get both links and raw HTML

    Use this tool to extract information from websites with flexible output format options.
    """
    args_schema: Type[BaseModel] = ScrapperToolSchema

    # Device presets for common types
    DEVICE_PRESETS: ClassVar[Dict[str, str]] = {
        'desktop': 'Desktop Chrome',
        'mobile': 'iPhone 12',
        'tablet': 'iPad Pro'
    }

    def _run(self, url: str, output_type: str = "text",
            cache: bool = True, stealth: bool = True, timeout: int = 60000,
            device: str = "desktop", wait_until: str = "domcontentloaded",
            css_selector: Optional[str] = None, **kwargs) -> str:
        """
        Run the website scraping tool.

        Args:
            url: URL to scrape
            output_type: Type(s) of output. Can be a single value or a comma-separated list of types
                         (html, cleaned_html, metadata, text, links, or full)
            cache: Whether to use cached results
            stealth: Whether to use stealth mode
            timeout: Timeout in milliseconds
            device: Device to emulate
            wait_until: When to consider navigation successful
            css_selector: CSS selector for targeted content (not yet implemented)

        Returns:
            JSON string with the scraped content in the requested format(s)
        """
        # Convert wait_until to wait_for (milliseconds) if needed
        wait_for = None
        if wait_until and wait_until != "domcontentloaded":
            # Use a default wait time of 2000ms for non-default wait_until values
            wait_for = 2000
        try:
            # Normalize device name
            device = self.DEVICE_PRESETS.get(device.lower(), device)

            # Process output types - our validator should have already converted this to
            # either a single OutputType enum or a list of OutputType enums
            if isinstance(output_type, list):
                output_types = output_type
            else:
                output_types = [output_type]

            # Log the processed output types
            logger.info(f"Scraping URL: {url} with output_types: {output_types}")

            # Check if FULL is included - it already contains everything
            if OutputType.FULL in output_types:
                # If FULL is requested, we can ignore other types as it contains everything
                output_types = [OutputType.FULL]

            # Get domain for logging
            domain = urlparse(url).netloc

            # Initialize result container
            result = {
                "success": True,
                "url": url,
                "domain": domain
            }

            # Get content data (needed for all output types)
            content_data = None

            # Fetch content using the scraper service
            content_data = scrape_url(
                url=url,
                output_type=output_type,  # Pass the original output_type string
                cache=cache,
                stealth=stealth,
                device=device,
                timeout=timeout,
                wait_for=wait_for,
                css_selector=css_selector
            )

            if not content_data:
                return json.dumps({
                    "success": False,
                    "error": "Failed to retrieve content",
                    "url": url
                })

            # Extract links from content data if needed
            links_data = content_data.get("links", [])

            # Process each requested output type
            for output_type_enum in output_types:
                if output_type_enum == OutputType.HTML and content_data:
                    result["html"] = content_data.get("fullContent", content_data.get("content", ""))

                elif output_type_enum == OutputType.CLEANED_HTML and content_data:
                    result["cleaned_html"] = content_data.get("content", "")

                elif output_type_enum == OutputType.TEXT and content_data:
                    text_content = content_data.get("textContent", "")
                    if not text_content:
                        # Try extracting text from HTML as fallback
                        from bs4 import BeautifulSoup
                        html_content = content_data.get("content", "")
                        if html_content:
                            soup = BeautifulSoup(html_content, 'html.parser')
                            text_content = soup.get_text(separator='\n', strip=True)
                    result["text"] = text_content

                elif output_type_enum == OutputType.METADATA and content_data:
                    result["title"] = content_data.get("title", "")
                    result["excerpt"] = content_data.get("excerpt", "")
                    result["length"] = content_data.get("length", 0)
                    result["meta"] = content_data.get("meta", {})

                elif output_type_enum == OutputType.LINKS and links_data:
                    result["links"] = links_data
                    result["links_count"] = len(links_data)

                elif output_type_enum == OutputType.FULL:
                    # FULL output combines all types
                    if content_data:
                        result["html"] = content_data.get("fullContent", content_data.get("content", ""))
                        result["cleaned_html"] = content_data.get("content", "")
                        result["text"] = content_data.get("textContent", "")
                        result["title"] = content_data.get("title", "")
                        result["excerpt"] = content_data.get("excerpt", "")
                        result["length"] = content_data.get("length", 0)
                        result["meta"] = content_data.get("meta", {})

                    if links_data:
                        result["links"] = links_data
                        result["links_count"] = len(links_data)

            return json.dumps(result, indent=2)

        except Exception as e:
            logger.error(f"Error in ScrapperTool: {str(e)}", exc_info=True)
            error_response = {
                "success": False,
                "error": str(e),
                "url": url
            }
            return json.dumps(error_response, indent=2)

    # These methods are kept for backward compatibility with any code still
    # calling them directly, but they're no longer used by the _run method
    def _format_html_output(self, data: Dict[str, Any]) -> str:
        """Format HTML output."""
        if data.get("fullContent"):
            # If full content was requested and available
            html_content = data["fullContent"]
        else:
            # Otherwise return the default content
            html_content = data.get("content", "")

        result = {
            "success": True,
            "url": data.get("url", ""),
            "html": html_content
        }
        return json.dumps(result, indent=2)

    def _format_cleaned_html_output(self, data: Dict[str, Any]) -> str:
        """Format cleaned HTML output."""
        cleaned_html = data.get("content", "")
        result = {
            "success": True,
            "url": data.get("url", ""),
            "cleaned_html": cleaned_html
        }
        return json.dumps(result, indent=2)

    def _format_text_output(self, data: Dict[str, Any]) -> str:
        """Format text output."""
        text_content = data.get("textContent", "")
        if not text_content:
            # Try extracting text from HTML as fallback
            from bs4 import BeautifulSoup
            html_content = data.get("content", "")
            if html_content:
                soup = BeautifulSoup(html_content, 'html.parser')
                text_content = soup.get_text(separator='\n', strip=True)

        result = {
            "success": True,
            "url": data.get("url", ""),
            "text": text_content
        }
        return json.dumps(result, indent=2)

    def _format_metadata_output(self, data: Dict[str, Any]) -> str:
        """Format metadata output."""
        metadata = {
            "url": data.get("url", ""),
            "title": data.get("title", ""),
            "domain": data.get("domain", ""),
            "excerpt": data.get("excerpt", ""),
            "length": data.get("length", 0),
            "meta": data.get("meta", {})
        }
        return json.dumps(metadata, indent=2)

    def _format_links_output(self, data: Dict[str, Any]) -> str:
        """Format links output."""
        result = {
            "url": data.get("url", ""),
            "domain": data.get("domain", ""),
            "title": data.get("title", ""),
            "links_count": len(data.get("links", [])),
            "links": data.get("links", [])
        }
        return json.dumps(result, indent=2)

    def _format_full_output(self, content_data: Dict[str, Any], links_data: Optional[Dict[str, Any]]) -> str:
        """Format full output with all content types."""
        # Start with basic info
        result = {
            "url": content_data.get("url", ""),
            "domain": content_data.get("domain", ""),
            "title": content_data.get("title", ""),
            "excerpt": content_data.get("excerpt", ""),
            "html": content_data.get("fullContent", content_data.get("content", "")),
            "cleaned_html": content_data.get("content", ""),
            "text": content_data.get("textContent", ""),
            "meta": content_data.get("meta", {}),
        }

        # Add links if available
        if links_data:
            result["links"] = links_data.get("links", [])
            result["links_count"] = len(links_data.get("links", []))

        return json.dumps(result, indent=2)

================
File: apps/agents/tools/screenshot_tool/screenshot_tool.py
================
import os
import logging
import base64
from typing import Any, Type, Dict
from pydantic import BaseModel, Field, ConfigDict
from apps.agents.tools.base_tool import BaseTool
from django.conf import settings
from core.storage import SecureFileStorage
from django.core.files.base import ContentFile
from urllib.parse import urlparse
import re

from apps.agents.utils.scraper_adapters.playwright_adapter import PlaywrightAdapter

"""
Screenshot tool for capturing website screenshots using Playwright.

You can use the ScreenshotTool by
 1. importing 'from apps.agents.tools.screenshot_tool import screenshot_tool'' and
 2. calling its run method with a URL as the argument: 'result = screenshot_tool.run(url=url)'
"""

logger = logging.getLogger(__name__)

# Instantiate SecureFileStorage for screenshots
screenshot_storage = SecureFileStorage(private=True, collection='crawled_screenshots')

class ScreenshotToolSchema(BaseModel):
    """Input schema for ScreenshotTool."""
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )

    url: str = Field(description="The URL of the website to capture a screenshot.")
    mobile: bool = Field(default=False, description="Whether to use mobile emulation.")
    full_page: bool = Field(default=True, description="Whether to capture the full page or just the viewport.")
    timeout: int = Field(default=60000, description="Timeout in milliseconds.")
    stealth: bool = Field(default=True, description="Whether to use stealth mode.")

class ScreenshotTool(BaseTool):
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )

    name: str = "Capture Website Screenshot"
    description: str = "Captures a screenshot of a given website URL."
    args_schema: Type[BaseModel] = ScreenshotToolSchema

    def _run(
        self,
        url: str,
        mobile: bool = False,
        full_page: bool = True,
        timeout: int = 60000,
        stealth: bool = True,
        **kwargs: Any
    ) -> Dict[str, Any]:
        """
        Run the screenshot tool and save to cloud storage.

        Args:
            url: The URL to screenshot
            mobile: Whether to use mobile emulation
            full_page: Whether to capture the full page or just the viewport
            timeout: Timeout in milliseconds
            stealth: Whether to use stealth mode
            **kwargs: Additional arguments

        Returns:
            dict: Contains either the screenshot URL or an error message
        """
        try:
            # Check if screenshot already exists
            existing_url = self._check_screenshot_exists(url)
            if existing_url:
                logger.info(f"Using existing screenshot for URL: {url}")
                return {'screenshot_url': existing_url}

            # Initialize the Playwright adapter
            adapter = PlaywrightAdapter()

            # Setup additional parameters
            additional_params = {
                'fullPage': full_page
            }

            # Request screenshot from Playwright
            result = adapter.scrape(
                url=url,
                formats=['screenshot'],
                timeout=timeout,
                mobile=mobile,
                stealth=stealth,
                **additional_params
            )

            # Check for errors
            if 'error' in result:
                error_msg = f"Failed to get screenshot: {result['error']}"
                logger.error(error_msg)
                return {'error': error_msg}

            # Check if screenshot was returned
            if 'screenshot' not in result:
                error_msg = "No screenshot data in response"
                logger.error(error_msg)
                return {'error': error_msg}

            # Get screenshot data
            screenshot_data = result['screenshot']

            if not screenshot_data:
                error_msg = "No screenshot data in response"
                logger.error(error_msg)
                return {'error': error_msg}

            # Generate a sanitized filename based on the URL
            parsed_url = urlparse(url)
            sanitized_name = re.sub(r'[^\w\-_\. ]', '_', parsed_url.netloc + parsed_url.path)
            filename = f"{sanitized_name[:200]}.png"  # Limit filename length

            # Create the relative path for cloud storage
            relative_path = os.path.join('crawled_screenshots', filename)

            try:
                # Convert base64 screenshot data to bytes and save
                import base64
                screenshot_bytes = base64.b64decode(screenshot_data.split(',')[1] if ',' in screenshot_data else screenshot_data)

                # Save the image using SecureFileStorage
                saved_path = screenshot_storage._save(relative_path, ContentFile(screenshot_bytes))

                # Generate the URL for the saved image using SecureFileStorage
                image_url = screenshot_storage.url(saved_path)

                logger.info(f"Screenshot saved successfully: {saved_path}")
                return {'screenshot_url': image_url}

            except Exception as e:
                error_msg = f"Error saving screenshot: {str(e)}"
                logger.error(error_msg)
                return {'error': error_msg}

        except Exception as e:
            error_msg = f"Error in screenshot tool: {str(e)}"
            logger.error(error_msg)
            return {'error': error_msg}

    def _check_screenshot_exists(self, url: str) -> str:
        """
        Check if a screenshot already exists for the given URL.

        Args:
            url: The URL to check

        Returns:
            str: The existing screenshot URL if found, None otherwise
        """
        try:
            parsed_url = urlparse(url)
            sanitized_name = re.sub(r'[^\w\-_\. ]', '_', parsed_url.netloc + parsed_url.path)
            filename = f"{sanitized_name[:200]}.png"
            # Use the collection defined in screenshot_storage instance implicitly
            # relative_path = os.path.join('crawled_screenshots', filename)
            # Construct path without the collection prefix, SecureFileStorage adds it
            relative_path_in_collection = filename

            # Check existence using SecureFileStorage
            if screenshot_storage.exists(relative_path_in_collection):
                # Get URL using SecureFileStorage
                return screenshot_storage.url(relative_path_in_collection)
            return None

        except Exception as e:
            logger.error(f"Error checking screenshot existence: {str(e)}")
            return None

# Initialize the tool
screenshot_tool = ScreenshotTool()

================
File: apps/agents/tools/search_context_tool/search_context_tool.py
================
import os
from typing import Any, Type, List, Dict
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.tools.searxng_tool.searxng_tool import SearxNGSearchTool
from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from apps.common.utils import get_llm as utils_get_llm
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
import json
import logging
from django.conf import settings

logger = logging.getLogger(__name__)

class SearchContextToolSchema(BaseModel):
    """Input schema for SearchContextTool."""
    question: str = Field(
        ..., 
        description="The user's question to research and answer.",
        examples=["What is the capital of France?"]
    )
    user_id: int = Field(..., description="ID of the user initiating the search")

    @classmethod
    def get_schema(cls) -> Dict:
        """Return a simplified schema for agent consumption"""
        return {
            "question": {
                "type": "string",
                "description": "The user's question to research and answer."
            },
            "user_id": {
                "type": "integer",
                "description": "ID of the user initiating the search"
            }
        }
    
    model_config = {
        "arbitrary_types_allowed": True,
        "extra": "forbid"
    }

class SearchContextTool(BaseTool):
    name: str = "Search and provide contextual answer"
    description: str = "Searches the internet, gathers context from multiple sources, and provides a detailed answer with follow-up questions."
    args_schema: Type[BaseModel] = SearchContextToolSchema
    
    # Define the tools as fields
    search_tool: SearxNGSearchTool = Field(default_factory=SearxNGSearchTool)
    crawl_tool: CrawlWebsiteTool = Field(default_factory=CrawlWebsiteTool)
    model_name: str = Field(default=settings.GENERAL_MODEL)
    llm: Any = None
    token_counter_callback: Any = None

    def __init__(self, **data):
        super().__init__(**data)
        self.llm, self.token_counter_callback = utils_get_llm(self.model_name, temperature=0.7)

    def _reformulate_question(self, original_question: str) -> str:
        "Reformulate the user's question into an optimized search query."
        
        reformulation_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert at reformulating questions into optimal search queries. 
            Your task is to analyze the user's question and create a more effective search query that will yield the most relevant results.
            
            Follow these guidelines:
            1. Identify Core Concepts:
                - Extract the main topics and key concepts
                - Identify any implicit assumptions or context
            
            2. Add Critical Context:
                - Include relevant technical terms
                - Add synonyms for important concepts
                - Specify time period if relevant (e.g., "2024", "recent", "latest")
            
            3. Optimize for Search:
                - Use boolean operators when helpful (AND, OR)
                - Include specific phrases in quotes for exact matches
                - Remove unnecessary words (articles, prepositions)
                - Add clarifying terms to disambiguate
            
            4. Enhance Specificity:
                - Add domain-specific terminology
                - Include relevant qualifiers
                - Specify desired information type (research, news, analysis, etc.)
            
            Return only the reformulated search query, without explanation or additional text."""),
            ("human", """Original question: {question}
            
            Create an optimized search query that will find the most relevant and comprehensive information to answer this question.""")
        ])

        reformulation_chain = reformulation_prompt | self.llm | StrOutputParser()

        try:
            optimized_query = reformulation_chain.invoke({
                'question': original_question
            })
            logger.info(f"Reformulated question: {optimized_query}")
            return optimized_query
        except Exception as e:
            logger.error(f"Error reformulating question: {str(e)}")
            return original_question

    def _extract_urls(self, search_results: str) -> List[str]:
        """Extract URLs from search results."""
        urls = []
        for line in search_results.split('\n'):
            if line.startswith('Link: '):
                urls.append(line.replace('Link: ', '').strip())
        return urls[:7]  # Get top 7 results

    def _gather_context(self, urls: List[str], user_id: int) -> str:
        """Gather context from URLs using CrawlWebsiteTool."""
        contexts = []
        for url in urls:
            try:
                # Use CrawlWebsiteTool with markdown output
                result = self.crawl_tool._run(
                    website_url=url,
                    user_id=user_id,
                    max_pages=1,  # Only get the main page
                    max_depth=0,  # No recursive crawling
                    output_type="markdown"
                )
                
                # Parse the result
                result_data = json.loads(result)
                if result_data.get("status") == "success" and result_data.get("results"):
                    content = result_data["results"][0].get("content", "")
                    if content and len(content) > 100:  # Basic validation
                        contexts.append(f"Source ({url}):\n{content}")
                        
            except Exception as e:
                logger.error(f"Error crawling {url}: {str(e)}")
                
        return "\n\n".join(contexts)

    def _generate_answer(self, question: str, context: str) -> str:
        """Generate answer using LLM."""
        answer_prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a helpful AI assistant. Using the provided context, 
            answer the user's question thoroughly and accurately. Cite sources when possible.
            Format your response in markdown."""),
            ("human", """
            Question: {question}
            
            Context: {context}
            
            Please provide a detailed answer based on the context provided.
            """)
        ])
        
        answer_chain = answer_prompt | self.llm | StrOutputParser()
        return answer_chain.invoke({
            'question': question,
            'context': context
        })

    def _generate_follow_up_questions(self, question: str, answer: str) -> List[str]:
        """Generate follow-up questions based on the answer."""
        followup_prompt = ChatPromptTemplate.from_messages([
            ("system", """Based on the original question and answer provided, 
            generate exactly 3 relevant follow-up questions that would help explore 
            the topic further. Format as a markdown list."""),
            ("human", """
            Original Question: {question}
            Answer: {answer}
            
            Generate 3 follow-up questions:
            """)
        ])
        
        followup_chain = followup_prompt | self.llm | StrOutputParser()
        return followup_chain.invoke({
            'question': question,
            'answer': answer
        })

    def _run(
        self,
        question: str,
        user_id: int,
        **kwargs: Any
        ) -> Any:
        """Execute the search context tool pipeline."""
        try:
            # 0. Reformulate the question for better search results
            optimized_query = self._reformulate_question(question)
            logger.info(f"Original question: {question}")
            logger.info(f"Optimized query: {optimized_query}")
            
            # 1. Search for relevant results using optimized query
            search_results = self.search_tool._run(search_query=optimized_query)
            
            # 2. Extract URLs and gather context
            urls = self._extract_urls(search_results)
            context = self._gather_context(urls, user_id)
            
            # 3. Generate answer (using original question for better context)
            answer = self._generate_answer(question, context)
            
            # 4. Generate follow-up questions
            follow_up = self._generate_follow_up_questions(question, answer)
            
            # 5. Format and return results
            result = {
                "original_question": question,
                "optimized_query": optimized_query,
                "answer": answer,
                "follow_up_questions": follow_up,
                "sources": urls
            }
            
            return json.dumps(result, indent=2)

        except Exception as e:
            logger.error(f"Error in SearchContextTool: {str(e)}")
            return f"An error occurred while processing your request: {str(e)}"

================
File: apps/agents/tools/search_context_tool/test_search_context_tool.py
================
import logging
import sys
import os

# Add the project root to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..', '..'))
sys.path.insert(0, project_root)

# Set up Django settings
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')  # Adjust this to your project's settings module
import django
django.setup()

from apps.agents.tools.search_context_tool.search_context_tool import SearchContextTool

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def test_search_context():
  # Initialize the tool
  search_tool = SearchContextTool()

  # Test question
  test_question = "as of october 29, 2024 what are the latest flooring trends in ottumwa that consumers are looking for and elaborate on the reasons why?"
  
  logger.info(f"Starting search context analysis for question: {test_question}")
  print(f"Starting search context analysis for question: {test_question}")
  
  try:
      # Get results
      result = search_tool._run(test_question)
      
      # Log and print the results
      logger.info("Search Context Results:")
      logger.info(result)
      print("\nSearch Context Results:")
      print(result)
      
  except Exception as e:
      logger.error(f"Error during search context analysis: {str(e)}")
      print(f"Error: {str(e)}")

if __name__ == "__main__":
  test_search_context()

================
File: apps/agents/tools/searxng_tool/__init__.py
================
from .searxng_tool import SearxNGSearchTool

__all__ = ['SearxNGSearchTool']

================
File: apps/agents/tools/searxng_tool/searxng_tool.py
================
import os
import requests
import json
from typing import Any, Type, Optional, List, Dict
from pydantic import BaseModel, Field, ConfigDict
from apps.agents.tools.base_tool import BaseTool
from apps.common.utils import get_llm
from langchain.prompts.chat import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from django.conf import settings
import logging

logger = logging.getLogger(__name__)

class SearchResult(BaseModel):
    """Model for validating search result relevance responses."""
    is_relevant: bool = Field(..., description="Whether the result is relevant to the search query")
    reason: str = Field(..., description="Reason why the result is or is not relevant")

class RelevanceResponse(BaseModel):
    """Model for validating the full LLM response for relevance filtering."""
    results: List[SearchResult] = Field(..., description="List of search results with relevance determinations")

class SearxNGToolSchema(BaseModel):
    """Input schema for SearxNGSearchTool."""
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    search_query: str = Field(description="The search query to be used.")
    relevant_results_only: bool = Field(
        default=False, 
        description="If True, will filter results to only those directly relevant to the search query using LLM."
    )

class SearxNGSearchTool(BaseTool):
    """
    A tool that searches the internet displaying titles, links, snippets, engines, and categories.
    """
    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )
    
    name: str = "Search the internet"
    description: str = "Searches the internet displaying titles, links, snippets, engines, and categories."
    args_schema: Type[BaseModel] = SearxNGToolSchema
    search_url: str = "https://search.neuralami.com"
    n_results: Optional[int] = None
    llm: Any = None
    token_counter_callback: Any = None

    def __init__(self, **data):
        super().__init__(**data)
        # Initialize LLM for relevance filtering
        model_name = data.get('llm_model', settings.SUMMARIZER)  # Use summarizer model which is optimized for content evaluation
        self.llm, self.token_counter_callback = get_llm(model_name, temperature=0.1)  # Low temperature for consistent evaluations

    def _filter_relevant_results(self, search_query: str, results: List[Dict]) -> List[Dict]:
        """Filter search results to keep only those relevant to the query."""
        if not results:
            return []
        
        # Extract snippets and other info for LLM evaluation
        snippets_with_metadata = []
        for i, result in enumerate(results):
            snippet = {
                'id': i,
                'title': result.get('title', 'No Title'),
                'snippet': result.get('content', 'No Snippet'),
                'url': result.get('url', 'No URL')
            }
            snippets_with_metadata.append(snippet)
        
        # Create prompt for LLM to evaluate relevance
        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert at evaluating search result relevance.
            For each search result, determine if it is directly relevant to the search query.
            
            A result is relevant if:
            1. It directly addresses the specific topic or question in the search query
            2. It provides useful information related to the core intent of the query
            3. It comes from a credible source for the topic
            
            A result is NOT relevant if:
            1. It's only tangentially related to the query
            2. It focuses primarily on a different topic
            3. It appears to be spam, misleading, or low-quality content
            
            Provide your evaluation as a JSON array where each item has:
            - "is_relevant": boolean (true/false)
            - "reason": brief explanation of your decision
            
            Your response must be VALID JSON with this structure:
            {{
              "results": [
                {{"is_relevant": true, "reason": "explanation"}},
                {{"is_relevant": false, "reason": "explanation"}}
              ]
            }}
            """),
            ("human", """Search Query: {search_query}
            
            Search Results:
            {results}
            
            Evaluate each result's relevance to the search query.
            Return ONLY a JSON object with the structure specified.
            Do not include any other text, explanation, or markdown formatting.""")
        ])
        
        chain = prompt | self.llm | StrOutputParser()
        
        max_retries = 3
        retries = 0
        
        while retries < max_retries:
            try:
                # Format results for the prompt
                formatted_results = json.dumps(snippets_with_metadata, indent=2)
                
                # Get LLM evaluation
                logger.info(f"Evaluating relevance of {len(results)} search results for query: {search_query}")
                llm_response = chain.invoke({
                    'search_query': search_query,
                    'results': formatted_results
                })
                
                # Clean and parse response
                llm_response = llm_response.strip()
                if llm_response.startswith("```json"):
                    llm_response = llm_response.replace("```json", "", 1)
                if llm_response.endswith("```"):
                    llm_response = llm_response.rstrip("```")
                llm_response = llm_response.strip()
                
                logger.debug(f"LLM relevance response (first 200 chars): {llm_response[:200]}...")
                
                try:
                    # Parse and validate with Pydantic
                    parsed_response = json.loads(llm_response)
                    
                    # Check for expected structure before validation
                    if not isinstance(parsed_response, dict) or "results" not in parsed_response:
                        logger.warning("LLM response missing 'results' key or not a dict. Response: " + llm_response[:500])
                        raise ValueError("Response missing 'results' key")
                    
                    relevance_data = RelevanceResponse(**parsed_response)
                    
                    # Instead of retrying when we don't have evaluations for all results,
                    # just work with what we have and log which items weren't evaluated
                    if len(relevance_data.results) != len(results):
                        logger.info(f"LLM returned {len(relevance_data.results)} evaluations for {len(results)} results. Working with partial results.")
                        unevaluated_indices = set(range(len(results))) - set(i for i in range(min(len(relevance_data.results), len(results))))
                        if unevaluated_indices:
                            logger.debug(f"Results at indices {unevaluated_indices} were not evaluated by the LLM.")
                    
                    # Filter results based on relevance - only include explicitly relevant results
                    relevant_results = []
                    excluded_results = []
                    
                    for i, result in enumerate(results):
                        # Only include result if it was evaluated and marked as relevant
                        if i < len(relevance_data.results) and relevance_data.results[i].is_relevant:
                            relevant_results.append(result)
                        else:
                            excluded_results.append(result)
                    
                    # Log excluded URLs
                    if excluded_results:
                        excluded_urls = [r.get('url', 'No URL') for r in excluded_results]
                        excluded_reasons = []
                        
                        for i, result in enumerate(results):
                            if i < len(relevance_data.results) and not relevance_data.results[i].is_relevant:
                                url = result.get('url', 'No URL')
                                reason = relevance_data.results[i].reason
                                excluded_reasons.append(f"{url}: {reason}")
                            elif i >= len(relevance_data.results):
                                url = result.get('url', 'No URL')
                                excluded_reasons.append(f"{url}: Not evaluated by LLM (treated as not relevant)")
                        
                        logger.debug(f"Excluded {len(excluded_urls)} URLs:")
                        for reason in excluded_reasons:
                            logger.debug(f"- {reason}")
                    
                    # Ensure we have at least some results (if not, we'll keep the top 3)
                    if len(relevant_results) == 0 and len(results) > 0:
                        logger.warning("No relevant results found. Keeping top 3 results to ensure some data is returned.")
                        relevant_results = results[:min(3, len(results))]
                    
                    logger.info(f"Filtered from {len(results)} to {len(relevant_results)} relevant results")
                    return relevant_results
                    
                except json.JSONDecodeError as e:
                    logger.error(f"JSON parsing error: {str(e)}")
                    logger.error(f"Raw response: {llm_response[:500]}")
                    retries += 1
                    continue
                    
                except Exception as e:
                    logger.error(f"Error validating results: {str(e)}")
                    retries += 1
                    continue
                
            except Exception as e:
                logger.error(f"Error filtering results (attempt {retries+1}/{max_retries}): {str(e)}")
                retries += 1
        
        # If all retries fail, return original results
        logger.warning(f"Failed to filter results after {max_retries} attempts. Returning all results.")
        return results

    def _run(
        self, 
        search_query: str,
        relevant_results_only: bool = False,
        **kwargs: Any
    ) -> Any:
        payload = {        
            'q': search_query,
            'format': 'json',
            'pageno': '1',
            'language': 'en-US'
        }
        response = requests.get(self.search_url, params=payload)
        if response.ok:
            results = response.json()['results']
            
            # Initialize token usage tracking
            llm_tokens_used = {"input_tokens": 0, "output_tokens": 0}
            
            # Filter for relevant results if requested
            if relevant_results_only:
                # Reset token counters before filtering
                if hasattr(self, 'token_counter_callback') and self.token_counter_callback:
                    # Store initial values in case there's already some usage
                    initial_input_tokens = getattr(self.token_counter_callback, 'input_tokens', 0)
                    initial_output_tokens = getattr(self.token_counter_callback, 'output_tokens', 0)
                    
                    logger.debug(f"Initial token counter values - Input: {initial_input_tokens}, Output: {initial_output_tokens}")
                
                logger.info(f"Filtering for relevant results from {len(results)} search results")
                results = self._filter_relevant_results(search_query, results)
                
                # Capture token usage after filtering
                if hasattr(self, 'token_counter_callback') and self.token_counter_callback:
                    # Calculate the tokens used during this operation
                    current_input_tokens = getattr(self.token_counter_callback, 'input_tokens', 0)
                    current_output_tokens = getattr(self.token_counter_callback, 'output_tokens', 0)
                    
                    llm_tokens_used["input_tokens"] = current_input_tokens - initial_input_tokens
                    llm_tokens_used["output_tokens"] = current_output_tokens - initial_output_tokens
                    
                    logger.info(f"LLM token usage - Input: {llm_tokens_used['input_tokens']}, Output: {llm_tokens_used['output_tokens']}")
            
            formatted_results = []
            for result in results:
                try:
                    engines = ', '.join(result['engines']) if 'engines' in result else 'N/A'
                    formatted_results.append('\n'.join([
                        f"Title: {result.get('title', 'No Title')}",
                        f"Link: {result.get('url', 'No Link')}",
                        f"Score: {result.get('score', 'No Score')}",
                        f"Snippet: {result.get('content', 'No Snippet')}",
                        f"Engines: {engines}",
                        f"Category: {result.get('category', 'No Category')}",
                        "---"
                    ]))
                except KeyError as e:
                    logger.warning(f"Skipping an entry due to missing key: {e}")
                    continue

            content = '\n'.join(formatted_results)
            
            # Add token usage information to the output
            token_info = ""
            if relevant_results_only and (llm_tokens_used["input_tokens"] > 0 or llm_tokens_used["output_tokens"] > 0):
                token_info = f"\n\nRelevance filtering token usage - Input: {llm_tokens_used['input_tokens']}, Output: {llm_tokens_used['output_tokens']}, Total: {llm_tokens_used['input_tokens'] + llm_tokens_used['output_tokens']}"
            
            return f"Search results:{token_info}\n{content}"
        else:
            return f"Failed to fetch search results. Status code: {response.status_code}"

================
File: apps/agents/tools/seo_audit_tool/content_type_detector.py
================
"""Content type detection for SEO audit tool."""
from typing import Dict, Any
from urllib.parse import urlparse

def determine_content_type(page_data: Dict[str, Any]) -> str:
    """
    Determine the content type of a page based on various signals.
    
    Args:
        page_data: Dictionary containing page information including URL, schema, meta tags, etc.
        
    Returns:
        str: Detected content type (e.g., "business_homepage", "blog", "article", etc.)
    """
    url = page_data.get("url", "")
    parsed_url = urlparse(url)
    path = parsed_url.path.lower()
    
    # Check if it's homepage
    if path in ['', '/']:
        return "business_homepage"
    
    # Check URL patterns
    url_indicators = {
        "blog": ['/blog/', '/posts/', '/articles/'],
        "news": ['/news/', '/press/', '/updates/'],
        "article": ['/article/', '/story/'],
        "product": ['/product/', '/item/', '/goods/'],
        "category": ['/category/', '/collection/', '/catalog/'],
        "contact": ['/contact/', '/reach-us/', '/location/'],
        "about": ['/about/', '/about-us/', '/company/']
    }
    
    # Check URL patterns
    for content_type, patterns in url_indicators.items():
        if any(pattern in path for pattern in patterns):
            return content_type
            
    # Check page structure and content
    html_structure = {
        "has_blog_schema": bool(page_data.get("schema_type") == "BlogPosting"),
        "has_article_schema": bool(page_data.get("schema_type") == "Article"),
        "has_news_schema": bool(page_data.get("schema_type") == "NewsArticle"),
        "has_product_schema": bool(page_data.get("schema_type") == "Product"),
    }
    
    # Check for schema.org markup
    if html_structure["has_blog_schema"]:
        return "blog"
    elif html_structure["has_news_schema"]:
        return "news"
    elif html_structure["has_article_schema"]:
        return "article"
    elif html_structure["has_product_schema"]:
        return "product"
    
    # Check meta tags
    meta_type = page_data.get("meta_type", "").lower()
    if meta_type:
        if "blog" in meta_type:
            return "blog"
        elif "news" in meta_type:
            return "news"
        elif "article" in meta_type:
            return "article"
        elif "product" in meta_type:
            return "product"
    
    # Default to generic content page if no specific type is detected
    return "content"

================
File: apps/agents/tools/seo_audit_tool/seo_audit_tool.py
================
import json
import os
from typing import Dict, List, Any, Optional, Type, Set
from datetime import datetime
import logging
import asyncio
import aiohttp
import ssl
from collections import defaultdict
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
import dotenv
from django.core.cache import cache
import re

from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from apps.agents.tools.seo_crawler_tool.seo_crawler_tool import SEOCrawlerTool
from apps.common.utils import normalize_url
from apps.agents.utils import URLDeduplicator
from .seo_checkers import SEOChecker
from apps.agents.tools.pagespeed_tool.pagespeed_tool import PageSpeedTool

dotenv.load_dotenv()
logger = logging.getLogger(__name__)

class SEOAuditToolSchema(BaseModel):
    """Input for SEOAuditTool."""
    website: str = Field(
        ..., 
        title="Website", 
        description="Full URL of the website to perform SEO audit on",
        json_schema_extra={"example": "https://example.com"}
    )
    max_pages: int = Field(
        default=100,
        title="Max Pages",
        description="Maximum number of pages to audit"
    )
    check_external_links: bool = Field(
        default=False,
        title="Check External Links",
        description="Whether to check external links for broken links"
    )
    crawl_delay: float = Field(
        default=1.0,
        title="Crawl Delay",
        description="Delay between crawling pages in seconds"
    )

class SEOAuditTool(BaseTool):
    name: str = "SEO Audit Tool"
    description: str = "A tool that performs comprehensive SEO audit on a website, checking for issues like broken links, duplicate content, meta tag issues, images, and more."
    args_schema: Type[BaseModel] = SEOAuditToolSchema
    tags: Set[str] = {"seo", "audit", "website", "content"}
    api_key: str = Field(default=os.environ.get('BROWSERLESS_API_KEY'))
    crawl_tool: CrawlWebsiteTool = Field(default_factory=CrawlWebsiteTool)
    seo_crawler: SEOCrawlerTool = Field(default_factory=SEOCrawlerTool)
    url_deduplicator: URLDeduplicator = Field(default_factory=URLDeduplicator)
    checker: SEOChecker = Field(default_factory=SEOChecker)
    pagespeed_tool: PageSpeedTool = Field(default_factory=PageSpeedTool)

    model_config = {"arbitrary_types_allowed": True}
    
    def __init__(self, **data):
        super().__init__(**data)
        if not self.api_key:
            logger.error("BROWSERLESS_API_KEY is not set in the environment variables.")
        self._session = None
        self._link_cache = {}
        self._semaphore = None
        self._checked_urls = set()

    def _run(
        self,
        website: str,
        max_pages: int = 100,
        check_external_links: bool = False,
        crawl_delay: float = 1.0,
        progress_callback = None,
        **kwargs: Any,
    ) -> Dict[str, Any]:
        """Run SEO audit."""
        logger.info(f"Starting SEO audit for: {website}")
        start_time = datetime.now()
        
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            result = loop.run_until_complete(self._async_audit(
                website=website,
                max_pages=max_pages,
                check_external_links=check_external_links,
                crawl_delay=crawl_delay,
                progress_callback=progress_callback
            ))
            end_time = datetime.now()
            if 'summary' not in result:
                result['summary'] = {}
            result['summary'].update({
                'audit_start_time': start_time.isoformat(),
                'audit_end_time': end_time.isoformat(),
                'start_time': start_time.isoformat(),  # For compatibility
                'end_time': end_time.isoformat(),      # For compatibility
                'total_audit_time_seconds': (end_time - start_time).total_seconds()
            })
            logger.info(f"SEO audit completed for: {website}")
            return json.loads(json.dumps(result, default=str))
        except Exception as e:
            logger.error(f"Error running SEO audit: {str(e)}")
            raise
        finally:
            loop.close()

    async def _async_audit(
        self,
        website: str,
        max_pages: int = 100,
        check_external_links: bool = False,
        crawl_delay: float = 1.0,
        progress_callback = None
    ) -> Dict[str, Any]:
        """Run SEO audit asynchronously."""
        logger.info("Starting crawler...")
        
        if progress_callback:
            progress_callback({
                'percent_complete': 0,
                'pages_analyzed': 0,
                'issues_found': 0,
                'status': 'Starting crawler...'
            })

        total_issues = 0  # Initialize total_issues at the module level
        audit_results = {
            "broken_links": [],
            "duplicate_content": [],
            "meta_tag_issues": [],
            "image_issues": [],
            "content_issues": [],
            "ssl_issues": {},
            "sitemap_present": False,
            "robots_txt_present": False,
            "page_analysis": []
        }

        last_progress_data = {}
        all_links = set()
        base_domain = urlparse(website).netloc

        def page_callback(page_data):
            nonlocal total_issues, last_progress_data
            
            # Check meta tags
            meta_issues = self.checker.check_meta_tags(page_data)
            if meta_issues:
                audit_results["meta_tag_issues"].extend(meta_issues)
                total_issues += len(meta_issues)
            
            # Check headings
            heading_issues = self.checker.check_headings(page_data)
            if heading_issues:
                audit_results["heading_issues"] = audit_results.get("heading_issues", [])
                audit_results["heading_issues"].extend(heading_issues)
                total_issues += len(heading_issues)
            
            # Check images
            image_issues = self.checker.check_images(page_data)
            if image_issues:
                audit_results["image_issues"] = audit_results.get("image_issues", [])
                audit_results["image_issues"].extend(image_issues)
                total_issues += len(image_issues)
            
            # Check content
            content_issues = self.checker.check_content(page_data)
            if content_issues:
                audit_results["content_issues"] = audit_results.get("content_issues", [])
                audit_results["content_issues"].extend(content_issues)
                total_issues += len(content_issues)

            # Check social media tags
            social_media_issues = self.checker.check_social_media_tags(page_data)
            if social_media_issues:
                audit_results["social_media_issues"] = audit_results.get("social_media_issues", [])
                audit_results["social_media_issues"].extend(social_media_issues)
                total_issues += len(social_media_issues)

            # Check canonical tags
            canonical_issues = self.checker.check_canonical_tags(page_data)
            if canonical_issues:
                audit_results["canonical_issues"] = audit_results.get("canonical_issues", [])
                audit_results["canonical_issues"].extend(canonical_issues)
                total_issues += len(canonical_issues)

            # Add semantic structure checks
            semantic_issues = self.checker.check_semantic_structure(page_data)
            if semantic_issues:
                audit_results["semantic_issues"] = audit_results.get("semantic_issues", [])
                audit_results["semantic_issues"].extend(semantic_issues)
                total_issues += len(semantic_issues)

            # Add robots indexing checks
            robots_issues = self.checker.check_robots_indexing(page_data)
            if robots_issues:
                audit_results["robots_issues"] = audit_results.get("robots_issues", [])
                audit_results["robots_issues"].extend(robots_issues)
                total_issues += len(robots_issues)

            # Add E-E-A-T signal checks
            eeat_issues = self.checker.check_eeat_signals(page_data)
            if eeat_issues:
                audit_results["eeat_issues"] = audit_results.get("eeat_issues", [])
                audit_results["eeat_issues"].extend(eeat_issues)
                total_issues += len(eeat_issues)

            # Add redirect chain checks
            redirect_issues = self.checker.check_redirect_chains(page_data)
            if redirect_issues:
                audit_results["redirect_issues"] = audit_results.get("redirect_issues", [])
                audit_results["redirect_issues"].extend(redirect_issues)
                total_issues += len(redirect_issues)
            
            # Collect internal links
            internal_links = self.checker.check_links(page_data, base_domain)
            for link in internal_links:
                all_links.add((page_data["url"], link))
            
            # Update progress data with all issues
            all_issues = []
            for issue_type, issues in audit_results.items():
                if issue_type.endswith('_issues'):
                    for issue in issues:
                        all_issues.append({
                            'severity': issue.get('severity', 'medium'),
                            'issue_type': issue.get('type'),
                            'url': issue.get('url'),
                            'details': issue.get('issue'),
                            'value': issue.get('value'),
                            'additional_details': issue.get('details', {})
                        })
            
            if all_issues:
                last_progress_data['recent_issues'] = all_issues
                last_progress_data['status'] = f"Found {len(all_issues)} issues on {page_data['url']}"
            
            # Add page metrics
            audit_results["page_analysis"].append(
                self.checker.get_page_metrics(page_data)
            )

        # Modify crawler call to use page callback
        def wrapped_progress_callback(data):
            if progress_callback:
                update_data = {
                    'percent_complete': int(data.get('percent_complete', 0) * 0.7),  # First 70% for crawling
                    'pages_analyzed': data.get('pages_analyzed', 0),
                    'issues_found': total_issues,  # Now using the correct total_issues
                    'status': last_progress_data.get('status', f"Analyzing: {data.get('status', '')}")
                }
                if 'recent_issues' in last_progress_data:
                    update_data['recent_issues'] = last_progress_data['recent_issues']
                    last_progress_data.clear()  # Clear after sending
                progress_callback(update_data)

        # Create a wrapper for the page callback that ensures it's called for each page
        def wrapped_page_callback(page):
            page_data = {
                "url": page.url,
                "title": page.title,
                "meta_description": page.meta_description,
                "h1_tags": page.h1_tags,
                "links": page.links,
                "text_content": page.text_content,
                "crawl_timestamp": page.crawl_timestamp,
                "status_code": page.status_code,
                "canonical_url": getattr(page, 'canonical_url', None),
                "canonical_count": len(page.canonical_tags) if hasattr(page, 'canonical_tags') else 0,
                "is_pagination": bool(page.pagination_info) if hasattr(page, 'pagination_info') else False,
                "canonical_chain": page.canonical_chain if hasattr(page, 'canonical_chain') else [],
                # Add semantic structure data
                "has_semantic_markup": getattr(page, 'has_semantic_markup', False),
                "has_header": getattr(page, 'has_header', False),
                "has_nav": getattr(page, 'has_nav', False),
                "has_main": getattr(page, 'has_main', False),
                "has_footer": getattr(page, 'has_footer', False),
                "semantic_nesting_issues": getattr(page, 'semantic_nesting_issues', []),
                "empty_semantic_elements": getattr(page, 'empty_semantic_elements', []),
                "page_type": getattr(page, 'page_type', 'content'),
                # Add robots indexing data
                "noindex": getattr(page, 'noindex', False),
                "noindex_source": getattr(page, 'noindex_source', None),
                "noindex_intentional": getattr(page, 'noindex_intentional', False),
                "x_robots_tag": getattr(page, 'x_robots_tag', None),
                "robots_blocked": getattr(page, 'robots_blocked', False),
                "robots_directive": getattr(page, 'robots_directive', None),
                "robots_user_agent": getattr(page, 'robots_user_agent', '*'),
                # Add E-E-A-T data
                "has_author": getattr(page, 'has_author', False),
                "author_info": getattr(page, 'author_info', None),
                "has_expertise": getattr(page, 'has_expertise', False),
                "expertise_indicators": getattr(page, 'expertise_indicators', []),
                "has_factual_accuracy": getattr(page, 'has_factual_accuracy', False),
                "factual_accuracy_indicators": getattr(page, 'factual_accuracy_indicators', []),
                "content_type": getattr(page, 'content_type', None),
                # Add redirect chain data
                "redirect_chain": getattr(page, 'redirect_chain', []),
                "meta_refresh": getattr(page, 'meta_refresh', False),
                "meta_refresh_url": getattr(page, 'meta_refresh_url', None),
                "meta_refresh_delay": getattr(page, 'meta_refresh_delay', None)
            }
            page_callback(page_data)
            return page

        crawler_results = await asyncio.to_thread(
            self.seo_crawler._run,
            website_url=website,
            max_pages=max_pages,
            respect_robots_txt=True,
            crawl_delay=crawl_delay,
            page_callback=wrapped_page_callback,
            progress_callback=wrapped_progress_callback
        )
        pages = crawler_results.get('pages', [])
        total_pages = len(pages)
        logger.info(f"Crawler completed. Found {total_pages} pages")

        # Check broken links (70-85%)
        if progress_callback:
            progress_callback({
                'percent_complete': 70,
                'pages_analyzed': total_pages,
                'issues_found': total_issues,
                'status': 'Checking broken links...'
            })

        logger.info("Checking for broken links...")
        await self._check_broken_links(all_links, audit_results)
        total_issues += len(audit_results["broken_links"])
        logger.info(f"Found {len(audit_results['broken_links'])} broken links")

        # Check duplicate content (85-95%)
        if progress_callback:
            progress_callback({
                'percent_complete': 75,
                'pages_analyzed': total_pages,
                'issues_found': total_issues,
                'status': 'Checking for duplicate content...'
            })

        logger.info("Checking for duplicate content...")
        # Filter out 404 pages before duplicate content check
        valid_pages = [page for page in pages if not self.checker.is_404_page(page)]
        logger.info(f"Found {len(pages) - len(valid_pages)} potential 404 pages out of {len(pages)} total pages")

        # Add 404 pages as issues
        for page in pages:
            if self.checker.is_404_page(page):
                audit_results["meta_tag_issues"].append({
                    "url": page["url"],
                    "issues": [{
                        "type": "404",
                        "issue": "Page returns 404 status or appears to be a 404 page",
                        "value": None,
                        "severity": "high"
                    }]
                })
                total_issues += 1

        # Check duplicate content
        content_map = defaultdict(list)
        for page in valid_pages:
            content = page.get('text_content', '').strip()
            if content:
                content_hash = hash(content)
                content_map[content_hash].append(page['url'])
        
        for urls in content_map.values():
            if len(urls) > 1:
                audit_results["duplicate_content"].append({
                    "urls": urls,
                    "similarity": 100,
                    "timestamp": datetime.now().isoformat()
                })
                total_issues += 1

        logger.info(f"Found {len(audit_results['duplicate_content'])} duplicate content issues")

        if progress_callback:
            progress_callback({
                'percent_complete': 80,
                'pages_analyzed': total_pages,
                'issues_found': total_issues,
                'status': 'Checking SSL, robots.txt and sitemap...'
            })

        logger.info("Checking SSL...")
        await self._check_ssl(website, audit_results)
        
        logger.info("Checking robots.txt and sitemap...")
        sitemap_issues = await self._check_robots_sitemap(website, audit_results)
        total_issues += sitemap_issues

        if progress_callback:
            progress_callback({
                'percent_complete': 85,
                'pages_analyzed': total_pages,
                'issues_found': total_issues,
                'status': 'Checking PageSpeed metrics...'
            })

        logger.info("Checking PageSpeed metrics for main URL...")
        pagespeed_issues = await self.checker.check_pagespeed_metrics(
            {"url": website}, 
            self.pagespeed_tool
        )

        if pagespeed_issues:
            if "performance_issues" not in audit_results:
                audit_results["performance_issues"] = []
            audit_results["performance_issues"].extend(pagespeed_issues)
            total_issues += len(pagespeed_issues)

        logger.info(f"Found {len(pagespeed_issues)} PageSpeed issues")

        if progress_callback:
            progress_callback({
                'percent_complete': 100,
                'pages_analyzed': total_pages,
                'issues_found': total_issues,
                'status': 'Completed',
                'recent_issues': [{
                    'severity': issue.get('severity', 'high'),
                    'issue_type': issue.get('type', 'sitemap_issue'),
                    'url': issue.get('url', ''),
                    'details': issue.get('issue', ''),
                    'value': issue.get('value', '')
                } for issue in audit_results.get("sitemap", {}).get("issues", [])]
            })

        # Add PageSpeed analysis for the main URL

        # Add summary stats
        audit_results["summary"] = {
            "total_pages": total_pages,
            "total_links": len(all_links),
            "total_issues": total_issues,
            "start_time": crawler_results["start_time"],
            "end_time": crawler_results["end_time"],
            "crawl_time_seconds": crawler_results["crawl_time_seconds"],
            "duration": (datetime.fromisoformat(crawler_results["end_time"]) - 
                        datetime.fromisoformat(crawler_results["start_time"])).total_seconds()
        }

        # Flatten all issues into a single list
        all_issues = []

        # Add all issues from each category
        for issue in audit_results.get('meta_tag_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('content_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('image_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('broken_links', []):
            all_issues.append(issue)
        for issue in audit_results.get('duplicate_content', []):
            all_issues.append(issue)
        for issue in audit_results.get('canonical_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('social_media_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('sitemap', {}).get('issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('performance_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('semantic_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('robots_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('eeat_issues', []):
            all_issues.append(issue)
        for issue in audit_results.get('redirect_issues', []):
            all_issues.append(issue)

        # Add SSL issues
        ssl_results = audit_results.get('ssl_issues', {})
        if ssl_results and ssl_results.get('errors'):
            all_issues.extend(ssl_results['errors'])

        # Replace individual issue lists with a single flattened list
        audit_results['issues'] = all_issues

        logger.info("SEO audit completed successfully")

        return audit_results

    async def _check_ssl(self, website: str, audit_results: Dict[str, Any]):
        """Check SSL certificate validity and configuration."""
        # Ensure we have a proper URL
        if not website.startswith(('http://', 'https://')):
            website = f'https://{website}'
        
        parsed_url = urlparse(website)
        hostname = parsed_url.netloc
        
        ssl_results = {
            "valid_certificate": False,
            "supports_https": False,
            "errors": [],
            "certificate_info": {}
        }
        
        try:
            # Create SSL context with strict verification
            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED
            
            async with aiohttp.TCPConnector(ssl=context) as connector:
                async with aiohttp.ClientSession(connector=connector) as session:
                    try:
                        async with session.get(f"https://{hostname}", timeout=10) as response:
                            ssl_results["supports_https"] = True
                            ssl_results["valid_certificate"] = True
                            
                            # Get certificate info if available
                            if response.connection and response.connection.transport:
                                ssl_object = response.connection.transport.get_extra_info('ssl_object')
                                if ssl_object:
                                    cert = ssl_object.getpeercert()
                                    if cert:
                                        ssl_results["certificate_info"] = {
                                            "subject": dict(x[0] for x in cert.get('subject', [])),
                                            "issuer": dict(x[0] for x in cert.get('issuer', [])),
                                            "version": cert.get('version'),
                                            "expires": cert.get('notAfter'),
                                            "valid_from": cert.get('notBefore')
                                        }
                    
                    except aiohttp.ClientConnectorCertificateError as e:
                        ssl_results["errors"].append(self.checker.create_issue(
                            issue_type="ssl_error",
                            issue="SSL Certificate Error",
                            url=website,
                            value=str(e),
                            severity="critical",
                            details={"error_type": "certificate_error"}
                        ))
                        ssl_results["valid_certificate"] = False
                    
                    except aiohttp.ClientConnectorSSLError as e:
                        ssl_results["errors"].append(self.checker.create_issue(
                            issue_type="ssl_error",
                            issue="SSL Connection Error",
                            url=website,
                            value=str(e),
                            severity="critical",
                            details={"error_type": "ssl_connection_error"}
                        ))
                        ssl_results["valid_certificate"] = False
                    
                    except aiohttp.ClientError as e:
                        ssl_results["errors"].append(self.checker.create_issue(
                            issue_type="ssl_error",
                            issue="Connection Error",
                            url=website,
                            value=str(e),
                            severity="high",
                            details={"error_type": "connection_error"}
                        ))
                        ssl_results["valid_certificate"] = False
            
            # Try HTTP fallback to check if HTTPS is supported
            if not ssl_results["supports_https"]:
                try:
                    async with aiohttp.TCPConnector(ssl=False) as connector:
                        async with aiohttp.ClientSession(connector=connector) as session:
                            async with session.get(f"http://{hostname}", timeout=10) as response:
                                if response.status == 200:
                                    ssl_results["errors"].append(self.checker.create_issue(
                                        issue_type="ssl_error",
                                        issue="Site accessible over HTTP but not HTTPS",
                                        url=website,
                                        value=None,
                                        severity="critical",
                                        details={"supports_http": True, "supports_https": False}
                                    ))
                except Exception:
                    ssl_results["errors"].append(self.checker.create_issue(
                        issue_type="ssl_error",
                        issue="Site not accessible over HTTP or HTTPS",
                        url=website,
                        value=None,
                        severity="critical",
                        details={"supports_http": False, "supports_https": False}
                    ))
        
        except Exception as e:
            ssl_results["errors"].append(self.checker.create_issue(
                issue_type="ssl_error",
                issue="Unexpected error during SSL check",
                url=website,
                value=str(e),
                severity="high",
                details={"error_type": type(e).__name__}
            ))
            ssl_results["valid_certificate"] = False
        
        audit_results["ssl_issues"] = ssl_results

    async def _check_robots_sitemap(self, website: str, audit_results: Dict[str, Any]):
        """Check for robots.txt and sitemap.xml with detailed validation."""
        # Ensure URL has a protocol
        if not website.startswith(('http://', 'https://')):
            website = f"https://{website}"
            
        base_url = f"https://{urlparse(website).netloc}"
        
        # Check robots.txt
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(f"{base_url}/robots.txt") as response:
                    audit_results["robots_txt"] = {
                        "present": response.status == 200,
                        "status_code": response.status
                    }
                    if response.status == 200:
                        content = await response.text()
                        audit_results["robots_txt"]["content"] = content
                        # Check for sitemap directive
                        sitemap_matches = re.findall(r'Sitemap:\s*(.+)', content, re.IGNORECASE)
                        audit_results["robots_txt"]["sitemap_directives"] = sitemap_matches
        except Exception as e:
            audit_results["robots_txt"] = {
                "present": False,
                "error": str(e)
            }
        
        # Perform detailed sitemap validation
        logger.info("Performing detailed sitemap validation...")
        sitemap_validation = await self.checker.validate_sitemap(base_url)
        
        # Add sitemap validation results to audit results
        audit_results["sitemap"] = {
            "present": sitemap_validation["sitemap_found"],
            "type": sitemap_validation["sitemap_type"],
            "total_urls": sitemap_validation["total_urls"],
            "valid_urls": sitemap_validation["valid_urls"],
            "urls_with_lastmod": sitemap_validation["last_modified_dates"],
            "urls_with_changefreq": sitemap_validation["change_frequencies"],
            "urls_with_priority": sitemap_validation["priorities"],
            "sitemap_locations": sitemap_validation["sitemap_locations"],
            "issues": sitemap_validation["issues"]
        }
        
        # Add sitemap issues to total issues count
        return len(sitemap_validation["issues"])

    async def _check_broken_links(self, links: Set[tuple], audit_results: Dict[str, Any]):
        """Check for broken internal links using HEAD requests with caching."""
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
        }
        
        async with aiohttp.ClientSession(headers=headers) as session:
            semaphore = asyncio.Semaphore(5)  # Allow more concurrent requests since HEAD is lightweight
            
            async def check_link(source_url: str, target_url: str):
                """Check if a link is broken using HEAD request with caching."""
                async with semaphore:
                    # Generate cache key
                    cache_key = f"link_status:{target_url}"
                    cached_result = cache.get(cache_key)
                    
                    if cached_result is not None:
                        # If link was broken in cache, add to audit results
                        if cached_result.get('is_broken', False):
                            audit_results["broken_links"].append({
                                "source_url": source_url,
                                "target_url": target_url,
                                "status_code": cached_result.get('status_code'),
                                "error": cached_result.get('error'),
                                "timestamp": datetime.now().isoformat()
                            })
                        return
                    
                    max_retries = 3
                    retry_count = 0
                    
                    while retry_count < max_retries:
                        try:
                            # Try HEAD first
                            try:
                                async with session.head(target_url, allow_redirects=True, timeout=5) as response:
                                    # If HEAD request is successful (status < 400), cache and return
                                    if response.status < 400:
                                        cache.set(cache_key, {
                                            'is_broken': False,
                                            'status_code': response.status,
                                            'checked_at': datetime.now().isoformat()
                                        }, timeout=86400)
                                        return
                                        
                                    # If HEAD fails, try GET
                                    async with session.get(target_url, allow_redirects=True, timeout=5) as get_response:
                                        result = {
                                            'is_broken': get_response.status >= 400,
                                            'status_code': get_response.status,
                                            'error': f"HTTP {get_response.status}" if get_response.status >= 400 else None,
                                            'checked_at': datetime.now().isoformat()
                                        }
                                        cache.set(cache_key, result, timeout=86400)
                                        
                                        if result['is_broken']:
                                            audit_results["broken_links"].append({
                                                "source_url": source_url,
                                                "target_url": target_url,
                                                "status_code": get_response.status,
                                                "error": f"HTTP {get_response.status}",
                                                "timestamp": datetime.now().isoformat()
                                            })
                                        return
                                        
                            except aiohttp.ClientError:
                                # If HEAD fails with client error, try GET
                                async with session.get(target_url, allow_redirects=True, timeout=5) as response:
                                    result = {
                                        'is_broken': response.status >= 400,
                                        'status_code': response.status,
                                        'error': f"HTTP {response.status}" if response.status >= 400 else None,
                                        'checked_at': datetime.now().isoformat()
                                    }
                                    cache.set(cache_key, result, timeout=86400)
                                    
                                    if result['is_broken']:
                                        audit_results["broken_links"].append({
                                            "source_url": source_url,
                                            "target_url": target_url,
                                            "status_code": response.status,
                                            "error": f"HTTP {response.status}",
                                            "timestamp": datetime.now().isoformat()
                                        })
                                    return
                            
                        except asyncio.TimeoutError:
                            retry_count += 1
                            if retry_count == max_retries:
                                result = {
                                    'is_broken': True,
                                    'status_code': None,
                                    'error': f"Timeout after {max_retries} retries",
                                    'checked_at': datetime.now().isoformat()
                                }
                                cache.set(cache_key, result, timeout=86400)
                                
                                audit_results["broken_links"].append({
                                    "source_url": source_url,
                                    "target_url": target_url,
                                    "status_code": None,
                                    "error": f"Timeout after {max_retries} retries",
                                    "timestamp": datetime.now().isoformat()
                                })
                            else:
                                await asyncio.sleep(1)  # Wait before retrying
                                continue
                                
                        except Exception as e:
                            result = {
                                'is_broken': True,
                                'status_code': None,
                                'error': str(e),
                                'checked_at': datetime.now().isoformat()
                            }
                            cache.set(cache_key, result, timeout=86400)
                            
                            audit_results["broken_links"].append({
                                "source_url": source_url,
                                "target_url": target_url,
                                "status_code": None,
                                "error": str(e),
                                "timestamp": datetime.now().isoformat()
                            })
                            return
            
            # Process links in smaller batches
            batch_size = 50
            all_links = list(links)
            for i in range(0, len(all_links), batch_size):
                batch = all_links[i:i + batch_size]
                tasks = []
                for source_url, target_url in batch:
                    tasks.append(asyncio.create_task(check_link(source_url, target_url)))
                
                if tasks:
                    await asyncio.gather(*tasks)
                    # Add a small delay between batches to prevent overwhelming
                    await asyncio.sleep(1)

    def _generate_report(self, audit_results: Dict[str, Any]) -> Dict[str, Any]:
        """Format the audit results into a detailed report."""
        # Calculate total issues
        total_issues = (
            len(audit_results.get("broken_links", [])) +
            len(audit_results.get("duplicate_content", [])) +
            len(audit_results.get("meta_tag_issues", [])) +
            len(audit_results.get("image_issues", [])) +
            len(audit_results.get("content_issues", [])) +
            len(audit_results.get("performance_issues", [])) +
            len(audit_results.get("mobile_issues", [])) +
            len(audit_results.get("social_media_issues", [])) +
            len(audit_results.get("canonical_issues", [])) +
            len(audit_results.get("sitemap", {}).get("issues", [])) +  # Include sitemap issues
            len([issue for issue in audit_results.get("ssl_issues", {}).get("errors", [])])  # Include SSL issues
        )
        
        report = {
            "summary": {
                "total_pages": audit_results["summary"]["total_pages"],
                "total_issues": total_issues,
                "timestamp": datetime.now().isoformat(),
                "canonical_stats": audit_results["summary"].get("canonical_stats", {}),
                "social_media_stats": {
                    "pages_with_og_tags": sum(1 for page in audit_results.get("social_media_issues", []) 
                        if not any(issue["type"].startswith("og_") for issue in page.get("issues", []))),
                    "pages_with_twitter_cards": sum(1 for page in audit_results.get("social_media_issues", [])
                        if not any(issue["type"].startswith("twitter_") for issue in page.get("issues", [])))
                }
            },
            "issues": {
                # Core issues
                "broken_links": audit_results.get("broken_links", []),
                "duplicate_content": audit_results.get("duplicate_content", []),
                "meta_tag_issues": audit_results.get("meta_tag_issues", []),
                
                # Content and structure issues
                "content_issues": audit_results.get("content_issues", []),
                "heading_issues": audit_results.get("heading_issues", []),
                "canonical_issues": audit_results.get("canonical_issues", []),
                
                # Media issues
                "image_issues": audit_results.get("image_issues", []),
                
                # Performance issues
                "performance_issues": audit_results.get("performance_issues", []),
                "page_speed_issues": audit_results.get("page_speed_issues", []),
                
                # Mobile issues
                "mobile_issues": audit_results.get("mobile_issues", []),
                "viewport_issues": audit_results.get("viewport_issues", []),
                
                # Social media issues
                "social_media_issues": audit_results.get("social_media_issues", []),
                "opengraph_issues": [
                    issue for page in audit_results.get("social_media_issues", [])
                    for issue in page.get("issues", []) if issue["type"].startswith("og_")
                ],
                "twitter_card_issues": [
                    issue for page in audit_results.get("social_media_issues", [])
                    for issue in page.get("issues", []) if issue["type"].startswith("twitter_")
                ],
                
                # Technical issues
                "sitemap_issues": audit_results.get("sitemap", {}).get("issues", []),
                "ssl_issues": [{"type": "ssl_error", "issue": error} for error in audit_results.get("ssl_issues", {}).get("errors", [])]
            },
            "technical": {
                # SSL and security
                "ssl": audit_results.get("ssl_issues", {}),
                "security_headers": audit_results.get("security_headers", {}),
                
                # Core technical aspects
                "sitemap": audit_results.get("sitemap", {}),  # Include full sitemap data
                "robots_txt": audit_results.get("robots_txt", {}),  # Include full robots.txt data
                "structured_data": audit_results.get("structured_data_validation", {}),
                "hreflang": audit_results.get("hreflang_validation", {}),
                
                # Mobile technical aspects
                "mobile_friendly": audit_results.get("mobile_friendly", False),
                "mobile_usability": audit_results.get("mobile_usability", {})
            },
            "crawl_stats": {
                "total_pages": audit_results["summary"]["total_pages"],
                "total_links": audit_results["summary"]["total_links"],
                "crawl_time": audit_results["summary"].get("crawl_time_seconds", 0),
                "average_page_load": audit_results["summary"].get("average_page_load", 0)
            },
            "page_analysis": audit_results.get("page_analysis", {})
        }
        
        return report

    async def _check_link(self, source_url: str, target_url: str) -> Dict[str, Any]:
        """Check if a link is broken using HEAD/GET requests with retries."""
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Connection': 'keep-alive',
        }
        
        # Generate cache key
        cache_key = f"link_status:{target_url}"
        cached_result = cache.get(cache_key)
        
        if cached_result is not None:
            return cached_result
        
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(headers=headers) as session:
                    # Try HEAD first
                    try:
                        async with session.head(target_url, allow_redirects=True, timeout=5) as response:
                            # If HEAD request is successful (status < 400), cache and return
                            if response.status < 400:
                                result = {
                                    'is_broken': False,
                                    'status_code': response.status,
                                    'error': None,
                                    'checked_at': datetime.now().isoformat()
                                }
                                cache.set(cache_key, result, timeout=86400)  # Cache for 24 hours
                                return result
                                
                            # If HEAD fails, try GET
                            async with session.get(target_url, allow_redirects=True, timeout=5) as get_response:
                                result = {
                                    'is_broken': get_response.status >= 400,
                                    'status_code': get_response.status,
                                    'error': f"HTTP {get_response.status}" if get_response.status >= 400 else None,
                                    'checked_at': datetime.now().isoformat()
                                }
                                cache.set(cache_key, result, timeout=86400)
                                return result
                                
                    except aiohttp.ClientError:
                        # If HEAD fails with client error, try GET
                        async with session.get(target_url, allow_redirects=True, timeout=5) as response:
                            result = {
                                'is_broken': response.status >= 400,
                                'status_code': response.status,
                                'error': f"HTTP {response.status}" if response.status >= 400 else None,
                                'checked_at': datetime.now().isoformat()
                            }
                            cache.set(cache_key, result, timeout=86400)
                            return result
                    
            except asyncio.TimeoutError:
                retry_count += 1
                if retry_count == max_retries:
                    result = {
                        'is_broken': True,
                        'status_code': None,
                        'error': f"Timeout after {max_retries} retries",
                        'checked_at': datetime.now().isoformat()
                    }
                    cache.set(cache_key, result, timeout=86400)
                    return result
                else:
                    await asyncio.sleep(1)  # Wait before retrying
                    continue
                    
            except Exception as e:
                result = {
                    'is_broken': True,
                    'status_code': None,
                    'error': str(e),
                    'checked_at': datetime.now().isoformat()
                }
                cache.set(cache_key, result, timeout=86400)
                return result

        # Should never reach here, but just in case
        return {
            'is_broken': True,
            'status_code': None,
            'error': 'Unknown error',
            'checked_at': datetime.now().isoformat()
        }

    async def _check_content_similarity(self, page1: Dict[str, Any], page2: Dict[str, Any]) -> float:
        """Check content similarity between two pages."""
        from difflib import SequenceMatcher
        
        # Get text content
        text1 = page1.get('text_content', '')
        text2 = page2.get('text_content', '')
        
        # Use SequenceMatcher for similarity ratio
        return SequenceMatcher(None, text1, text2).ratio()

================
File: apps/agents/tools/seo_audit_tool/seo_checkers.py
================
"""SEO check implementations for the SEO Audit Tool."""
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse, urljoin
import logging
import aiohttp
from bs4 import BeautifulSoup
from datetime import datetime
import re
from .content_type_detector import determine_content_type
from apps.agents.tools.content_expertise_tool.content_expertise_tool import ContentExpertiseTool
from apps.agents.tools.business_credibility_tool.business_credibility_tool import BusinessCredibilityTool
import json

logger = logging.getLogger(__name__)

class SEOChecker:
    """Base class for SEO checks."""
    
    @staticmethod
    def create_issue(
        issue_type: str,
        issue: str,
        url: str,
        value: Any = None,
        severity: str = "medium",
        details: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Create a standardized issue object.
        
        Args:
            issue_type: The type of issue (must match one of the ISSUE_TYPES in SEOAuditIssue model)
            issue: A human-readable description of the issue
            url: The URL where the issue was found
            value: The specific value that caused the issue (optional)
            severity: The severity level (critical, high, medium, low, info)
            details: Additional structured details about the issue
        
        Returns:
            A standardized issue dictionary
        """
        if not details:
            details = {}
        
        # Ensure severity is one of the allowed values
        allowed_severities = {'critical', 'high', 'medium', 'low', 'info'}
        if severity not in allowed_severities:
            severity = 'medium'
        
        # Create the standardized issue object
        issue_obj = {
            "type": issue_type,
            "issue": issue,
            "url": url,
            "severity": severity,
            "value": value,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        
        return issue_obj

    @staticmethod
    def is_404_page(page_data: Dict[str, Any]) -> bool:
        """Helper function to detect 404 pages including custom error pages."""
        # Check status code first
        if page_data.get('status_code') == 404:
            return True
                
        # Check common 404 indicators in title and content
        title = page_data.get('title', '').lower()
        content = page_data.get('text_content', '').lower()
        url = page_data.get('url', '').lower()
        
        error_indicators = [
            '404', 'not found', 'page not found', 'error 404',
            'page does not exist', 'page no longer exists',
            'page couldn\'t be found', 'page could not be found',
            'nothing found', 'entry not found', 'article not found',
            'product not found', 'no results found',
            'error page', 'page missing', 'content not found'
        ]
        
        # Check title for error indicators
        if any(indicator in title for indicator in error_indicators):
            return True
                
        # Check first 1000 chars of content for error indicators
        content_start = content[:1000]
        if any(indicator in content_start for indicator in error_indicators):
            return True
                
        # Check URL patterns that often indicate 404 pages
        url_indicators = ['/404', 'error', 'not-found', 'notfound', 'page-not-found']
        if any(indicator in url for indicator in url_indicators):
            return True
                
        return False
    
    @staticmethod
    def check_meta_tags(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check meta tags including title and description."""
        issues = []
        url = page_data.get("url", "")
        
        # Title tag checks
        title = page_data.get("title", "").strip()
        if not title:
            issues.append(SEOChecker.create_issue(
                issue_type="title",
                issue="Missing title tag",
                url=url,
                value=None,
                severity="critical"
            ))
        elif len(title) < 10:
            issues.append(SEOChecker.create_issue(
                issue_type="title",
                issue=f"Title tag too short ({len(title)} chars)",
                url=url,
                value=title,
                severity="high",
                details={"length": len(title)}
            ))
        elif len(title) > 60:
            issues.append(SEOChecker.create_issue(
                issue_type="title",
                issue=f"Title tag too long ({len(title)} chars)",
                url=url,
                value=title,
                severity="medium",
                details={"length": len(title)}
            ))
        
        # Meta description checks
        meta_desc = page_data.get("meta_description", "").strip()
        if not meta_desc:
            issues.append(SEOChecker.create_issue(
                issue_type="meta_description",
                issue="Missing meta description",
                url=url,
                value=None,
                severity="high"
            ))
        elif len(meta_desc) < 50:
            issues.append(SEOChecker.create_issue(
                issue_type="meta_description",
                issue=f"Meta description too short ({len(meta_desc)} chars)",
                url=url,
                value=meta_desc,
                severity="medium",
                details={"length": len(meta_desc)}
            ))
        elif len(meta_desc) > 160:
            issues.append(SEOChecker.create_issue(
                issue_type="meta_description",
                issue=f"Meta description too long ({len(meta_desc)} chars)",
                url=url,
                value=meta_desc,
                severity="low",
                details={"length": len(meta_desc)}
            ))
        
        # Viewport checks
        if not page_data.get("viewport"):
            issues.append(SEOChecker.create_issue(
                issue_type="viewport_missing",
                issue="Missing viewport meta tag",
                url=url,
                value=None,
                severity="high"
            ))
        
        return issues

    @staticmethod
    def check_headings(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check heading structure."""
        issues = []
        url = page_data.get("url", "")
        
        # H1 tag checks
        h1_tags = page_data.get("h1_tags", [])
        if not h1_tags:
            issues.append(SEOChecker.create_issue(
                issue_type="h1",
                issue="Missing H1 tag",
                url=url,
                value=None,
                severity="high"
            ))
        elif len(h1_tags) > 1:
            issues.append(SEOChecker.create_issue(
                issue_type="h1",
                issue=f"Multiple H1 tags ({len(h1_tags)})",
                url=url,
                value=h1_tags,
                severity="medium",
                details={"count": len(h1_tags), "h1_contents": h1_tags}
            ))
        
        return issues

    @staticmethod
    def check_images(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check image optimization."""
        issues = []
        page_url = page_data.get("url", "")
        images = page_data.get("images", [])
        
        for img in images:
            img_url = img.get("src", "")
            
            # Alt text checks
            if not img.get("alt"):
                issues.append(SEOChecker.create_issue(
                    issue_type="missing_alt",
                    issue="Missing alt text",
                    url=page_url,
                    value=img_url,
                    severity="medium",
                    details={"image_url": img_url}
                ))
            elif len(img.get("alt", "")) < 3:
                issues.append(SEOChecker.create_issue(
                    issue_type="short_alt",
                    issue="Alt text too short",
                    url=page_url,
                    value=img.get("alt"),
                    severity="medium",
                    details={"image_url": img_url, "alt_length": len(img.get("alt", ""))}
                ))
            
            # Dimension checks
            width = img.get("width")
            height = img.get("height")
            if not (width and height):
                issues.append(SEOChecker.create_issue(
                    issue_type="missing_dimensions",
                    issue="Missing width/height attributes",
                    url=page_url,
                    value=img_url,
                    severity="medium",
                    details={"image_url": img_url, "width": width, "height": height}
                ))
            
            # Filename checks
            filename = img_url.split("/")[-1]
            if filename.lower().startswith(("img", "image", "pic", "dsc")):
                issues.append(SEOChecker.create_issue(
                    issue_type="generic_filename",
                    issue="Generic image filename",
                    url=page_url,
                    value=filename,
                    severity="low",
                    details={"image_url": img_url}
                ))
            
            # Size checks
            size = img.get("size", 0)
            if size > 500000:  # 500KB
                issues.append(SEOChecker.create_issue(
                    issue_type="large_size",
                    issue=f"Image size too large ({size/1000:.0f}KB)",
                    url=page_url,
                    value=img_url,
                    severity="high",
                    details={"image_url": img_url, "size_kb": size/1000}
                ))
            
            # Lazy loading check
            if not img.get("loading") == "lazy":
                issues.append(SEOChecker.create_issue(
                    issue_type="no_lazy_loading",
                    issue="Image missing lazy loading",
                    url=page_url,
                    value=img_url,
                    severity="high",
                    details={"image_url": img_url}
                ))
            
            # Responsive image checks
            if not img.get("srcset"):
                issues.append(SEOChecker.create_issue(
                    issue_type="no_srcset",
                    issue="Image missing responsive srcset",
                    url=page_url,
                    value=img_url,
                    severity="medium",
                    details={"image_url": img_url}
                ))
        
        return issues

    @staticmethod
    def check_links(page_data: Dict[str, Any], base_domain: str) -> List[str]:
        """Extract and check internal links."""
        internal_links = []
        page_links = page_data.get("links", [])
        
        for link in page_links:
            if urlparse(link).netloc == base_domain:
                internal_links.append(link)
        
        return internal_links

    @staticmethod
    def check_content(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check content quality and structure."""
        issues = []
        url = page_data.get("url", "")
        text_content = page_data.get("text_content", "")
        word_count = len(text_content.split())
        
        # Content length check
        if word_count < 300:
            issues.append(SEOChecker.create_issue(
                issue_type="thin_content",
                issue=f"Thin content ({word_count} words)",
                url=url,
                value=word_count,
                severity="medium",
                details={"word_count": word_count}
            ))
        
        # Check for keyword density and readability if content exists
        if text_content:
            # Add readability score check
            sentences = len(re.split(r'[.!?]+', text_content))
            if sentences > 0:
                avg_words_per_sentence = word_count / sentences
                if avg_words_per_sentence > 25:
                    issues.append(SEOChecker.create_issue(
                        issue_type="readability",
                        issue=f"Sentences too long (avg {avg_words_per_sentence:.1f} words)",
                        url=url,
                        value=avg_words_per_sentence,
                        severity="medium",
                        details={
                            "avg_words_per_sentence": avg_words_per_sentence,
                            "total_sentences": sentences,
                            "total_words": word_count
                        }
                    ))
            
            # Check for long paragraphs
            paragraphs = [p.strip() for p in text_content.split('\n\n') if p.strip()]
            for i, para in enumerate(paragraphs):
                para_words = len(para.split())
                if para_words > 150:  # Generally, 150 words is considered a long paragraph
                    issues.append(SEOChecker.create_issue(
                        issue_type="long_paragraph",
                        issue=f"Long paragraph detected ({para_words} words)",
                        url=url,
                        value=para_words,
                        severity="low",
                        details={
                            "paragraph_index": i,
                            "word_count": para_words,
                            "paragraph_preview": para[:100] + "..." if len(para) > 100 else para
                        }
                    ))
        
        return issues

    @staticmethod
    def check_canonical_tags(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check canonical tag implementation and validation."""
        issues = []
        url = page_data.get("url", "")
        canonical_url = page_data.get("canonical_url", "")
        page_content = page_data.get("text_content", "")
        
        # Check if canonical tag exists
        if not canonical_url:
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_missing",
                issue="Missing canonical tag",
                url=url,
                value=None,
                severity="high",
                details={"page_type": "content" if page_content else "unknown"}
            ))
            return issues

        # Validate canonical URL format
        if not canonical_url.startswith(('http://', 'https://')):
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_invalid_format",
                issue="Invalid canonical URL format",
                url=url,
                value=canonical_url,
                severity="high",
                details={"canonical_url": canonical_url}
            ))

        # Check for self-referential canonical
        if canonical_url != url:
            # If the page is pointing to a different URL, check if it might be a duplicate
            if page_content:
                issues.append(SEOChecker.create_issue(
                    issue_type="canonical_different",
                    issue="Canonical URL points to a different page",
                    url=url,
                    value=canonical_url,
                    severity="medium",
                    details={
                        "canonical_url": canonical_url,
                        "content_length": len(page_content)
                    }
                ))

        # Check for relative canonical URLs
        if canonical_url.startswith('/'):
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_relative",
                issue="Canonical URL is relative",
                url=url,
                value=canonical_url,
                severity="medium",
                details={"canonical_url": canonical_url}
            ))

        # Check for multiple canonical tags
        canonical_count = page_data.get("canonical_count", 0)
        if canonical_count > 1:
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_multiple",
                issue=f"Multiple canonical tags found ({canonical_count})",
                url=url,
                value=str(canonical_count),
                severity="critical",
                details={
                    "canonical_count": canonical_count,
                    "canonical_url": canonical_url
                }
            ))

        # Check for canonical on non-canonical pages
        if page_data.get("is_pagination", False) and canonical_url == url:
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_on_pagination",
                issue="Self-referential canonical on paginated page",
                url=url,
                value=canonical_url,
                severity="medium",
                details={"is_pagination": True}
            ))

        # Check for canonical chain (if available)
        canonical_chain = page_data.get("canonical_chain", [])
        if len(canonical_chain) > 1:
            issues.append(SEOChecker.create_issue(
                issue_type="canonical_chain",
                issue=f"Canonical chain detected (length: {len(canonical_chain)})",
                url=url,
                value=" -> ".join(canonical_chain),
                severity="high",
                details={
                    "chain_length": len(canonical_chain),
                    "canonical_chain": canonical_chain
                }
            ))
        
        return issues

    @staticmethod
    def get_page_metrics(page_data: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate page metrics for analysis."""
        images = page_data.get("images", [])
        return {
            "url": page_data["url"],
            "title_length": len(page_data.get("title", "")),
            "meta_description_length": len(page_data.get("meta_description", "")),
            "h1_count": len(page_data.get("h1_tags", [])),
            "outbound_links": len(page_data.get("links", [])),
            "content_length": len(page_data.get("text_content", "")),
            "image_count": len(images),
            "images_without_alt": sum(1 for img in images if not img.get("alt")),
            "total_image_size": sum(img.get("size", 0) for img in images),
            "timestamp": page_data.get("crawl_timestamp"),
            "has_canonical": bool(page_data.get("canonical_url")),
            "canonical_url": page_data.get("canonical_url", ""),
            "canonical_count": page_data.get("canonical_count", 0)
        } 

    @staticmethod
    async def validate_sitemap(base_url: str) -> Dict[str, Any]:
        """Validate XML sitemap structure and content."""
        sitemap_issues = []
        sitemap_data = {
            "sitemap_found": False,
            "sitemap_type": None,  # "index" or "urlset"
            "total_urls": 0,
            "valid_urls": 0,
            "issues": [],
            "last_modified_dates": 0,
            "change_frequencies": 0,
            "priorities": 0,
            "sitemap_locations": []
        }

        async def check_sitemap_url(sitemap_url: str) -> Optional[Dict[str, Any]]:
            try:
                # Add a standard User-Agent header
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
                }
                async with aiohttp.ClientSession(headers=headers) as session:
                    async with session.get(sitemap_url, allow_redirects=True, timeout=15) as response:
                        if response.status != 200:
                            sitemap_issues.append(SEOChecker.create_issue(
                                issue_type="sitemap_http_error",
                                issue=f"Sitemap HTTP error {response.status}",
                                url=sitemap_url,
                                value=str(response.status),
                                severity="medium"
                            ))
                            return None

                        content = await response.text()
                        # Explicitly use lxml-xml parser if available
                        try:
                            soup = BeautifulSoup(content, 'lxml-xml') 
                        except ImportError:
                            soup = BeautifulSoup(content, 'xml') # Fallback to default xml
                        
                        # --- Add Logging --- 
                        root_element = soup.find() # Get the first element tag
                        logger.debug(f"Sitemap Check: URL={sitemap_url}, Root element found: {root_element.name if root_element else 'None'}")
                        # --- End Logging ---

                        # Check if it's a sitemap index
                        sitemapindex = soup.find('sitemapindex')
                        if sitemapindex:
                            sitemap_data["sitemap_type"] = "index"
                            sitemaps = sitemapindex.find_all('sitemap')
                            for sitemap in sitemaps:
                                loc = sitemap.find('loc')
                                if loc:
                                    sitemap_data["sitemap_locations"].append(loc.text)
                                    sub_result = await check_sitemap_url(loc.text)
                                    if sub_result:
                                        for key in ["total_urls", "valid_urls", "last_modified_dates", "change_frequencies", "priorities"]:
                                            sitemap_data[key] += sub_result[key]
                            return sitemap_data

                        # Check if it's a regular sitemap
                        urlset = soup.find('urlset')
                        if urlset:
                            sitemap_data["sitemap_type"] = "urlset"
                            urls = urlset.find_all('url')
                            result = {
                                "total_urls": len(urls),
                                "valid_urls": 0,
                                "last_modified_dates": 0,
                                "change_frequencies": 0,
                                "priorities": 0
                            }

                            for url in urls:
                                loc = url.find('loc')
                                if not loc or not loc.text:
                                    sitemap_issues.append(SEOChecker.create_issue(
                                        issue_type="missing_url",
                                        issue="URL entry missing location",
                                        url=sitemap_url,
                                        value="",
                                        severity="high",
                                        details={"sitemap_type": sitemap_data["sitemap_type"]}
                                    ))
                                    continue

                                url_str = loc.text.strip()
                                if not url_str.startswith(('http://', 'https://')):
                                    sitemap_issues.append(SEOChecker.create_issue(
                                        issue_type="invalid_url",
                                        issue="Invalid URL format",
                                        url=url_str,
                                        value=url_str,
                                        severity="high",
                                        details={"sitemap_url": sitemap_url}
                                    ))
                                    continue

                                result["valid_urls"] += 1

                                # Check optional elements
                                if url.find('lastmod'):
                                    result["last_modified_dates"] += 1
                                    # Validate lastmod format
                                    lastmod = url.find('lastmod').text
                                    if not re.match(r'^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(\+\d{2}:\d{2}|Z)?)?$', lastmod):
                                        sitemap_issues.append(SEOChecker.create_issue(
                                            issue_type="invalid_lastmod",
                                            issue="Invalid lastmod date format",
                                            url=url_str,
                                            value=lastmod,
                                            severity="medium",
                                            details={"sitemap_url": sitemap_url}
                                        ))

                                if url.find('changefreq'):
                                    result["change_frequencies"] += 1
                                    # Validate changefreq value
                                    changefreq = url.find('changefreq').text
                                    if changefreq not in ['always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', 'never']:
                                        sitemap_issues.append(SEOChecker.create_issue(
                                            issue_type="invalid_changefreq",
                                            issue="Invalid changefreq value",
                                            url=url_str,
                                            value=changefreq,
                                            severity="low",
                                            details={"sitemap_url": sitemap_url, "allowed_values": ['always', 'hourly', 'daily', 'weekly', 'monthly', 'yearly', 'never']}
                                        ))

                                if url.find('priority'):
                                    result["priorities"] += 1
                                    # Validate priority value
                                    priority = url.find('priority').text
                                    try:
                                        priority_float = float(priority)
                                        if not 0.0 <= priority_float <= 1.0:
                                            sitemap_issues.append(SEOChecker.create_issue(
                                                issue_type="invalid_priority",
                                                issue="Priority value out of range (0.0-1.0)",
                                                url=url_str,
                                                value=priority,
                                                severity="low",
                                                details={"sitemap_url": sitemap_url, "allowed_range": "0.0-1.0"}
                                            ))
                                    except ValueError:
                                        sitemap_issues.append(SEOChecker.create_issue(
                                            issue_type="invalid_priority",
                                            issue="Invalid priority value format",
                                            url=url_str,
                                            value=priority,
                                            severity="low",
                                            details={"sitemap_url": sitemap_url}
                                        ))

                            return result

            except Exception as e:
                sitemap_issues.append(SEOChecker.create_issue(
                    issue_type="sitemap_error",
                    issue=f"Error processing sitemap: {str(e)}",
                    url=sitemap_url,
                    value=str(e),
                    severity="high",
                    details={"error_type": type(e).__name__}
                ))
                return None

        # Check common sitemap locations
        sitemap_urls = [
            f"{base_url}/sitemap_index.xml",
            f"{base_url}/sitemap.xml",
            f"{base_url}/sitemap",
            f"{base_url}/sitemap_news.xml",
            f"{base_url}/sitemap_products.xml",
            f"{base_url}/post-sitemap.xml"
        ]

        for sitemap_url in sitemap_urls:
            result = await check_sitemap_url(sitemap_url)
            if result:
                sitemap_data["sitemap_found"] = True
                break

        # Check robots.txt for Sitemap directive
        try:
            # Add a standard User-Agent header for robots.txt check too
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
            }
            async with aiohttp.ClientSession(headers=headers) as session:
                async with session.get(f"{base_url}/robots.txt", timeout=10) as response:
                    if response.status == 200:
                        robots_content = await response.text()
                        sitemap_matches = re.findall(r'Sitemap:\s*(.+)', robots_content, re.IGNORECASE)
                        for sitemap_url in sitemap_matches:
                            sitemap_url = sitemap_url.strip()
                            if sitemap_url not in sitemap_urls:
                                result = await check_sitemap_url(sitemap_url)
                                if result:
                                    sitemap_data["sitemap_found"] = True
                                    break
        except Exception as e:
            logger.error(f"Error checking robots.txt for sitemap: {e}")

        sitemap_data["issues"] = sitemap_issues
        return sitemap_data 

    @staticmethod
    def check_social_media_tags(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check social media meta tags including OpenGraph and Twitter Cards."""
        issues = []
        url = page_data.get("url", "")
        
        # OpenGraph checks
        og_title = page_data.get("og_title", "")
        og_description = page_data.get("og_description", "")
        og_image = page_data.get("og_image", "")
        
        if not og_title:
            issues.append({
                "type": "og_title_missing",
                "issue": "Missing OpenGraph title tag",
                "url": url,
                "value": None,
                "severity": "medium"
            })
        
        if not og_description:
            issues.append({
                "type": "og_description_missing",
                "issue": "Missing OpenGraph description tag",
                "url": url,
                "value": None,
                "severity": "medium"
            })
        
        if not og_image:
            issues.append({
                "type": "og_image_missing",
                "issue": "Missing OpenGraph image tag",
                "url": url,
                "value": None,
                "severity": "medium"
            })
        elif not og_image.startswith(('http://', 'https://')):
            issues.append({
                "type": "og_image_invalid",
                "issue": "Invalid OpenGraph image URL format",
                "url": url,
                "value": og_image,
                "severity": "medium"
            })
        
        return issues 

    @staticmethod
    def check_semantic_structure(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check HTML5 semantic structure."""
        issues = []
        url = page_data.get("url", "")
        page_type = page_data.get("page_type", "content")
        
        # Define semantic elements and their requirements based on page type
        semantic_elements = {
            'header': {
                'purpose': 'Main header/banner area',
                'required_for': ['content', 'landing', 'blog', 'article', 'product'],
                'optional_for': ['search', 'category', 'error']
            },
            'main': {
                'purpose': 'Primary content area',
                'required_for': ['*'],  # Required for all pages
                'optional_for': []
            },
            'nav': {
                'purpose': 'Navigation menu',
                'required_for': ['content', 'landing', 'blog', 'article', 'product'],
                'optional_for': ['search', 'category', 'error']
            },
            'footer': {
                'purpose': 'Footer area',
                'required_for': ['content', 'landing', 'blog', 'article', 'product'],
                'optional_for': ['search', 'category', 'error']
            },
            'article': {
                'purpose': 'Self-contained content',
                'required_for': ['blog', 'article', 'news'],
                'optional_for': ['content', 'product']
            },
            'section': {
                'purpose': 'Thematic grouping of content',
                'required_for': [],
                'optional_for': ['*']  # Optional for all pages
            },
            'aside': {
                'purpose': 'Sidebar/complementary content',
                'required_for': [],
                'optional_for': ['*']  # Optional for all pages
            }
        }
        
        # Check for required semantic elements based on page type
        for element, config in semantic_elements.items():
            is_required = (
                '*' in config['required_for'] or 
                page_type in config['required_for']
            )
            is_optional = (
                '*' in config['optional_for'] or 
                page_type in config['optional_for']
            )
            
            if not page_data.get(f"has_{element}"):
                if is_required:
                    issues.append(SEOChecker.create_issue(
                        issue_type="semantic_structure",
                        issue=f"Missing required {element} semantic element",
                        url=url,
                        value=element,
                        severity="high" if element == 'main' else "medium",
                        details={
                            "element_type": element,
                            "element_purpose": config['purpose'],
                            "page_type": page_type,
                            "is_required": True,
                            "requirement_reason": "Required for this page type"
                        }
                    ))
                elif is_optional:
                    issues.append(SEOChecker.create_issue(
                        issue_type="semantic_structure",
                        issue=f"Missing recommended {element} semantic element",
                        url=url,
                        value=element,
                        severity="low",
                        details={
                            "element_type": element,
                            "element_purpose": config['purpose'],
                            "page_type": page_type,
                            "is_required": False,
                            "requirement_reason": "Recommended for better structure"
                        }
                    ))
        
        # Check for proper nesting of semantic elements
        if page_data.get("semantic_nesting_issues"):
            for issue in page_data["semantic_nesting_issues"]:
                issues.append(SEOChecker.create_issue(
                    issue_type="semantic_nesting",
                    issue=f"Improper nesting of semantic elements: {issue['elements']}",
                    url=url,
                    value=issue['elements'],
                    severity="medium",
                    details={
                        "parent_element": issue.get("parent"),
                        "child_element": issue.get("child"),
                        "recommended_structure": issue.get("recommendation"),
                        "page_type": page_type
                    }
                ))
        
        # Check for empty semantic elements
        if page_data.get("empty_semantic_elements"):
            for element in page_data["empty_semantic_elements"]:
                # Only report empty elements if they're required or used
                if element in semantic_elements:
                    issues.append(SEOChecker.create_issue(
                        issue_type="empty_semantic_element",
                        issue=f"Empty {element} semantic element",
                        url=url,
                        value=element,
                        severity="low",
                        details={
                            "element_type": element,
                            "element_purpose": semantic_elements[element]['purpose'],
                            "page_type": page_type,
                            "is_required": (
                                '*' in semantic_elements[element]['required_for'] or 
                                page_type in semantic_elements[element]['required_for']
                            )
                        }
                    ))
        
        return issues

    @staticmethod
    def check_redirect_chains(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for redirect chains and loops."""
        issues = []
        url = page_data.get("url", "")
        redirects = page_data.get("redirect_chain", [])
        
        # Check for long redirect chains
        if len(redirects) > 2:  # More than 2 redirects in chain
            issues.append(SEOChecker.create_issue(
                issue_type="redirect_chain",
                issue=f"Long redirect chain detected ({len(redirects)} redirects)",
                url=url,
                value=redirects,
                severity="high",
                details={
                    "chain_length": len(redirects),
                    "redirect_chain": redirects,
                    "final_url": redirects[-1] if redirects else url,
                    "hops": len(redirects) - 1
                }
            ))
        
        # Check for redirect loops
        if len(redirects) != len(set(redirects)):
            issues.append(SEOChecker.create_issue(
                issue_type="redirect_loop",
                issue="Redirect loop detected",
                url=url,
                value=redirects,
                severity="critical",
                details={
                    "chain_length": len(redirects),
                    "redirect_chain": redirects,
                    "unique_urls": len(set(redirects))
                }
            ))
        
        # Check for meta refresh redirects
        if page_data.get("meta_refresh"):
            issues.append(SEOChecker.create_issue(
                issue_type="meta_refresh",
                issue="Meta refresh redirect detected",
                url=url,
                value=page_data.get("meta_refresh_url"),
                severity="medium",
                details={
                    "refresh_delay": page_data.get("meta_refresh_delay", 0),
                    "target_url": page_data.get("meta_refresh_url"),
                    "is_immediate": page_data.get("meta_refresh_delay", 0) == 0
                }
            ))
        
        return issues

    @staticmethod
    def check_robots_indexing(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check robots.txt and indexing directives."""
        issues = []
        url = page_data.get("url", "")
        
        # Check noindex directives
        if page_data.get("noindex"):
            issues.append(SEOChecker.create_issue(
                issue_type="noindex_detected",
                issue="Page has noindex directive",
                url=url,
                value=page_data.get("noindex_source", "meta"),
                severity="critical",
                details={
                    "source": page_data.get("noindex_source", "meta"),
                    "directive_type": "noindex",
                    "is_intentional": page_data.get("noindex_intentional", False)
                }
            ))
        
        # Check X-Robots-Tag header
        if page_data.get("x_robots_tag"):
            x_robots = page_data["x_robots_tag"]
            if "noindex" in x_robots or "none" in x_robots:
                issues.append(SEOChecker.create_issue(
                    issue_type="indexing_blocked",
                    issue="Indexing blocked by X-Robots-Tag header",
                    url=url,
                    value=x_robots,
                    severity="critical",
                    details={
                        "header_value": x_robots,
                        "directives": [d.strip() for d in x_robots.split(",")]
                    }
                ))
        
        # Check robots.txt blocking
        if page_data.get("robots_blocked"):
            issues.append(SEOChecker.create_issue(
                issue_type="robots_misconfiguration",
                issue="Page blocked by robots.txt",
                url=url,
                value=page_data.get("robots_directive", ""),
                severity="high",
                details={
                    "directive": page_data.get("robots_directive", ""),
                    "user_agent": page_data.get("robots_user_agent", "*")
                }
            ))
        
        return issues 

    @staticmethod
    def check_eeat_signals(page_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Check for E-E-A-T signals."""
        issues = []
        url = page_data.get("url", "")
        content_type = determine_content_type(page_data)
        logger.debug(f"Content type: {content_type}")
        # For local business homepage and general pages
        if content_type in ["business_homepage", "content", "about", "contact"]:
            try:
                # Use business credibility tool directly
                credibility_tool = BusinessCredibilityTool()
                result = credibility_tool._run(
                    text_content=page_data.get("text_content", ""),
                    html_content=page_data.get("html", "")
                )
                
                analysis = json.loads(result)
                logger.debug(f"Business credibility analysis: {analysis}")
                if "error" in analysis:
                    logger.error(f"Error in business credibility analysis: {analysis['message']}")
                    return []
                    
                # Convert tool results into issues
                credibility_signals = analysis.get("credibility_signals", {})
                signal_details = analysis.get("signal_details", {})
                
                # Map missing signals to issues
                signal_to_issue = {
                    "business_info": ("business_info_missing", "Missing basic business information", "high"),
                    "years_in_business": ("years_missing", "Years in business not specified", "medium"),
                    "customer_reviews": ("reviews_missing", "No customer reviews/testimonials found", "medium"),
                    "services_list": ("services_missing", "Services/products not clearly listed", "medium"),
                    "certifications": ("certifications_missing", "No professional certifications found", "medium")
                }
                
                for signal, (issue_type, message, severity) in signal_to_issue.items():
                    if not credibility_signals.get(signal, False):
                        issues.append(SEOChecker.create_issue(
                            issue_type=issue_type,
                            issue=message,
                            url=url,
                            severity=severity,
                            details=signal_details.get(signal, {})
                        ))
                        
            except Exception as e:
                logger.error(f"Error checking business credibility: {str(e)}")
                return []

        # For informational content, use content expertise tool
        elif content_type in ["blog", "article", "news"]:
            try:
                expertise_tool = ContentExpertiseTool()
                result = expertise_tool._run(
                    text_content=page_data.get("text_content", ""),
                    html_content=page_data.get("html", ""),
                    content_type=content_type,
                    url=url
                )
                
                analysis = json.loads(result)
                
                if "error" in analysis:
                    logger.error(f"Error in content expertise analysis: {analysis['message']}")
                    return []
                    
                # Convert tool results into issues
                expertise_signals = analysis.get("expertise_signals", {})
                signal_details = analysis.get("signal_details", {})
                
                # Map missing signals to issues
                signal_to_issue = {
                    "has_author": ("author_missing", "Missing author information", "high"),
                    "has_author_bio": ("author_bio_missing", "Author bio missing", "medium"),
                    "has_credentials": ("author_credentials_missing", "Author credentials not specified", "medium"),
                    "has_citations": ("citations_missing", "No citations or references found", "medium"),
                    "has_freshness": ("freshness_missing", "No last updated date found", "low"),
                    "has_fact_checking": ("fact_checking_missing", "No fact-checking elements found", "medium"),
                    "has_structure": ("poor_structure", "Content structure needs improvement", "medium"),
                    "has_depth": ("shallow_coverage", "Topic coverage may be insufficient", "medium"),
                    "has_schema": ("schema_missing", "Missing appropriate Article schema markup", "medium")
                }
                
                for signal, (issue_type, message, severity) in signal_to_issue.items():
                    if not expertise_signals.get(signal, False):
                        issues.append(SEOChecker.create_issue(
                            issue_type=issue_type,
                            issue=message,
                            url=url,
                            severity=severity,
                            details=signal_details.get(signal, {})
                        ))
                        
            except Exception as e:
                logger.error(f"Error checking content expertise: {str(e)}")
                return []

        return issues 

    @staticmethod
    async def check_pagespeed_metrics(page_data: Dict[str, Any], pagespeed_tool) -> List[Dict[str, Any]]:
        """Check PageSpeed metrics for a page."""
        issues = []
        url = page_data.get("url", "")
        
        try:
            # Get PageSpeed data
            result = pagespeed_tool._run(
                url=url,
                strategy="mobile",
                categories=["performance", "accessibility", "best-practices", "seo"]
            )

            # Wait for the task to complete if it's pending
            if isinstance(result, dict) and result.get('status') == 'pending':
                task_id = result.get('task_id')
                if task_id:
                    from celery.result import AsyncResult
                    task_result = AsyncResult(task_id)
                    # Wait for the task to complete (this will block until the task is done)
                    result = task_result.get()

            # Process performance score
            performance_score = result.get('performance_score')
            if performance_score is not None and performance_score < 0.5:
                issues.append(SEOChecker.create_issue(
                    issue_type="performance_poor",
                    issue="Low performance score",
                    url=url,
                    value=str(performance_score * 100),
                    severity="high" if performance_score < 0.3 else "medium",
                    details={"score": performance_score}
                ))
            
            # Process Core Web Vitals
            lab_data = result.get('core_web_vitals', {}).get('lab_data', {})
            
            # Check LCP
            lcp = lab_data.get('lcp', {})
            if lcp and lcp.get('value') and lcp.get('value') > 2500:
                issues.append(SEOChecker.create_issue(
                    issue_type="lcp_poor",
                    issue="High Largest Contentful Paint (LCP)",
                    url=url,
                    value=f"{lcp.get('display_value')}",
                    severity="high" if lcp.get('value') > 4000 else "medium",
                    details={"metric": "LCP", "value": lcp.get('value')}
                ))

            # Check CLS
            cls = lab_data.get('cls', {})
            if cls and cls.get('value') and cls.get('value') > 0.1:
                issues.append(SEOChecker.create_issue(
                    issue_type="cls_poor",
                    issue="High Cumulative Layout Shift (CLS)",
                    url=url,
                    value=f"{cls.get('display_value')}",
                    severity="high" if cls.get('value') > 0.25 else "medium",
                    details={"metric": "CLS", "value": cls.get('value')}
                ))

            # Check TBT (Total Blocking Time)
            tbt = lab_data.get('tbt', {})
            if tbt and tbt.get('value') and tbt.get('value') > 300:
                issues.append(SEOChecker.create_issue(
                    issue_type="performance_poor",
                    issue="High Total Blocking Time (TBT)",
                    url=url,
                    value=f"{tbt.get('display_value')}",
                    severity="high" if tbt.get('value') > 600 else "medium",
                    details={"metric": "TBT", "value": tbt.get('value')}
                ))

            # Process opportunities
            opportunities = result.get('opportunities', {})
            for opp_id, opp_data in opportunities.items():
                if opp_data.get('score', 1) < 0.9:  # Only report significant opportunities
                    # Map opportunity types to valid issue types
                    issue_type = "performance_poor"
                    if "render-blocking" in opp_id:
                        issue_type = "performance_render-blocking-resources"
                    elif "unoptimized-images" in opp_id:
                        issue_type = "performance_unoptimized-images"
                    elif "unused-css" in opp_id:
                        issue_type = "performance_unused-css"
                    elif "unused-javascript" in opp_id:
                        issue_type = "performance_unused-javascript"
                    elif "server-response-time" in opp_id:
                        issue_type = "performance_server-response-time"
                    
                    issues.append(SEOChecker.create_issue(
                        issue_type=issue_type,
                        issue=opp_data.get('title', 'Performance opportunity'),
                        url=url,
                        value=opp_data.get('display_value'),
                        severity="medium",
                        details={
                            "description": opp_data.get('description'),
                            "score": opp_data.get('score'),
                            "opportunity_id": opp_id
                        }
                    ))

            # Store the complete result in page_data
            page_data['pagespeed_data'] = result

        except Exception as e:
            logger.error(f"Error checking PageSpeed metrics for {url}: {str(e)}")
            issues.append(SEOChecker.create_issue(
                issue_type="pagespeed_error",
                issue="Error checking PageSpeed metrics",
                url=url,
                value=str(e),
                severity="high"
            ))
            # Store error in page_data
            page_data['pagespeed_data'] = {
                'status': 'error',
                'error': str(e)
            }

        return issues

================
File: apps/agents/tools/seo_crawler_tool/seo_crawler_tool.py
================
import asyncio
import logging
import json
from typing import Dict, List, Any, Optional, Type, Set, Literal, Union
from datetime import datetime
from urllib.parse import urljoin, urlparse, urlunparse
from bs4 import BeautifulSoup
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from celery import shared_task
from celery.contrib.abortable import AbortableTask
import aiohttp
import os
import time

from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from apps.crawl_website.models import CrawlResult
from apps.common.utils import normalize_url
from apps.agents.utils import URLDeduplicator

logger = logging.getLogger(__name__)

# Define valid page sections
PageSection = Literal[
    "url", "html", "text_content", "title", "meta_description", "meta_keywords", 
    "h1_tags", "links", "status_code", "content_type", "crawl_timestamp",
    "has_header", "has_nav", "has_main", "has_footer", "has_article", "has_section", "has_aside",
    "og_title", "og_description", "og_image",
    "canonical_url", "canonical_tags",
    "viewport",
    "images",
    "internal_links", "external_links"
]

class SEOCrawlerToolSchema(BaseModel):
    """Input schema for SEOCrawlerTool."""
    website_url: str = Field(
        ..., 
        title="Website URL",
        description="Website URL to crawl (e.g., https://example.com)"
    )
    max_pages: int = Field(
        default=100,
        title="Max Pages",
        description="Maximum number of pages to crawl"
    )
    respect_robots_txt: bool = Field(
        default=True,
        title="Respect Robots.txt",
        description="Whether to respect robots.txt rules"
    )
    crawl_delay: float = Field(
        default=1.0,
        title="Crawl Delay",
        description="Delay between requests in seconds"
    )
    sections: Optional[List[PageSection]] = Field(
        default=None,
        title="Sections to Return",
        description="List of page sections to include in results (default: all sections)"
    )

class SEOPage(BaseModel):
    """Represents a crawled page with SEO-relevant data."""
    url: str = Field(..., description="URL of the page")
    html: str = Field(..., description="Raw HTML content")
    text_content: str = Field(..., description="Extracted text content")
    title: str = Field(default="", description="Page title")
    meta_description: str = Field(default="", description="Meta description")
    meta_keywords: List[str] = Field(default_factory=list, description="Meta keywords")
    h1_tags: List[str] = Field(default_factory=list, description="H1 headings")
    links: Set[str] = Field(default_factory=set, description="All found links")
    status_code: int = Field(..., description="HTTP status code")
    content_type: str = Field(default="general", description="Content type")
    crawl_timestamp: str = Field(default_factory=lambda: datetime.now().isoformat(), description="When the page was crawled")
    # Semantic structure data
    has_header: bool = Field(default=False, description="Whether the page has a header")
    has_nav: bool = Field(default=False, description="Whether the page has a navigation")
    has_main: bool = Field(default=False, description="Whether the page has a main content area")
    has_footer: bool = Field(default=False, description="Whether the page has a footer")
    has_article: bool = Field(default=False, description="Whether the page has an article")
    has_section: bool = Field(default=False, description="Whether the page has a section")
    has_aside: bool = Field(default=False, description="Whether the page has an aside")
    # OpenGraph data
    og_title: Optional[str] = Field(default=None, description="OpenGraph title")
    og_description: Optional[str] = Field(default=None, description="OpenGraph description")
    og_image: Optional[str] = Field(default=None, description="OpenGraph image")
    # Canonical data
    canonical_url: Optional[str] = Field(default=None, description="Canonical URL")
    canonical_tags: List[str] = Field(default_factory=list, description="Canonical tags")
    # Viewport data
    viewport: Optional[str] = Field(default=None, description="Viewport meta tag")
    # Image data
    images: List[Dict[str, Any]] = Field(default_factory=list, description="Images with attributes")
    # Link categorization
    internal_links: Set[str] = Field(default_factory=set, description="Internal links")
    external_links: Set[str] = Field(default_factory=set, description="External links")

    model_config = {"arbitrary_types_allowed": True}

    def model_dump(self, **kwargs):
        """Override model_dump to ensure datetime is serialized."""
        data = super().model_dump(**kwargs)
        # Ensure crawl_timestamp is a string
        if isinstance(data['crawl_timestamp'], datetime):
            data['crawl_timestamp'] = data['crawl_timestamp'].isoformat()
        # Convert sets to lists for JSON serialization
        if 'links' in data and isinstance(data['links'], set):
            data['links'] = list(data['links'])
        if 'internal_links' in data and isinstance(data['internal_links'], set):
            data['internal_links'] = list(data['internal_links'])
        if 'external_links' in data and isinstance(data['external_links'], set):
            data['external_links'] = list(data['external_links'])
        return data
        
    def filtered_dump(self, sections: Optional[List[PageSection]] = None) -> Dict[str, Any]:
        """Return a filtered dictionary containing only the specified sections."""
        data = self.model_dump()
        
        # If no sections specified, return all data
        if not sections:
            return data
            
        # Filter data to include only requested sections
        return {key: value for key, value in data.items() if key in sections}

class SEOCrawlerToolConfig(BaseModel):
    """Configuration model for SEOCrawlerTool."""
    max_pages: int = Field(default=100, description="Maximum number of pages to crawl")
    max_concurrent: int = Field(default=5, description="Maximum number of concurrent requests")
    visited_urls: Set[str] = Field(default_factory=set, description="Set of visited URLs")
    found_links: Set[str] = Field(default_factory=set, description="Set of links found during crawling")
    pages: List[SEOPage] = Field(default_factory=list, description="List of crawled pages")
    url_deduplicator: URLDeduplicator = Field(default_factory=URLDeduplicator, description="URL deduplication utility")
    crawl_tool: CrawlWebsiteTool = Field(default_factory=CrawlWebsiteTool, description="Crawl tool for making requests")
    page_callback: Optional[Any] = Field(default=None, description="Callback function for processing pages")

    model_config = {"arbitrary_types_allowed": True}

class SEOCrawlerTool(BaseTool):
    """Tool for crawling websites and extracting SEO-relevant information."""
    name: str = "seo_crawler"
    description: str = "Tool for crawling websites and extracting SEO-relevant information"
    args_schema: Type[SEOCrawlerToolSchema] = SEOCrawlerToolSchema
    config: SEOCrawlerToolConfig = Field(default_factory=SEOCrawlerToolConfig)
    
    def __init__(self, **data):
        super().__init__(**data)
        self._semaphore = None
        # Ensure tools are initialized
        if not self.config.url_deduplicator:
            self.config.url_deduplicator = URLDeduplicator()
        if not self.config.crawl_tool:
            self.config.crawl_tool = CrawlWebsiteTool()

    @property
    def semaphore(self) -> Optional[asyncio.Semaphore]:
        return self._semaphore
        
    @semaphore.setter
    def semaphore(self, value: Optional[asyncio.Semaphore]):
        self._semaphore = value

    async def _async_run(
        self,
        website_url: str,
        max_pages: Optional[int] = None,
        max_concurrent: Optional[int] = None,
        respect_robots_txt: bool = True,
        crawl_delay: float = 1.0,
        progress_callback = None,
        page_callback = None,
        sections: Optional[Union[List[PageSection], str]] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """Run the crawler asynchronously."""
        # Convert sections from string to list if provided as a string
        if sections and isinstance(sections, str):
            try:
                sections = json.loads(sections)
            except json.JSONDecodeError:
                logger.warning(f"Failed to parse sections parameter: {sections}. Using all sections.")
                sections = None
                
        if max_pages is not None:
            self.config.max_pages = max_pages
        if max_concurrent is not None:
            self.config.max_concurrent = max_concurrent
        
        self.semaphore = asyncio.Semaphore(self.config.max_concurrent)
        self.config.page_callback = page_callback
        
        return await self._async_crawl(
            website_url=website_url,
            max_pages=self.config.max_pages,
            respect_robots_txt=respect_robots_txt,
            crawl_delay=crawl_delay,
            progress_callback=progress_callback,
            sections=sections
        )

    def _run(
        self,
        website_url: str,
        max_pages: Optional[int] = None,
        max_concurrent: Optional[int] = None,
        respect_robots_txt: bool = True,
        crawl_delay: float = 1.0,
        progress_callback = None,
        page_callback = None,
        sections: Optional[Union[List[PageSection], str]] = None,
        **kwargs
    ) -> Dict[str, Any]:
        """Run the crawler synchronously."""
        # Convert sections from string to list if provided as a string
        if sections and isinstance(sections, str):
            try:
                sections = json.loads(sections)
            except json.JSONDecodeError:
                logger.warning(f"Failed to parse sections parameter: {sections}. Using all sections.")
                sections = None
                
        # Create a new event loop if one doesn't exist
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
        
        try:
            return loop.run_until_complete(
                self._async_run(
                    website_url=website_url,
                    max_pages=max_pages,
                    max_concurrent=max_concurrent,
                    respect_robots_txt=respect_robots_txt,
                    crawl_delay=crawl_delay,
                    progress_callback=progress_callback,
                    page_callback=page_callback,
                    sections=sections,
                    **kwargs
                )
            )
        finally:
            # Clean up the event loop if we created it
            if not loop.is_running():
                loop.close()

    async def _async_crawl(
        self,
        website_url: str,
        max_pages: int,
        respect_robots_txt: bool,
        crawl_delay: float,
        progress_callback = None,
        sections: Optional[List[PageSection]] = None
    ) -> Dict[str, Any]:
        """Crawl the website asynchronously."""
        start_time = datetime.now()
        
        logger.info(f"Starting _async_crawl with max_pages: {max_pages}")
        
        # Ensure website_url has protocol
        if not website_url.startswith(('http://', 'https://')):
            website_url = 'https://' + website_url
            
        # IMPORTANT: Clear state to ensure we start fresh
        self.config.visited_urls = set()
        self.config.pages = []
        self.config.found_links = set()
        
        # Initialize with the start URL
        self.config.found_links.add(website_url)
        
        # Safety counter to prevent infinite loops
        iterations = 0
        max_iterations = max(100, max_pages * 2)
        
        # Error tracking to stop on consecutive failures
        consecutive_errors = 0
        max_consecutive_errors = 3
        
        while len(self.config.visited_urls) < max_pages and self.config.found_links and iterations < max_iterations:
            iterations += 1
            logger.info(f"Crawl iteration {iterations}/{max_iterations}")
            
            # Safety check - stop if we've reached max_pages
            if len(self.config.visited_urls) >= max_pages:
                logger.info(f"Reached max_pages ({max_pages}), stopping crawl")
                break
                
            # Get next batch of URLs to process
            batch_size = min(self.config.max_concurrent, max_pages - len(self.config.visited_urls))
            if batch_size <= 0:
                logger.info(f"No more capacity to crawl pages (visited: {len(self.config.visited_urls)}, max: {max_pages})")
                break
                
            batch_urls = set(list(self.config.found_links)[:batch_size])
            self.config.found_links -= batch_urls
            
            logger.info(f"Crawl loop: visited_urls count: {len(self.config.visited_urls)}, max_pages: {max_pages}, found_links: {len(self.config.found_links)}")
            logger.info(f"Processing batch of {len(batch_urls)} URLs: {batch_urls}")
            
            # Process batch concurrently
            tasks = []
            for url in batch_urls:
                if url not in self.config.visited_urls and len(self.config.visited_urls) < max_pages:
                    tasks.append(self._process_url(url))
                else:
                    logger.info(f"Skipping URL {url}, already visited or at max_pages limit")
            
            if tasks:
                # Use wait instead of gather to not block if a task hangs
                done, pending = await asyncio.wait(tasks, timeout=30)
                
                # Track success/failure for this batch
                successful_pages = 0
                
                if pending:
                    logger.warning(f"{len(pending)} tasks timed out and will be cancelled")
                    for task in pending:
                        task.cancel()
                
                # Check the results from done tasks
                for task in done:
                    try:
                        result = task.result()
                        if result is not None:
                            successful_pages += 1
                    except Exception as e:
                        logger.error(f"Error in task: {str(e)}", exc_info=True)
                
                # If no pages were successfully processed in this batch, increment consecutive errors
                if successful_pages == 0 and len(tasks) > 0:
                    consecutive_errors += 1
                    logger.warning(f"No pages successfully processed in this batch. Consecutive errors: {consecutive_errors}")
                    if consecutive_errors >= max_consecutive_errors:
                        logger.error(f"Too many consecutive errors ({consecutive_errors}), stopping crawl")
                        break
                else:
                    # Reset consecutive errors on success
                    consecutive_errors = 0
                
                await asyncio.sleep(crawl_delay)  # Respect crawl delay between batches

                # Send progress update
                if progress_callback:
                    pages_analyzed = len(self.config.visited_urls)
                    percent_complete = min(100, int((pages_analyzed / max_pages) * 100))
                    total_links = len(self.config.visited_urls) + len(self.config.found_links)
                    progress_callback({
                        'percent_complete': percent_complete,
                        'pages_analyzed': pages_analyzed,
                        'total_links': total_links,
                        'status': f'Page {pages_analyzed} of {max_pages}...',
                        'current_url': list(batch_urls)[-1] if batch_urls else None,
                        'new_links_found': len(self.config.found_links),
                        'remaining_urls': len(self.config.found_links)
                    })
            
            # Extra safety check - stop if we've reached max_pages
            if len(self.config.visited_urls) >= max_pages:
                logger.info(f"Reached max_pages ({max_pages}) after processing batch, stopping crawl")
                break

        logger.info(f"Crawl loop completed. Final visited_urls count: {len(self.config.visited_urls)}, max_pages: {max_pages}")

        # Prepare results
        end_time = datetime.now()
        return {
            "pages": [page.filtered_dump(sections) for page in self.config.pages],
            "total_pages": len(self.config.pages),
            "total_links": len(self.config.visited_urls),
            "crawl_time_seconds": (end_time - start_time).total_seconds(),
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "visited_urls": list(self.config.visited_urls),
            "remaining_urls": list(self.config.found_links),
            "timestamp": datetime.now().isoformat()  # Add timestamp for consistency
        }

    async def _process_url(self, url: str, parent_url: Optional[str] = None) -> Optional[SEOPage]:
        """Process a single URL and return a SEOPage object."""
        if not url or not self.config.url_deduplicator.should_process_url(url):
            logger.info(f"URL not processable: {url}")
            return None
            
        # Normalize early to prevent duplicate processing
        normalized_url = self.config.url_deduplicator.canonicalize_url(url)
        
        # Check if we've already visited this URL
        if normalized_url in self.config.visited_urls:
            logger.info(f"URL already visited, skipping: {normalized_url}")
            return None
            
        # Mark URL as visited early to prevent duplicates in concurrent processing
        self.config.visited_urls.add(normalized_url)
        logger.info(f"Added URL to visited_urls: {normalized_url} (count now: {len(self.config.visited_urls)})")
            
        # Check if URL points to an image or media file
        async with self.semaphore:
            if self._is_media_url(url):
                logger.info(f"Skipping media URL: {url}")
                return None

            logger.info(f"Processing URL: {url} (normalized: {normalized_url})")

            try:
                # Add a timeout for the crawl_tool._run call
                try:
                    # Use asyncio.wait_for to add a timeout to the to_thread operation
                    result = await asyncio.wait_for(
                        asyncio.to_thread(
                            self.config.crawl_tool._run,
                            website_url=normalized_url,
                            user_id=1,  # TODO: Pass user_id properly
                            max_pages=1,
                            max_depth=0,
                            output_type="full"
                        ),
                        timeout=60  # 60 second timeout for page processing
                    )
                except asyncio.TimeoutError:
                    logger.error(f"Timeout processing URL {normalized_url} after 60 seconds")
                    return None
                
                if isinstance(result, dict):
                    data = result
                else:
                    try:
                        data = json.loads(result)
                    except json.JSONDecodeError as e:
                        logger.error(f"Failed to parse result for {normalized_url}: {result[:100]}...", exc_info=True)
                        return None
                
                if data.get("status") != "success" or not data.get("results"):
                    logger.warning(f"Failed to get content for {normalized_url}")
                    return None

                # Handle different possible response structures
                page_data = None
                if isinstance(data.get("results"), list) and data["results"]:
                    if isinstance(data["results"][0], dict):
                        page_data = data["results"][0].get("content", {})
                elif isinstance(data.get("result"), dict):
                    page_data = data["result"].get("content", {})
                
                if not page_data:
                    logger.warning(f"Invalid page data structure for {normalized_url}")
                    return None

                html_content = page_data.get("html", "")
                if not isinstance(html_content, str):
                    if html_content is None:
                        html_content = ""
                    else:
                        try:
                            html_content = str(html_content)
                        except Exception as e:
                            logger.error(f"Error converting HTML content to string for {normalized_url}: {str(e)}")
                            return None

                metadata = page_data.get("metadata", {})
                
                # Parse HTML to extract additional data
                try:
                    soup = BeautifulSoup(html_content, 'lxml')
                except Exception as e:
                    logger.error(f"Error parsing HTML for {normalized_url}: {str(e)}")
                    return None
                
                # Extract text content from HTML
                text_content = " ".join(soup.stripped_strings)
                
                # Extract h1 tags
                h1_tags = [h1.get_text(strip=True) for h1 in soup.find_all('h1')]
                
                # Determine content type based on HTML structure
                content_type = "general"
                if soup.find('article'):
                    content_type = "article"
                elif soup.find(['form', 'input']):
                    content_type = "form"
                elif soup.find(['table', 'tbody']):
                    content_type = "data"

                # Extract semantic structure data
                has_header = bool(soup.find('header'))
                has_nav = bool(soup.find('nav'))
                has_main = bool(soup.find('main'))
                has_footer = bool(soup.find('footer'))
                has_article = bool(soup.find('article'))
                has_section = bool(soup.find('section'))
                has_aside = bool(soup.find('aside'))

                # Extract OpenGraph tags
                og_title = soup.find('meta', property='og:title')
                og_description = soup.find('meta', property='og:description')
                og_image = soup.find('meta', property='og:image')

                # Extract canonical URL
                canonical_tag = soup.find('link', rel='canonical')
                canonical_url = canonical_tag['href'] if canonical_tag else None
                # Extract all canonical tag URLs as strings
                canonical_tag_objects = soup.find_all('link', rel='canonical')
                canonical_tag_urls = [tag['href'] for tag in canonical_tag_objects if tag.get('href')] # Extract hrefs
                
                # Extract viewport meta tag
                viewport = soup.find('meta', attrs={'name': 'viewport'})
                
                # Extract images with their attributes
                images = []
                for img in soup.find_all('img'):
                    image_data = {
                        "src": img.get('src', ''),
                        "alt": img.get('alt', ''),
                        "width": img.get('width', ''),
                        "height": img.get('height', ''),
                        "title": img.get('title', ''),
                        "loading": img.get('loading', ''),
                        "srcset": img.get('srcset', ''),
                        "size": 0  # Will be populated for local images
                    }
                    
                    # Normalize image URL
                    if image_data["src"]:
                        image_data["src"] = urljoin(url, image_data["src"])
                    
                    images.append(image_data)
                
                # Extract all links and categorize them
                base_domain = urlparse(normalized_url).netloc
                internal_links = set()
                external_links = set()
                
                for a in soup.find_all('a', href=True):
                    href = a["href"].strip()
                    try:
                        # Skip empty, javascript, mailto, tel links
                        if not href or href.startswith(('javascript:', 'mailto:', 'tel:', '#', 'data:', 'file:', 'about:')):
                            continue
                            
                        # Convert to absolute URL
                        absolute_url = urljoin(normalized_url, href)
                        parsed_url = urlparse(absolute_url)
                        
                        # Categorize as internal or external
                        if parsed_url.netloc == base_domain:
                            if self.config.url_deduplicator.should_process_url(absolute_url):
                                internal_links.add(absolute_url)
                        else:
                            external_links.add(absolute_url)
                            
                    except Exception as e:
                        logger.warning(f"Error processing link {href}: {str(e)}")

                # Update found_links with internal links
                self.config.found_links.update(internal_links)
                logger.info(f"Added {len(internal_links)} new internal links from {normalized_url}")

                # Create SEOPage object with enhanced data
                page = SEOPage(
                    url=normalized_url,
                    html=html_content,
                    text_content=text_content,
                    title=metadata.get("title") or "",
                    meta_description=metadata.get("description") or "",
                    meta_keywords=metadata.get("keywords", "").split(",") if metadata.get("keywords") else [],
                    h1_tags=h1_tags,
                    links=internal_links | external_links,  # Combine internal and external links
                    status_code=page_data.get("status_code", 200),
                    content_type=content_type,
                    crawl_timestamp=datetime.now().isoformat(),
                    # Add semantic structure data
                    has_header=has_header,
                    has_nav=has_nav,
                    has_main=has_main,
                    has_footer=has_footer,
                    has_article=has_article,
                    has_section=has_section,
                    has_aside=has_aside,
                    # Add OpenGraph data
                    og_title=og_title.get('content') if og_title else None,
                    og_description=og_description.get('content') if og_description else None,
                    og_image=og_image.get('content') if og_image else None,
                    # Add canonical data
                    canonical_url=canonical_url,
                    canonical_tags=canonical_tag_urls, # Pass the list of strings
                    # Add viewport data
                    viewport=viewport.get('content') if viewport else None,
                    # Add image data
                    images=images,
                    # Add link categorization
                    internal_links=internal_links,
                    external_links=external_links
                )

                # Store the page
                self.config.pages.append(page)
                logger.info(f"Page processed and added to results: {normalized_url}")
                
                # Call the page callback if provided
                if hasattr(self.config, 'page_callback') and self.config.page_callback:
                    try:
                        processed_page = self.config.page_callback(page)
                        if processed_page:
                            page = processed_page
                    except Exception as e:
                        logger.error(f"Error in page callback for {normalized_url}: {str(e)}")
                
                return page

            except Exception as e:
                logger.error(f"Error processing URL {normalized_url}: {str(e)}", exc_info=True)
                return None

    def _is_media_url(self, url: str) -> bool:
        """Check if a URL points to an image or media file."""
        parsed_url = urlparse(url)
        path = parsed_url.path.lower()
        return any(path.endswith(ext) for ext in [
            '.jpg', '.jpeg', '.png', '.gif', '.svg', 
            '.webp', '.ico', '.pdf', '.mp4', '.webm'
        ])

    def _get_meta_content(self, soup: BeautifulSoup, name: str) -> str:
        """Extract content from a meta tag."""
        meta = soup.find("meta", attrs={"name": name})
        return meta.get("content", "") if meta else ""

    def _extract_links(self, base_url: str, html_content: str) -> List[str]:
        """Extract and normalize all links from the page."""
        links = set()  # Use a set to avoid duplicates
        base_domain = urlparse(base_url).netloc
        normalized_base = normalize_url(base_url)
        
        soup = BeautifulSoup(html_content, 'lxml')
        
        for a in soup.find_all("a", href=True):
            href = a["href"].strip()
            try:
                # Skip empty, javascript, mailto, tel links
                if not href or href.startswith(('javascript:', 'mailto:', 'tel:', '#', 'data:', 'file:', 'about:')):
                    continue
                    
                # Convert to absolute URL
                absolute_url = urljoin(normalized_base, href)
                normalized_url = normalize_url(absolute_url)
                parsed_url = urlparse(normalized_url)
                
                # Only include http(s) URLs from the same domain
                if (parsed_url.scheme in ('http', 'https') and 
                    parsed_url.netloc == base_domain):
                    # Normalize URL
                    links.add(normalized_url)
                    
            except Exception as e:
                logger.warning(f"Error processing link {href}: {str(e)}")
                
        return list(links)

    async def _process_page(self, url: str, html_content: str, status_code: int) -> Dict[str, Any]:
        """Process a single page and extract relevant information."""
        soup = BeautifulSoup(html_content, 'html.parser')
        
        # Extract images with their attributes
        images = []
        for img in soup.find_all('img'):
            image_data = {
                "src": img.get('src', ''),
                "alt": img.get('alt', ''),
                "width": img.get('width', ''),
                "height": img.get('height', ''),
                "title": img.get('title', ''),
                "loading": img.get('loading', ''),
                "srcset": img.get('srcset', ''),
                "size": 0  # Will be populated for local images
            }
            
            # Normalize image URL
            if image_data["src"]:
                image_data["src"] = urljoin(url, image_data["src"])
                
                # Get image size if it's from the same domain
                if urlparse(image_data["src"]).netloc == urlparse(url).netloc:
                    try:
                        async with aiohttp.ClientSession() as session:
                            async with session.head(image_data["src"]) as response:
                                if response.status == 200:
                                    image_data["size"] = int(response.headers.get('content-length', 0))
                    except Exception as e:
                        logger.warning(f"Failed to get image size for {image_data['src']}: {str(e)}")
            
            images.append(image_data)

        # Extract existing data
        title = soup.title.string.strip() if soup.title else ""
        meta_desc = ""
        meta_desc_tag = soup.find('meta', attrs={'name': 'description'})
        if meta_desc_tag:
            meta_desc = meta_desc_tag.get('content', '').strip()

        h1_tags = [h1.get_text().strip() for h1 in soup.find_all('h1')]
        
        # Extract links
        links = []
        for link in soup.find_all('a'):
            href = link.get('href')
            if href:
                absolute_url = urljoin(url, href)
                if self._should_include_url(absolute_url):
                    links.append(absolute_url)

        # Get text content
        text_content = ' '.join([
            p.get_text().strip()
            for p in soup.find_all(['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'])
        ])

        return {
            "url": url,
            "title": title,
            "meta_description": meta_desc,
            "h1_tags": h1_tags,
            "links": links,
            "images": images,  # Add images to the return data
            "text_content": text_content,
            "status_code": status_code,
            "crawl_timestamp": datetime.now().isoformat()
        }

@shared_task(bind=True, base=AbortableTask, time_limit=600, soft_time_limit=540)
def crawl_website_task(self, website_url: str, user_id: int, max_pages: int = 100, sections: Optional[Union[List[str], str]] = None) -> Optional[int]:
    """Celery task to run the crawler asynchronously."""
    logger.info(f"Starting crawl task for {website_url} with max_pages={max_pages}, sections={sections}")
    
    start_time = time.time()
    
    # Convert sections from string to list if provided as a string
    if sections and isinstance(sections, str):
        try:
            sections = json.loads(sections)
            logger.info(f"Parsed sections from string: {sections}")
        except json.JSONDecodeError:
            logger.warning(f"Failed to parse sections parameter: {sections}. Using all sections.")
            sections = None
    
    crawler = SEOCrawlerTool()
    try:
        logger.info(f"Executing crawler with website_url={website_url}, max_pages={max_pages}, sections={sections}")
        result = crawler._run(website_url, max_pages=max_pages, sections=sections)
        
        visited_count = len(crawler.config.visited_urls)
        logger.info(f"Crawl completed. Visited {visited_count} pages out of max {max_pages}")
        
        # Create CrawlResult
        crawl_result = CrawlResult.objects.create(
            user_id=user_id,
            website_url=website_url,
            content=result["pages"],
            links_visited=list(crawler.config.visited_urls),
            total_links=result["total_links"],
            links_to_visit=list(crawler.config.found_links)
        )
        
        elapsed_time = time.time() - start_time
        logger.info(f"Crawl completed for {website_url} in {elapsed_time:.2f} seconds, created CrawlResult with ID {crawl_result.id}")
        return crawl_result.id
        
    except Exception as e:
        elapsed_time = time.time() - start_time
        logger.error(f"Error during crawl after {elapsed_time:.2f} seconds: {str(e)}", exc_info=True)
        return None

================
File: apps/agents/tools/sitemap_retriever_tool/__init__.py
================
from .sitemap_retriever_tool import SitemapRetrieverTool

__all__ = ['SitemapRetrieverTool']

================
File: apps/agents/tools/sitemap_retriever_tool/sitemap_retriever_tool.py
================
from typing import Type, Optional, List, Dict, Any, Set, ClassVar, Tuple, Callable
from pydantic import BaseModel, Field, field_validator, AnyHttpUrl
from apps.agents.tools.base_tool import BaseTool
import json
import logging
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse, urlunparse
import xml.etree.ElementTree as ET
import csv
import io
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from requests.exceptions import RequestException, Timeout, ConnectionError
import time
import threading
from apps.agents.utils.rate_limited_fetcher import RateLimitedFetcher
from urllib.robotparser import RobotFileParser

logger = logging.getLogger(__name__)

class SitemapRetrieverSchema(BaseModel):
    """Input schema for the Sitemap Retriever Tool."""
    url: AnyHttpUrl = Field(
        ...,
        description="The starting URL of the website (e.g., 'https://example.com')."
    )
    user_id: int = Field(
        ...,
        description="ID of the user initiating the request (for logging/tracking)."
    )
    max_pages: int = Field(
        100,
        description="Maximum number of URLs to return. Applies to both sitemap parsing and crawling.",
        gt=0
    )
    requests_per_second: float = Field(
        5.0,
        description="Maximum desired requests per second. Will be lowered if robots.txt Crawl-delay is stricter.",
        gt=0
    )

    # Pydantic automatically validates AnyHttpUrl and numeric constraints (gt=0)
    model_config = {
        "arbitrary_types_allowed": True,
        "extra": "forbid"
    }

class SitemapRetrieverTool(BaseTool):
    """
    Retrieves website URLs by first searching for and parsing sitemaps (XML or TXT).
    Respects robots.txt directives (Sitemap, Crawl-delay).
    If no sitemaps are found or they yield no URLs, falls back to crawling the site.
    Limits the number of returned URLs via max_pages.
    Uses RateLimitedFetcher for network requests.
    """
    name: str = "Sitemap Retriever Tool"
    description: str = (
        "Finds and parses website sitemaps (robots.txt, common paths) or crawls "
        "the site to retrieve a list of URLs, respecting robots.txt rules and rate limits. "
        "Specify the website's starting URL."
    )
    args_schema: Type[BaseModel] = SitemapRetrieverSchema

    # --- Constants ---
    TIMEOUT: ClassVar[int] = 15  # Increased timeout for potentially slow sites
    MAX_WORKERS_SITEMAP_CHECK: ClassVar[int] = 5
    DEFAULT_USER_AGENT: ClassVar[str] = "NeuralAMI-Agent/1.0"
    COMMON_SITEMAP_PATHS: ClassVar[List[str]] = [
        "sitemap.xml",          # Standard sitemap location
        "sitemap_index.xml",    # Common WordPress/RankMath/Yoast index
        "sitemap/",             # Sitemap directory
        "sitemap1.xml",         # Numbered sitemap
        "post-sitemap.xml",     # Content type specific sitemap (WordPress/RankMath)
        "page-sitemap.xml",     # Content type specific sitemap (WordPress/RankMath)
        "category-sitemap.xml", # Category specific sitemap (WordPress/RankMath)
        "sitemapindex.xml",     # Alternative index naming
        "sitemap-index.xml",    # Alternative index naming with hyphen
        "sitemap.php",          # Dynamic sitemap
        "sitemap.txt",          # Text-based sitemap
        "sitemap.xml.gz",       # Gzipped XML sitemap
        "sitemap_index.xml.gz"  # Gzipped XML sitemap index
    ]
    SITEMAP_XML_NAMESPACE: ClassVar[Dict[str, str]] = {'ns': 'http://www.sitemaps.org/schemas/sitemap/0.9'}

    # --- Rate Limiting State - REMOVED ---
    # Rate limiting state and methods (_get_domain_lock, _init_rate_limiting, _apply_rate_limit)
    # are now fully handled by the RateLimitedFetcher class.

    # --- Fetching Logic ---
    # REMOVED _fetch_url - RateLimitedFetcher.fetch_url is used directly.

    # --- Sitemap Discovery Logic ---
    # --- Sitemap Discovery Logic ---
    def _check_robots(self, base_url: str, domain: str) -> Tuple[Set[str], Optional[float]]:
        """Fetches and parses robots.txt using RateLimitedFetcher.

        Uses urllib.robotparser for sitemaps.
        Includes a robust manual check for crawl-delay for the '*' agent,
        handling cases where it's not the first directive on the line.
        Returns a set of sitemap URLs found and the crawl delay (float) for the '*' agent, or None.
        Does NOT initialize rate limiting itself.
        """
        robots_url_http = urlunparse(urlparse(base_url)._replace(scheme='http', path='robots.txt', query='', fragment=''))
        robots_url_https = urlunparse(urlparse(base_url)._replace(scheme='https', path='robots.txt', query='', fragment=''))
        sitemap_urls = set()
        crawl_delay = None
        found_authoritative_robots = False
        checked_urls = set()

        for robots_url in [robots_url_https, robots_url_http]:
            if robots_url in checked_urls:
                continue
            checked_urls.add(robots_url)
            # Stop checking (e.g. http) if we successfully parsed one (e.g. https) AND found a delay
            if found_authoritative_robots and crawl_delay is not None:
                break

            logger.debug(f"Checking robots.txt at: {robots_url}")
            response_data = RateLimitedFetcher.fetch_url(robots_url)

            if response_data["success"] and response_data["content"] is not None:
                logger.debug(f"Successfully fetched robots.txt content from {robots_url}")
                robots_content = response_data["content"]
                parser = RobotFileParser()
                manual_crawl_delay = None
                current_agent_is_wildcard = False # Track state across lines

                # 1. Manual check for wildcard crawl-delay and sitemaps
                try:
                    lines = robots_content.splitlines()
                    for line in lines:
                        line = line.strip()
                        if not line or line.startswith('#'): continue

                        line_lower = line.lower()
                        # Check for User-agent change first
                        if line_lower.startswith('user-agent:'):
                            value_part = line.split(':', 1)[-1].strip()
                            # Take only the first part before any space (potential directive)
                            agent = value_part.split(None, 1)[0].strip()
                            current_agent_is_wildcard = (agent == '*')
                            # Don't continue; check current line for delay/sitemap

                        # Check for crawl-delay IF we are in the wildcard block
                        if current_agent_is_wildcard:
                            directive_key_cd = 'crawl-delay:'
                            idx_cd = line_lower.find(directive_key_cd)
                            if idx_cd != -1:
                                # Extract the part after 'crawl-delay:'
                                value_part_cd = line[idx_cd + len(directive_key_cd):].lstrip()
                                try:
                                    # Split by whitespace and take the first part (the number)
                                    value_str_cd = value_part_cd.split(None, 1)[0]
                                    delay = float(value_str_cd)
                                    if delay > 0:
                                        # Check if this is the first delay found OR if it's stricter (smaller value) than a previously found one
                                        # Note: Robot standard typically uses first match, but stricter seems safer if multiple exist. Let's stick to first found for now.
                                        if manual_crawl_delay is None: # Only assign if not already found in this file
                                            manual_crawl_delay = delay
                                            logger.info(f"Manually found crawl-delay: {manual_crawl_delay}s for '*' in {robots_url} (Line: '{line}')")
                                            # Don't break, might find Sitemap on same line or later lines
                                    else:
                                         logger.debug(f"Ignoring non-positive manual crawl-delay value: {value_str_cd} from line '{line}'")
                                except (ValueError, TypeError, IndexError) as e:
                                    logger.warning(f"Could not parse manual crawl-delay value after '{directive_key_cd}' from line '{line}'. Error: {e}")

                        # Check for Sitemap directive (can appear under any user-agent or globally)
                        directive_key_sm = 'sitemap:'
                        idx_sm = line_lower.find(directive_key_sm)
                        if idx_sm != -1:
                            value_part_sm = line[idx_sm + len(directive_key_sm):].lstrip()
                            # Sitemap URL might have spaces if other directives follow, take everything until likely end
                            sitemap_path = value_part_sm.split(None, 1)[0].strip() # Take first part
                            if sitemap_path:
                                try:
                                    # Resolve relative path against the base URL of the robots.txt file itself
                                    absolute_sitemap_url = urljoin(robots_url, sitemap_path)
                                    parsed_sitemap_url = urlparse(absolute_sitemap_url)
                                    # Basic validation: needs scheme and netloc
                                    if parsed_sitemap_url.scheme and parsed_sitemap_url.netloc:
                                         logger.info(f"Manually found Sitemap directive: {absolute_sitemap_url} in {robots_url} (Line: '{line}')")
                                         sitemap_urls.add(absolute_sitemap_url)
                                    else:
                                         logger.warning(f"Ignoring manually found invalid sitemap URL: '{sitemap_path}' derived from line '{line}' in {robots_url}")

                                except Exception as e:
                                     logger.warning(f"Error processing manually found sitemap URL '{sitemap_path}' from line '{line}' in {robots_url}: {e}")
                            else:
                                logger.warning(f"Found '{directive_key_sm}' but no value on line '{line}' in {robots_url}")


                    if sitemap_urls:
                         logger.debug(f"Manual check for {robots_url} found sitemaps: {sitemap_urls}")


                except Exception as e:
                    logger.error(f"Error during manual robots.txt parsing: {e}", exc_info=True)

                # 2. Use standard parser for sitemaps (as fallback/confirmation) and delay (only if manual failed)
                try:
                    # Re-initialize parser for each file's content
                    parser = RobotFileParser()
                    parser.parse(io.StringIO(robots_content).readlines())
                    found_authoritative_robots = True # Mark this file as successfully parsed

                    # Get sitemaps using parser (confirm/add to manually found ones)
                    parser_sitemaps = parser.site_maps()
                    if parser_sitemaps:
                        sitemaps_found_by_parser = set(parser_sitemaps)
                        newly_found_by_parser = sitemaps_found_by_parser - sitemap_urls # Find only those not found manually
                        if newly_found_by_parser:
                             logger.info(f"Parser found {len(newly_found_by_parser)} additional sitemap(s) in {robots_url}: {newly_found_by_parser}")
                             sitemap_urls.update(newly_found_by_parser)
                        else:
                             logger.debug(f"Parser confirmed sitemaps already found manually or found none in {robots_url}")
                    else:
                        logger.debug(f"Parser found no sitemap directives in {robots_url}")

                    # Get crawl delay from parser (only if manual check failed)
                    if manual_crawl_delay is None:
                        parser_crawl_delay_val = parser.crawl_delay('*')
                        if parser_crawl_delay_val is not None:
                            try:
                                parsed_delay_float = float(parser_crawl_delay_val)
                                if parsed_delay_float > 0:
                                     logger.debug(f"Parser found crawl-delay: {parsed_delay_float}s for agent '*' in {robots_url}")
                                     manual_crawl_delay = parsed_delay_float # Use parser's value as final
                                     logger.info("Using parser's crawl-delay as manual check failed.")
                                else:
                                     logger.debug(f"Ignoring non-positive parser crawl-delay: {parser_crawl_delay_val}")
                            except (ValueError, TypeError):
                                 logger.warning(f"Could not parse parser crawl-delay value '{parser_crawl_delay_val}' from {robots_url}")
                        else:
                            logger.debug(f"Parser also did not find crawl-delay directive for agent '*' in {robots_url}")


                except Exception as e:
                    logger.error(f"Error parsing robots.txt content from {robots_url} with urllib.robotparser: {e}", exc_info=True)
                    # Continue to next URL if parsing fails, keep manually found delay

                # Prioritize the delay found (manual first, then parser) from this file
                if manual_crawl_delay is not None:
                    crawl_delay = manual_crawl_delay


            elif response_data.get("status_code") != 404:
                 logger.warning(f"Failed to fetch {robots_url}: Status={response_data.get('status_code')}, Error={response_data.get('error')}")

        # Final log after checking URLs
        if not crawl_delay:
             logger.info(f"No valid crawl-delay found for agent '*' after checking robots.txt.")

        logger.info(f"_check_robots finished. Found {len(sitemap_urls)} sitemaps. Final Crawl-delay: {crawl_delay}")
        return sitemap_urls, crawl_delay

    def _check_common_paths(self, base_url: str, domain: str) -> Set[str]:
        """Checks common sitemap paths concurrently using RateLimitedFetcher."""
        common_urls_to_check = {urljoin(base_url, path) for path in self.COMMON_SITEMAP_PATHS}
        found_sitemaps = set()
        logger.info(f"Checking {len(common_urls_to_check)} common sitemap paths for {base_url}...")

        # Use ThreadPoolExecutor for concurrent checks
        # Note: RateLimiterFetcher handles domain-level locking internally
        with ThreadPoolExecutor(max_workers=self.MAX_WORKERS_SITEMAP_CHECK) as executor:
            future_to_url = {executor.submit(RateLimitedFetcher.fetch_url, url): url for url in common_urls_to_check}
            for future in as_completed(future_to_url):
                url = future_to_url[future]
                try:
                    result = future.result()
                    # Check for success and valid content type (XML or TXT)
                    if result["success"]:
                        content_type = result.get("content_type", "").lower()
                        # Basic check for XML/TXT content types or file extensions
                        is_xml = 'xml' in content_type or url.endswith(('.xml', '.xml.gz'))
                        is_txt = 'text/plain' in content_type or url.endswith(('.txt', '.txt.gz'))

                        if is_xml or is_txt:
                            logger.debug(f"Found potential sitemap at common path: {url}")
                            found_sitemaps.add(result["final_url"]) # Use final URL after redirects
                        else:
                            logger.debug(f"Skipping common path {url} due to unexpected content type: {content_type}")
                    # Log errors for common paths if not 404
                    elif result.get("status_code") != 404:
                         logger.warning(f"Error checking common path {url}: HTTP {result.get('status_code', 'N/A')} - {result.get('error', 'Unknown error')}")

                except Exception as e:
                    logger.error(f"Exception checking common path {url}: {e}", exc_info=True)

        logger.info(f"Common path check finished for {base_url}. Found {len(found_sitemaps)} potential sitemaps.")
        return found_sitemaps

    # REMOVED _find_sitemap_urls METHOD

    def _parse_single_sitemap(self, sitemap_url: str, domain: str, processed_locs: Set[str], max_pages: int, current_url_count: int) -> Tuple[List[Dict[str, Any]], List[str]]:
        """Parses a single sitemap URL (XML or TXT) or sitemap index."""
        logger.debug(f"Parsing sitemap: {sitemap_url}")
        page_urls = []
        child_sitemap_urls = []

        if current_url_count >= max_pages:
            return page_urls, child_sitemap_urls # Stop early if max_pages reached

        # Fetch sitemap content using RateLimitedFetcher
        result = RateLimitedFetcher.fetch_url(sitemap_url) # Ensure this uses the class method

        if not result["success"] or result["content"] is None:
            logger.warning(f"Failed to fetch sitemap content from {sitemap_url}: {result.get('error')}")
            return page_urls, child_sitemap_urls

        content = result["content"]
        content_type = result.get("content_type", "").lower()
        final_url = result["final_url"] # Use final URL

        # Determine parsing strategy based on content type or URL
        is_xml = 'xml' in content_type or final_url.endswith(('.xml', '.xml.gz'))
        is_txt = 'text/plain' in content_type or final_url.endswith(('.txt', '.txt.gz'))

        # 1. Try XML Parsing (Sitemap Index or URL Set)
        if is_xml:
            try:
                # Attempt to prevent XML vulnerabilities
                # Use defusedxml if available, otherwise standard ET
                try:
                    import defusedxml.ElementTree as SafeET
                    root = SafeET.fromstring(content)
                except ImportError:
                     root = ET.fromstring(content)
                except ET.ParseError as xml_err:
                    root = None # Signal fallback

                if root is not None:
                    # Check if it's a sitemap index
                    if root.tag.endswith('sitemapindex'):
                        sitemaps = root.findall('ns:sitemap', self.SITEMAP_XML_NAMESPACE)
                        for sitemap_tag in sitemaps:
                            loc_tag = sitemap_tag.find('ns:loc', self.SITEMAP_XML_NAMESPACE)
                            if loc_tag is not None and loc_tag.text:
                                child_sitemap_urls.append(loc_tag.text.strip())
                        # Return early, don't look for <url> tags in an index file
                        logger.debug(f"Finished parsing index {final_url}. Found {len(child_sitemap_urls)} child sitemaps.")
                        return page_urls, child_sitemap_urls

                    # Check if it's a URL set
                    elif root.tag.endswith('urlset'):
                        urls = root.findall('ns:url', self.SITEMAP_XML_NAMESPACE)
                        for url_tag in urls:
                            if current_url_count >= max_pages: break
                            loc_tag = url_tag.find('ns:loc', self.SITEMAP_XML_NAMESPACE)
                            if loc_tag is not None and loc_tag.text:
                                loc_text = loc_tag.text.strip()
                                if loc_text not in processed_locs:
                                    url_data = {'loc': loc_text}
                                    # Optional fields
                                    lastmod = url_tag.find('ns:lastmod', self.SITEMAP_XML_NAMESPACE)
                                    if lastmod is not None: url_data['lastmod'] = lastmod.text
                                    changefreq = url_tag.find('ns:changefreq', self.SITEMAP_XML_NAMESPACE)
                                    if changefreq is not None: url_data['changefreq'] = changefreq.text
                                    priority = url_tag.find('ns:priority', self.SITEMAP_XML_NAMESPACE)
                                    if priority is not None: url_data['priority'] = priority.text

                                    page_urls.append(url_data)
                                    processed_locs.add(loc_text)
                                    current_url_count += 1
                        logger.debug(f"Finished parsing {final_url}. Found {len(page_urls)} new URLs via XML.")
                        return page_urls, child_sitemap_urls # Successfully parsed as XML urlset
                    else:
                         logger.warning(f"Unknown root tag in XML sitemap {final_url}: {root.tag}. Trying regex/text fallback.")

            except Exception as e:
                # Catch broader errors during XML parsing, including defusedxml/ET issues
                logger.warning(f"Error parsing XML content for {final_url}: {e}. Trying regex/text fallback.", exc_info=False)
                # Fall through to regex/text parsing

        # 2. Try Regex Fallback (for malformed XML or other formats containing <loc>)
        # Only attempt if XML parsing failed or wasn't attempted
        if not page_urls and not child_sitemap_urls:
             try:
                  # Find URLs within <loc>...</loc> tags
                  loc_matches = re.findall(r'<loc>(.*?)</loc>', content, re.IGNORECASE)
                  for loc_text in loc_matches:
                       if current_url_count >= max_pages: break
                       loc_text = loc_text.strip()
                       if loc_text.startswith(('http://', 'https://')) and loc_text not in processed_locs:
                            # Check if it looks like a child sitemap URL first
                            if loc_text.endswith(('.xml', '.xml.gz', '.txt', '.txt.gz')) or 'sitemap' in loc_text.lower():
                                 child_sitemap_urls.append(loc_text)
                            else:
                                 page_urls.append({'loc': loc_text}) # Basic data
                                 processed_locs.add(loc_text)
                                 current_url_count += 1
                  if page_urls or child_sitemap_urls:
                       logger.debug(f"Found {len(page_urls)} URLs and {len(child_sitemap_urls)} child sitemaps via Regex in {final_url}.")
                       return page_urls, child_sitemap_urls # Found URLs via regex
             except Exception as e:
                  logger.warning(f"Regex parsing failed for {final_url}: {e}. Trying direct text parsing.")


        # 3. Try Direct Text Parsing (for sitemap.txt or simple lists)
        # Only attempt if XML and Regex failed or wasn't attempted (e.g., is_txt was true)
        if not page_urls and not child_sitemap_urls:
            try:
                    lines = content.splitlines()
                    for line in lines:
                     if current_url_count >= max_pages: break
                     line = line.strip()
                     if line.startswith(('http://', 'https://')) and line not in processed_locs:
                          # Check if it looks like a child sitemap URL first
                          if line.endswith(('.xml', '.xml.gz', '.txt', '.txt.gz')) or 'sitemap' in line.lower():
                              child_sitemap_urls.append(line)
                          else:
                              page_urls.append({'loc': line}) # Basic data
                              processed_locs.add(line)
                              current_url_count += 1
                     if page_urls or child_sitemap_urls:
                        logger.debug(f"Found {len(page_urls)} URLs and {len(child_sitemap_urls)} child sitemaps via Text in {final_url}.")
                        return page_urls, child_sitemap_urls
            except Exception as e:
                 logger.warning(f"Direct text parsing failed for {final_url}: {e}")


        logger.debug(f"Finished parsing {final_url}. Found {len(page_urls)} new URLs, {len(child_sitemap_urls)} child sitemaps.")
        return page_urls, child_sitemap_urls


    def _parse_sitemaps(self, initial_sitemap_urls: Set[str], domain: str, max_pages: int) -> List[Dict[str, Any]]:
        """Parses a queue of sitemap URLs, handling nested sitemaps."""
        sitemap_queue = list(initial_sitemap_urls)
        processed_sitemaps = set(initial_sitemap_urls) # Avoid reprocessing
        processed_locs = set() # Track unique page URLs found across all sitemaps
        extracted_urls = []
        total_sitemaps_parsed = 0

        logger.info(f"Starting sitemap parsing. Queue: {len(sitemap_queue)}, Max pages: {max_pages}")

        while sitemap_queue and len(extracted_urls) < max_pages:
            current_sitemap_url = sitemap_queue.pop(0)
            total_sitemaps_parsed += 1

            page_urls, child_sitemap_urls = self._parse_single_sitemap(
                sitemap_url=current_sitemap_url,
                domain=domain,
                processed_locs=processed_locs,
                max_pages=max_pages,
                current_url_count=len(extracted_urls)
            )

            # Only extend if we haven't hit the limit
            if len(extracted_urls) < max_pages:
                urls_to_add = page_urls[:max_pages - len(extracted_urls)]
                extracted_urls.extend(urls_to_add)

            # Add newly discovered child sitemaps to the queue if not already processed
            # and we haven't hit the max_pages limit (no point parsing more if we can't add URLs)
            if len(extracted_urls) < max_pages:
                for child_url in child_sitemap_urls:
                    if child_url not in processed_sitemaps:
                        sitemap_queue.append(child_url)
                        processed_sitemaps.add(child_url)

            # Early exit if max pages reached
            if len(extracted_urls) >= max_pages:
                logger.info(f"Reached max_pages limit ({max_pages}) during sitemap parsing.")
                break

        logger.info(f"Sitemap parsing complete. Extracted {len(extracted_urls)} URLs from {total_sitemaps_parsed} files.")
        return extracted_urls # Already sliced to max_pages if limit was hit


    def _crawl_website(self, base_url: str, domain: str, max_pages: int) -> List[Dict[str, Any]]:
        """Fallback: Basic web crawl if sitemaps are insufficient."""
        logger.warning(f"No usable sitemaps found for {base_url}. Falling back to basic crawl (max {max_pages} pages). Ensure rate limits are set.")
        urls_to_visit = {base_url}
        visited_urls = set()
        extracted_data = [] # Store as list of dicts like sitemap parser

        while urls_to_visit and len(extracted_data) < max_pages:
            current_url = urls_to_visit.pop()
            if current_url in visited_urls:
                continue

            # Avoid crawling external domains (simple check)
            parsed_current = urlparse(current_url)
            current_domain = parsed_current.netloc.replace("www.", "")
            if current_domain != domain:
                 logger.debug(f"Skipping external URL during crawl: {current_url}")
                 continue

            visited_urls.add(current_url)
            logger.info(f"Crawling ({len(extracted_data) + 1}/{max_pages}): {current_url}")

            result = RateLimitedFetcher.fetch_url(current_url) # Ensure using class method

            if result["success"] and result["content"] and 'html' in result.get("content_type", ""):
                # Add current URL to results
                extracted_data.append({'loc': result["final_url"]}) # Basic format

                # Find new links on the page
                try:
                    soup = BeautifulSoup(result["content"], 'html.parser')
                    for link in soup.find_all('a', href=True):
                        if len(extracted_data) + len(urls_to_visit) > max_pages + 100: # Limit queue growth
                                break # Stop adding new links if queue is large

                        href = link['href'].strip()
                        # Resolve relative URLs and clean fragments
                        absolute_url = urljoin(result["final_url"], href)
                        cleaned_url = urlunparse(urlparse(absolute_url)._replace(fragment=''))
                        parsed_cleaned = urlparse(cleaned_url)
                        cleaned_domain = parsed_cleaned.netloc.replace("www.", "")

                        # Add to visit queue if it's within the domain and not visited
                        if cleaned_domain == domain and cleaned_url not in visited_urls:
                            # Basic filter for common non-page links
                            if not cleaned_url.lower().endswith(('.pdf', '.jpg', '.png', '.gif', '.zip', '.mp4', '.mov', '.avi')):
                                urls_to_visit.add(cleaned_url)

                except Exception as e:
                    logger.warning(f"Error parsing HTML for links on {current_url}: {e}")

            elif not result["success"]:
                 logger.warning(f"Failed to fetch {current_url} during crawl: {result.get('error')}")


        logger.info(f"Basic crawl finished for {base_url}. Found {len(extracted_data)} URLs.")
        return extracted_data[:max_pages]


    def _format_output(self, success: bool, method: str, urls: List[Dict[str, Any]], start_time: float, crawl_delay: Optional[float], **kwargs) -> Dict[str, Any]:
        """Formats the final output dictionary, including the determined crawl_delay.""" # Updated docstring
        end_time = time.time()
        # Get the actual interval used by the fetcher for this domain
        domain = urlparse(kwargs.get("base_url", "")).netloc.replace("www.", "")
        final_interval = RateLimitedFetcher.get_request_interval(domain) if domain else None

        result = {
            "success": success,
            "method_used": method, # 'sitemap' or 'crawl'
            "total_urls_found": len(urls),
            "urls": urls, # List of dicts, e.g., [{'loc': url, 'lastmod': ...}, ...]
            "duration_seconds": round(end_time - start_time, 2),
            "robots_crawl_delay_found": crawl_delay, # The delay found in robots.txt (or None)
            "final_request_interval_used": final_interval # The actual interval applied by fetcher
        }
        # Add any extra kwargs passed (like error messages or base_url)
        result.update(kwargs)
        logger.info(f"SitemapRetrieverTool finished in {result['duration_seconds']}s. Method: {method}. Found {result['total_urls_found']} URLs. Robots Crawl Delay: {crawl_delay}. Final Interval: {final_interval}s")
        # Return the dictionary directly, Celery task will handle JSON conversion if needed
        return result


    # --- Main Execution ---
    def _run(self, url: str, user_id: int, max_pages: int = 1000, requests_per_second: float = 5.0) -> Dict[str, Any]:
        """
        Orchestrates the process: check robots, init rate limiter, check common paths, parse sitemaps, fallback crawl.
        """
        start_time = time.time()
        parsed_url = urlparse(url)
        base_url = urlunparse(parsed_url._replace(path='', query='', fragment=''))
        domain = parsed_url.netloc.replace("www.", "") # Normalize domain
        if not domain:
             logger.error(f"Could not parse domain from URL: {url}")
             # Use format_output for consistency
             return self._format_output(
                 success=False, method='setup', urls=[], start_time=start_time,
                 error="Invalid URL: Could not parse domain", crawl_delay=None, base_url=url
             )

        logger.info(f"Starting Sitemap Retriever for {url} (Domain: {domain}, Max Pages: {max_pages}, User RPS: {requests_per_second})")

        # 1. Check robots.txt for sitemaps and crawl-delay (DOES NOT init rate limit)
        # Fetching robots.txt uses RateLimitedFetcher default (likely uninitialized/fast rate)
        sitemap_urls_from_robots, robots_crawl_delay = self._check_robots(base_url, domain)

        # 2. Initialize Rate Limiter *LATER* - Only if crawling is needed.

        # 3. Check common sitemap paths (uses RateLimitedFetcher default rate)
        sitemap_urls_from_common = self._check_common_paths(base_url, domain)

        # 4. Combine and Parse Sitemaps (uses RateLimitedFetcher default rate)
        initial_sitemap_urls = sitemap_urls_from_robots.union(sitemap_urls_from_common)
        parsed_urls = [] # Initialize to empty list
        method_used = 'none' # Initialize method

        if initial_sitemap_urls:
            logger.info(f"Found {len(initial_sitemap_urls)} potential sitemaps from robots.txt and common paths.")
            parsed_urls = self._parse_sitemaps(initial_sitemap_urls, domain, max_pages)
            if parsed_urls:
                # Success via sitemap parsing
                method_used = 'sitemap'
                logger.info(f"Successfully parsed {len(parsed_urls)} URLs via sitemap method.")
                # We have URLs, format output and return
                return self._format_output(
                    success=True,
                    method=method_used,
                    urls=parsed_urls,
                    start_time=start_time,
                    crawl_delay=robots_crawl_delay, # Pass the determined delay
                    base_url=base_url # Include base_url for context
                )
            else:
                 logger.warning(f"Parsing {len(initial_sitemap_urls)} potential sitemaps yielded no URLs for {base_url}.")
                 method_used = 'sitemap_failed' # Indicate sitemaps were found but empty/failed
        else:
            logger.info(f"No sitemap URLs found in robots.txt or common paths for {base_url}.")
            method_used = 'no_sitemaps_found'

        # 5. Fallback to Basic Crawl (if sitemaps failed or yielded nothing)
        if not parsed_urls: # Only crawl if sitemap parsing didn't yield results
            logger.info(f"Falling back to basic website crawl for {base_url}")

            # *** Initialize Rate Limiter NOW, only before crawling ***
            # Use the delay found in robots.txt (if any) and the user's desired RPS.
            # The RateLimitedFetcher will choose the stricter (slower) rate.
            try:
                logger.info(f"Initializing rate limiter for domain {domain} before crawl. User RPS: {requests_per_second}, Robots Delay: {robots_crawl_delay}")
                RateLimitedFetcher.init_rate_limiting(domain, requests_per_second, robots_crawl_delay)
            except Exception as e:
                logger.error(f"Error initializing rate limiter for domain {domain} before crawl: {e}", exc_info=True)
                # Proceed with crawl using default/uninitialized rate limiting, but log error
                # Or return failure? Let's proceed but the rate might be wrong.
                # For safety, let's return failure here.
                return self._format_output(
                    success=False, method='crawl_setup_failed', urls=[], start_time=start_time,
                    error=f"Rate limiter initialization failed before crawl: {e}", crawl_delay=robots_crawl_delay, base_url=url
                )

            crawled_urls = self._crawl_website(base_url, domain, max_pages)
            if crawled_urls:
                 method_used = 'crawl'
                 return self._format_output(
                      success=True, method=method_used, urls=crawled_urls,
                      start_time=start_time, crawl_delay=robots_crawl_delay, base_url=base_url
                  )
            else:
                 # If crawl also fails, return failure
                 method_used = 'crawl_failed'
                 logger.error(f"Sitemap and Crawl methods failed to find any URLs for {base_url}.")
                 return self._format_output(
                      success=False, method=method_used, urls=[], start_time=start_time,
                      error="Sitemap and Crawl methods failed to find any URLs.", crawl_delay=robots_crawl_delay, base_url=base_url
                 )
        else:
            # This case should ideally not be reached due to the return in step 4,
            # but as a fallback, if parsed_urls exists but wasn't returned.
             logger.warning("Reached unexpected state after sitemap parsing.")
             return self._format_output(
                    success=True, # Assume sitemap success if parsed_urls has items
                    method='sitemap', # Assume sitemap method
                    urls=parsed_urls,
                    start_time=start_time,
                    crawl_delay=robots_crawl_delay,
                    base_url=base_url
                )


# Example Usage (for testing)
if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    tool = SitemapRetrieverTool()
    # test_url = "https://www.google.com" # Simple case
    # test_url = "https://www.paradisefloorsandmore.com" # Has crawl-delay and complex sitemaps
    test_url = "https://invalid-domain-should-fail.xyz"
    # test_url = "http://httpbin.org/delay/5" # Timeout test

    results = tool.run(url=test_url, user_id=0, max_pages=10, requests_per_second=2.0)

    print("\n--- Final Results ---")
    # Use json.dumps for pretty printing the dictionary
    print(json.dumps(results, indent=2))

    if results["success"]:
        print(f"\nSuccessfully retrieved {results['total_urls_found']} URLs using method: {results['method_used']}")
        # print("First 5 URLs:")
        # for i, url_data in enumerate(results["urls"][:5]):
        #     print(f"  {i+1}. {url_data.get('loc')}")
    else:
        print(f"\nTool failed: {results.get('error', 'Unknown error')}")

    print(f"\nDuration: {results['duration_seconds']} seconds")
    print(f"Crawl Delay Used: {results['robots_crawl_delay_found']}")

================
File: apps/agents/tools/web_crawler_tool/__init__.py
================
from .web_crawler_tool import WebCrawlerTool, WebCrawlerToolSchema, CrawlOutputFormat
from .sitemap_crawler import SitemapCrawlerTool, SitemapCrawlerSchema, sitemap_crawler_task

__all__ = ['WebCrawlerTool', 'WebCrawlerToolSchema', 'CrawlOutputFormat',
           'SitemapCrawlerTool', 'SitemapCrawlerSchema', 'sitemap_crawler_task']

================
File: apps/agents/tools/web_crawler_tool/test_web_crawler_tool.py
================
import unittest
from unittest.mock import patch, MagicMock
import json
from django.test import TestCase
from django.contrib.auth.models import User

from .web_crawler_tool import WebCrawlerTool, CrawlOutputFormat

class WebCrawlerToolTests(TestCase):
    """Tests for the WebCrawlerTool"""
    
    def setUp(self):
        """Set up test environment"""
        # Create a test user
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='password'
        )
        
        # Create an instance of the tool
        self.crawler_tool = WebCrawlerTool()
        
        # Test URL
        self.test_url = "https://example.com"
    
    @patch('apps.agents.tools.scrapper_tool.ScrapperTool._run')
    def test_basic_crawl(self, mock_scrapper_run):
        """Test basic crawling functionality"""
        # Mock ScrapperTool response for initial page
        mock_scrapper_run.side_effect = [
            # First call - TEXT content
            json.dumps({
                "url": self.test_url,
                "domain": "example.com",
                "title": "Example Domain",
                "text": "This is an example website.",
            }),
            # Second call - LINKS content
            json.dumps({
                "url": self.test_url,
                "domain": "example.com",
                "title": "Example Domain",
                "links": [
                    {"url": "https://example.com/page1", "text": "Page 1"},
                    {"url": "https://example.com/page2", "text": "Page 2"},
                ]
            }),
            # Third call - TEXT content for page1
            json.dumps({
                "url": "https://example.com/page1",
                "domain": "example.com",
                "title": "Page 1",
                "text": "This is page 1.",
            }),
            # Fourth call - LINKS content for page1
            json.dumps({
                "url": "https://example.com/page1",
                "domain": "example.com",
                "title": "Page 1",
                "links": [
                    {"url": "https://example.com/page3", "text": "Page 3"},
                ]
            }),
            # Fifth call - TEXT content for page2
            json.dumps({
                "url": "https://example.com/page2",
                "domain": "example.com",
                "title": "Page 2",
                "text": "This is page 2.",
            }),
            # Sixth call - LINKS content for page2
            json.dumps({
                "url": "https://example.com/page2",
                "domain": "example.com",
                "title": "Page 2",
                "links": []
            }),
        ]
        
        # Run crawler with limited settings
        result = self.crawler_tool._run(
            start_url=self.test_url,
            user_id=self.user.id,
            max_pages=3,
            max_depth=1
        )
        
        # Check that result is valid JSON
        result_data = json.loads(result)
        
        # Validate the result
        self.assertEqual(result_data["status"], "success")
        self.assertEqual(result_data["start_url"], self.test_url)
        self.assertEqual(result_data["total_pages"], 3)
        
        # Verify that ScrapperTool was called the expected number of times
        self.assertEqual(mock_scrapper_run.call_count, 6)
    
    @patch('apps.agents.tools.scrapper_tool.ScrapperTool._run')
    def test_crawl_with_patterns(self, mock_scrapper_run):
        """Test crawling with include/exclude patterns"""
        # Mock ScrapperTool response
        mock_scrapper_run.side_effect = [
            # First call - TEXT content
            json.dumps({
                "url": self.test_url,
                "domain": "example.com",
                "title": "Example Domain",
                "text": "This is an example website.",
            }),
            # Second call - LINKS content
            json.dumps({
                "url": self.test_url,
                "domain": "example.com",
                "title": "Example Domain",
                "links": [
                    {"url": "https://example.com/blog/post1", "text": "Blog Post 1"},
                    {"url": "https://example.com/products/item1", "text": "Product 1"},
                    {"url": "https://example.com/blog/post2", "text": "Blog Post 2"},
                ]
            }),
            # Third call - TEXT content for blog/post1
            json.dumps({
                "url": "https://example.com/blog/post1",
                "domain": "example.com",
                "title": "Blog Post 1",
                "text": "This is blog post 1.",
            }),
            # Fourth call - LINKS content for blog/post1
            json.dumps({
                "url": "https://example.com/blog/post1",
                "domain": "example.com",
                "title": "Blog Post 1",
                "links": []
            }),
            # Fifth call - TEXT content for blog/post2
            json.dumps({
                "url": "https://example.com/blog/post2",
                "domain": "example.com",
                "title": "Blog Post 2",
                "text": "This is blog post 2.",
            }),
            # Sixth call - LINKS content for blog/post2
            json.dumps({
                "url": "https://example.com/blog/post2",
                "domain": "example.com",
                "title": "Blog Post 2",
                "links": []
            }),
        ]
        
        # Run crawler with include pattern for blog posts only
        result = self.crawler_tool._run(
            start_url=self.test_url,
            user_id=self.user.id,
            max_pages=5,
            max_depth=1,
            include_patterns=["blog"]
        )
        
        # Check that result is valid JSON
        result_data = json.loads(result)
        
        # Validate the result - should only have the main page and 2 blog posts
        self.assertEqual(result_data["status"], "success")
        self.assertEqual(result_data["total_pages"], 3)
        
        # All results should be either the main page or have "blog" in the URL
        for page_result in result_data["results"]:
            self.assertTrue(page_result["url"] == self.test_url or "blog" in page_result["url"])
    
    @patch('apps.agents.tools.scrapper_tool.ScrapperTool._run')
    def test_error_handling(self, mock_scrapper_run):
        """Test error handling during crawling"""
        # Mock ScrapperTool to return error for some URLs
        def side_effect_func(url, **kwargs):
            if url == self.test_url:
                # Main page succeeds
                return json.dumps({
                    "url": self.test_url,
                    "domain": "example.com",
                    "title": "Example Domain",
                    "text": "This is an example website.",
                })
            elif url == "https://example.com/page1":
                # Page 1 succeeds with links
                if kwargs.get('output_type') == 'links':
                    return json.dumps({
                        "url": url,
                        "domain": "example.com",
                        "links": [
                            {"url": "https://example.com/error", "text": "Error Page"},
                        ]
                    })
                else:
                    return json.dumps({
                        "url": url,
                        "domain": "example.com",
                        "title": "Page 1",
                        "text": "This is page 1."
                    })
            elif url == "https://example.com/error":
                # Error page fails
                return json.dumps({
                    "success": False,
                    "error": "Failed to load page",
                    "url": url
                })
            else:
                # Default page with no links
                if kwargs.get('output_type') == 'links':
                    return json.dumps({
                        "url": url,
                        "domain": "example.com",
                        "links": []
                    })
                else:
                    return json.dumps({
                        "url": url,
                        "domain": "example.com",
                        "title": f"Page at {url}",
                        "text": f"Content at {url}"
                    })
        
        mock_scrapper_run.side_effect = side_effect_func
        
        # Run crawler
        result = self.crawler_tool._run(
            start_url=self.test_url,
            user_id=self.user.id,
            max_pages=5,
            max_depth=2
        )
        
        # Check that result is valid JSON
        result_data = json.loads(result)
        
        # Validate the result
        self.assertEqual(result_data["status"], "success")
        # Should only have successfully crawled pages
        self.assertGreaterEqual(result_data["total_pages"], 1)
        
        # Verify the error page is not in the results
        error_page_found = False
        for page_result in result_data["results"]:
            if page_result["url"] == "https://example.com/error":
                error_page_found = True
                break
        
        self.assertFalse(error_page_found, "Error page should not be in results")

if __name__ == "__main__":
    unittest.main()

================
File: apps/agents/tools/web_crawler_tool/web_crawler_tool.py
================
"""
Web crawler tool for crawling websites.
This tool can use both sitemap-based and discovery-based crawling strategies.
"""
import logging
import json
import re
import time
from typing import Dict, List, Any, Optional, Union, Set, Type, Callable
from enum import Enum
from urllib.parse import urlparse, urljoin
from datetime import datetime

from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.utils.crawler_utils import init_crawler_rate_limiting, respect_rate_limit
from apps.agents.utils.scraper_adapters import get_adapter
from apps.agents.utils.scraper_adapters.playwright_adapter import PlaywrightAdapter
from apps.agents.tools.sitemap_retriever_tool.sitemap_retriever_tool import SitemapRetrieverTool

logger = logging.getLogger(__name__)

#
# Output Format Definitions
#
class CrawlOutputFormat(str, Enum):
    """Output formats for the web crawler."""
    TEXT = "text"
    HTML = "html"
    METADATA = "metadata"
    LINKS = "links"
    SCREENSHOT = "screenshot"
    FULL = "full"

class CrawlMode(str, Enum):
    """Crawl modes for the web crawler."""
    AUTO = "auto"
    SITEMAP = "sitemap"
    DISCOVERY = "discovery"

#
# Tool Schema
#
class WebCrawlerToolSchema(BaseModel):
    """Input schema for Web Crawler Tool."""
    start_url: str = Field(
        ...,
        description="The URL to start crawling from"
    )
    max_pages: int = Field(
        default=10,
        description="Maximum number of pages to crawl",
        gt=0
    )
    max_depth: int = Field(
        default=2,
        description="Maximum depth of links to follow",
        ge=0
    )
    output_format: str = Field(
        default="text",
        description="Format of the output (text, html, metadata, links, screenshot, full or comma-separated combination)"
    )
    include_patterns: Optional[List[str]] = Field(
        default=None,
        description="List of regex patterns to include URLs"
    )
    exclude_patterns: Optional[List[str]] = Field(
        default=None,
        description="List of regex patterns to exclude URLs"
    )
    stay_within_domain: bool = Field(
        default=True,
        description="Whether to stay within the same domain"
    )
    delay_seconds: float = Field(
        default=1.0,
        description="Delay between requests in seconds"
    )
    mode: CrawlMode = Field(
        default=CrawlMode.AUTO,
        description="Crawl mode (auto, sitemap, or discovery)"
    )
    respect_robots: bool = Field(
        default=True,
        description="Whether to respect robots.txt"
    )

#
# Base Crawler Classes
#
class CrawlerBase:
    """Base class for all crawlers with common functionality."""
    
    def __init__(self, respect_robots: bool = True):
        """
        Initialize the crawler base.
        
        Args:
            respect_robots: Whether to respect robots.txt
        """
        self.respect_robots = respect_robots
        self.adapter = get_adapter()
        
    def init_rate_limiting(self, url: str, requests_per_second: float) -> tuple:
        """
        Initialize rate limiting based on robots.txt.
        
        Args:
            url: The URL to crawl
            requests_per_second: User-specified rate limit in requests per second
            
        Returns:
            Tuple of (domain, robots_crawl_delay)
        """
        if self.respect_robots:
            return init_crawler_rate_limiting(url, requests_per_second)
        else:
            # If not respecting robots.txt, just return the domain
            domain = urlparse(url).netloc
            if domain.startswith('www.'):
                domain = domain[4:]
            return domain, None
        
    def apply_rate_limiting(self, domain: str):
        """
        Apply rate limiting for a domain.
        
        Args:
            domain: The domain to respect rate limit for
        """
        if self.respect_robots:
            respect_rate_limit(domain)
        
    def normalize_url(self, url: str) -> str:
        """
        Normalize a URL by removing trailing slashes and fragments.
        
        Args:
            url: The URL to normalize
            
        Returns:
            Normalized URL
        """
        parsed = urlparse(url)
        # Remove trailing slash
        path = parsed.path
        if path.endswith('/') and len(path) > 1:
            path = path[:-1]
        # Reconstruct URL without fragment
        normalized = f"{parsed.scheme}://{parsed.netloc}{path}"
        if parsed.query:
            normalized += f"?{parsed.query}"
        return normalized
        
    def extract_domain(self, url: str) -> str:
        """
        Extract and normalize the domain from a URL.
        
        Args:
            url: The URL to extract domain from
            
        Returns:
            Normalized domain
        """
        domain = urlparse(url).netloc
        if domain.startswith('www.'):
            domain = domain[4:]
        return domain
        
    def is_same_domain(self, url1: str, url2: str) -> bool:
        """
        Check if two URLs have the same domain.
        
        Args:
            url1: First URL
            url2: Second URL
            
        Returns:
            True if the domains are the same, False otherwise
        """
        return self.extract_domain(url1) == self.extract_domain(url2)
        
    def fetch_content(self, url: str, formats: List[str], timeout: int = 30000) -> Dict[str, Any]:
        """
        Fetch content from a URL using the adapter.
        
        Args:
            url: The URL to fetch
            formats: List of content formats to fetch
            timeout: Timeout in milliseconds
            
        Returns:
            Dictionary with content in requested formats
        """
        try:
            # Apply rate limiting
            domain = self.extract_domain(url)
            self.apply_rate_limiting(domain)
            
            # Fetch content
            result = self.adapter.scrape(
                url=url,
                formats=formats,
                timeout=timeout,
                stealth=True
            )
            
            if "error" in result:
                logger.error(f"Error fetching URL {url}: {result['error']}")
                return {"error": result["error"]}
                
            return result
        except Exception as e:
            logger.error(f"Exception fetching URL {url}: {str(e)}")
            return {"error": str(e)}

class CrawlStrategy:
    """Interface for crawling strategies."""
    
    def find_urls(self, start_url: str, max_urls: int) -> List[str]:
        """
        Find URLs to crawl.
        
        Args:
            start_url: The starting URL
            max_urls: Maximum number of URLs to find
            
        Returns:
            List of URLs to crawl
        """
        raise NotImplementedError
        
    def crawl(self, urls: List[str], formats: List[str], max_depth: int, **kwargs) -> Dict[str, Any]:
        """
        Crawl the given URLs.
        
        Args:
            urls: List of URLs to crawl
            formats: List of content formats to fetch
            max_depth: Maximum crawl depth
            **kwargs: Additional arguments
            
        Returns:
            Dictionary with crawl results
        """
        raise NotImplementedError

#
# Specific Crawl Strategies
#
class SitemapCrawlStrategy(CrawlStrategy, CrawlerBase):
    """Strategy for crawling websites using sitemaps."""
    
    def __init__(self, respect_robots: bool = True):
        """
        Initialize the sitemap crawl strategy.
        
        Args:
            respect_robots: Whether to respect robots.txt
        """
        CrawlerBase.__init__(self, respect_robots)
        self.sitemap_retriever = SitemapRetrieverTool()
        
    def find_urls(self, start_url: str, max_urls: int) -> List[str]:
        """
        Find URLs to crawl from the sitemap.
        
        Args:
            start_url: The starting URL
            max_urls: Maximum number of URLs to find
            
        Returns:
            List of URLs to crawl
        """
        logger.info(f"Finding URLs from sitemap for {start_url} (max: {max_urls})")
        
        try:
            # Use SitemapRetrieverTool to find URLs
            sitemap_result = self.sitemap_retriever._run(
                url=start_url,
                user_id=1,  # Default user ID
                max_pages=max_urls,  # Maximum number of pages to retrieve
                requests_per_second=1.0  # Default RPS
            )
            
            # Parse the result
            if isinstance(sitemap_result, str):
                try:
                    parsed_result = json.loads(sitemap_result)
                    urls = []
                    
                    # Extract URLs from the result
                    if "urls" in parsed_result:
                        urls = parsed_result["urls"]
                    elif "results" in parsed_result:
                        urls = [item.get("url") for item in parsed_result["results"] if "url" in item]
                        
                    if urls:
                        logger.info(f"Found {len(urls)} URLs in sitemap for {start_url}")
                        return urls[:max_urls]
                except json.JSONDecodeError:
                    logger.error(f"Failed to parse sitemap result as JSON: {sitemap_result[:100]}...")
            
            logger.warning(f"No URLs found in sitemap for {start_url}")
            return []
        except Exception as e:
            logger.error(f"Error finding URLs from sitemap for {start_url}: {str(e)}")
            return []
        
    def crawl(self, urls: List[str], formats: List[str], max_depth: int, **kwargs) -> Dict[str, Any]:
        """
        Crawl the given URLs found in the sitemap.
        
        Args:
            urls: List of URLs to crawl
            formats: List of content formats to fetch
            max_depth: Maximum crawl depth (not used in sitemap crawling)
            **kwargs: Additional arguments
            
        Returns:
            Dictionary with crawl results
        """
        logger.info(f"Crawling {len(urls)} URLs from sitemap with formats: {formats}")
        
        # Initialize rate limiting for the first URL (if any)
        if urls:
            domain, robots_crawl_delay = self.init_rate_limiting(urls[0], kwargs.get("requests_per_second", 1.0))
            logger.info(f"Initialized rate limiting for domain '{domain}'. Robots Delay={robots_crawl_delay}")
        
        # Crawl each URL
        results = []
        for i, url in enumerate(urls):
            logger.info(f"Crawling URL {i+1}/{len(urls)}: {url}")
            
            # Fetch content
            result = self.fetch_content(url, formats, kwargs.get("timeout", 30000))
            
            # Add URL to result if not already present
            if "url" not in result:
                result["url"] = url
                
            # Add to results
            results.append(result)
            
        return {
            "results": results,
            "stats": {
                "total_urls": len(urls),
                "crawled_urls": len(results),
                "success_count": sum(1 for r in results if "error" not in r),
                "error_count": sum(1 for r in results if "error" in r)
            }
        }

class DiscoveryCrawlStrategy(CrawlStrategy, CrawlerBase):
    """Strategy for crawling websites by discovering links."""
    
    def __init__(self, respect_robots: bool = True):
        """
        Initialize the discovery crawl strategy.
        
        Args:
            respect_robots: Whether to respect robots.txt
        """
        CrawlerBase.__init__(self, respect_robots)
        
    def find_urls(self, start_url: str, max_urls: int) -> List[str]:
        """
        Find URLs to crawl by discovering links.
        
        Args:
            start_url: The starting URL
            max_urls: Maximum number of URLs to find
            
        Returns:
            List of URLs to crawl
        """
        logger.info(f"Finding URLs by discovery for {start_url} (max: {max_urls})")
        
        # For discovery strategy, we start with just the start URL
        # and discover more URLs during crawling
        return [start_url]
        
    def crawl(self, urls: List[str], formats: List[str], max_depth: int, **kwargs) -> Dict[str, Any]:
        """
        Crawl the given URLs and discover more URLs by following links.
        
        Args:
            urls: List of URLs to crawl
            formats: List of content formats to fetch
            max_depth: Maximum crawl depth
            **kwargs: Additional arguments
            
        Returns:
            Dictionary with crawl results
        """
        logger.info(f"Crawling with discovery strategy. Starting URLs: {len(urls)}, max_depth: {max_depth}")
        
        # Make sure "links" is in formats for discovery
        if "links" not in formats:
            formats = formats + ["links"]
            
        # Initialize variables
        visited_urls = set()
        urls_to_visit = [(url, 0) for url in urls]  # (url, depth)
        results = []
        max_pages = kwargs.get("max_pages", 10)
        start_domain = self.extract_domain(urls[0]) if urls else None
        
        # Initialize rate limiting
        if urls:
            domain, robots_crawl_delay = self.init_rate_limiting(urls[0], kwargs.get("requests_per_second", 1.0))
            logger.info(f"Initialized rate limiting for domain '{domain}'. Robots Delay={robots_crawl_delay}")
        
        # Crawl loop
        while urls_to_visit and len(visited_urls) < max_pages:
            # Get next URL to visit
            url, depth = urls_to_visit.pop(0)
            normalized_url = self.normalize_url(url)
            
            # Skip if already visited
            if normalized_url in visited_urls:
                continue
                
            # Mark as visited
            visited_urls.add(normalized_url)
            
            logger.info(f"Crawling URL {len(visited_urls)}/{max_pages} (depth {depth}): {url}")
            
            # Fetch content
            result = self.fetch_content(url, formats, kwargs.get("timeout", 30000))
            
            # Add URL to result if not already present
            if "url" not in result:
                result["url"] = url
                
            # Add to results
            results.append(result)
            
            # If we've reached max depth, don't extract more links
            if depth >= max_depth:
                continue
                
            # Extract links for further crawling
            if "links" in result and isinstance(result["links"], list):
                # Process links
                for link in result["links"]:
                    link_url = None
                    
                    # Extract URL from link
                    if isinstance(link, dict) and "href" in link:
                        link_url = link["href"]
                    elif isinstance(link, str):
                        link_url = link
                        
                    if not link_url:
                        continue
                        
                    # Convert relative URLs to absolute
                    if not link_url.startswith(('http://', 'https://')):
                        link_url = urljoin(url, link_url)
                        
                    # Skip non-HTTP(S) URLs
                    if not link_url.startswith(('http://', 'https://')):
                        continue
                        
                    # Skip URLs from different domains if same_domain is True
                    if kwargs.get("same_domain", True) and not self.is_same_domain(link_url, url):
                        continue
                        
                    # Skip already visited or queued URLs
                    normalized_link = self.normalize_url(link_url)
                    if normalized_link in visited_urls or any(normalized_link == self.normalize_url(u) for u, _ in urls_to_visit):
                        continue
                        
                    # Add to queue
                    urls_to_visit.append((link_url, depth + 1))
        
        return {
            "results": results,
            "stats": {
                "total_urls": len(visited_urls),
                "crawled_urls": len(results),
                "success_count": sum(1 for r in results if "error" not in r),
                "error_count": sum(1 for r in results if "error" in r)
            }
        }

#
# Unified Web Crawler
#
class UnifiedWebCrawler:
    """Unified web crawler that combines sitemap and discovery-based crawling."""
    
    def __init__(self, respect_robots: bool = True):
        """
        Initialize the unified web crawler.
        
        Args:
            respect_robots: Whether to respect robots.txt
        """
        self.sitemap_strategy = SitemapCrawlStrategy(respect_robots)
        self.discovery_strategy = DiscoveryCrawlStrategy(respect_robots)
        
    def crawl(self, 
              start_url: str, 
              mode: Union[str, CrawlMode] = CrawlMode.AUTO,
              max_pages: int = 10,
              max_depth: int = 1,
              formats: Optional[List[str]] = None,
              same_domain: bool = True,
              delay_seconds: float = 1.0,
              timeout: int = 30000,
              **kwargs) -> Dict[str, Any]:
        """
        Crawl a website using the specified mode.
        
        Args:
            start_url: The starting URL
            mode: Crawl mode (auto, sitemap, or discovery)
            max_pages: Maximum number of pages to crawl
            max_depth: Maximum crawl depth
            formats: List of content formats to fetch
            same_domain: Whether to stay on the same domain
            delay_seconds: Delay between requests in seconds
            timeout: Timeout for each request in milliseconds
            **kwargs: Additional arguments
            
        Returns:
            Dictionary with crawl results
        """
        # Default formats
        if formats is None:
            formats = ["text", "links", "metadata"]
            
        # Convert string mode to enum
        if isinstance(mode, str):
            try:
                mode = CrawlMode(mode.lower())
            except ValueError:
                logger.warning(f"Invalid mode: {mode}. Using AUTO mode.")
                mode = CrawlMode.AUTO
                
        logger.info(f"Starting unified crawl for URL: {start_url}, mode: {mode}, max_pages: {max_pages}, max_depth: {max_depth}")
        
        # Common parameters for all strategies
        common_params = {
            "max_pages": max_pages,
            "requests_per_second": 1.0 / delay_seconds if delay_seconds > 0 else None,
            "timeout": timeout,
            "same_domain": same_domain
        }
        
        start_time = time.time()
        
        if mode == CrawlMode.AUTO:
            # Try sitemap first
            logger.info(f"AUTO mode: Trying sitemap strategy first for {start_url}")
            urls = self.sitemap_strategy.find_urls(start_url, max_pages)
            
            if urls:
                logger.info(f"Found {len(urls)} URLs in sitemap. Using sitemap strategy.")
                result = self.sitemap_strategy.crawl(urls, formats, max_depth, **common_params)
                result["crawl_mode"] = "sitemap"
            else:
                logger.info(f"No URLs found in sitemap. Falling back to discovery strategy.")
                result = self.discovery_strategy.crawl([start_url], formats, max_depth, **common_params)
                result["crawl_mode"] = "discovery"
                
        elif mode == CrawlMode.SITEMAP:
            # Use sitemap only
            logger.info(f"SITEMAP mode: Using sitemap strategy for {start_url}")
            urls = self.sitemap_strategy.find_urls(start_url, max_pages)
            
            if urls:
                result = self.sitemap_strategy.crawl(urls, formats, max_depth, **common_params)
                result["crawl_mode"] = "sitemap"
            else:
                logger.warning(f"No URLs found in sitemap for {start_url}")
                result = {
                    "error": "No sitemap found or sitemap is empty",
                    "crawl_mode": "sitemap",
                    "results": []
                }
                
        elif mode == CrawlMode.DISCOVERY:
            # Use discovery only
            logger.info(f"DISCOVERY mode: Using discovery strategy for {start_url}")
            result = self.discovery_strategy.crawl([start_url], formats, max_depth, **common_params)
            result["crawl_mode"] = "discovery"
            
        # Add timing information
        elapsed_time = time.time() - start_time
        result["elapsed_time"] = elapsed_time
        logger.info(f"Crawl completed in {elapsed_time:.2f} seconds. Mode: {result.get('crawl_mode')}")
        
        return result

#
# Web Crawler Tool
#
class WebCrawlerTool(BaseTool):
    """Tool for crawling websites."""
    name: str = "web_crawler_tool"
    description: str = "Crawl a website and extract content from multiple pages"
    schema: Type[BaseModel] = WebCrawlerToolSchema

    def _run(
        self,
        start_url: str,
        max_pages: int = 10,
        max_depth: int = 2,
        output_format: Union[CrawlOutputFormat, str, List[str]] = CrawlOutputFormat.TEXT,
        include_patterns: Optional[List[str]] = None,
        exclude_patterns: Optional[List[str]] = None,
        stay_within_domain: bool = True,
        delay_seconds: float = 1.0,
        mode: str = "auto",
        respect_robots: bool = True,
        **kwargs
    ) -> Dict[str, Any]:
        """
        Run the web crawler tool.
        
        Args:
            start_url: The URL to start crawling from
            max_pages: Maximum number of pages to crawl
            max_depth: Maximum depth of links to follow
            output_format: Format of the output (text, html, metadata, links, screenshot, full)
            include_patterns: List of regex patterns to include URLs
            exclude_patterns: List of regex patterns to exclude URLs
            stay_within_domain: Whether to stay within the same domain
            delay_seconds: Delay between requests in seconds
            mode: Crawl mode (auto, sitemap, or discovery)
            respect_robots: Whether to respect robots.txt
            **kwargs: Additional arguments
            
        Returns:
            Dictionary with the crawl results
        """
        # Call the crawl_website function
        result = crawl_website(
            start_url=start_url,
            max_pages=max_pages,
            max_depth=max_depth,
            output_format=output_format,
            include_patterns=include_patterns,
            exclude_patterns=exclude_patterns,
            stay_within_domain=stay_within_domain,
            delay_seconds=delay_seconds,
            mode=mode,
            respect_robots=respect_robots
        )
        
        return result

#
# Main Function
#
def crawl_website(
    start_url: str,
    max_pages: int = 10,
    max_depth: int = 2,
    output_format: Union[CrawlOutputFormat, str, List[str]] = CrawlOutputFormat.TEXT,
    include_patterns: Optional[List[str]] = None,
    exclude_patterns: Optional[List[str]] = None,
    stay_within_domain: bool = True,
    delay_seconds: float = 1.0,
    mode: str = "auto",
    respect_robots: bool = True,
    **kwargs
) -> Dict[str, Any]:
    """
    Crawl a website starting from the given URL and extract content from multiple pages.
    
    Args:
        start_url: The URL to start crawling from
        max_pages: Maximum number of pages to crawl
        max_depth: Maximum depth of links to follow
        output_format: Format of the output (text, html, metadata, links, screenshot, full)
        include_patterns: List of regex patterns to include URLs
        exclude_patterns: List of regex patterns to exclude URLs
        stay_within_domain: Whether to stay within the same domain
        delay_seconds: Delay between requests in seconds
        mode: Crawl mode (auto, sitemap, or discovery)
        respect_robots: Whether to respect robots.txt
        **kwargs: Additional arguments
        
    Returns:
        Dictionary with the crawl results
    """
    logger.info(f"Starting crawl for URL: {start_url}, max_pages: {max_pages}, max_depth: {max_depth}, delay: {delay_seconds}s, mode: {mode}")
    
    # Normalize output_format to list
    formats = []
    if isinstance(output_format, str):
        if ',' in output_format:
            formats = [fmt.strip() for fmt in output_format.split(',')]
        else:
            formats = [output_format]
    elif isinstance(output_format, list):
        formats = output_format
    elif isinstance(output_format, CrawlOutputFormat):
        formats = [output_format.value]
    else:
        formats = ["text", "links", "metadata"]
        
    # Validate formats
    valid_formats = [fmt.value for fmt in CrawlOutputFormat]
    formats = [fmt for fmt in formats if fmt in valid_formats or fmt in valid_formats]
    
    if not formats:
        formats = ["text", "links", "metadata"]
        
    logger.debug(f"Using formats: {formats}")
    
    # Compile regex patterns
    compiled_include = None
    compiled_exclude = None
    
    if include_patterns:
        try:
            compiled_include = [re.compile(pattern) for pattern in include_patterns]
        except re.error as e:
            logger.error(f"Invalid include pattern: {e}")
            
    if exclude_patterns:
        try:
            compiled_exclude = [re.compile(pattern) for pattern in exclude_patterns]
        except re.error as e:
            logger.error(f"Invalid exclude pattern: {e}")
    
    # Use the unified crawler
    crawler = UnifiedWebCrawler(respect_robots=respect_robots)
    result = crawler.crawl(
        start_url=start_url,
        mode=mode,
        max_pages=max_pages,
        max_depth=max_depth,
        formats=formats,
        same_domain=stay_within_domain,
        delay_seconds=delay_seconds,
        timeout=kwargs.get("timeout", 60000)
    )
    
    # Apply include/exclude patterns to results if needed
    if compiled_include or compiled_exclude:
        filtered_results = []
        for item in result.get("results", []):
            url = item.get("url", "")
            
            # Apply include/exclude patterns
            if compiled_include and not any(pattern.search(url) for pattern in compiled_include):
                continue
                
            if compiled_exclude and any(pattern.search(url) for pattern in compiled_exclude):
                continue
                
            filtered_results.append(item)
            
        # Update the results
        result["results"] = filtered_results
        
        # Update stats
        result["stats"] = {
            "total_urls": len(filtered_results),
            "crawled_urls": len(filtered_results),
            "success_count": sum(1 for r in filtered_results if "error" not in r),
            "error_count": sum(1 for r in filtered_results if "error" in r)
        }
    
    logger.info(f"Completed crawl with {len(result.get('results', []))} pages")
    
    return result

================
File: apps/agents/tools/website_detector_tool/platforms.py
================
{
  "platforms": [
    {
      "name": "WordPress",
      "checks": [
        {"html": "wp-content"},
        {"meta": {"name": "generator", "value": "wordpress"}},
        {"path": "/wp-admin/"}
      ]
    },
    {
      "name": "Drupal",
      "checks": [
        {"meta": {"name": "generator", "value": "drupal"}},
        {"html": "sites/default"},
        {"header": {"X-Generator": "Drupal"}}
      ]
    },
    {
      "name": "Joomla",
      "checks": [
        {"meta": {"name": "generator", "value": "joomla"}},
        {"html": "joomla"},
        {"path": "/administrator/"}
      ]
    },
    {
      "name": "TYPO3",
      "checks": [
        {"html": "typo3"},
        {"meta": {"name": "generator", "value": "typo3"}}
      ]
    },
    {
      "name": "Craft CMS",
      "checks": [
        {"html": "craftcms.com"},
        {"html": "craft", "additional": "cms"}
      ]
    },
    {
      "name": "ExpressionEngine",
      "checks": [
        {"html": "expressionengine"},
        {"cookie": "exp_"}
      ]
    },
    {
      "name": "Concrete CMS",
      "checks": [
        {"html": "concrete5"},
        {"meta": {"name": "generator", "value": "concrete5"}}
      ]
    },
    {
      "name": "Sitecore",
      "checks": [
        {"html": "sitecore"},
        {"cookie": "sc_"}
      ]
    },
    {
      "name": "Adobe Experience Manager",
      "checks": [
        {"html": "adobe"},
        {"html": "aem"},
        {"html": "cq_"}
      ]
    },
    {
      "name": "1C-Bitrix",
      "checks": [
        {"html": "bitrix"},
        {"cookie": "bx_"}
      ]
    },
    {
      "name": "Umbraco",
      "checks": [
        {"html": "umbraco"},
        {"cookie": "umb_"}
      ]
    },
    {
      "name": "MODX",
      "checks": [
        {"meta": {"name": "generator", "value": "modx"}},
        {"html": "modx"}
      ]
    },
    {
      "name": "SilverStripe",
      "checks": [
        {"html": "silverstripe"},
        {"meta": {"name": "generator", "value": "silverstripe"}}
      ]
    },
    {
      "name": "PyroCMS",
      "checks": [
        {"html": "pyrocms"},
        {"html": "powered by pyrocms"}
      ]
    },
    {
      "name": "Contao",
      "checks": [
        {"html": "contao"},
        {"meta": {"name": "generator", "value": "contao"}}
      ]
    },
    {
      "name": "Grav",
      "checks": [
        {"html": "grav"},
        {"meta": {"name": "generator", "value": "grav"}}
      ]
    },
    {
      "name": "October CMS",
      "checks": [
        {"html": "octobercms"},
        {"cookie": "october_session"}
      ]
    },
    {
      "name": "Shopify",
      "checks": [
        {"domain": ".myshopify.com"},
        {"html": "shopify"}
      ]
    },
    {
      "name": "Magento",
      "checks": [
        {"html": "mage"},
        {"html": "magento"},
        {"header": {"X-Magento-Cache-Control": null}}
      ]
    },
    {
      "name": "WooCommerce",
      "checks": [
        {"html": "woocommerce"},
        {"html": "wp-content/plugins/woocommerce"}
      ]
    },
    {
      "name": "BigCommerce",
      "checks": [
        {"html": "bigcommerce.com"},
        {"domain": "bigcommerce"}
      ]
    },
    {
      "name": "PrestaShop",
      "checks": [
        {"html": "prestashop"},
        {"cookie": "ps_"}
      ]
    },
    {
      "name": "OpenCart",
      "checks": [
        {"html": "opencart"},
        {"html": "catalog", "additional": "cart"}
      ]
    },
    {
      "name": "Volusion",
      "checks": [
        {"html": "volusion.com"},
        {"html": "v/vspfiles"}
      ]
    },
    {
      "name": "Shift4Shop",
      "checks": [
        {"html": "3dcart.com"},
        {"html": "shift4shop.com"}
      ]
    },
    {
      "name": "Zen Cart",
      "checks": [
        {"html": "zencart"},
        {"html": "zen-cart"}
      ]
    },
    {
      "name": "osCommerce",
      "checks": [
        {"html": "oscommerce"},
        {"html": "powered by oscommerce"}
      ]
    },
    {
      "name": "Sylius",
      "checks": [
        {"html": "sylius"},
        {"cookie": "sylius"}
      ]
    },
    {
      "name": "Spree Commerce",
      "checks": [
        {"html": "spree"},
        {"html": "powered by spree"}
      ]
    },
    {
      "name": "Wix",
      "checks": [
        {"html": "wix.com"},
        {"header": {"X-Wix": null}},
        {"html": "wixstatic.com"}
      ]
    },
    {
      "name": "Squarespace",
      "checks": [
        {"html": "squarespace"},
        {"header": {"X-ServedBy": "squarespace"}}
      ]
    },
    {
      "name": "GoDaddy Website Builder",
      "checks": [
        {"domain": "godaddysites.com"},
        {"html": "godaddy"}
      ]
    },
    {
      "name": "Weebly",
      "checks": [
        {"html": "weebly.com"},
        {"domain": "weebly"}
      ]
    },
    {
      "name": "Duda",
      "checks": [
        {"html": "duda.co"},
        {"html": "dmws"}
      ]
    },
    {
      "name": "Webflow",
      "checks": [
        {"html": "webflow.com"},
        {"domain": "webflow"}
      ]
    },
    {
      "name": "Jimdo",
      "checks": [
        {"html": "jimdo.com"},
        {"domain": "jimdosite.com"}
      ]
    },
    {
      "name": "Strikingly",
      "checks": [
        {"html": "strikingly.com"},
        {"domain": "strikingly.com"}
      ]
    },
    {
      "name": "Webnode",
      "checks": [
        {"html": "webnode.com"},
        {"domain": "webnode"}
      ]
    },
    {
      "name": "Voog",
      "checks": [
        {"html": "voog.com"},
        {"domain": "voog.com"}
      ]
    },
    {
      "name": "Blogger",
      "checks": [
        {"domain": "blogger.com"},
        {"domain": "blogspot.com"},
        {"html": "blogger"}
      ]
    },
    {
      "name": "Tumblr",
      "checks": [
        {"domain": "tumblr.com"},
        {"html": "tumblr"}
      ]
    },
    {
      "name": "Ghost",
      "checks": [
        {"meta": {"name": "generator", "value": "ghost"}},
        {"html": "ghost.org"}
      ]
    },
    {
      "name": "Medium",
      "checks": [
        {"domain": "medium.com"},
        {"html": "medium.com"}
      ]
    },
    {
      "name": "Laravel",
      "checks": [
        {"html": "laravel"},
        {"cookie": "laravel_session"},
        {"header": {"X-Powered-By": "PHP"}}
      ]
    },
    {
      "name": "Django",
      "checks": [
        {"html": "django"},
        {"cookie": "csrftoken"},
        {"header": {"X-Powered-By": "Python"}}
      ]
    },
    {
      "name": "Ruby on Rails",
      "checks": [
        {"html": "rails"},
        {"cookie": "rails"},
        {"header": {"X-Powered-By": "Ruby"}}
      ]
    },
    {
      "name": "CakePHP",
      "checks": [
        {"html": "cakephp"},
        {"cookie": "cake_"}
      ]
    },
    {
      "name": "Symfony",
      "checks": [
        {"html": "symfony"},
        {"cookie": "sf_"},
        {"header": {"X-Powered-By": "PHP"}}
      ]
    },
    {
      "name": "Flask",
      "checks": [
        {"html": "flask"},
        {"header": {"Server": "Werkzeug"}}
      ]
    },
    {
      "name": "Next.js",
      "checks": [
        {"html": "next.js"},
        {"header": {"Server": "Vercel"}}
      ]
    },
    {
      "name": "Express.js",
      "checks": [
        {"header": {"X-Powered-By": "Express"}}
      ]
    },
    {
      "name": "Nuxt.js",
      "checks": [
        {"html": "nuxt"},
        {"html": "__nuxt"}
      ]
    },
    {
      "name": "SvelteKit",
      "checks": [
        {"html": "sveltekit"},
        {"html": "svelte"}
      ]
    },
    {
      "name": "Angular",
      "checks": [
        {"html": "ng-version"},
        {"html": "angular"}
      ]
    },
    {
      "name": "Vue.js",
      "checks": [
        {"html": "vue"},
        {"html": "data-v-"}
      ]
    },
    {
      "name": "Spring",
      "checks": [
        {"html": "spring"},
        {"header": {"X-Powered-By": "Spring"}}
      ]
    },
    {
      "name": "CodeIgniter",
      "checks": [
        {"html": "codeigniter"},
        {"cookie": "ci_session"}
      ]
    },
    {
      "name": "Gatsby",
      "checks": [
        {"html": "gatsbyjs"},
        {"html": "gatsby"}
      ]
    },
    {
      "name": "Hugo",
      "checks": [
        {"meta": {"name": "generator", "value": "hugo"}}
      ]
    },
    {
      "name": "Jekyll",
      "checks": [
        {"meta": {"name": "generator", "value": "jekyll"}},
        {"html": "jekyll"}
      ]
    },
    {
      "name": "Hexo",
      "checks": [
        {"meta": {"name": "generator", "value": "hexo"}},
        {"html": "hexo"}
      ]
    },
    {
      "name": "Pelican",
      "checks": [
        {"meta": {"name": "generator", "value": "pelican"}},
        {"html": "pelican"}
      ]
    },
    {
      "name": "Eleventy",
      "checks": [
        {"html": "11ty"},
        {"html": "eleventy"}
      ]
    },
    {
      "name": "Astro",
      "checks": [
        {"html": "astro"},
        {"meta": {"name": "generator", "value": "astro"}}
      ]
    },
    {
      "name": "Docusaurus",
      "checks": [
        {"html": "docusaurus"},
        {"html": "powered by docusaurus"}
      ]
    },
    {
      "name": "MkDocs",
      "checks": [
        {"html": "mkdocs"},
        {"meta": {"name": "generator", "value": "mkdocs"}}
      ]
    },
    {
      "name": "Publii",
      "checks": [
        {"html": "publii"},
        {"meta": {"name": "generator", "value": "publii"}}
      ]
    },
    {
      "name": "HubSpot CMS",
      "checks": [
        {"html": "hubspot"},
        {"html": "hs-scripts.com"}
      ]
    },
    {
      "name": "Kentico",
      "checks": [
        {"html": "kentico"},
        {"cookie": "kentico"}
      ]
    },
    {
      "name": "Liferay",
      "checks": [
        {"html": "liferay"},
        {"cookie": "lfr_"}
      ]
    },
    {
      "name": "Contentful",
      "checks": [
        {"html": "contentful"},
        {"html": "powered by contentful"}
      ]
    },
    {
      "name": "Episerver",
      "checks": [
        {"html": "episerver"},
        {"cookie": "epi_"}
      ]
    },
    {
      "name": "Bloomreach",
      "checks": [
        {"html": "bloomreach"},
        {"html": "brxm"}
      ]
    },
    {
      "name": "Bubble",
      "checks": [
        {"html": "bubble"},
        {"domain": "bubbleapps.io"}
      ]
    },
    {
      "name": "Carrd",
      "checks": [
        {"html": "carrd"},
        {"domain": "carrd.co"}
      ]
    },
    {
      "name": "Framer",
      "checks": [
        {"html": "framer"},
        {"domain": "framer.app"}
      ]
    },
    {
      "name": "Notion Sites",
      "checks": [
        {"html": "notion.so"},
        {"html": "notion-site"}
      ]
    }
  ]
}

================
File: apps/agents/tools/website_detector_tool/website_detector_tool.py
================
# detect_platform.py
import requests
from bs4 import BeautifulSoup
from urllib.parse import urlparse
import json

# Load platforms from JSON file
with open("platforms.json", "r") as f:
    PLATFORMS = json.load(f)["platforms"]

def check_platform(url, html_content, soup, headers, cookies, domain):
    for platform in PLATFORMS:
        for check in platform["checks"]:
            # HTML content check
            if "html" in check:
                if check["html"] in html_content:
                    if "additional" in check and check["additional"] not in html_content:
                        continue
                    return platform["name"]

            # Meta tag check
            if "meta" in check:
                meta = soup.find("meta", {"name": check["meta"]["name"], "content": lambda x: x and check["meta"]["value"] in x.lower()})
                if meta:
                    return platform["name"]

            # Header check
            if "header" in check:
                for header_key, header_value in check["header"].items():
                    if header_key in headers and (header_value is None or header_value in headers[header_key]):
                        return platform["name"]

            # Cookie check
            if "cookie" in check:
                if any(check["cookie"] in cookie for cookie in cookies):
                    return platform["name"]

            # Domain check
            if "domain" in check:
                if check["domain"] in domain:
                    return platform["name"]

            # Path check (e.g., /wp-admin/)
            if "path" in check:
                try:
                    path_response = requests.get(url + check["path"], timeout=5, allow_redirects=False)
                    if path_response.status_code in [200, 301, 302]:
                        return platform["name"]
                except requests.RequestException:
                    continue

    return "Unknown or custom platform"

def detect_platform(url):
    try:
        # Normalize URL
        if not url.startswith("http"):
            url = "https://" + url
        
        # Fetch the webpage
        response = requests.get(url, timeout=10, allow_redirects=True)
        headers = response.headers
        html_content = response.text.lower()  # Case-insensitive matching
        soup = BeautifulSoup(html_content, "html.parser")
        
        # Parse URL and cookies
        parsed_url = urlparse(response.url)
        domain = parsed_url.netloc
        cookies = response.cookies.keys()

        # Detect platform
        platform = check_platform(url, html_content, soup, headers, cookies, domain)
        return platform

    except requests.RequestException as e:
        return f"Error: Could not fetch site - {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

# Test cases
test_urls = [
    "https://wordpress.com",
    "https://shopify.com",
    "https://wix.com",
    "https://squarespace.com",
    "https://joomla.org",
    "https://drupal.org",
    "https://magento.com",
    "https://typo3.org",
    "https://craftcms.com",
    "https://nextjs.org",
    "https://gohugo.io",
    "https://jekyllrb.com",
    "https://hexo.io",
    "https://getpelican.com",
    "https://kentico.com",
    "https://liferay.com",
]

for url in test_urls:
    platform = detect_platform(url)
    print(f"{url} -> {platform}")

================
File: apps/agents/tools/website_distiller_tool/__init__.py
================
from .website_distiller_tool import WebsiteDistillerTool

__all__ = ['WebsiteDistillerTool']

================
File: apps/agents/tools/website_distiller_tool/website_distiller_tool.py
================
import logging
from typing import Type
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from apps.agents.utils.scrape_url import scrape_url
from apps.agents.tools.web_crawler_tool.web_crawler_tool import WebCrawlerTool
from apps.agents.tools.compression_tool.compression_tool import CompressionTool
import json
from urllib.parse import urlparse, urlunparse

logger = logging.getLogger(__name__)

class WebsiteDistillerToolSchema(BaseModel):
    """Input schema for WebsiteDistillerTool."""
    website_url: str = Field(..., description="The website URL to crawl and process")
    max_tokens: int = Field(default=16384, description="Maximum number of tokens in the processed output")
    detail_level: str = Field(
        default="comprehensive",
        description="Detail level: 'comprehensive' (preserve all details), 'detailed' (preserve most details), or 'focused' (key details only)"
    )
    max_pages: int = Field(default=1, description="Maximum number of pages to crawl (if 1, uses direct scraping)")
    max_depth: int = Field(default=1, description="Maximum depth for crawling")

    model_config = {
        "extra": "forbid"
    }

class WebsiteDistillerTool(BaseTool):
    """
    Crawls a website to extract its content, then processes and organizes the content while preserving important information.
    Combines website crawling with advanced NLP processing for comprehensive content analysis (comprehensive, detailed, or focused)
    """
    name: str = "Website Content Distillation Tool"
    description: str = """
    Crawls a website to extract its content, then processes and organizes the content while preserving important information.
    Combines website crawling with advanced NLP processing for comprehensive content analysis.
    """
    args_schema: Type[BaseModel] = WebsiteDistillerToolSchema

    def _run(
        self,
        website_url: str,
        max_tokens: int = 16384,
        detail_level: str = "comprehensive",
        max_pages: int = 10,
        max_depth: int = 3
    ) -> str:
        try:
            # Step 1: Normalize the URL
            parsed = urlparse(website_url)
            normalized_url = urlunparse((
                parsed.scheme or 'https',  # Default to https if no scheme
                parsed.netloc.lower(),
                parsed.path.rstrip('/'),  # Remove trailing slashes
                '',
                parsed.query,
                ''
            ))
            
            # Step 2: Choose method based on max_pages
            logger.info(f"Starting website content extraction for: {normalized_url}, max_pages={max_pages}")
            
            raw_content = None
            result_data = None
            
            if max_pages == 1:
                # Use direct scraping for single page
                logger.info(f"Using direct scrape_url for single page: {normalized_url}")
                try:
                    # Use scrape_url for single page extraction
                    scrape_result = scrape_url(
                        url=normalized_url,
                        cache=True,
                        stealth=True,
                        timeout=60000
                    )
                    
                    if not scrape_result:
                        logger.error(f"Direct scraping failed for URL: {normalized_url}")
                        return json.dumps({
                            "error": "Scraping failed",
                            "message": "Could not fetch content from the provided URL"
                        })
                    
                    # Extract content - check for 'text' field which is what direct scraping returns
                    raw_content = scrape_result.get("text", scrape_result.get("textContent", scrape_result.get("content", "")))
                    
                    # Create similar structure to multi-page result
                    result_data = {
                        "status": "success",
                        "results": [scrape_result],
                        "total_pages": 1
                    }
                    
                except Exception as e:
                    logger.error(f"Error during direct scraping: {str(e)}")
                    return json.dumps({
                        "error": "Scraping failed",
                        "message": str(e)
                    })
            else:
                # Use WebCrawlerTool for multi-page crawling
                logger.info(f"Using WebCrawlerTool for multi-page crawl: {normalized_url}")
                try:
                    web_crawler_tool = WebCrawlerTool()
                    
                    # Crawl multiple pages
                    crawl_result = web_crawler_tool._run(
                        start_url=normalized_url,
                        max_pages=max_pages,
                        max_depth=max_depth,
                        output_format="text,metadata",  # Get text and metadata
                        stay_within_domain=True
                    )
                    
                    # Parse the crawl result
                    result_data = json.loads(crawl_result)
                    if result_data.get("status") != "success":
                        logger.error(f"Crawl failed: {result_data.get('message', 'Unknown error')}")
                        return json.dumps({
                            "error": "Crawling failed",
                            "message": result_data.get("message", "Unknown error")
                        })
                    
                    # Get the content from results
                    results = result_data.get("results", [])
                    if not results:
                        return json.dumps({
                            "error": "No content found",
                            "message": "The crawl returned no results"
                        })
                    
                    # Combine content from all pages with page titles as headers
                    combined_content = []
                    for page_result in results:
                        page_url = page_result.get("url", "")
                        page_title = page_result.get("title", page_url)
                        # Look for content in 'text' field first, which is what WebCrawlerTool returns
                        page_content = page_result.get("text", page_result.get("textContent", page_result.get("content", "")))
                        
                        if page_content:
                            combined_content.append(f"# {page_title}\n\n{page_content}\n\n")
                    
                    raw_content = "\n".join(combined_content)
                    
                except Exception as e:
                    logger.error(f"Error during multi-page crawl: {str(e)}")
                    return json.dumps({
                        "error": "Crawling failed",
                        "message": str(e)
                    })
            
            if not raw_content:
                return json.dumps({
                    "error": "No content found",
                    "message": "The extraction process returned no content"
                })

            # Step 3: Process the content
            logger.info("Processing extracted content")
            compression_tool = CompressionTool()
            processed_result = compression_tool._run(
                content=raw_content,
                max_tokens=max_tokens,
                detail_level=detail_level
            )

            # Parse the compression tool result
            compression_data = json.loads(processed_result)
            
            # Format the final result
            result = {
                'processed_content': compression_data.get('processed_content', ''),
                'source_url': normalized_url,
                'crawl_result_id': result_data.get('crawl_result_id'),
                'total_pages': result_data.get('total_pages', 0),
                'timestamp': result_data.get('timestamp', '')
            }
            
            return json.dumps(result)

        except Exception as e:
            logger.error(f"Error in WebsiteDistillerTool: {str(e)}")
            return json.dumps({
                "error": "Processing failed",
                "message": str(e)
            })

================
File: apps/agents/tools/wordpress/base.py
================
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
import aiohttp
import asyncio

class WordPressBaseSchema(BaseModel):
    website_url: str = Field(..., description="WordPress site URL")
    user_id: int = Field(..., description="ID of user initiating the change")
    auth_token: str = Field(..., description="WordPress REST API authentication token")
    verify_ssl: bool = Field(default=True, description="Verify SSL certificates for requests")

class WordPressBaseTool:
    """Shared WordPress tool functionality"""
    _session = None
    
    def _run_sync(self, coro):
        """Run async code in sync context for Celery"""
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        return loop.run_until_complete(coro)
    
    async def _get_session(self, auth_token: str):
        """Reusable aiohttp session with auth"""
        if not self._session:
            self._session = aiohttp.ClientSession(
                headers={"Authorization": f"Bearer {auth_token}"}
            )
        return self._session

================
File: apps/agents/tools/wordpress/content_tool.py
================
from apps.agents.tools.base_tool import BaseTool
from pydantic import BaseModel, Field
from .base import WordPressBaseSchema, WordPressBaseTool
from typing import Type
import aiohttp
import json
import asyncio
from bs4 import BeautifulSoup

class WordPressContentSchema(WordPressBaseSchema):
    post_id: int = Field(..., description="ID of post/page to update")
    content: str = Field(..., description="HTML content to set")
    allowed_tags: list = Field(
        default=["h1", "h2", "h3", "p", "ul", "ol", "li", "strong", "em", "a"],
        description="Allowed HTML tags for content sanitization"
    )

class WordPressContentTool(BaseTool, WordPressBaseTool):
    name: str = "WordPress Content Updater"
    description: str = """Updates main content of WordPress posts/pages with proper sanitization
    and SEO-friendly formatting. Maintains semantic HTML structure."""
    args_schema: Type[BaseModel] = WordPressContentSchema

    def _run(self, **kwargs) -> str:
        """Sync entry point for Celery"""
        return self._run_sync(self._async_update_content(**kwargs))

    async def _async_update_content(self, website_url: str, post_id: int,
                                  content: str, allowed_tags: list, **kwargs) -> str:
        session = await self._get_session(kwargs['auth_token'])
        
        try:
            # Sanitize HTML content
            sanitized = self._sanitize_html(content, allowed_tags)
            
            async with session.post(
                f"{website_url}/wp-json/wp/v2/posts/{post_id}",
                json={"content": sanitized}
            ) as response:
                if response.status == 200:
                    return json.dumps({
                        "success": True,
                        "post_id": post_id,
                        "content_length": len(sanitized),
                        "allowed_tags": allowed_tags
                    })
                return json.dumps({
                    "error": f"Content update failed: {response.status}",
                    "details": await response.text()
                })
        except Exception as e:
            return json.dumps({
                "error": "Content update failed",
                "message": str(e)
            })

    def _sanitize_html(self, html: str, allowed_tags: list) -> str:
        """Sanitize HTML while preserving SEO elements"""
        soup = BeautifulSoup(html, 'html.parser')
        
        # Remove disallowed tags but keep their content
        for tag in soup.find_all(True):
            if tag.name not in allowed_tags:
                tag.unwrap()
                
        # Clean up empty tags
        for tag in soup.find_all(True):
            if len(tag.get_text(strip=True)) == 0:
                tag.decompose()
                
        return str(soup)

================
File: apps/agents/tools/wordpress/meta_tool.py
================
from apps.agents.tools.base_tool import BaseTool
from pydantic import BaseModel, Field
from .base import WordPressBaseSchema, WordPressBaseTool

class WordPressMetaSchema(WordPressBaseSchema):
    post_id: int = Field(..., description="ID of post/page to update")
    meta_fields: Dict[str, str] = Field(
        ...,
        description="Meta fields to update. Valid keys: title, meta_description, og_title, og_description",
        example={"title": "New SEO Title", "meta_description": "Optimized description"}
    )

class WordPressMetaTool(BaseTool, WordPressBaseTool):
    name: str = "WordPress Meta Updater"
    description: str = """Updates SEO meta information on WordPress posts/pages including:
    - Title
    - Meta description
    - OpenGraph titles
    - OpenGraph descriptions
    
    Example usage:
    {
        "website_url": "https://blog.example.com",
        "user_id": 42,
        "auth_token": "wp_rest_token",
        "post_id": 123,
        "meta_fields": {
            "title": "New SEO Optimized Title",
            "meta_description": "Improved meta description for search engines"
        }
    }"""
    args_schema: Type[BaseModel] = WordPressMetaSchema

    def _run(self, **kwargs) -> str:
        """Sync entry point for Celery"""
        return self._run_sync(self._async_update_meta(**kwargs))

    async def _async_update_meta(self, website_url: str, post_id: int, 
                               meta_fields: Dict[str, str], **kwargs) -> str:
        session = await self._get_session(kwargs['auth_token'])
        
        valid_fields = {
            "title": "title",
            "meta_description": "meta:description",
            "og_title": "og:title",
            "og_description": "og:description"
        }
        
        updates = {
            "meta": {
                valid_fields[key]: value
                for key, value in meta_fields.items()
                if key in valid_fields
            }
        }
        
        try:
            async with session.post(
                f"{website_url}/wp-json/wp/v2/posts/{post_id}",
                json=updates
            ) as response:
                if response.status == 200:
                    return json.dumps({
                        "success": True,
                        "post_id": post_id,
                        "updated_fields": list(meta_fields.keys())
                    })
                return json.dumps({
                    "error": f"API request failed with status {response.status}",
                    "details": await response.text()
                })
        except Exception as e:
            return json.dumps({
                "error": "Meta update failed",
                "message": str(e)
            })

================
File: apps/agents/tools/wordpress/post_tool.py
================
from apps.agents.tools.base_tool import BaseTool
from pydantic import BaseModel, Field
from .base import WordPressBaseSchema, WordPressBaseTool
from typing import Type
import aiohttp
import json
import asyncio

class WordPressPostSchema(WordPressBaseSchema):
    title: str = Field(..., description="Post title")
    content: str = Field(..., description="HTML content for the new post")
    status: str = Field(default="draft", description="Post status: draft, publish, future")
    categories: list = Field(default=[], description="Category IDs for the post")
    tags: list = Field(default=[], description="Tag IDs for the post")
    meta_fields: dict = Field(default={}, description="Initial meta fields")

class WordPressPostTool(BaseTool, WordPressBaseTool):
    name: str = "WordPress Post Creator"
    description: str = """Creates new WordPress posts with SEO-optimized structure.
    
    Example usage:
    {
        "website_url": "https://blog.example.com",
        "user_id": 42,
        "auth_token": "wp_rest_token",
        "title": "New SEO Optimized Post",
        "content": "<h1>Main Heading</h1><p>Quality content...</p>",
        "status": "draft",
        "categories": [5],
        "tags": [12, 15],
        "meta_fields": {
            "meta_description": "Post description for search engines"
        }
    }"""
    args_schema: Type[BaseModel] = WordPressPostSchema

    def _run(self, **kwargs) -> str:
        """Sync entry point for Celery"""
        return self._run_sync(self._async_create_post(**kwargs))

    async def _async_create_post(self, website_url: str, title: str, 
                               content: str, **kwargs) -> str:
        session = await self._get_session(kwargs['auth_token'])
        
        post_data = {
            "title": title,
            "content": content,
            "status": kwargs.get('status', 'draft'),
            "categories": kwargs.get('categories', []),
            "tags": kwargs.get('tags', []),
            "meta": kwargs.get('meta_fields', {})
        }
        
        try:
            async with session.post(
                f"{website_url}/wp-json/wp/v2/posts",
                json=post_data
            ) as response:
                if response.status == 201:
                    data = await response.json()
                    return json.dumps({
                        "success": True,
                        "post_id": data.get('id'),
                        "edit_link": data.get('link')
                    })
                return json.dumps({
                    "error": f"Post creation failed: {response.status}",
                    "details": await response.text()
                })
        except Exception as e:
            return json.dumps({
                "error": "Post creation failed",
                "message": str(e)
            })

================
File: apps/agents/tools/wordpress/reader_tool.py
================
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, Field, ConfigDict
from apps.agents.tools.base_tool import BaseTool
import json
import logging
from .base import WordPressBaseTool
import asyncio
import aiohttp

logger = logging.getLogger(__name__)

class WordPressReaderSchema(BaseModel):
    """Schema for WordPress content reading operations"""
    website_url: str = Field(..., description="WordPress site URL")
    auth_token: str = Field(..., description="WordPress REST API authentication token")
    
    # Search parameters
    search_query: Optional[str] = Field(
        default="",
        description="Search term to find specific content"
    )
    search_field: Optional[str] = Field(
        default="title",
        description="Field to search in (title, content, slug)"
    )
    
    # Listing parameters
    list_all: Optional[bool] = Field(
        default=True,
        description="List all posts/pages instead of searching"
    )
    post_type: Optional[str] = Field(
        default="post",
        description="Content type to retrieve (post, page)"
    )
    per_page: Optional[int] = Field(
        default=20,
        description="Number of items per page (max 100)"
    )
    page: Optional[int] = Field(
        default=1,
        description="Page number for pagination"
    )
    
    # Additional filters
    status: Optional[str] = Field(
        default="publish",
        description="Content status (publish, draft, private)"
    )
    order_by: Optional[str] = Field(
        default="date",
        description="Sort field (date, title, modified)"
    )
    order: Optional[str] = Field(
        default="desc",
        description="Sort order (asc, desc)"
    )

    model_config = ConfigDict(
        extra='forbid',
        arbitrary_types_allowed=True
    )

class WordPressReaderTool(BaseTool, WordPressBaseTool):
    name: str = "WordPress Content Reader"
    description: str = """Retrieves WordPress post/page information for editing purposes.
    
    Features:
    - Search by URL, title, or slug
    - List all posts/pages with filters
    - Get post IDs and metadata
    
    Example usage:
    {
        "website_url": "https://blog.example.com",
        "auth_token": "wp_rest_token",
        "search_query": "optimizing-seo",
        "search_field": "slug"
    }"""
    
    args_schema: type[BaseModel] = WordPressReaderSchema

    def _run(
        self,
        website_url: str,
        auth_token: str,
        search_query: str = "",
        search_field: str = "title",
        list_all: bool = True,
        post_type: str = "post",
        per_page: int = 20,
        page: int = 1,
        status: str = "publish",
        order_by: str = "date",
        order: str = "desc",
        **kwargs
    ) -> str:
        """Handle WordPress content reading operations with explicit parameters"""
        logger.debug(f"Running WordPress reader with parameters: website_url={website_url}, "
                    f"search_query={search_query}, list_all={list_all}, post_type={post_type}")
        
        # Create validated schema instance
        params = WordPressReaderSchema(
            website_url=website_url,
            auth_token=auth_token,
            search_query=search_query,
            search_field=search_field,
            list_all=list_all,
            post_type=post_type,
            per_page=per_page,
            page=page,
            status=status,
            order_by=order_by,
            order=order
        )
        
        # Pass validated parameters to async method
        return self._run_sync(self._async_get_post(
            website_url=params.website_url,
            auth_token=params.auth_token,
            search_query=params.search_query,
            search_field=params.search_field,
            list_all=params.list_all,
            post_type=params.post_type,
            per_page=params.per_page,
            page=params.page,
            status=params.status,
            order_by=params.order_by,
            order=params.order
        ))

    async def _async_get_post(
        self,
        website_url: str,
        auth_token: str,
        search_query: str = "",
        search_field: str = "title",
        list_all: bool = True,
        post_type: str = "post",
        per_page: int = 20,
        page: int = 1,
        status: str = "publish",
        order_by: str = "date",
        order: str = "desc"
    ) -> str:
        """Async method to fetch WordPress content"""
        # Create timeout object with longer durations
        timeout = aiohttp.ClientTimeout(
            total=30,  # Total timeout for the whole request
            connect=10,  # Timeout for connecting to the server
            sock_read=30  # Timeout for reading the response
        )
        
        # Get base session without timeout
        session = await self._get_session(auth_token)
        # Update session timeout
        session._timeout = timeout
        
        # Rest of the headers and params setup...
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/json,*/*;q=0.9',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive'
        }
        
        if auth_token:
            headers['Authorization'] = f'Bearer {auth_token.replace(" ", "")}'
        
        params = {
            'per_page': per_page,
            'page': page,
            'status': status,
            'orderby': order_by,
            'order': order
        }
        
        # Add search parameters if searching
        if search_query and not list_all:
            params['search'] = search_query
            if search_field in ['title', 'content', 'slug']:
                params['search_columns'] = [search_field]
        
        try:
            logger.debug(f"Attempting to fetch WordPress content from {website_url} with timeout {timeout}")
            async with session.get(
                f"{website_url}/wp-json/wp/v2/{post_type}s",
                params=params,
                headers=headers,
                timeout=timeout
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    total_posts = response.headers.get('X-WP-Total', '0')
                    total_pages = response.headers.get('X-WP-TotalPages', '0')
                    
                    return json.dumps({
                        'success': True,
                        'total_posts': total_posts,
                        'total_pages': total_pages,
                        'current_page': page,
                        'posts': [
                            {
                                'id': post.get('id'),
                                'title': post.get('title', {}).get('rendered', ''),
                                'slug': post.get('slug', ''),
                                'status': post.get('status', ''),
                                'link': post.get('link', ''),
                                'modified': post.get('modified', '')
                            }
                            for post in data
                        ]
                    })
                return json.dumps({
                    'error': f"API request failed with status {response.status}",
                    'details': await response.text()
                })
        except asyncio.TimeoutError as e:
            logger.error(f"Timeout error fetching WordPress content: {str(e)}")
            return json.dumps({
                'error': "Request timed out",
                'message': "The request took too long to complete. Please try again."
            })
        except Exception as e:
            logger.error(f"Error fetching WordPress content: {str(e)}")
            return json.dumps({
                'error': "Failed to fetch WordPress content",
                'message': str(e)
            })

================
File: apps/agents/tools/youtube_video_search_tool/youtube_video_search_tool.py
================
from typing import Any, Optional, Type, Dict
from pydantic import BaseModel, Field
from apps.agents.tools.base_tool import BaseTool
from embedchain.models.data_type import DataType
import logging
import json
from django.conf import settings

logger = logging.getLogger(__name__)

class YoutubeVideoSearchToolSchema(BaseModel):
    """Input schema for YoutubeVideoSearchTool."""
    search_query: str = Field(
        ...,
        description="The search query to use when searching the Youtube Video content"
    )
    youtube_video_url: Optional[str] = Field(
        None,
        description="Optional youtube video URL to search. If not provided, will use pre-configured URL"
    )

class YoutubeVideoSearchTool(BaseTool):
    name: str = "Youtube Video Search Tool"
    description: str = "A tool that can be used to semantic search a query from Youtube Video content."
    args_schema: Type[BaseModel] = YoutubeVideoSearchToolSchema
    rag_instance: Optional[Any] = Field(default=None, exclude=True)
    youtube_video_url: Optional[str] = Field(default=None)
    
    def __init__(self, youtube_video_url: Optional[str] = None, **kwargs):
        super().__init__(**kwargs)
        if youtube_video_url:
            self.youtube_video_url = youtube_video_url
            self.description = f"A tool that can be used to semantic search queries from the Youtube Video at: {youtube_video_url}"
            self._initialize_rag(youtube_video_url)

    def _initialize_rag(self, video_url: str) -> None:
        """Initialize RAG system with the video content"""
        try:
            # Initialize your RAG system here
            self.rag_instance = self._create_rag_instance()
            self.rag_instance.add(video_url, data_type=DataType.YOUTUBE_VIDEO)
            logger.debug(f"Initialized RAG system with video: {video_url}")
        except Exception as e:
            logger.error(f"Error initializing RAG system: {str(e)}")
            raise

    def _create_rag_instance(self) -> Any:
        """Create and return RAG instance with appropriate configuration"""
        # Implement your RAG instance creation logic here
        # This would contain the logic from your parent RagTool class
        pass

    def _run(
        self,
        search_query: str,
        youtube_video_url: Optional[str] = None,
        **kwargs: Any,
    ) -> str:
        try:
            # Initialize RAG with new URL if provided
            if youtube_video_url and youtube_video_url != self.youtube_video_url:
                self._initialize_rag(youtube_video_url)
                self.youtube_video_url = youtube_video_url
            
            # Ensure RAG is initialized
            if not self.rag_instance:
                if not self.youtube_video_url:
                    raise ValueError("No Youtube video URL provided or configured")
                self._initialize_rag(self.youtube_video_url)
            
            # Perform the search
            result = self.rag_instance.search(search_query)
            
            logger.debug(f"Youtube video search completed for query: {search_query[:50]}...")
            return str(result)

        except Exception as e:
            logger.error(f"Error in YoutubeVideoSearchTool: {str(e)}")
            return json.dumps({
                "error": "Youtube video search failed",
                "message": str(e)
            })

================
File: apps/agents/tools/__init__.py
================
# Empty file to make the directory a Python package

================
File: apps/agents/tools/analytics_tool.py
================


================
File: apps/agents/tools/base_tool.py
================
from apps.agents.utils.minimal_tools import BaseTool, Tool, tool, ToolUsageError

__all__ = ['BaseTool', 'Tool', 'tool', 'ToolUsageError']

================
File: apps/agents/tools/manager.py
================
import logging
from langchain_core.tools import Tool
from ..utils import get_tool_classes

logger = logging.getLogger(__name__)

class AgentToolManager:
    def __init__(self):
        pass

    async def load_tools(self, agent):
        """Load and initialize agent tools"""
        tools = []
        for tool_model in agent.tools.all():
            try:
                tool_classes = get_tool_classes(tool_model.tool_class)
                tool_class = next((cls for cls in tool_classes 
                                if cls.__name__ == tool_model.tool_subclass), None)
                
                if tool_class:
                    logger.info(f"Initializing tool: {tool_class.__name__}")
                    tool_instance = tool_class()
                    tools.append(tool_instance)
                else:
                    logger.error(f"Tool class not found: {tool_model.tool_subclass}")
            except Exception as e:
                logger.error(f"Error loading tool {tool_model.name}: {str(e)}")
        return tools

    def convert_to_langchain_tools(self, tools):
        """Convert custom tools to Langchain format"""
        return [self._create_langchain_tool(tool) for tool in tools]

    def _create_langchain_tool(self, tool):
        """Create individual Langchain tool"""
        formatted_name = ''.join(c for c in tool.name if c.isalnum() or c in '_-')[:64]
        
        async def tool_func(query: str, tool=tool):
            try:
                result = await self.execute_tool(tool, {"query": query})
                return result
            except Exception as e:
                logger.error(f"Tool execution error: {str(e)}")
                return f"Error: {str(e)}"

        return Tool(
            name=formatted_name,
            description=self._create_tool_description(tool),
            func=tool_func,
            coroutine=tool_func
        )

================
File: apps/agents/tools/organization_context.py
================
import logging
import functools
from typing import Any, Dict, Optional, Type
from crewai.tools import BaseTool
from pydantic import Field, model_validator

from apps.organizations.utils import OrganizationContext

logger = logging.getLogger(__name__)

class OrganizationAwareToolMixin:
    """
    A mixin to make tools organization-aware.
    
    This mixin adds organization_id as a parameter to tools and ensures
    that organization context is properly set during tool execution.
    """
    organization_id: Optional[str] = Field(
        default=None,
        description="ID of the organization context for this tool execution"
    )
    
    @model_validator(mode='after')
    def _validate_organization(self):
        """Validate that organization_id is properly set"""
        if not self.organization_id:
            # If no organization_id, try to get from current context
            current_org = OrganizationContext.get_current()
            if current_org:
                self.organization_id = str(current_org.id)
                logger.debug(f"Using organization from current context: {self.organization_id}")
        
        return self
    
    def _run_with_org_context(self, original_run, **kwargs):
        """Run the tool with organization context set"""
        if not self.organization_id:
            logger.warning(
                f"Tool {self.__class__.__name__} executed without organization_id. "
                "Organization context will not be set."
            )
            return original_run(**kwargs)
            
        try:
            with OrganizationContext.organization_context(self.organization_id):
                logger.debug(f"Running tool {self.__class__.__name__} with organization_id: {self.organization_id}")
                return original_run(**kwargs)
        except Exception as e:
            logger.exception(
                f"Error in tool {self.__class__.__name__} "
                f"with organization_id {self.organization_id}: {str(e)}"
            )
            raise

def make_tool_organization_aware(tool_cls: Type[BaseTool]) -> Type[BaseTool]:
    """
    Factory function to create organization-aware versions of existing tools.
    
    Example:
        # Create an organization-aware version of an existing tool
        OrganizationAwareSEOCrawlerTool = make_tool_organization_aware(SEOCrawlerTool)
        
        # Use it with organization context
        tool = OrganizationAwareSEOCrawlerTool(organization_id=org.id)
        result = tool.run(website_url="https://example.com")
    """
    # Create a new class inheriting from the original tool and the mixin
    class OrganizationAwareTool(OrganizationAwareToolMixin, tool_cls):
        """
        Organization-aware version of {tool_cls.__name__}.
        Automatically handles organization context during execution.
        """
        
        def __init__(self, **data):
            super().__init__(**data)
            
            # Store original _run method
            self._original_run = super()._run
            
            # Override _run method with organization-aware version
            self._run = functools.partial(self._run_with_org_context, self._original_run)
            
    # Set appropriate name and docstring
    OrganizationAwareTool.__name__ = f"OrganizationAware{tool_cls.__name__}"
    OrganizationAwareTool.__doc__ = f"Organization-aware version of {tool_cls.__name__}."
    
    return OrganizationAwareTool

================
File: apps/agents/tools/utils.py
================
import os
from typing import Optional
from django.conf import settings
from django.core.files.storage import default_storage
from django.contrib.auth import get_user_model
import logging

logger = logging.getLogger(__name__)

def get_safe_path(user_id: int, path: str, directory: Optional[str] = None) -> str:
    """
    Ensures the path is valid for cloud storage and sanitizes it.
    
    Args:
        user_id: The ID of the user
        path: The requested path (/ represents user's media root)
        directory: Optional directory path
    
    Returns:
        str: Sanitized relative path for cloud storage
        
    Raises:
        ValueError: If path attempts directory traversal
    """
    try:
        # Construct user's base path
        user_base_path = str(user_id)
        
        # Handle root directory request
        if path == "/" or path == "":
            return user_base_path
        
        # Remove leading slash if present to make path relative
        path = path.lstrip('/')
        
        # Combine directory and path if directory is provided
        if directory:
            path = os.path.join(directory.lstrip('/'), path)
        
        # Create the full relative path
        relative_path = os.path.join(user_base_path, path)
        
        # Normalize path to resolve any . or .. components
        normalized_path = os.path.normpath(relative_path)
        
        # Security check: Verify the normalized path starts with user_id
        if not normalized_path.startswith(user_base_path):
            error_msg = f"Access denied: Path {path} attempts to access parent directory"
            logger.error(error_msg)
            raise ValueError(error_msg)
        
        # Ensure the path exists in storage (create if needed)
        if not path.endswith('/'):  # Only create directories for directory paths
            directory_path = os.path.dirname(normalized_path)
            if directory_path and not default_storage.exists(directory_path):
                # Create an empty placeholder file to ensure directory exists
                default_storage.save(os.path.join(directory_path, '.keep'), ContentFile(''))
                logger.debug(f"Created directory structure: {directory_path}")
        
        return normalized_path
        
    except Exception as e:
        if not isinstance(e, ValueError):  # Don't log ValueError as it's already logged
            logger.error(f"Error in get_safe_path: {str(e)}")
        raise

================
File: apps/agents/utils/scraper_adapters/__init__.py
================
"""
Scraper adapters package.
"""
from .base import ScraperAdapter
from .firecrawl_adapter import FireCrawlAdapter
from .firecrawl_crawl_adapter import FireCrawlCrawlAdapter
from .playwright_adapter import PlaywrightAdapter

__all__ = ['ScraperAdapter', 'FireCrawlAdapter', 'FireCrawlCrawlAdapter', 'PlaywrightAdapter', 'get_adapter']

def get_adapter(adapter_type='playwright'):
    """
    Get a scraper adapter instance.

    Args:
        adapter_type: Type of adapter to get ('playwright', 'firecrawl', or 'firecrawl_crawl')

    Returns:
        ScraperAdapter instance
    """
    if adapter_type == 'playwright':
        return PlaywrightAdapter()
    elif adapter_type == 'firecrawl':
        return FireCrawlAdapter()
    elif adapter_type == 'firecrawl_crawl':
        return FireCrawlCrawlAdapter()
    else:
        raise ValueError(f"Unknown adapter type: {adapter_type}")

================
File: apps/agents/utils/scraper_adapters/base.py
================
"""
Base adapter interface for web scraping services.
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Union


class ScraperAdapter(ABC):
    """Base adapter interface for web scraping services."""
    
    @abstractmethod
    def scrape(self, 
               url: str, 
               formats: List[str], 
               timeout: int = 30000,
               wait_for: Optional[int] = None,
               css_selector: Optional[str] = None,
               headers: Optional[Dict[str, str]] = None,
               mobile: bool = False,
               stealth: bool = False,
               **kwargs) -> Dict[str, Any]:
        """
        Scrape a URL and return the content in the requested formats.
        
        Args:
            url: The URL to scrape
            formats: List of formats to return (text, html, links, metadata, full)
            timeout: Timeout in milliseconds
            wait_for: Wait for element or time in milliseconds
            css_selector: CSS selector to extract content from
            headers: Custom headers to send with the request
            mobile: Whether to use mobile user agent
            stealth: Whether to use stealth mode
            **kwargs: Additional provider-specific parameters
            
        Returns:
            Dictionary with the requested formats as keys and their content as values
        """
        pass
    
    @abstractmethod
    def get_supported_formats(self) -> List[str]:
        """
        Get the list of formats supported by this adapter.
        
        Returns:
            List of supported format names
        """
        pass
    
    @abstractmethod
    def map_formats(self, formats: Union[str, List[str]]) -> List[str]:
        """
        Map internal format names to provider-specific format names.
        
        Args:
            formats: List of internal format names or comma-separated string
            
        Returns:
            List of provider-specific format names
        """
        pass

================
File: apps/agents/utils/scraper_adapters/firecrawl_adapter.py
================
"""
FireCrawl adapter for web scraping.
"""
import json
import logging
import requests
from typing import Dict, List, Any, Optional, Union

from django.conf import settings
from .base import ScraperAdapter

logger = logging.getLogger(__name__)


class FireCrawlAdapter(ScraperAdapter):
    """Adapter for FireCrawl web scraping service."""

    # Format mapping from internal formats to FireCrawl formats
    FORMAT_MAPPING = {
        'text': 'markdown',
        'html': 'html',
        'raw_html': 'rawHtml',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot',
        'full': ['markdown', 'html', 'links', 'metadata']
    }

    # Reverse mapping for response processing
    REVERSE_MAPPING = {
        'markdown': 'text',
        'html': 'html',
        'rawHtml': 'raw_html',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot'
    }

    def __init__(self, api_url=None, api_key=None):
        """
        Initialize the FireCrawl adapter.

        Args:
            api_url: FireCrawl API URL (defaults to settings.FIRECRAWL_URL)
            api_key: FireCrawl API key (defaults to settings.FIRECRAWL_API_KEY)
        """
        # Use the same URL construction as the original implementation
        self.api_url = getattr(settings, 'FIRECRAWL_URL', 'https://firecrawl.neuralami.ai')

    def get_supported_formats(self) -> List[str]:
        """Get the list of formats supported by FireCrawl."""
        return list(self.FORMAT_MAPPING.keys())

    def map_formats(self, formats: Union[str, List[str]]) -> List[str]:
        """Map internal format names to FireCrawl format names."""
        if isinstance(formats, str):
            # Handle comma-separated string
            formats = [fmt.strip() for fmt in formats.split(',')]

        firecrawl_formats = []
        for fmt in formats:
            if fmt in self.FORMAT_MAPPING:
                mapped_fmt = self.FORMAT_MAPPING[fmt]
                if isinstance(mapped_fmt, list):
                    firecrawl_formats.extend(mapped_fmt)
                else:
                    firecrawl_formats.append(mapped_fmt)
            else:
                logger.warning(f"Unknown format: {fmt}, ignoring")

        # Remove duplicates while preserving order
        return list(dict.fromkeys(firecrawl_formats))

    def _get_headers(self) -> Dict[str, str]:
        """Get headers for FireCrawl API request."""
        headers = {
            'Content-Type': 'application/json',
        }

        # The original implementation wasn't adding the API key to the headers
        # So we'll do the same here for compatibility

        return headers

    def _process_response(self, response_data: Dict[str, Any], requested_formats: List[str]) -> Dict[str, Any]:
        """
        Process FireCrawl response and map it back to internal format names.

        Args:
            response_data: FireCrawl response data
            requested_formats: Original requested formats (internal names)

        Returns:
            Dictionary with internal format names as keys
        """
        if not response_data.get('success', False):
            error_msg = response_data.get('error', 'Unknown error')
            logger.error(f"FireCrawl scrape failed: {error_msg}")
            return {'error': error_msg}

        result = {}
        data = response_data.get('data', {})

        # Map FireCrawl response keys to internal format names
        for fc_key, internal_key in self.REVERSE_MAPPING.items():
            if fc_key in data and data[fc_key] is not None:
                result[internal_key] = data[fc_key]

        # Special handling for metadata
        if 'metadata' in data:
            result['metadata'] = data['metadata']

        # Check if we got all requested formats
        for fmt in requested_formats:
            if fmt not in result and fmt != 'full':
                logger.warning(f"Requested format '{fmt}' not found in FireCrawl response")

        return result

    def scrape(self,
               url: str,
               formats: List[str],
               timeout: int = 30000,
               wait_for: Optional[int] = None,
               css_selector: Optional[str] = None,
               headers: Optional[Dict[str, str]] = None,
               mobile: bool = False,
               stealth: bool = False,
               cache: bool = True,
               **kwargs) -> Dict[str, Any]:
        """
        Scrape a URL using FireCrawl and return the content in the requested formats.

        Args:
            url: The URL to scrape
            formats: List of formats to return (text, html, links, metadata, full)
            timeout: Timeout in milliseconds
            wait_for: Wait for element or time in milliseconds
            css_selector: CSS selector to extract content from
            headers: Custom headers to send with the request
            mobile: Whether to use mobile user agent
            stealth: Whether to use stealth mode
            **kwargs: Additional FireCrawl-specific parameters

        Returns:
            Dictionary with the requested formats as keys and their content as values
        """
        # Map internal formats to FireCrawl formats
        firecrawl_formats = self.map_formats(formats)

        # Build request payload
        payload = {
            "url": url,
            "formats": firecrawl_formats,
            "timeout": timeout
            # FireCrawl v1 API doesn't support the 'cache' parameter
        }

        # Add optional parameters
        if wait_for:
            payload["waitFor"] = wait_for

        if css_selector:
            payload["includeTags"] = [css_selector]

        if mobile:
            payload["mobile"] = True

        if stealth:
            payload["proxy"] = "stealth"

        if headers:
            payload["headers"] = headers

        # Add any additional parameters
        for key, value in kwargs.items():
            if value is not None:
                # Convert snake_case to camelCase for FireCrawl API
                camel_key = ''.join(word.capitalize() if i > 0 else word
                                   for i, word in enumerate(key.split('_')))
                payload[camel_key] = value

        # Make the request
        logger.info(f"FireCrawl scrape request for URL: {url} with payload: {json.dumps(payload)}")

        try:
            # Submit scrape task using the same URL construction as the original implementation
            endpoint_url = f"{self.api_url}/v1/scrape"
            headers = self._get_headers()

            # Log detailed request information for debugging
            logger.debug(f"Making request to: {endpoint_url}")
            logger.debug(f"Headers: {headers}")
            logger.debug(f"Payload: {json.dumps(payload, indent=2)}")

            response = requests.post(
                endpoint_url,
                headers=headers,
                json=payload,
                timeout=timeout/1000  # Convert to seconds for requests
            )

            # Log response information
            logger.debug(f"Response status code: {response.status_code}")
            logger.debug(f"Response headers: {response.headers}")

            try:
                response_text = response.text
                logger.debug(f"Response text: {response_text}")
            except Exception as e:
                logger.debug(f"Could not get response text: {str(e)}")

            # Raise exception for non-2xx status codes
            response.raise_for_status()
            response_data = response.json()

            logger.info(f"Successfully scraped URL with FireCrawl: {url}")

            # Process and return the response
            result = self._process_response(response_data, formats)

            # Log the keys we got back
            logger.debug(f"Successfully retrieved content with keys: {list(result.keys())}")

            return result

        except requests.exceptions.RequestException as e:
            logger.error(f"Error scraping URL with FireCrawl: {url}, error: {str(e)}")
            return {"error": str(e)}
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding FireCrawl response: {str(e)}")
            return {"error": f"Invalid JSON response: {str(e)}"}
        except Exception as e:
            logger.error(f"Unexpected error scraping URL with FireCrawl: {url}, error: {str(e)}")
            return {"error": str(e)}

================
File: apps/agents/utils/scraper_adapters/firecrawl_crawl_adapter.py
================
"""
FireCrawl Crawl adapter for web crawling.
"""
import json
import logging
import requests
import time
from typing import Dict, List, Any, Optional, Union

from django.conf import settings
from .base import ScraperAdapter

logger = logging.getLogger(__name__)


class FireCrawlCrawlAdapter(ScraperAdapter):
    """Adapter for FireCrawl web crawling service using the /crawl endpoint."""

    # Format mapping from internal formats to FireCrawl formats
    FORMAT_MAPPING = {
        'text': 'markdown',
        'html': 'html',
        'raw_html': 'rawHtml',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot',
        'full': ['markdown', 'html', 'links', 'metadata']
    }

    # Reverse mapping for response processing
    REVERSE_MAPPING = {
        'markdown': 'text',
        'html': 'html',
        'rawHtml': 'raw_html',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot'
    }

    def __init__(self, api_url=None, api_key=None):
        """
        Initialize the FireCrawl Crawl adapter.

        Args:
            api_url: FireCrawl API URL (defaults to settings.FIRECRAWL_URL)
            api_key: FireCrawl API key (defaults to settings.FIRECRAWL_API_KEY)
        """
        # Use the same URL construction as the original implementation
        self.api_url = getattr(settings, 'FIRECRAWL_URL', 'https://firecrawl.neuralami.ai')
        self.api_key = getattr(settings, 'FIRECRAWL_API_KEY', None)

    def get_supported_formats(self) -> List[str]:
        """Get the list of formats supported by FireCrawl."""
        return list(self.FORMAT_MAPPING.keys())

    def map_formats(self, formats: Union[str, List[str]]) -> List[str]:
        """Map internal format names to FireCrawl format names."""
        if isinstance(formats, str):
            # Handle comma-separated string
            formats = [fmt.strip() for fmt in formats.split(',')]

        firecrawl_formats = []
        for fmt in formats:
            if fmt in self.FORMAT_MAPPING:
                mapped_fmt = self.FORMAT_MAPPING[fmt]
                if isinstance(mapped_fmt, list):
                    firecrawl_formats.extend(mapped_fmt)
                else:
                    firecrawl_formats.append(mapped_fmt)
            else:
                logger.warning(f"Unknown format: {fmt}, ignoring")

        # Remove duplicates while preserving order
        return list(dict.fromkeys(firecrawl_formats))

    def _get_headers(self) -> Dict[str, str]:
        """Get headers for FireCrawl API request."""
        headers = {
            'Content-Type': 'application/json',
        }

        # The original implementation wasn't adding the API key to the headers
        # So we'll do the same here for compatibility

        return headers

    def _process_response(self, response_data: Dict[str, Any], requested_formats: List[str]) -> Dict[str, Any]:
        """
        Process FireCrawl response and map it back to internal format names.

        Args:
            response_data: FireCrawl response data
            requested_formats: Original requested formats (internal names)

        Returns:
            Dictionary with internal format names as keys
        """
        if not response_data.get('success', False):
            error_msg = response_data.get('error', 'Unknown error')
            logger.error(f"FireCrawl crawl failed: {error_msg}")
            return {'error': error_msg}

        result = {}

        # For crawl endpoint, the data is a list of pages
        pages_data = response_data.get('data', [])

        # Combine all pages into a single result
        for page in pages_data:
            url = page.get('url', '')

            # Skip if no URL
            if not url:
                continue

            # Create page entry if it doesn't exist
            if url not in result:
                result[url] = {}

            # Map FireCrawl response keys to internal format names
            for fc_key, internal_key in self.REVERSE_MAPPING.items():
                if fc_key in page and page[fc_key] is not None:
                    result[url][internal_key] = page[fc_key]

            # Special handling for metadata
            if 'metadata' in page:
                result[url]['metadata'] = page['metadata']

        return result

    def scrape(self,
               url: str,
               formats: List[str],
               timeout: int = 30000,
               wait_for: Optional[int] = None,
               css_selector: Optional[str] = None,
               headers: Optional[Dict[str, str]] = None,
               mobile: bool = False,
               stealth: bool = False,
               cache: bool = True,
               max_pages: int = 100,
               max_depth: int = 3,
               include_patterns: Optional[List[str]] = None,
               exclude_patterns: Optional[List[str]] = None,
               stay_within_domain: bool = True,
               **kwargs) -> Dict[str, Any]:
        """
        Crawl a website using FireCrawl and return the content in the requested formats.

        Args:
            url: The URL to crawl
            formats: List of formats to return (text, html, links, metadata, full)
            timeout: Timeout in milliseconds
            wait_for: Wait for element or time in milliseconds
            css_selector: CSS selector to extract content from
            headers: Custom headers to send with the request
            mobile: Whether to use mobile user agent
            stealth: Whether to use stealth mode
            cache: Whether to use cached results
            max_pages: Maximum number of pages to crawl
            max_depth: Maximum depth to crawl
            include_patterns: URL patterns to include in crawl
            exclude_patterns: URL patterns to exclude from crawl
            stay_within_domain: Whether to stay within the domain
            **kwargs: Additional FireCrawl-specific parameters

        Returns:
            Dictionary with the requested formats as keys and their content as values
        """
        # Map internal formats to FireCrawl formats
        firecrawl_formats = self.map_formats(formats)

        # Build request payload to match the original implementation
        payload = {
            "url": url,
            "limit": max_pages,
            "scrapeOptions": {
                "formats": firecrawl_formats
            }
        }

        # Add maxDepth if provided
        if max_depth > 0:
            payload["maxDepth"] = max_depth

        # Enable backward links to improve coverage (gets pages that aren't direct children)
        payload["allowBackwardLinks"] = True

        # Only stay on the same domain by default
        payload["allowExternalLinks"] = not stay_within_domain

        # Add optional parameters
        if wait_for:
            payload["scrapeOptions"]["waitFor"] = wait_for

        if css_selector:
            payload["scrapeOptions"]["includeTags"] = [css_selector]

        if mobile:
            payload["scrapeOptions"]["mobile"] = True

        # Handle stealth mode - in /crawl it might be a top-level parameter
        if stealth:
            # Try both locations to be safe
            payload["scrapeOptions"]["proxy"] = "stealth"

        if headers:
            payload["scrapeOptions"]["headers"] = headers

        # Add include/exclude patterns
        if include_patterns:
            payload["includePaths"] = include_patterns
        else:
            # Default to include all paths
            payload["includePaths"] = ["/.*"]

        if exclude_patterns:
            payload["excludePaths"] = exclude_patterns

        # We already set allowExternalLinks above, so no need to set it again

        # Add any additional parameters
        for key, value in kwargs.items():
            if value is not None:
                # Convert snake_case to camelCase for FireCrawl API
                camel_key = ''.join(word.capitalize() if i > 0 else word
                                   for i, word in enumerate(key.split('_')))
                payload[camel_key] = value

        # Make the request
        logger.info(f"FireCrawl crawl request for URL: {url} with payload: {json.dumps(payload)}")

        try:
            # Submit crawl task using the same URL construction as the original implementation
            endpoint_url = f"{self.api_url}/v1/crawl"
            headers = self._get_headers()

            # Log detailed request information for debugging
            logger.debug(f"Making request to: {endpoint_url}")
            logger.debug(f"Headers: {headers}")
            logger.debug(f"Payload: {json.dumps(payload, indent=2)}")

            response = requests.post(
                endpoint_url,
                headers=headers,
                json=payload,
                timeout=timeout/1000  # Convert to seconds for requests
            )

            # Log response information
            logger.debug(f"Response status code: {response.status_code}")
            logger.debug(f"Response headers: {response.headers}")

            try:
                response_text = response.text
                logger.debug(f"Response text: {response_text}")
            except Exception as e:
                logger.debug(f"Could not get response text: {str(e)}")

            # Raise exception for non-2xx status codes
            response.raise_for_status()
            task_data = response.json()

            if not task_data.get("success"):
                error_message = f"Failed to submit crawl task: {task_data.get('error', 'Unknown error')}"
                logger.error(error_message)
                return {"error": error_message}

            crawl_task_id = task_data.get("id")
            crawl_task_url = task_data.get("url")

            logger.info(f"Crawl task submitted, ID: {crawl_task_id}")

            # Poll for results
            polling_timeout = 1620  # seconds
            start_time = time.time()
            polling_interval = 5  # seconds between status checks

            # Poll for results of crawl
            while True:
                if time.time() - start_time > polling_timeout:
                    return {"error": f"Task {crawl_task_id} timed out after {polling_timeout} seconds"}

                result_response = requests.get(
                    crawl_task_url,
                    headers=self._get_headers()
                )
                result_response.raise_for_status()
                status = result_response.json()

                # Log status information for debugging
                logger.info(f"Crawl status: {status.get('status', 'unknown')}, Total: {status.get('total', 0)}, Completed: {status.get('completed', 0)}")

                # Check if crawl is complete
                if status.get("status") == "completed":
                    logger.info(f"Crawl completed: {crawl_task_id}")

                    # Process and return the response
                    result = self._process_response(status, formats)

                    # Log the keys we got back
                    logger.debug(f"Successfully retrieved content for {len(result)} pages")

                    return result

                # Check if crawl failed
                if status.get("status") == "failed":
                    error_message = f"Crawl failed: {status.get('error', 'Unknown error')}"
                    logger.error(error_message)
                    return {"error": error_message}

                # Wait before checking again
                time.sleep(polling_interval)

        except requests.exceptions.RequestException as e:
            logger.error(f"Error crawling URL with FireCrawl: {url}, error: {str(e)}")
            return {"error": str(e)}
        except json.JSONDecodeError as e:
            logger.error(f"Error decoding FireCrawl response: {str(e)}")
            return {"error": f"Invalid JSON response: {str(e)}"}
        except Exception as e:
            logger.error(f"Unexpected error crawling URL with FireCrawl: {url}, error: {str(e)}")
            return {"error": str(e)}

================
File: apps/agents/utils/scraper_adapters/playwright_adapter.py
================
"""
Playwright adapter for web scraping using an external Playwright service.
"""
import json
import logging
import requests
import re
from typing import Dict, List, Any, Optional, Union
from urllib.parse import urlparse

from django.conf import settings
from .base import ScraperAdapter

logger = logging.getLogger(__name__)


class PlaywrightAdapter(ScraperAdapter):
    """Adapter for external Playwright web scraping service."""

    # Format mapping from internal formats to Playwright formats
    FORMAT_MAPPING = {
        'text': 'text',
        'html': 'html',
        'raw_html': 'raw_html',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot',
        'full': ['text', 'html', 'links', 'metadata', 'screenshot']
    }

    # Reverse mapping for response processing
    REVERSE_MAPPING = {
        'text': 'text',
        'html': 'html',
        'raw_html': 'raw_html',
        'links': 'links',
        'metadata': 'metadata',
        'screenshot': 'screenshot'
    }

    def __init__(self, api_url=None, api_key=None):
        """
        Initialize the Playwright adapter.

        Args:
            api_url: Playwright service API URL (defaults to settings.PLAYWRIGHT_API_URL)
            api_key: Playwright service API key (defaults to settings.PLAYWRIGHT_API_KEY)
        """
        self.api_url = api_url or getattr(settings, 'PLAYWRIGHT_API_URL', 'https://playwright-service.example.com/api')
        self.api_key = api_key or getattr(settings, 'PLAYWRIGHT_API_KEY', None)

    def get_supported_formats(self) -> List[str]:
        """Get the list of formats supported by Playwright."""
        return list(self.FORMAT_MAPPING.keys())

    def map_formats(self, formats: Union[str, List[str]]) -> List[str]:
        """Map internal format names to Playwright format names."""
        if isinstance(formats, str):
            # Handle comma-separated string
            formats = [fmt.strip() for fmt in formats.split(',')]

        # Ensure formats is a list
        if not isinstance(formats, list):
            formats = [formats]

        playwright_formats = []
        for fmt in formats:
            # Handle non-string formats
            if not isinstance(fmt, str):
                logger.warning(f"Non-string format: {fmt}, converting to string")
                fmt = str(fmt)

            # Strip whitespace if it's a string
            if isinstance(fmt, str):
                fmt = fmt.strip()

            if fmt in self.FORMAT_MAPPING:
                mapped_fmt = self.FORMAT_MAPPING[fmt]
                if isinstance(mapped_fmt, list):
                    playwright_formats.extend(mapped_fmt)
                else:
                    playwright_formats.append(mapped_fmt)
            else:
                logger.warning(f"Unknown format: {fmt}, ignoring")

        # Remove duplicates while preserving order
        return list(dict.fromkeys(playwright_formats))

    def _get_headers(self) -> Dict[str, str]:
        """Get headers for Playwright API request."""
        headers = {
            'Content-Type': 'application/json',
        }

        if self.api_key:
            headers['Authorization'] = f'Bearer {self.api_key}'
            logger.debug(f"Using API key: {self.api_key[:4]}...{self.api_key[-4:] if len(self.api_key) > 8 else ''}")
        else:
            logger.warning("No Playwright API key found. API calls may fail.")

        return headers

    def _clean_text(self, text: str) -> str:
        """
        Clean text content by removing non-breaking spaces and excessive whitespace.

        Args:
            text: The text to clean

        Returns:
            Cleaned text
        """
        if not text:
            return ""

        # Replace non-breaking space characters (Â, \xa0, etc.)
        cleaned = re.sub(r'\xa0|Â', ' ', text)

        # Replace multiple spaces with a single space
        cleaned = re.sub(r'\s+', ' ', cleaned)

        # Replace multiple newlines with a single newline
        cleaned = re.sub(r'\n+', '\n', cleaned)

        # Remove leading/trailing whitespace
        cleaned = cleaned.strip()

        return cleaned

    def _process_response(self, response_data: Dict[str, Any], requested_formats: List[str]) -> Dict[str, Any]:
        """
        Process Playwright response and map it back to internal format names.

        Args:
            response_data: Playwright response data
            requested_formats: Original requested formats (internal names)

        Returns:
            Dictionary with internal format names as keys
        """
        if not response_data.get('success', False):
            error_msg = response_data.get('error', 'Unknown error')
            logger.error(f"Playwright scrape failed: {error_msg}")
            return {'error': error_msg}

        result = {}
        data = response_data.get('data', {})

        # Map Playwright response keys to internal format names
        for pw_key, internal_key in self.REVERSE_MAPPING.items():
            if pw_key in data and data[pw_key] is not None:
                # Clean text content if this is the text field
                if pw_key == 'text':
                    result[internal_key] = self._clean_text(data[pw_key])
                else:
                    result[internal_key] = data[pw_key]

        # Special handling for metadata
        if 'metadata' in data:
            result['metadata'] = data['metadata']

            # If title is in metadata, make sure it's also at the top level
            if 'title' in data['metadata'] and data['metadata']['title']:
                result['title'] = data['metadata']['title']

        # Check if we got all requested formats
        for fmt in requested_formats:
            if fmt not in result and fmt != 'full':
                logger.warning(f"Requested format '{fmt}' not found in Playwright response")

        return result

    def scrape(self,
               url: str,
               formats: Union[List[str], str] = None,
               timeout: int = 30000,
               wait_for: Optional[int] = None,
               css_selector: Optional[str] = None,
               headers: Optional[Dict[str, str]] = None,
               mobile: bool = False,
               stealth: bool = False,
               cache: bool = True,
               max_retries: int = 3,  # Add retry mechanism
               **kwargs) -> Dict[str, Any]:
        """
        Scrape a URL using Playwright and return the content in the requested formats.

        Args:
            url: The URL to scrape
            formats: List of formats to return (text, html, links, metadata, full)
            timeout: Timeout in milliseconds
            wait_for: Wait for element or time in milliseconds
            css_selector: CSS selector to extract content from
            headers: Custom headers to send with the request
            mobile: Whether to use mobile user agent
            stealth: Whether to use stealth mode
            cache: Whether to use cached results
            **kwargs: Additional Playwright-specific parameters

        Returns:
            Dictionary with the requested formats as keys and their content as values
        """
        # Handle default formats
        if formats is None:
            formats = ["text", "links"]

        # Map internal formats to Playwright formats
        logger.debug(f"Original formats: {formats}")

        # Remove duplicates while preserving order
        unique_formats = []
        for fmt in formats:
            if fmt not in unique_formats:
                unique_formats.append(fmt)

        # Map the formats
        playwright_formats = self.map_formats(unique_formats)
        logger.debug(f"Mapped formats: {playwright_formats}")

        # Build request payload
        payload = {
            "url": url,
            "formats": playwright_formats,
            "timeout": timeout,
            "cache": cache,
            "headers": {
                # Use a more common browser user agent
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                "Accept-Language": "en-US,en;q=0.9",
                "Accept-Encoding": "gzip, deflate, br",
                "Connection": "keep-alive",
                "Upgrade-Insecure-Requests": "1",
                "Sec-Fetch-Dest": "document",
                "Sec-Fetch-Mode": "navigate",
                "Sec-Fetch-Site": "none",
                "Sec-Fetch-User": "?1",
                "Cache-Control": "max-age=0",
                # Add a referer to make it look like we're coming from Google
                "Referer": "https://www.google.com/"
            }
        }

        # Add optional parameters
        if wait_for:
            payload["waitFor"] = wait_for

        if css_selector:
            payload["selector"] = css_selector

        if mobile:
            payload["mobile"] = True

        if stealth:
            payload["stealth"] = True

        # Always enable JavaScript to handle potential Cloudflare challenges
        payload["javascript"] = True

        # Enable debug mode to get more information about the page
        payload["debug"] = True

        # Use a non-headless browser to avoid detection
        payload["headless"] = False

        # Add browser fingerprinting to make it look more like a real browser
        payload["browser"] = {
            "name": "chrome",
            "platform": "Windows",
            "version": "91.0.4472.124",
            "viewport": {
                "width": 1920,
                "height": 1080
            },
            "userAgent": payload["headers"]["User-Agent"]
        }

        # Add cookies to make it look like a returning visitor
        payload["cookies"] = [
            {
                "name": "visited",
                "value": "true",
                "domain": urlparse(url).netloc,
                "path": "/"
            }
        ]

        if headers:
            payload["headers"] = headers

        # Add any additional parameters
        for key, value in kwargs.items():
            if value is not None:
                # Convert snake_case to camelCase for API
                camel_key = ''.join(word.capitalize() if i > 0 else word
                                   for i, word in enumerate(key.split('_')))
                payload[camel_key] = value

        # Make the request
        logger.info(f"Playwright scrape request for URL: {url} with payload: {json.dumps(payload)}")

        # Initialize retry counter
        retry_count = 0
        last_error = None

        while retry_count < max_retries:
            try:
                # Log detailed request information for debugging
                endpoint_url = f"{self.api_url}/scrape"
                headers = self._get_headers()

                logger.debug(f"Making request to: {endpoint_url} (Attempt {retry_count + 1}/{max_retries})")
                logger.debug(f"Headers: {headers}")
                logger.debug(f"Payload: {json.dumps(payload, indent=2)}")

                response = requests.post(
                    endpoint_url,
                    headers=headers,
                    json=payload,
                    timeout=timeout/1000  # Convert to seconds for requests
                )

                # Log response information
                logger.debug(f"Response status code: {response.status_code}")
                #logger.debug(f"Response headers: {response.headers}")

                try:
                    response_text = response.text
                    logger.debug(f"Response text: {response_text}")
                except Exception as e:
                    logger.debug(f"Could not get response text: {str(e)}")

                # Check if the response is successful (2xx status code)
                if response.status_code >= 200 and response.status_code < 300:
                    response_data = response.json()

                    # Check if the Playwright service returned a 403 error from the website
                    if response_data.get('success', True) and response_data.get('data', {}).get('text') == '403 Forbidden':
                        logger.warning(f"Playwright service received a 403 Forbidden response from the website: {url}")

                        # Immediately try RateLimitedFetcher as a fallback for 403 errors
                        logger.info(f"Immediately trying RateLimitedFetcher as a fallback for 403 error: {url}")

                        try:
                            # Import here to avoid circular imports
                            from apps.agents.utils.rate_limited_fetcher import RateLimitedFetcher

                            # Use RateLimitedFetcher as a fallback
                            fetch_result = RateLimitedFetcher.fetch_url(url)

                            if fetch_result.get("success", False):
                                logger.info(f"Successfully fetched URL with RateLimitedFetcher: {url}")

                                # Create a result dictionary with the fetched content
                                fallback_result = {}

                                # Add text content if requested
                                if "text" in formats:
                                    fallback_result["text"] = self._clean_text(fetch_result.get("content", ""))

                                # Add HTML content if requested
                                if "html" in formats:
                                    fallback_result["html"] = fetch_result.get("content", "")

                                # Extract metadata if requested
                                if "metadata" in formats:
                                    # Try to extract metadata from HTML
                                    from bs4 import BeautifulSoup
                                    soup = BeautifulSoup(fetch_result.get("content", ""), "html.parser")

                                    metadata = {}

                                    # Extract title
                                    title_tag = soup.find("title")
                                    if title_tag:
                                        metadata["title"] = title_tag.text.strip()
                                        fallback_result["title"] = title_tag.text.strip()

                                    # Extract meta tags
                                    for meta in soup.find_all("meta"):
                                        if meta.get("name"):
                                            metadata[meta.get("name")] = meta.get("content", "")
                                        elif meta.get("property"):
                                            metadata[meta.get("property")] = meta.get("content", "")

                                    fallback_result["metadata"] = metadata

                                # Extract links if requested
                                if "links" in formats:
                                    from bs4 import BeautifulSoup
                                    soup = BeautifulSoup(fetch_result.get("content", ""), "html.parser")

                                    links = []
                                    for link in soup.find_all("a"):
                                        href = link.get("href")
                                        if href:
                                            links.append({
                                                "href": href,
                                                "text": link.text.strip()
                                            })

                                    fallback_result["links"] = links

                                # Add URL to the result
                                fallback_result["url"] = url

                                return fallback_result
                            else:
                                # If RateLimitedFetcher also fails, continue with the normal retry process
                                logger.warning(f"RateLimitedFetcher fallback failed for 403 error: {url}")
                                raise requests.exceptions.HTTPError("403 Forbidden response from website")
                        except Exception as fallback_error:
                            logger.error(f"Error using RateLimitedFetcher fallback for 403 error: {str(fallback_error)}")
                            raise requests.exceptions.HTTPError("403 Forbidden response from website")
                else:
                    # Raise exception for non-2xx status codes
                    response.raise_for_status()
                    response_data = response.json()

                logger.info(f"Successfully scraped URL with Playwright: {url}")

                # Process and return the response
                result = self._process_response(response_data, formats)

                # If we get here, the request was successful, so break out of the retry loop
                break

            except requests.exceptions.RequestException as e:
                retry_count += 1
                last_error = e
                logger.warning(f"Playwright request failed (attempt {retry_count}/{max_retries}): {str(e)}")

                if retry_count < max_retries:
                    # Check if this is a 403 error
                    is_403_error = False
                    if isinstance(last_error, requests.exceptions.HTTPError) and "403 Forbidden" in str(last_error):
                        is_403_error = True
                        logger.warning(f"Detected 403 Forbidden error, using special handling")

                    # Try different approaches on each retry
                    if is_403_error:
                        # Special handling for 403 errors
                        if retry_count == 1:
                            # First retry for 403: Try with a completely different browser profile
                            payload["headers"]["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                            payload["headers"]["Accept"] = "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8"
                            payload["headers"]["Accept-Language"] = "en-US,en;q=0.9"
                            # Add cookies to bypass potential cookie checks
                            payload["cookies"] = [
                                {"name": "visited", "value": "true", "domain": urlparse(url).netloc, "path": "/"},
                                {"name": "cookieconsent_status", "value": "dismiss", "domain": urlparse(url).netloc, "path": "/"}
                            ]
                            # Use a different referer that looks like a search engine
                            payload["headers"]["Referer"] = "https://www.google.com/search?q=" + urlparse(url).netloc
                            # Disable headless mode
                            payload["headless"] = False
                            # Disable stealth mode (sometimes stealth mode is detected)
                            if "stealth" in payload:
                                del payload["stealth"]
                            logger.info(f"Retry {retry_count} for 403 error: Using different browser profile and cookies")
                        elif retry_count == 2:
                            # Second retry for 403: Try with mobile emulation and a different approach
                            payload["mobile"] = True
                            payload["headers"]["User-Agent"] = "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
                            # Add a delay before navigation to allow the page to fully load
                            payload["navigationDelay"] = 2000
                            # Add a wait for navigation to complete
                            payload["waitForNavigation"] = True
                            # Try to bypass Cloudflare by waiting for the page to load completely
                            payload["waitUntil"] = "networkidle"
                            logger.info(f"Retry {retry_count} for 403 error: Using mobile emulation with navigation delay")
                    else:
                        # Standard retry approach for non-403 errors
                        if retry_count == 1:
                            # First retry: Try with a different user agent
                            user_agents = [
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15",
                                "Mozilla/5.0 (X11; Linux x86_64; rv:89.0) Gecko/20100101 Firefox/89.0",
                                "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
                            ]
                            payload["headers"]["User-Agent"] = user_agents[0]
                            # Add a different referer
                            payload["headers"]["Referer"] = "https://www.bing.com/"
                            logger.info(f"Retry {retry_count}: Using different user agent and referer")
                        elif retry_count == 2:
                            # Second retry: Try with mobile emulation
                            payload["mobile"] = True
                            payload["headers"]["User-Agent"] = "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
                            # Remove headless mode
                            payload["headless"] = False
                            # Try without stealth mode
                            if "stealth" in payload:
                                del payload["stealth"]
                            logger.info(f"Retry {retry_count}: Using mobile emulation without stealth mode")

                    # Wait a bit before retrying
                    import time
                    time.sleep(1 * retry_count)  # Exponential backoff
                else:
                    # This was the last retry and it failed
                    logger.error(f"All {max_retries} Playwright requests failed for URL: {url}")

        # If we've exhausted all retries and still failed, try using RateLimitedFetcher as a fallback
        if retry_count >= max_retries and last_error is not None:
            logger.error(f"All {max_retries} Playwright requests failed for URL: {url}, last error: {str(last_error)}")
            logger.info(f"Trying RateLimitedFetcher as a fallback for URL: {url}")

            try:
                # Import here to avoid circular imports
                from apps.agents.utils.rate_limited_fetcher import RateLimitedFetcher

                # Use RateLimitedFetcher as a fallback
                fetch_result = RateLimitedFetcher.fetch_url(url)

                if fetch_result.get("success", False):
                    logger.info(f"Successfully fetched URL with RateLimitedFetcher: {url}")

                    # Create a result dictionary with the fetched content
                    result = {}

                    # Add text content if requested
                    if "text" in formats:
                        result["text"] = self._clean_text(fetch_result.get("content", ""))

                    # Add HTML content if requested
                    if "html" in formats:
                        result["html"] = fetch_result.get("content", "")

                    # Extract metadata if requested
                    if "metadata" in formats:
                        # Try to extract metadata from HTML
                        from bs4 import BeautifulSoup
                        soup = BeautifulSoup(fetch_result.get("content", ""), "html.parser")

                        metadata = {}

                        # Extract title
                        title_tag = soup.find("title")
                        if title_tag:
                            metadata["title"] = title_tag.text.strip()
                            result["title"] = title_tag.text.strip()

                        # Extract meta tags
                        for meta in soup.find_all("meta"):
                            if meta.get("name"):
                                metadata[meta.get("name")] = meta.get("content", "")
                            elif meta.get("property"):
                                metadata[meta.get("property")] = meta.get("content", "")

                        result["metadata"] = metadata

                    # Extract links if requested
                    if "links" in formats:
                        from bs4 import BeautifulSoup
                        soup = BeautifulSoup(fetch_result.get("content", ""), "html.parser")

                        links = []
                        for link in soup.find_all("a"):
                            href = link.get("href")
                            if href:
                                links.append({
                                    "href": href,
                                    "text": link.text.strip()
                                })

                        result["links"] = links

                    # Add URL to the result
                    result["url"] = url

                    return result
                else:
                    logger.error(f"RateLimitedFetcher fallback also failed for URL: {url}")
                    return {"error": f"Failed after {max_retries} retries with Playwright and RateLimitedFetcher fallback: {str(last_error)}"}
            except Exception as fallback_error:
                logger.error(f"Error using RateLimitedFetcher fallback: {str(fallback_error)}")
                return {"error": f"Failed after {max_retries} retries with Playwright and RateLimitedFetcher fallback: {str(last_error)}"}

        # Log the keys we got back if we have a result
        if 'result' in locals() and result:
            logger.debug(f"Successfully retrieved content with keys: {list(result.keys())}")
            return result

        # Fallback error if something unexpected happened
        logger.error(f"Unexpected error in Playwright scraping for URL: {url}")
        return {"error": "Unknown error"}

================
File: apps/agents/utils/__init__.py
================
"""
Utils package for agent-related utilities.
This package replaces the original utils.py with a more modular structure.
"""

# Import and expose all key functions from tool_utils.py
from .tool_utils import (
    load_tool, 
    get_tool_description, 
    get_available_tools, 
    get_tool_classes, 
    get_tool_class_obj, 
    get_tool_info
)

# Import and expose URL utilities
from .url_utils import URLDeduplicator

# Import and expose client utilities
from .client_utils import ClientDataUtils

# Import and expose other utilities as needed
from .formatters import *
from .error_handling import *
from .scrape_url import *
from .get_targeted_keywords import *

# Make all imports available at the package level
__all__ = [
    # Tool utilities
    'load_tool', 
    'get_tool_description', 
    'get_available_tools', 
    'get_tool_classes', 
    'get_tool_class_obj', 
    'get_tool_info',
    
    # URL utilities
    'URLDeduplicator',
    
    # Client utilities
    'ClientDataUtils',
]

================
File: apps/agents/utils/client_utils.py
================
import logging
from django.utils import timezone
from apps.seo_manager.models import Client
from django.apps import apps
from channels.db import database_sync_to_async
from apps.organizations.shortcuts import get_object_or_404

# Try to import OrganizationContext, but don't fail if not available
try:
    from apps.organizations.utils import OrganizationContext
except ImportError:
    OrganizationContext = None
    logging.getLogger(__name__).warning("OrganizationContext not available, some multi-tenancy features may be limited")

logger = logging.getLogger(__name__)

class ClientDataUtils:
    """
    Utility class for client data operations.
    Provides consistent access to client data across the application.
    Compatible with both synchronous and asynchronous code via ContextVars.
    """
    
    @staticmethod
    def get_client_data(client, organization_id=None):
        """
        Get formatted client data with analytics credentials.
        
        Args:
            client: A Client model instance
            organization_id: Optional organization ID to override current context
            
        Returns:
            dict: Dictionary containing client data and credentials
        """
        if not client:
            logger.warning("get_client_data called with None client")
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
        
        # Format SEO projects into a readable string
        seo_projects_list = []
        for project in client.seo_projects.all().order_by('-implementation_date'):
            project_str = (
                f"Project: {project.title}\n"
                f"Description: {project.description}\n"
                f"Status: {project.status}\n"
                f"Implementation Date: {project.implementation_date.isoformat() if project.implementation_date else 'Not set'}\n"
                f"Completion Date: {project.completion_date.isoformat() if project.completion_date else 'Not set'}"
            )
            seo_projects_list.append(project_str)
        
        seo_projects_str = "\n\n".join(seo_projects_list) if seo_projects_list else ""
        
        client_data = {
            'client_id': client.id,
            'client_name': client.name,
            'client_website_url': client.website_url,
            'client_business_objectives': '\n'.join(str(obj) for obj in client.business_objectives) if client.business_objectives else '',
            'client_target_audience': client.target_audience,
            'client_profile': client.client_profile,
            'client_seo_projects': seo_projects_str,
            'current_date': timezone.now().date().isoformat(),
        }
        
        # Add Google Analytics credentials if available
        try:
            if hasattr(client, 'ga_credentials') and client.ga_credentials:
                ga_creds = client.ga_credentials
                
                # Try to get property_id using get_property_id() method if available
                if hasattr(ga_creds, 'get_property_id') and callable(getattr(ga_creds, 'get_property_id')):
                    try:
                        property_id = ga_creds.get_property_id()
                        client_data['analytics_property_id'] = str(property_id) if property_id is not None else ''
                        logger.debug(f"Got property_id '{property_id}' using get_property_id() method")
                    except Exception as e:
                        logger.warning(f"Failed to get property_id using get_property_id() method: {e}")
                        client_data['analytics_property_id'] = ''
                else:
                    # Fallback to direct attribute access
                    client_data['analytics_property_id'] = getattr(ga_creds, 'property_id', '')
                    
                    # Fallback to view_id for older GA3 structure
                    if not client_data['analytics_property_id'] and hasattr(ga_creds, 'view_id'):
                        client_data['analytics_property_id'] = getattr(ga_creds, 'view_id', '')
                        logger.debug(f"Using view_id as fallback for property_id")
                
                # Create actual credentials dictionary with real values
                client_data['analytics_credentials'] = {
                    'ga_client_id': getattr(ga_creds, 'ga_client_id', ''),
                    'client_secret': getattr(ga_creds, 'client_secret', ''), 
                    'refresh_token': getattr(ga_creds, 'refresh_token', ''),
                    'token_uri': getattr(ga_creds, 'token_uri', 'https://oauth2.googleapis.com/token'),
                    'access_token': getattr(ga_creds, 'access_token', '')
                }
                
                # Log safely without exposing sensitive data
                logger.debug(f"Added Google Analytics credentials for client {client.name} (ID: {client.id})")
                
                # Add warning for missing critical fields
                missing_fields = []
                for field in ['ga_client_id', 'client_secret', 'refresh_token']:
                    if not getattr(ga_creds, field, ''):
                        missing_fields.append(field)
                
                if missing_fields:
                    logger.warning(f"Missing critical Analytics credential fields for client {client.name}: {', '.join(missing_fields)}")
            else:
                logger.debug(f"Client {client.name} (ID: {client.id}) has no Google Analytics credentials")
        except Exception as e:
            logger.error(f"Error adding Google Analytics credentials for client {client.name}: {str(e)}")
        
        # Add Search Console credentials if available
        try:
            if hasattr(client, 'sc_credentials') and client.sc_credentials:
                sc_creds = client.sc_credentials
                
                # Use the get_property_url method properly
                try:
                    if hasattr(sc_creds, 'get_property_url') and callable(getattr(sc_creds, 'get_property_url')):
                        property_url = sc_creds.get_property_url()
                        client_data['search_console_property_url'] = property_url if property_url else ''
                        logger.debug(f"Got property_url using get_property_url() method")
                    else:
                        # Fallback to direct attribute access
                        property_url = getattr(sc_creds, 'property_url', '') or getattr(sc_creds, 'property_id', '')
                        client_data['search_console_property_url'] = property_url
                except Exception as e:
                    logger.error(f"Error calling get_property_url: {str(e)}")
                    # Fallback to direct attribute access
                    property_url = getattr(sc_creds, 'property_url', '') or getattr(sc_creds, 'property_id', '')
                    client_data['search_console_property_url'] = property_url
                
                if not property_url:
                    logger.warning(f"Client {client.name} has Search Console credentials but no valid property URL")
                
                # Create actual credentials dictionary with real values
                client_data['search_console_credentials'] = {
                    'sc_client_id': getattr(sc_creds, 'sc_client_id', ''),
                    'client_secret': getattr(sc_creds, 'client_secret', ''),
                    'refresh_token': getattr(sc_creds, 'refresh_token', ''),
                    'token_uri': getattr(sc_creds, 'token_uri', 'https://oauth2.googleapis.com/token'),
                    'access_token': getattr(sc_creds, 'access_token', '')
                }
                
                # Log safely without exposing sensitive data
                logger.debug(f"Added Search Console credentials for client {client.name} (ID: {client.id})")
                
                # Add warning for missing critical fields
                missing_fields = []
                for field in ['sc_client_id', 'client_secret', 'refresh_token']:
                    if not getattr(sc_creds, field, ''):
                        missing_fields.append(field)
                
                if missing_fields:
                    logger.warning(f"Missing critical Search Console credential fields for client {client.name}: {', '.join(missing_fields)}")
            else:
                logger.debug(f"Client {client.name} (ID: {client.id}) has no Search Console credentials")
        except Exception as e:
            logger.error(f"Error adding Search Console credentials for client {client.name}: {str(e)}")
        
        # Log the available keys for debugging
        logger.debug(f"Client data keys available: {', '.join(client_data.keys())}")
        
        return client_data
    
    @staticmethod
    def get_client_by_id(client_id, organization_id=None):
        """
        Get a client by ID with organization-aware error handling.
        Works with both synchronous and asynchronous code via ContextVars.
        
        Args:
            client_id: The ID of the client to retrieve
            organization_id: Optional organization ID to override current context
            
        Returns:
            Client: The client object or None if not found
        """
        if not client_id:
            logger.warning("get_client_by_id called with None client_id")
            return None
            
        try:
            # If organization_id is provided, use it to set context temporarily
            if organization_id:
                # Check if OrganizationContext is available
                if OrganizationContext:
                    with OrganizationContext.organization_context(organization_id):
                        # Use the secure get_object_or_404 that enforces organization boundaries
                        return get_object_or_404(Client, id=client_id)
                else:
                    # Fall back to direct filter
                    logger.warning("OrganizationContext not available, using direct filter")
                    return get_object_or_404(Client, id=client_id, organization_id=organization_id)
            else:
                # Use secure get_object_or_404 with the current organization context
                return get_object_or_404(Client, id=client_id)
                
        except Exception as e:
            logger.error(f"Error retrieving client with ID {client_id}: {str(e)}")
            return None
    
    @staticmethod
    def get_client_data_by_id(client_id, organization_id=None):
        """
        Get client data directly by ID, with organization context handling.
        This is a convenience method that combines get_client_by_id and get_client_data.
        
        Args:
            client_id: The ID of the client
            organization_id: Optional organization ID to override current context
            
        Returns:
            dict: Dictionary containing client data and credentials
        """
        try:
            # Enhanced logging for debugging
            logger.info("=" * 80)
            logger.info(f"GET_CLIENT_DATA_BY_ID CALLED - client_id: {client_id}, organization_id: {organization_id}")
            
            # Get the client with organization context
            client = ClientDataUtils.get_client_by_id(client_id, organization_id)
            if not client:
                logger.warning(f"No client found with ID {client_id} and organization_id {organization_id}")
                return {
                    'client_id': None,
                    'current_date': timezone.now().date().isoformat(),
                }
                
            # Get client data with organization context
            client_data = ClientDataUtils.get_client_data(client, organization_id)
            
            # Log what we got for troubleshooting
            analytics_keys = [k for k in client_data.keys() if 'analytics' in k.lower()]
            if analytics_keys:
                logger.info(f"Retrieved analytics keys in get_client_data_by_id: {analytics_keys}")
                
                # Verify property_id
                if 'analytics_property_id' in client_data:
                    logger.info(f"analytics_property_id value: {client_data['analytics_property_id']}")
                
                # Verify credentials structure
                if 'analytics_credentials' in client_data and isinstance(client_data['analytics_credentials'], dict):
                    cred_keys = list(client_data['analytics_credentials'].keys())
                    logger.info(f"analytics_credentials keys: {cred_keys}")
                    
                    # Check for required fields
                    required_fields = ['access_token', 'refresh_token', 'ga_client_id', 'client_secret']
                    missing = [field for field in required_fields if field not in cred_keys or not client_data['analytics_credentials'].get(field)]
                    if missing:
                        logger.warning(f"Missing required credential fields: {missing}")
            
            logger.info("=" * 80)
            return client_data
        
        except Exception as e:
            logger.error(f"Error in get_client_data_by_id: {str(e)}", exc_info=True)
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }
    
    @staticmethod
    @database_sync_to_async
    def get_client_data_async(client_id, organization_id=None):
        """
        Async version of get_client_data that first retrieves the client by ID.
        Uses ContextVars for organization context, making it work properly in async code.
        
        Args:
            client_id: The ID of the client to retrieve data for
            organization_id: Optional organization ID to override current context
            
        Returns:
            dict: Dictionary containing client data and credentials
        """
        try:
            # Get client with proper organization context
            client = ClientDataUtils.get_client_by_id(client_id, organization_id)
            return ClientDataUtils.get_client_data(client, organization_id)
        except Exception as e:
            logger.error(f"Error in get_client_data_async: {str(e)}", exc_info=True)
            return {
                'client_id': None,
                'current_date': timezone.now().date().isoformat(),
            }

================
File: apps/agents/utils/crawl_url.py
================
import requests
import logging
import json
import asyncio
from django.conf import settings
from urllib.parse import urlparse, urljoin
import re
import time
from apps.common.utils import is_pdf_url, is_youtube
from apps.agents.utils.scrape_url import (
    _load_from_youtube, 
    _load_from_pdf, 
    is_excluded_url, 
    _compress_large_content
)

logger = logging.getLogger(__name__)

# Define default FireCrawl base URL (without version)
DEFAULT_FIRECRAWL_BASE_URL = "https://firecrawl.neuralami.ai"

def _get_firecrawl_base_url():
    """Get FireCrawl base URL from settings, ensure /v1/ is appended."""
    base_url = getattr(settings, 'FIRECRAWL_URL', DEFAULT_FIRECRAWL_BASE_URL)
    # Clean up potential trailing slashes or existing /v1 path
    base_url = base_url.rstrip('/')
    if base_url.endswith('/v1'):
        base_url = base_url[:-3].rstrip('/')
    # Append /v1/
    return base_url + '/v1/'

def _get_firecrawl_headers():
    """Helper function to create headers with optional Authorization."""
    headers = {
        "Content-Type": "application/json"
    }
    # Check if FIRECRAWL_API_KEY is defined and not empty in settings
    api_key = getattr(settings, 'FIRECRAWL_API_KEY', None)
    if api_key:
        #logger.debug("Adding FireCrawl API Key to headers.")
        headers["Authorization"] = f"Bearer {api_key}"

    return headers

def crawl_url(url, limit=100, exclude_paths=None, include_paths=None, 
              max_depth=10, max_discovery_depth=None, ignore_sitemap=False,
              ignore_query_parameters=False, allow_backward_links=False,
              allow_external_links=False, webhook=None, scrape_options=None,
              include_html=True, include_markdown=True, poll_interval=30,
              wait_for_completion=True, timeout=3600, excluded_urls=None):
    """
    Crawls a website and all accessible subpages using the FireCrawl crawl endpoint.
    
    Args:
        url (str): The base URL to start crawling from
        limit (int): Maximum number of pages to crawl (default: 100)
        exclude_paths (list): URL pathname regex patterns to exclude
        include_paths (list): URL pathname regex patterns to include
        max_depth (int): Maximum depth to crawl relative to base URL (default: 10)
        max_discovery_depth (int): Maximum depth based on discovery order
        ignore_sitemap (bool): Ignore the website sitemap when crawling
        ignore_query_parameters (bool): Do not re-scrape same path with different query parameters
        allow_backward_links (bool): Enable crawler to navigate to previously linked pages
        allow_external_links (bool): Allow crawler to follow links to external websites
        webhook (dict): A webhook specification object
        scrape_options (dict): Scrape options for each page
        include_html (bool): Include HTML content in results
        include_markdown (bool): Include Markdown content in results
        poll_interval (int): Seconds between status checks when waiting for completion
        wait_for_completion (bool): Wait for crawl to complete before returning
        timeout (int): Maximum seconds to wait for crawl completion
        excluded_urls (list): Additional list of URL patterns to exclude from crawling
    
    Returns:
        dict: The crawl results with all pages content and metadata, or crawl job info if not waiting for completion
    """
    # Check if URL should be excluded
    if is_excluded_url(url):
        logger.info(f"URL {url} is in the exclusion list, skipping crawl")
        return None
    
    # Check additional excluded URLs if provided
    if excluded_urls:
        for pattern in excluded_urls:
            if pattern in url:
                logger.info(f"URL {url} is in the additional exclusion list, skipping crawl")
                return None
    
    # Check if URL is a YouTube video or PDF - handle with specific loaders
    if is_youtube(url):
        logger.info(f"Detected YouTube URL: {url}. Using specific YouTube loader instead of crawl.")
        return _load_from_youtube(url)
    
    if is_pdf_url(url):
        logger.info(f"Detected PDF URL: {url}. Using specific PDF loader instead of crawl.")
        return _load_from_pdf(url)
    
    # Prepare scrape options if not provided
    if scrape_options is None:
        scrape_options = {}
    
    # Set formats based on include_html and include_markdown
    formats = []
    if include_markdown:
        formats.append("markdown")
    if include_html:
        formats.append("html")
    
    if formats and "formats" not in scrape_options:
        scrape_options["formats"] = formats
    
    # Use FireCrawl crawl endpoint
    try:
        # Get base URL (already includes /v1/)
        base_url_v1 = _get_firecrawl_base_url()
        # Construct the full endpoint URL - join relative path 'crawl'
        firecrawl_endpoint_url = urljoin(base_url_v1, "crawl")
        logger.debug(f"Using FireCrawl endpoint: {firecrawl_endpoint_url}")
        
        # Setup request data for FireCrawl crawl endpoint
        request_data = {
            "url": url,
            "limit": limit
        }
        
        # Add optional parameters if provided
        if exclude_paths:
            request_data["excludePaths"] = exclude_paths
        
        if include_paths:
            request_data["includePaths"] = include_paths
            
        if max_depth != 10:  # Only include if different from default
            request_data["maxDepth"] = max_depth
            
        if max_discovery_depth is not None:
            request_data["maxDiscoveryDepth"] = max_discovery_depth
            
        if ignore_sitemap:
            request_data["ignoreSitemap"] = ignore_sitemap
            
        if ignore_query_parameters:
            request_data["ignoreQueryParameters"] = ignore_query_parameters
            
        if allow_backward_links:
            request_data["allowBackwardLinks"] = allow_backward_links
            
        if allow_external_links:
            request_data["allowExternalLinks"] = allow_external_links
            
        if webhook:
            request_data["webhook"] = webhook
            
        # Explicitly log scrape_options before adding to request_data
        if scrape_options:
            logger.debug(f"Received scrape_options in crawl_url: {json.dumps(scrape_options)}")
            request_data["scrapeOptions"] = scrape_options
        else:
            logger.warning("No scrape_options provided to crawl_url")
            # Even if scrape_options is None, make sure formats are set based on include flags
            if "scrapeOptions" not in request_data:
                request_data["scrapeOptions"] = {"formats": []}
            if include_markdown and "markdown" not in request_data["scrapeOptions"]["formats"]:
                request_data["scrapeOptions"]["formats"].append("markdown")
            if include_html and "html" not in request_data["scrapeOptions"]["formats"]:
                request_data["scrapeOptions"]["formats"].append("html")
            logger.debug(f"Manually set scrapeOptions formats: {request_data['scrapeOptions']}")
        
        # Get headers with optional Authorization
        headers = _get_firecrawl_headers()
        
        # Log the complete request data payload being sent to FireCrawl
        logger.info(f"FireCrawl crawl request payload: {json.dumps(request_data)}")
        
        # Make the request to FireCrawl crawl endpoint
        response = requests.post(
            firecrawl_endpoint_url, # Use dynamic URL
            headers=headers,
            json=request_data,
            timeout=(30, 120)  # (connect timeout, read timeout)
        )
        
        # Check response status
        if response.status_code != 200:
            logger.error(f"FireCrawl service returned status code {response.status_code} for URL {url}")
            try:
                error_details = response.json()
                logger.error(f"Error details: {error_details}")
            except:
                logger.error(f"Raw error response: {response.text}")
            return None
        
        # Parse response to get crawl job info
        crawl_job = response.json()
        
        # Check if crawl job was created successfully
        if not crawl_job.get("success", False):
            logger.error(f"FireCrawl crawl job creation failed for URL {url}: {crawl_job.get('error', 'Unknown error')}")
            return None
        
        # Get crawl job ID
        crawl_id = crawl_job.get("id")
        if not crawl_id:
            logger.error(f"FireCrawl crawl job ID missing in response for URL {url}")
            return None
            
        logger.info(f"FireCrawl crawl job created with ID: {crawl_id} for URL: {url}")
        
        # If not waiting for completion, return the crawl job info
        if not wait_for_completion:
            return {
                "success": True,
                "id": crawl_id,
                "status": "started",
                "message": "Crawl job started successfully. Use check_crawl_status to monitor progress."
            }
        
        # Wait for crawl to complete
        return _poll_crawl_status(crawl_id, poll_interval, timeout)
        
    except Exception as e:
        logger.error(f"Error starting crawl for URL {url} with FireCrawl: {str(e)}")
        return None

def check_crawl_status(crawl_id):
    """
    Check the status of a crawl job.
    
    Args:
        crawl_id (str): The ID of the crawl job
        
    Returns:
        dict: The current status and data of the crawl job
    """
    try:
        # Get base URL (already includes /v1/)
        base_url_v1 = _get_firecrawl_base_url()
        # Construct the status check URL - join relative path 'crawl/{crawl_id}'
        status_url = urljoin(base_url_v1, f"crawl/{crawl_id}")
        logger.debug(f"Checking crawl status at URL: {status_url}")
        
        # Get headers with optional Authorization
        headers = _get_firecrawl_headers()
        
        # Make the request
        response = requests.get(
            status_url,
            headers=headers,
            timeout=(30, 120)  # (connect timeout, read timeout)
        )
        
        # Check response status
        if response.status_code != 200:
            logger.error(f"FireCrawl service returned status code {response.status_code} for crawl ID {crawl_id}")
            try:
                error_details = response.json()
                logger.error(f"Error details: {error_details}")
            except:
                logger.error(f"Raw error response: {response.text}")
            return None
        
        # Parse response
        status_result = response.json()
        logger.info(f"FireCrawl crawl status for ID {crawl_id}: {status_result.get('status', 'unknown')}, "
                    f"completed: {status_result.get('completed', 0)}/{status_result.get('total', 0)}")
        
        return status_result
        
    except Exception as e:
        logger.error(f"Error checking crawl status for ID {crawl_id}: {str(e)}")
        return None

def _poll_crawl_status(crawl_id, poll_interval=30, timeout=3600):
    """
    Poll the crawl status until completion or timeout.
    
    Args:
        crawl_id (str): The ID of the crawl job
        poll_interval (int): Seconds between status checks
        timeout (int): Maximum seconds to wait
        
    Returns:
        dict: The complete crawl data or status on timeout
    """
    start_time = time.time()
    complete_data = []
    
    while time.time() - start_time < timeout:
        # Check crawl status
        status_result = check_crawl_status(crawl_id)
        
        if not status_result:
            logger.error(f"Failed to get status for crawl ID {crawl_id}")
            return None
        
        # If data is available, add it to our complete data
        if "data" in status_result and status_result["data"]:
            complete_data.extend(status_result["data"])
        
        # Check if there's more data to retrieve (pagination)
        next_url = status_result.get("next")
        
        # Follow pagination until we get all available data
        while next_url:
            try:
                #logger.info(f"Fetching next page of crawl data from: {next_url}")
                # Get headers with optional Authorization for pagination request
                headers = _get_firecrawl_headers()
                
                response = requests.get(
                    next_url,
                    headers=headers, # Use updated headers
                    timeout=(30, 120)
                )
                
                if response.status_code != 200:
                    logger.error(f"Error fetching next page of crawl data: {response.status_code}")
                    break
                    
                next_data = response.json()
                
                if "data" in next_data and next_data["data"]:
                    complete_data.extend(next_data["data"])
                
                # Update for next iteration
                next_url = next_data.get("next")
                
            except Exception as e:
                logger.error(f"Error fetching next page of crawl data: {str(e)}")
                break
        
        # Check if crawl is complete
        status = status_result.get("status")
        if status == "completed":
            logger.info(f"Crawl job {crawl_id} completed successfully with {len(complete_data)} pages")
            
            # Process and organize the results
            return _process_crawl_results(complete_data, status_result)
            
        elif status == "failed":
            logger.error(f"Crawl job {crawl_id} failed: {status_result.get('error', 'Unknown error')}")
            return {
                "success": False,
                "id": crawl_id,
                "status": "failed",
                "error": status_result.get("error", "Unknown error"),
                "data": complete_data if complete_data else []
            }
        
        # Wait before checking again
        time.sleep(poll_interval)
    
    # If we're here, we've timed out
    logger.warning(f"Timed out waiting for crawl job {crawl_id} to complete")
    return {
        "success": False,
        "id": crawl_id,
        "status": "timeout",
        "message": f"Timed out after {timeout} seconds",
        "data": complete_data if complete_data else []
    }

def _process_crawl_results(crawl_data, status_info):
    """
    Process and organize the crawl results into a structured format.
    
    Args:
        crawl_data (list): List of page data from the crawl
        status_info (dict): Status information about the crawl
        
    Returns:
        dict: Structured crawl results
    """
    # Extract domain from the first result's sourceURL if available
    domain = ""
    if crawl_data and "metadata" in crawl_data[0] and "sourceURL" in crawl_data[0]["metadata"]:
        parsed_url = urlparse(crawl_data[0]["metadata"]["sourceURL"])
        domain = parsed_url.netloc
    
    # Debug log the structure of the first item
    if crawl_data:
        logger.debug(f"First crawl data item keys: {list(crawl_data[0].keys())}")
        logger.debug(f"Metadata keys: {list(crawl_data[0].get('metadata', {}).keys())}")
        
        # If there's no html/markdown in the first item, log a warning
        if "html" not in crawl_data[0] and "markdown" not in crawl_data[0]:
            logger.warning("First result doesn't contain html or markdown fields. This may be why content is empty.")
    
    # Process each page in the crawl data
    processed_pages = []
    for page in crawl_data:
        # Log the raw page data for debugging
        logger.debug(f"Processing page with keys: {list(page.keys())}")
        
        # Extract metadata
        metadata = page.get("metadata", {})
        source_url = metadata.get("sourceURL", "")
        title = metadata.get("title", "")
        description = metadata.get("description", "")
        
        # Get content - FireCrawl returns markdown and html directly at the top level
        markdown_content = page.get("markdown", "")
        
        # Check for both "html" and "rawHtml" fields as FireCrawl might use either
        html_content = page.get("html", "")
        if not html_content:
            html_content = page.get("rawHtml", "")
            if html_content:
                logger.debug(f"Used rawHtml field instead of html for {source_url}")
        
        # Log content lengths for debugging
        logger.debug(f"URL: {source_url}, Markdown length: {len(markdown_content)}, HTML length: {len(html_content)}")
        
        # Check if content is too large and needs compression
        if len(markdown_content) > 500000:
            logger.info(f"Markdown content from {source_url} exceeds 500,000 characters. Compressing...")
            compressed_content = _compress_large_content(markdown_content)
            if compressed_content:
                logger.info(f"Successfully compressed markdown content from {source_url}")
                markdown_content = compressed_content
        
        # Create page result
        page_result = {
            'url': source_url,
            'domain': domain,
            'title': title,
            'byline': metadata.get("author", ""),
            'content': html_content,  # HTML content
            'textContent': markdown_content,  # Markdown as text content
            'excerpt': description if description else (markdown_content[:200] + "..." if len(markdown_content) > 200 else markdown_content),
            'length': len(markdown_content),
            'meta': {
                'general': {
                    'author': metadata.get("author", ""),
                    'description': description,
                    'language': metadata.get("language", ""),
                    'statusCode': metadata.get("statusCode", 200),
                },
                'contentType': 'html',
                'links': page.get("links", [])
            }
        }
        
        # Add screenshot if available
        if "screenshot" in page:
            page_result['meta']['screenshot'] = page["screenshot"]
            
        processed_pages.append(page_result)
    
    # Create final result
    result = {
        'success': True,
        'id': status_info.get("id", ""),
        'status': "completed",
        'pages': processed_pages,
        'total_pages': len(processed_pages),
        'credits_used': status_info.get("creditsUsed", 0)
    }
    
    return result

async def crawl_url_and_watch(url, options=None, on_document=None, on_error=None, on_done=None):
    """
    Start a crawl and watch for real-time updates via WebSocket.
    This is a placeholder implementation as the actual WebSocket functionality
    would require additional implementation.
    
    Args:
        url (str): The URL to crawl
        options (dict): Crawl options
        on_document (callable): Callback for document events
        on_error (callable): Callback for error events
        on_done (callable): Callback for done events
        
    Returns:
        dict: Result of the crawl
    """
    logger.warning("WebSocket functionality for crawl_url_and_watch is not fully implemented")
    logger.info(f"Starting crawl for {url} with options: {options}")
    
    # For now, fall back to the regular crawl method
    result = crawl_url(
        url=url,
        limit=options.get("limit", 100) if options else 100,
        exclude_paths=options.get("excludePaths") if options else None,
        include_paths=options.get("includePaths") if options else None,
        max_depth=options.get("maxDepth", 10) if options else 10,
        wait_for_completion=True
    )
    
    # Call callbacks if provided
    if result and result.get("success") and on_document and "pages" in result:
        for page in result["pages"]:
            on_document(page)
    
    if result and not result.get("success") and on_error:
        on_error({"error": result.get("error", "Unknown error")})
    
    if on_done:
        on_done({"status": result.get("status", "unknown")})
    
    return result

================
File: apps/agents/utils/crawler_utils.py
================
"""
Common utilities for web crawlers.
"""
import logging
import time
from urllib.parse import urlparse
from typing import Optional, Tuple

from apps.agents.utils.rate_limited_fetcher import RateLimitedFetcher

logger = logging.getLogger(__name__)

def init_crawler_rate_limiting(url: str, user_rate_limit: float) -> Tuple[str, Optional[float]]:
    """
    Initialize rate limiting for a crawler based on robots.txt and user settings.
    
    Args:
        url: The URL to crawl
        user_rate_limit: User-specified rate limit in requests per second
        
    Returns:
        Tuple of (normalized_domain, robots_crawl_delay)
    """
    try:
        # Parse and normalize the URL
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        
        # Normalize domain (remove www. if present)
        if domain.startswith('www.'):
            domain = domain[4:]
            
        # Check robots.txt for crawl-delay
        robots_crawl_delay = None
        
        # Try to get robots.txt from both www and non-www versions
        robots_urls = [
            f"https://{domain}/robots.txt",
            f"https://www.{domain}/robots.txt",
            f"http://{domain}/robots.txt",
            f"http://www.{domain}/robots.txt"
        ]
        
        for robots_url in robots_urls:
            try:
                logger.debug(f"Checking robots.txt at: {robots_url}")
                robots_result = RateLimitedFetcher.fetch_url(robots_url)
                
                if robots_result.get("success", False):
                    robots_content = robots_result.get("content", "")
                    logger.debug(f"Successfully fetched robots.txt content from {robots_url}")
                    
                    # Manual check for Crawl-delay directive
                    for line in robots_content.splitlines():
                        line = line.strip()
                        if line.lower().startswith("crawl-delay:"):
                            try:
                                # Extract the delay value
                                delay_value = line.split(":", 1)[1].strip()
                                robots_crawl_delay = float(delay_value)
                                logger.info(f"Found Crawl-delay: {robots_crawl_delay} in {robots_url}")
                                break
                            except (ValueError, IndexError) as e:
                                logger.warning(f"Error parsing Crawl-delay in {robots_url}: {e}")
                                
                    # If we found a crawl-delay, no need to check other robots.txt files
                    if robots_crawl_delay is not None:
                        break
            except Exception as e:
                logger.warning(f"Error fetching robots.txt from {robots_url}: {e}")
                
        # Initialize rate limiting
        logger.info(f"Initializing rate limiting for domain '{domain}'. User RPS={user_rate_limit}, Robots Delay={robots_crawl_delay}")
        RateLimitedFetcher.init_rate_limiting(
            domain=domain,
            rate_limit=user_rate_limit,
            crawl_delay=robots_crawl_delay
        )
        
        return domain, robots_crawl_delay
        
    except Exception as e:
        logger.error(f"Error initializing rate limiting: {e}", exc_info=True)
        # Return default values
        return urlparse(url).netloc, None
        
def respect_rate_limit(domain: str):
    """
    Respect the rate limit for a domain by sleeping if necessary.
    
    Args:
        domain: The domain to respect rate limit for
    """
    # Use the RateLimitedFetcher's _apply_rate_limit method
    RateLimitedFetcher._apply_rate_limit(domain)

================
File: apps/agents/utils/error_handling.py
================
from functools import wraps
import logging
import json
from typing import Optional, Any, Callable
from django.core.exceptions import ValidationError

logger = logging.getLogger(__name__)

class ChatError(Exception):
    """Base class for chat-related errors"""
    def __init__(self, message: str, code: Optional[str] = None):
        super().__init__(message)
        self.code = code

def handle_chat_errors(func: Callable) -> Callable:
    """Decorator to handle chat-related errors"""
    @wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except ChatError as e:
            logger.warning(f"Chat error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': e.code
            }
        except ValidationError as e:
            logger.warning(f"Validation error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': str(e),
                'code': 'validation_error'
            }
        except Exception as e:
            logger.error(f"Unexpected error: {str(e)}", exc_info=True)
            return {
                'error': True,
                'message': 'An unexpected error occurred',
                'code': 'internal_error'
            }
    return wrapper

================
File: apps/agents/utils/formatters.py
================
import json
import logging
from typing import Any

logger = logging.getLogger(__name__)

class TableFormatter:
    @staticmethod
    def detect_tabular_data(data: Any) -> bool:
        """Detect if data appears to be tabular"""
        try:
            # Handle string input
            if isinstance(data, str):
                try:
                    data = json.loads(data)
                except json.JSONDecodeError:
                    return False

            # Handle dictionary with nested data
            if isinstance(data, dict):
                # Look for common response patterns and nested data
                for key in ['data', 'results', 'search_console_data', 'analytics_data', 
                           'records', 'rows', 'items', 'response']:
                    if key in data and isinstance(data[key], list):
                        data = data[key]
                        break
                # If no list found in known keys, check all values
                if isinstance(data, dict):
                    for value in data.values():
                        if isinstance(value, list) and len(value) > 0:
                            data = value
                            break

            # Check if it's a list of dictionaries with consistent structure
            if isinstance(data, list) and len(data) > 0:
                if all(isinstance(item, dict) for item in data):
                    # Get keys from first item
                    keys = set(data[0].keys())
                    # Check if all items have same keys and at least one key
                    return len(keys) > 0 and all(set(item.keys()) == keys for item in data)

            return False
            
        except Exception as e:
            logger.error(f"Error detecting tabular data: {str(e)}")
            return False

================
File: apps/agents/utils/get_targeted_keywords.py
================
from bs4 import BeautifulSoup
from boilerpy3 import extractors
from rake_nltk import Rake
from collections import Counter
import re
from nltk.corpus import stopwords
import nltk
import logging

logger = logging.getLogger(__name__)

# Ensure NLTK data is downloaded
try:
    nltk.data.find('corpora/stopwords')
except LookupError:
    nltk.download('stopwords')

try:
    nltk.data.find('tokenizers/punkt')
except LookupError:
    nltk.download('punkt')

# Extended list of web-specific stopwords to filter out
WEB_SPECIFIC_STOPWORDS = {
    # Common website terms
    'cookie', 'cookies', 'privacy', 'policy', 'terms', 'conditions',
    'accept', 'decline', 'website', 'site', 'click', 'homepage',
    
    # Navigation terms
    'menu', 'navigation', 'nav', 'sidebar', 'footer', 'header',
    'login', 'signin', 'signup', 'register', 'account',
    
    # UI elements
    'button', 'link', 'image', 'icon', 'logo', 'banner',
    'scroll', 'dropdown', 'popup', 'modal',
    
    # Generic web actions
    'click', 'submit', 'cancel', 'close', 'open', 'save', 'delete',
    'download', 'upload', 'share', 'like', 'follow',
    
    # Generic fillers
    'please', 'thank', 'thanks', 'welcome', 'hello', 'get', 'make',
    'read', 'learn', 'find', 'see', 'view', 'check',
    
    # Time-related
    'today', 'yesterday', 'tomorrow', 'week', 'month', 'year',
    'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday',
    'january', 'february', 'march', 'april', 'may', 'june', 'july', 
    'august', 'september', 'october', 'november', 'december'
}

def get_targeted_keywords(html_text, top_n=10):
    """
    Extracts keywords a webpage is targeting for SEO based on its HTML content.

    Args:
        html_text (str): The HTML content of the webpage to analyze.
        top_n (int): The number of top keywords to return (default is 10).

    Returns:
        list: A list of the top targeted keywords.
    """
    try:
        # Step 1: Extract the main content using boilerpy3
        extractor = extractors.ArticleExtractor()
        main_content = extractor.get_content(html_text)

        # Step 2: Parse HTML with BeautifulSoup
        soup = BeautifulSoup(html_text, 'html.parser')

        # Extract title
        title = soup.title.string if soup.title else ''

        # Extract meta description
        meta_desc = ''
        meta_tag = soup.find('meta', attrs={'name': 'description'})
        if meta_tag and 'content' in meta_tag.attrs:
            meta_desc = meta_tag['content']

        # Extract H1 and H2 headers
        headers = [header.get_text(strip=True) for header in soup.find_all(['h1', 'h2'])]

        # Step 3: Keyword extraction
        # Initialize RAKE for main content keyword extraction
        rake = Rake()
        rake.extract_keywords_from_text(main_content)
        main_keywords = rake.get_ranked_phrases()[:10]  # Limit to top 10 phrases

        # Helper function to extract keywords from short text
        standard_stop_words = set(stopwords.words('english'))
        # Combine standard stopwords with our custom web-specific stopwords
        enhanced_stop_words = standard_stop_words.union(WEB_SPECIFIC_STOPWORDS)
        
        def extract_keywords(text):
            words = re.findall(r'\w+', text.lower())
            return [word for word in words if word not in enhanced_stop_words and len(word) > 2]

        # Extract keywords from title, meta description, and headers
        title_keywords = extract_keywords(title)
        meta_keywords = extract_keywords(meta_desc)
        header_keywords = []
        for header in headers:
            header_keywords.extend(extract_keywords(header))

        # Step 4: Combine and score keywords
        keyword_scores = Counter()

        # Assign weights to keywords based on their source
        for keyword in title_keywords:
            keyword_scores[keyword] += 3  # High importance for title
        for keyword in meta_keywords:
            keyword_scores[keyword] += 2  # Medium importance for meta description
        for keyword in header_keywords:
            keyword_scores[keyword] += 2  # Medium importance for headers
        for phrase in main_keywords:
            words = re.findall(r'\w+', phrase.lower())
            for word in words:
                if word not in enhanced_stop_words and len(word) > 2:
                    keyword_scores[word] += 1  # Lower importance for main content

        # Step 5: Get the top N keywords
        top_keywords = [keyword for keyword, _ in keyword_scores.most_common(top_n)]
        return top_keywords

    except Exception as e:
        logger.error(f"Error extracting keywords: {e}")
        return []

================
File: apps/agents/utils/minimal_tools.py
================
from abc import ABC, abstractmethod
from typing import Any, Callable, Optional, Type
from pydantic import BaseModel, ConfigDict, Field, field_validator
from pydantic import BaseModel as PydanticBaseModel
import logging
import json

# Import CrewAI's BaseTool to inherit from
from crewai.tools import BaseTool as CrewAIBaseTool

logger = logging.getLogger(__name__)

class ToolUsageError(Exception):
    """Exception raised when a tool is used incorrectly."""
    pass

# Make our BaseTool inherit from CrewAI's BaseTool
class BaseTool(CrewAIBaseTool):
    """Custom BaseTool that inherits from CrewAI's BaseTool for compatibility."""
    # Keep existing functionality for backward compatibility
    # but inherit from CrewAI's BaseTool for compatibility with CrewAI tasks

    class _ArgsSchemaPlaceholder(PydanticBaseModel):
        pass

    model_config = ConfigDict()

    name: str
    """The unique name of the tool that clearly communicates its purpose."""
    description: str
    """Used to tell the model how/when/why to use the tool."""
    args_schema: Type[PydanticBaseModel] = Field(default_factory=_ArgsSchemaPlaceholder)
    """The schema for the arguments that the tool accepts."""
    description_updated: bool = False
    """Flag to check if the description has been updated."""
    cache_function: Optional[Callable] = lambda _args, _result: True
    """Function that will be used to determine if the tool should be cached."""
    result_as_answer: bool = False
    """Flag to check if the tool should be the final agent answer."""

    @field_validator("args_schema", mode="before")
    def _default_args_schema(
        cls, v: Type[PydanticBaseModel]
    ) -> Type[PydanticBaseModel]:
        # Keep existing validator for backward compatibility
        if hasattr(cls, "_ArgsSchemaPlaceholder") and not isinstance(v, cls._ArgsSchemaPlaceholder):
            return v

        return type(
            f"{cls.__name__}Schema",
            (PydanticBaseModel,),
            {
                "__annotations__": {
                    k: v for k, v in cls._run.__annotations__.items() if k != "return"
                },
            },
        )

    def model_post_init(self, __context: Any) -> None:
        self._generate_description()
        super().model_post_init(__context)

    def run(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> Any:
        return self._run(*args, **kwargs)

    @abstractmethod
    def _run(
        self,
        *args: Any,
        **kwargs: Any,
    ) -> Any:
        """Here goes the actual implementation of the tool."""

    def _set_args_schema(self):
        # Keep existing method for backward compatibility
        if self.args_schema is None:
            class_name = f"{self.__class__.__name__}Schema"
            self.args_schema = type(
                class_name,
                (PydanticBaseModel,),
                {
                    "__annotations__": {
                        k: v
                        for k, v in self._run.__annotations__.items()
                        if k != "return"
                    },
                },
            )

    # Override CrewAI's _generate_description if needed for compatibility
    # But let the parent method handle most of the functionality
    def _generate_description(self):
        # First call the parent method
        super()._generate_description()
        
        # Then apply any custom formatting as needed
        args = []
        args_description = []
        if hasattr(self, 'args_schema') and self.args_schema:
            schema = getattr(self.args_schema, 'schema', lambda: {})()
            if 'properties' in schema:
                for arg, attribute in schema['properties'].items():
                    if "type" in attribute:
                        args.append(f"{arg}: '{attribute['type']}'")
                    if "description" in attribute:
                        args_description.append(f"{arg}: '{attribute['description']}'")

        # Update description with additional formatting if needed
        if args and not self.description.endswith(')'):
            description = self.description.replace("\n", " ")
            self.description = f"{self.name}({', '.join(args)}) - {description} {', '.join(args_description)}"

    # Provide backward compatibility for invoke method
    def invoke(self, input=None, **kwargs):
        """Invoke the tool with the given input."""
        if input is None:
            input = {}
        if isinstance(input, str):
            try:
                input = json.loads(input)
            except json.JSONDecodeError:
                # If input is a string and not JSON, pass it as is
                return self._run(input)
        return self._run(**input)

class Tool(BaseTool):
    """A tool that wraps a callable function."""
    
    func: Callable
    """The function that will be executed when the tool is called."""

    def _run(self, *args: Any, **kwargs: Any) -> Any:
        """Execute the wrapped function with the provided arguments."""
        return self.func(*args, **kwargs)

def tool(*args):
    """
    Decorator to create a tool from a function.
    """
    def _make_with_name(tool_name: str) -> Callable:
        def _make_tool(f: Callable) -> BaseTool:
            if f.__doc__ is None:
                raise ValueError("Function must have a docstring")
            if f.__annotations__ is None:
                raise ValueError("Function must have type annotations")

            class_name = "".join(tool_name.split()).title()
            args_schema = type(
                class_name,
                (PydanticBaseModel,),
                {
                    "__annotations__": {
                        k: v for k, v in f.__annotations__.items() if k != "return"
                    },
                },
            )

            return Tool(
                name=tool_name,
                description=f.__doc__,
                func=f,
                args_schema=args_schema,
            )

        return _make_tool

    if len(args) == 1 and callable(args[0]):
        return _make_with_name(args[0].__name__)(args[0])
    if len(args) == 1 and isinstance(args[0], str):
        return _make_with_name(args[0])
    raise ValueError("Invalid arguments")

================
File: apps/agents/utils/rate_limited_fetcher.py
================
import logging
import threading
import time
import gzip
from typing import Dict, Any, Optional, ClassVar, Tuple
from urllib.parse import urlparse

import requests
from requests.exceptions import RequestException, Timeout, ConnectionError

logger = logging.getLogger(__name__)

class RateLimitedFetcher:
    """Utility class for fetching URLs with thread-safe rate limiting."""

    # --- Constants ---
    TIMEOUT: ClassVar[int] = 15
    DEFAULT_USER_AGENT: ClassVar[str] = "NeuralAMI-Agent/1.0"

    # --- Rate Limiting State (Thread-Safe) ---
    _rate_limiter_lock: ClassVar[threading.Lock] = threading.Lock()
    _domain_locks: ClassVar[Dict[str, threading.Lock]] = {}
    _last_request_time: ClassVar[Dict[str, float]] = {}
    _request_interval: ClassVar[Dict[str, float]] = {} # Stores calculated interval

    @classmethod
    def _get_domain_lock(cls, domain: str) -> threading.Lock:
        """Gets or creates a lock specific to a domain."""
        # Use the class lock to safely access/modify the shared _domain_locks dict
        with cls._rate_limiter_lock:
            if domain not in cls._domain_locks:
                cls._domain_locks[domain] = threading.Lock()
            return cls._domain_locks[domain]

    @classmethod
    def init_rate_limiting(cls, domain: str, rate_limit: float, crawl_delay: Optional[float]):
        """Initializes rate limiting state for a domain, considering crawl_delay.

        Selects the stricter (longer interval) between the user-provided rate limit
        and the crawl_delay found in robots.txt.
        """
        user_interval = 1.0 / rate_limit if rate_limit > 0 else float('inf')
        robots_interval = crawl_delay if crawl_delay is not None and crawl_delay > 0 else 0.0

        logger.debug(f"Rate limit inputs for {domain}: User RPS={rate_limit} (Interval={user_interval:.3f}s), Robots Crawl-Delay={crawl_delay}s")

        effective_interval = user_interval
        source = f"user setting ({rate_limit} rps)"

        if robots_interval > 0:
            if robots_interval > user_interval:
                effective_interval = robots_interval
                source = f"robots.txt crawl-delay ({crawl_delay}s)"
                logger.info(f"Rate limit for {domain}: Using stricter crawl-delay ({crawl_delay}s). User interval was {user_interval:.3f}s.")
            else:
                 logger.info(f"Rate limit for {domain}: User setting ({user_interval:.3f}s) is stricter than or equal to crawl-delay ({robots_interval}s). Using user setting.")
        else:
            logger.info(f"Rate limit for {domain}: No valid crawl-delay found in robots.txt. Using user setting ({user_interval:.3f}s interval).")
        
        logger.info(f"Rate limit for {domain} set: interval={effective_interval:.3f}s (Source: {source})")

        # Use the specific domain lock to safely update its rate limit info
        with cls._get_domain_lock(domain):
            # Initialize last request time relative to the interval to allow the first request immediately
            cls._last_request_time[domain] = time.time() - effective_interval 
            cls._request_interval[domain] = effective_interval

    @classmethod
    def _apply_rate_limit(cls, domain: str):
        """Applies rate limiting delay for the given domain (BLOCKING)."""
        # Use the specific domain lock to safely access/update its state
        with cls._get_domain_lock(domain):
            interval = cls._request_interval.get(domain)
            last_time = cls._last_request_time.get(domain)

            # If not initialized (should not happen if init is called properly), log and return
            if interval is None or last_time is None:
                return

            current_time = time.time()
            time_since_last = current_time - last_time

            if time_since_last < interval:
                sleep_time = interval - time_since_last
                #logger.debug(f"Rate limiting: sleeping for {sleep_time:.4f}s for domain {domain}")
                # CRITICAL: Sleep *within* the domain lock to ensure serialization
                time.sleep(sleep_time)

            # Update last request time *after* potential sleep, still within the lock
            cls._last_request_time[domain] = time.time()
            
    @classmethod
    def get_request_interval(cls, domain: str) -> Optional[float]:
        """Gets the configured request interval for a domain."""
        with cls._get_domain_lock(domain):
            return cls._request_interval.get(domain)

    @classmethod
    def fetch_url(cls, url: str) -> Dict[str, Any]:
        """Fetches a URL, handles errors, respects rate limits, handles Gzip and BOM."""
        try:
            parsed_url = urlparse(url)
            # Normalize domain consistently: remove leading 'www.'
            domain = parsed_url.netloc.replace("www.", "")
            if not domain:
                 logger.error(f"Could not extract domain from URL: {url}")
                 # Use requested_url in error dict for consistency
                 return {"success": False, "error": "Invalid URL: No domain", "requested_url": url}
        except Exception as e:
             logger.error(f"Error parsing URL '{url}': {e}", exc_info=True)
             return {"success": False, "error": f"URL parsing error: {e}", "requested_url": url}
        
        cls._apply_rate_limit(domain) # Use normalized domain
        
        #logger.debug(f"Fetching: {url}")
        try:
            response = requests.get(
                url,
                timeout=cls.TIMEOUT,
                headers={'User-Agent': cls.DEFAULT_USER_AGENT},
                allow_redirects=True,
                stream=True
            )
            response.raise_for_status()

            content_type = response.headers.get('content-type', '').lower()
            content = None
            content_bytes = None

            content_bytes = response.raw.read() # Read the raw content
            
            if content_bytes:
                 # 1. Check for and handle Gzip *FIRST*
                if content_bytes.startswith(b'\x1f\x8b'):
                    try:
                        decompressed_bytes = gzip.decompress(content_bytes)
                        content_bytes = decompressed_bytes # Replace original bytes with decompressed ones
                        # Update content_type if it wasn't set correctly
                        if 'xml' not in content_type and 'text' not in content_type:
                             if url.endswith(('.xml', '.xml.gz')):
                                 content_type = 'application/xml'
                                 logger.debug(f"Corrected content type to xml based on extension for {url}")
                             elif url.endswith(('.txt', '.txt.gz')):
                                 content_type = 'text/plain'
                                 logger.debug(f"Corrected content type to text based on extension for {url}")
                                 
                    except gzip.BadGzipFile as gzip_err:
                         logger.error(f"BadGzipFile error for {url}: {gzip_err}. Treating as non-gzipped.")
                         # Keep original content_bytes if decompression fails
                    except Exception as e:
                         logger.error(f"Failed to decompress assumed gzipped content for {url}: {e}", exc_info=True)
                         # Return error if decompression fails when expected
                         return {"success": False, "status_code": response.status_code, "error": f"Gzip decompression error: {e}", "content_bytes": content_bytes, "requested_url": url}
                else:
                     logger.debug(f"No Gzip magic bytes detected for {url}")

                 # 2. Decode Handling (with BOM detection on potentially decompressed bytes)
                try:
                    # Check for UTF-8 BOM first
                    if content_bytes.startswith(b'\xef\xbb\xbf'):
                        logger.debug(f"Detected and removing UTF-8 BOM for {url}")
                        content = content_bytes[3:].decode('utf-8', errors='replace')
                    else:
                        # No BOM detected, proceed with normal decoding
                        # Use encoding from headers if available and reliable, else default to utf-8
                        detected_encoding = response.encoding if response.encoding else 'utf-8'
                        content = content_bytes.decode(detected_encoding, errors='replace')
                except UnicodeDecodeError as decode_err:
                     logger.warning(f"Decoding failed for {url} using {detected_encoding}: {decode_err}. Trying latin-1.")
                     try:
                          content = content_bytes.decode('latin-1')
                     except Exception as final_decode_err:
                          logger.error(f"Failed decode even with latin-1 for {url}: {final_decode_err}")
                          content = None
                          return {"success": False, "status_code": response.status_code, "error": "Content decoding failed", "content_bytes": content_bytes, "requested_url": url}
                except Exception as e:
                     logger.error(f"Error during content decoding/BOM check for {url}: {e}", exc_info=True)
                     content = None
                     return {"success": False, "status_code": response.status_code, "error": f"Content decoding/BOM error: {e}", "content_bytes": content_bytes, "requested_url": url}
            else:
                 logger.debug("Received empty content_bytes.")
                 content = '' # Treat empty bytes as empty string

            return {
                "success": True,
                "status_code": response.status_code,
                "content_type": content_type,
                "content": content,
                "content_bytes": content_bytes if len(content_bytes) <= 5000 else b'[content_bytes truncated]', # Avoid huge logs
                "final_url": response.url,
                "requested_url": url
            }

        except Timeout:
            logger.warning(f"Request timed out for {url}")
            return {"success": False, "error": "Timeout", "requested_url": url}
        except ConnectionError as e:
            logger.warning(f"Connection error for {url}: {e}")
            return {"success": False, "error": f"ConnectionError: {e}", "requested_url": url}
        except requests.exceptions.HTTPError as e:
            logger.warning(f"HTTP error for {url}: {e.response.status_code}")
            content_bytes_error = None
            try: 
                content_bytes_error = e.response.content
            except: pass
            return {"success": False, "status_code": e.response.status_code, "error": f"HTTP {e.response.status_code}", "content_bytes": content_bytes_error, "requested_url": url}
        except RequestException as e:
            logger.error(f"Request failed for {url}: {e}", exc_info=True)
            return {"success": False, "error": f"RequestException: {e}", "requested_url": url}
        except Exception as e:
            logger.error(f"Unexpected error fetching {url}: {e}", exc_info=True)
            return {"success": False, "error": f"Unexpected error: {e}", "requested_url": url}

================
File: apps/agents/utils/scrape_url.py
================
import logging
import json
import re
from urllib.parse import urlparse
from typing import Dict, List, Any, Optional, Union
# Import utilities for content type detection
from apps.common.utils import is_pdf_url, is_youtube
# Import loaders for PDF and YouTube content
from langchain_community.document_loaders import YoutubeLoader, PyMuPDFLoader
# Import CompressionTool for processing large content
from apps.agents.tools.compression_tool.compression_tool import CompressionTool
# Import the scraper service
from .scraper_service import ScraperService

# NOTE: This file has been updated to use the Playwright adapter by default
# The Playwright adapter connects to a self-hosted Playwright service
# that extracts comprehensive metadata from web pages

logger = logging.getLogger(__name__)

# List of URL patterns to exclude from scraping
# These can be exact domains or regex patterns
EXCLUDED_URL_PATTERNS = [
    # Example patterns (uncomment or add your own):
    # 'facebook.com',
    # 'twitter.com',
    # 'instagram.com',
    # 'linkedin.com',
    # r'.*\.pdf$',  # PDF files
    'yelp.com',
]

def is_excluded_url(url):
    """
    Check if a URL should be excluded from scraping based on predefined patterns.

    Args:
        url (str): The URL to check

    Returns:
        bool: True if the URL should be excluded, False otherwise
    """
    parsed_url = urlparse(url)
    domain = parsed_url.netloc

    for pattern in EXCLUDED_URL_PATTERNS:
        # Check if it's a regex pattern (starts with r')
        if pattern.startswith('r\'') and pattern.endswith('\''):
            # Extract the actual regex pattern
            regex = pattern[2:-1]
            if re.search(regex, url, re.IGNORECASE):
                logger.info(f"URL {url} excluded by regex pattern: {regex}")
                return True
        # Check if domain contains the pattern
        elif pattern in domain:
            logger.info(f"URL {url} excluded by domain pattern: {pattern}")
            return True

    return False

def _load_from_youtube(url: str) -> dict:
    """
    Load and process YouTube video content using YoutubeLoader.

    Args:
        url (str): YouTube video URL

    Returns:
        dict: Processed YouTube content with transcript and metadata
    """
    try:
        loader = YoutubeLoader.from_youtube_url(url)
        docs = loader.load()

        if not docs:
            logger.error(f"No content extracted from YouTube video: {url}")
            return None

        page_content = "".join(doc.page_content for doc in docs)
        metadata = docs[0].metadata

        # Create output string with metadata and page_content
        transcript = f"Title: {metadata.get('title')}\n\n"
        transcript += f"Description: {metadata.get('description')}\n\n"
        transcript += f"View Count: {metadata.get('view_count')}\n\n"
        transcript += f"Author: {metadata.get('author')}\n\n"
        transcript += f"Category: {metadata.get('category')}\n\n"
        transcript += f"Source: {metadata.get('source')}\n\n"
        transcript += f"Page Content:\n{page_content}"

        # Check if content is too large and needs compression
        if len(transcript) > 500000:
            logger.info(f"YouTube content from {url} exceeds 500,000 characters. Compressing...")
            compressed_content = _compress_large_content(transcript)
            # Use compressed content if compression succeeded
            if compressed_content:
                logger.info(f"Successfully compressed YouTube content from {url}")
                transcript = compressed_content
                page_content = compressed_content  # Update page_content as well

        # Create result in the scrape_url format
        parsed_url = urlparse(url)
        domain = parsed_url.netloc

        result = {
            'url': url,
            'domain': domain,
            'title': metadata.get('title', ''),
            'byline': metadata.get('author', ''),
            'content': transcript,  # Full formatted content
            'textContent': page_content,
            'excerpt': page_content[:200] + "..." if len(page_content) > 200 else page_content,
            'length': len(page_content),
            'meta': {
                'general': {
                    'author': metadata.get('author', ''),
                    'description': metadata.get('description', ''),
                },
                'youtube': metadata,
                'contentType': 'youtube',
                'compressed': len(transcript) > 500000
            }
        }

        logger.info(f"Successfully loaded YouTube content from: {url}")
        return result

    except Exception as e:
        logger.error(f"Error loading YouTube content from {url}: {str(e)}")
        return None

def _load_from_pdf(url: str) -> dict:
    """
    Load and process PDF content using PyMuPDFLoader.

    Args:
        url (str): PDF document URL

    Returns:
        dict: Processed PDF content with text and metadata
    """
    try:
        loader = PyMuPDFLoader(url)
        docs = loader.load()

        if not docs:
            logger.error(f"No content extracted from PDF: {url}")
            return None

        pdf_text = "".join(doc.page_content for doc in docs)

        # Check if content is too large and needs compression
        was_compressed = False
        if len(pdf_text) > 500000:
            logger.info(f"PDF content from {url} exceeds 500,000 characters. Compressing...")
            compressed_content = _compress_large_content(pdf_text)
            # Use compressed content if compression succeeded
            if compressed_content:
                logger.info(f"Successfully compressed PDF content from {url}")
                pdf_text = compressed_content
                was_compressed = True

        # Extract filename from URL
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        filename = parsed_url.path.split('/')[-1]

        # Create result in the scrape_url format
        result = {
            'url': url,
            'domain': domain,
            'title': filename,
            'byline': '',
            'content': pdf_text,  # Full PDF text
            'textContent': pdf_text,
            'excerpt': pdf_text[:200] + "..." if len(pdf_text) > 200 else pdf_text,
            'length': len(pdf_text),
            'meta': {
                'general': {
                    'filename': filename,
                },
                'contentType': 'pdf',
                'pageCount': len(docs),
                'compressed': was_compressed
            }
        }

        logger.info(f"Successfully loaded PDF content from: {url}")
        return result

    except Exception as e:
        logger.error(f"Error loading PDF content from {url}: {str(e)}")
        return None

def _compress_large_content(content: str) -> str:
    """
    Compress large content using CompressionTool.

    Args:
        content (str): Content to compress

    Returns:
        str: Compressed content or original content if compression fails
    """
    try:
        logger.info(f"Compressing content of length {len(content)}")

        # Initialize the compression tool
        compression_tool = CompressionTool()

        # Call the tool with appropriate parameters
        # Setting a smaller max_tokens to ensure significant compression
        result_json = compression_tool._run(
            content=content,
            max_tokens=32767,  # This is a reasonable size that balances detail and compression
            detail_level="detailed"  # Use "detailed" to preserve important information
        )

        result = json.loads(result_json)

        # Check if compression was successful
        if "processed_content" in result:
            compressed_content = result["processed_content"]
            original_tokens = result.get("original_tokens", 0)
            final_tokens = result.get("final_tokens", 0)
            reduction_ratio = result.get("reduction_ratio", 0)

            logger.info(f"Content compressed: original tokens: {original_tokens}, "
                        f"final tokens: {final_tokens}, reduction ratio: {reduction_ratio}")

            return compressed_content
        else:
            logger.error(f"Compression failed: {result.get('error', 'Unknown error')}")
            return content  # Return original content if compression fails

    except Exception as e:
        logger.error(f"Error compressing content: {str(e)}")
        return content  # Return original content if compression fails

def crawl_website(url, output_type="text", max_pages=100, max_depth=3, include_patterns=None,
                exclude_patterns=None, stay_within_domain=True, cache=True, stealth=False,
                timeout=30000, device=None, excluded_urls=None, adapter_name=None, **kwargs):
    # Use FireCrawl's dedicated crawl adapter for multi-page crawling
    # until Playwright service supports multi-page crawling
    if max_pages > 1 and adapter_name is None:
        adapter_name = "firecrawl_crawl"
    """
    Crawls a website and returns the content in the requested format.
    Uses the Playwright adapter for multi-page crawling.

    Args:
        url (str): The URL to crawl
        output_type (str): Format(s) to return (text, html, links, metadata, full) or comma-separated string
        max_pages (int): Maximum number of pages to crawl
        max_depth (int): Maximum depth to crawl
        include_patterns (list): URL patterns to include in crawl
        exclude_patterns (list): URL patterns to exclude from crawl
        stay_within_domain (bool): Whether to stay within the domain
        cache (bool): Whether to use cached results if available
        stealth (bool): Whether to use stealth mode for challenging websites
        timeout (int): Timeout in milliseconds
        device (str): Device to emulate (e.g., "mobile" or "desktop")
        excluded_urls (list): Additional list of URL patterns to exclude from scraping
        adapter_name (str): Name of the adapter to use (defaults to "playwright")
        **kwargs: Additional provider-specific parameters

    Returns:
        dict: The crawled content and metadata from the website or None if failed
    """
    # Check if URL should be excluded
    if is_excluded_url(url):
        logger.info(f"URL {url} is in the exclusion list, skipping crawl")
        return None

    # Check additional excluded URLs if provided
    if excluded_urls:
        for pattern in excluded_urls:
            if pattern in url:
                logger.info(f"URL {url} is in the additional exclusion list, skipping crawl")
                return None

    # Check if URL is a YouTube video
    if is_youtube(url):
        logger.info(f"Detected YouTube URL: {url}")
        return _load_from_youtube(url)

    # Check if URL is a PDF
    if is_pdf_url(url):
        logger.info(f"Detected PDF URL: {url}")
        return _load_from_pdf(url)

    # Use the scraper service for all other URLs
    try:
        # Initialize the scraper service
        scraper_service = ScraperService(adapter_name)

        # Determine if mobile device is requested
        mobile = device == "mobile" if device else False

        # Crawl the website
        crawl_result = scraper_service.scrape(
            url=url,
            output_types=output_type,
            timeout=timeout,
            mobile=mobile,
            stealth=stealth,
            cache=cache,
            max_pages=max_pages,
            max_depth=max_depth,
            include_patterns=include_patterns,
            exclude_patterns=exclude_patterns,
            stay_within_domain=stay_within_domain,
            **kwargs
        )

        # Check if crawl was successful
        if "error" in crawl_result:
            logger.error(f"Crawl failed for URL {url}: {crawl_result['error']}")
            return None

        # Process the crawl results
        # For crawl, we get a dictionary of URLs to their content
        # We'll combine them into a single result
        combined_result = {
            'url': url,
            'domain': urlparse(url).netloc,
            'pages': [],
            'links': [],
            'meta': {
                'crawled_pages': len(crawl_result) if isinstance(crawl_result, dict) else 1,
                'crawl_depth': max_depth,
                'max_pages': max_pages
            }
        }

        # Process the crawl result based on its structure
        # Check if it's a dictionary with page URLs as keys
        if isinstance(crawl_result, dict) and all(isinstance(k, str) and isinstance(v, dict) for k, v in crawl_result.items() if k != 'error'):
            # It's a dictionary of pages - process each page
            for page_url, page_content in crawl_result.items():
                if page_url == 'error':
                    continue

                # Extract content based on available formats
                html_content = page_content.get("html", page_content.get("raw_html", ""))
                text_content = page_content.get("text", "")
                links = page_content.get("links", [])
                metadata = page_content.get("metadata", {})

                # Add page to the combined result
                combined_result['pages'].append({
                    'url': page_url,
                    'title': metadata.get("title", ""),
                    'content': html_content,
                    'textContent': text_content,
                    'links': links,
                    'metadata': metadata
                })

                # Add links to the combined result
                combined_result['links'].extend(links)
        else:
            # It's a single page result - treat it as a single page
            # This handles the case where the adapter returns a string or a simple object
            logger.info(f"Received single page result for {url}")

            # For string results (like text content)
            if isinstance(crawl_result, str):
                text_content = crawl_result
                html_content = ""
                links = []
                metadata = {}
            else:
                # For dictionary results
                html_content = crawl_result.get("html", crawl_result.get("raw_html", ""))
                text_content = crawl_result.get("text", "")
                links = crawl_result.get("links", [])
                metadata = crawl_result.get("metadata", {})

            # Add the single page to the result
            combined_result['pages'].append({
                'url': url,
                'title': metadata.get("title", "") if isinstance(metadata, dict) else "",
                'content': html_content,
                'textContent': text_content,
                'links': links,
                'metadata': metadata
            })

            # Add links to the combined result
            if links:
                combined_result['links'].extend(links)

        # Remove duplicate links
        combined_result['links'] = list(set(combined_result['links']))

        logger.info(f"Successfully crawled website: {url} - {len(combined_result['pages'])} pages")
        return combined_result

    except Exception as e:
        logger.error(f"Error crawling website {url}: {str(e)}")
        return None


def scrape_url(url, output_type="text", cache=True, stealth=False, screenshot=False,
               timeout=30000, wait_for=None, css_selector=None, device=None,
               excluded_urls=None, adapter_name="playwright", **kwargs):
    """
    Retrieves content of a URL using the configured scraper adapter.
    Support for PDF documents and YouTube videos has been added.

    Args:
        url (str): The URL to scrape
        output_type (str): Format(s) to return (text, html, links, metadata, full) or comma-separated string
        cache (bool): Whether to use cached results if available
        stealth (bool): Whether to use stealth mode for challenging websites
        screenshot (bool): Whether to capture screenshot
        timeout (int): Timeout in milliseconds
        wait_for (int): Time to wait after page load in milliseconds
        css_selector (str): CSS selector to extract content from
        device (str): Device to emulate (e.g., "mobile" or "desktop")
        excluded_urls (list): Additional list of URL patterns to exclude from scraping
        adapter_name (str): Name of the adapter to use (defaults to "playwright")
        **kwargs: Additional provider-specific parameters

    Returns:
        dict: The scraped content and metadata from the URL or None if failed

    Response structure includes:
        - byline: Author information
        - content: Cleaned HTML content
        - excerpt: Brief description
        - url: Original URL
        - domain: Website domain
        - textContent: Plain text content
        - title: Page title
        - meta: Metadata (og, twitter tags, etc.)
        - and more...
    """
    # Check if URL should be excluded
    if is_excluded_url(url):
        logger.info(f"URL {url} is in the exclusion list, skipping scrape")
        return None

    # Check additional excluded URLs if provided
    if excluded_urls:
        for pattern in excluded_urls:
            if pattern in url:
                logger.info(f"URL {url} is in the additional exclusion list, skipping scrape")
                return None

    # Check if URL is a YouTube video
    if is_youtube(url):
        logger.info(f"Detected YouTube URL: {url}")
        return _load_from_youtube(url)

    # Check if URL is a PDF
    if is_pdf_url(url):
        logger.info(f"Detected PDF URL: {url}")
        return _load_from_pdf(url)

    # Use the scraper service for all other URLs
    try:
        # Initialize the scraper service
        scraper_service = ScraperService(adapter_name)

        # Determine if mobile device is requested
        mobile = device == "mobile" if device else False

        # Scrape the URL
        scrape_result = scraper_service.scrape(
            url=url,
            output_types=output_type,
            timeout=timeout,
            wait_for=wait_for,
            css_selector=css_selector,
            mobile=mobile,
            stealth=stealth,
            cache=cache,
            **kwargs
        )

        # Check if scrape was successful
        if "error" in scrape_result:
            logger.error(f"Scrape failed for URL {url}: {scrape_result['error']}")
            return None

        # Create result in the expected format
        parsed_url = urlparse(url)
        domain = parsed_url.netloc

        # Extract content based on available formats
        html_content = scrape_result.get("html", scrape_result.get("raw_html", ""))
        text_content = scrape_result.get("text", "")
        metadata = scrape_result.get("metadata", {})

        # Add links to metadata if available
        if "links" in scrape_result:
            metadata["links"] = scrape_result["links"]

        # Log the metadata keys for debugging
        if metadata:
            logger.info(f"Metadata keys received: {list(metadata.keys())}")
        else:
            logger.warning(f"No metadata received for URL: {url}")

        # Extract title and description from metadata
        title = metadata.get("title", "")
        description = metadata.get("meta_description", metadata.get("description", ""))

        # Check for content compression
        if len(text_content) > 500000:
            logger.info(f"Text content from {url} exceeds 500,000 characters. Compressing...")
            compressed_content = _compress_large_content(text_content)
            if compressed_content:
                logger.info(f"Successfully compressed text content from {url}")
                text_content = compressed_content

        # Create a structured result
        result = {
            'url': url,
            'domain': domain,
            'title': title,
            'byline': metadata.get("author", ""),
            'content': html_content,  # HTML content
            'textContent': text_content,  # Text content
            'excerpt': description if description else (text_content[:200] + "..." if len(text_content) > 200 else text_content),
            'length': len(text_content),
            'meta': metadata  # Simply use the metadata directly
        }

        # Add screenshot if available
        if screenshot and "screenshot" in scrape_result:
            result['meta']['screenshot'] = scrape_result["screenshot"]

        logger.info(f"Successfully scraped URL: {url}")
        return result

    except Exception as e:
        logger.error(f"Error scraping URL {url}: {str(e)}")
        return None

================
File: apps/agents/utils/scraper_service.py
================
"""
Scraper service for web scraping.
"""
import logging
from typing import Dict, List, Any, Optional, Union, Type

from django.conf import settings
from .scraper_adapters import ScraperAdapter, FireCrawlAdapter, FireCrawlCrawlAdapter, PlaywrightAdapter

logger = logging.getLogger(__name__)


class ScraperService:
    """
    Service for web scraping using different adapters.
    """

    # Default adapter to use if not specified
    DEFAULT_ADAPTER = 'firecrawl'

    # Map of adapter names to adapter classes
    ADAPTERS = {
        'firecrawl': FireCrawlAdapter,
        'firecrawl_crawl': FireCrawlCrawlAdapter,
        'playwright': PlaywrightAdapter,
    }

    def __init__(self, adapter_name=None):
        """
        Initialize the scraper service.

        Args:
            adapter_name: Name of the adapter to use (defaults to settings.DEFAULT_SCRAPER_ADAPTER or 'firecrawl')
        """
        self.adapter_name = adapter_name or getattr(settings, 'DEFAULT_SCRAPER_ADAPTER', self.DEFAULT_ADAPTER)
        self.adapter = self._get_adapter(self.adapter_name)

    def _get_adapter(self, adapter_name: str) -> ScraperAdapter:
        """
        Get an instance of the specified adapter.

        Args:
            adapter_name: Name of the adapter to use

        Returns:
            Instance of the adapter

        Raises:
            ValueError: If the adapter is not found
        """
        adapter_class = self.ADAPTERS.get(adapter_name.lower())
        if not adapter_class:
            raise ValueError(f"Unknown scraper adapter: {adapter_name}")

        return adapter_class()

    def register_adapter(self, name: str, adapter_class: Type[ScraperAdapter]):
        """
        Register a new adapter.

        Args:
            name: Name of the adapter
            adapter_class: Adapter class
        """
        self.ADAPTERS[name.lower()] = adapter_class

    def get_supported_formats(self) -> List[str]:
        """
        Get the list of formats supported by the current adapter.

        Returns:
            List of supported format names
        """
        return self.adapter.get_supported_formats()

    def scrape(self,
               url: str,
               output_types: Union[str, List[str]],
               timeout: int = 30000,
               wait_for: Optional[int] = None,
               css_selector: Optional[str] = None,
               headers: Optional[Dict[str, str]] = None,
               mobile: bool = False,
               stealth: bool = False,
               cache: bool = True,
               adapter_name: Optional[str] = None,
               **kwargs) -> Dict[str, Any]:
        """
        Scrape a URL and return the content in the requested formats.

        Args:
            url: The URL to scrape
            output_types: List of formats to return or comma-separated string
                         (text, html, links, metadata, full)
            timeout: Timeout in milliseconds
            wait_for: Wait for element or time in milliseconds
            css_selector: CSS selector to extract content from
            headers: Custom headers to send with the request
            mobile: Whether to use mobile user agent
            stealth: Whether to use stealth mode
            adapter_name: Name of the adapter to use (overrides the default)
            **kwargs: Additional provider-specific parameters

        Returns:
            Dictionary with the requested formats as keys and their content as values
        """
        # Use specified adapter if provided
        adapter = self._get_adapter(adapter_name) if adapter_name else self.adapter

        # Normalize output_types to a list
        if isinstance(output_types, str):
            if ',' in output_types:
                formats = [fmt.strip() for fmt in output_types.split(',')]
            else:
                formats = [output_types]
        else:
            formats = output_types

        # Validate formats
        supported_formats = adapter.get_supported_formats()
        for fmt in formats:
            if fmt not in supported_formats:
                logger.warning(f"Format '{fmt}' not supported by adapter '{adapter_name or self.adapter_name}', ignoring")

        # Filter to only supported formats
        valid_formats = [fmt for fmt in formats if fmt in supported_formats]

        if not valid_formats:
            logger.error(f"No valid formats specified. Supported formats: {supported_formats}")
            return {"error": f"No valid formats specified. Supported formats: {supported_formats}"}

        # Scrape the URL
        return adapter.scrape(
            url=url,
            formats=valid_formats,
            timeout=timeout,
            wait_for=wait_for,
            css_selector=css_selector,
            headers=headers,
            mobile=mobile,
            stealth=stealth,
            cache=cache,
            **kwargs
        )

================
File: apps/agents/utils/tool_utils.py
================
import os
import importlib
from apps.agents.utils.minimal_tools import BaseTool
from langchain.tools import BaseTool as LangChainBaseTool
import logging
import re
from typing import Optional, Type
from django.core.cache import cache
from pydantic import BaseModel

logger = logging.getLogger(__name__)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for item in dirs + files:
            if item.endswith('.py') and not item.startswith('__'):
                rel_path = os.path.relpath(os.path.join(root, item), tools_dir)
                module_path = os.path.splitext(rel_path)[0].replace(os.path.sep, '.')
                available_tools.append(module_path)

    return available_tools

def get_tool_classes(tool_path):
    module_path = f"apps.agents.tools.{tool_path}"
    
    try:
        module = importlib.import_module(module_path)
        tool_classes = []
        
        for attr_name in dir(module):
            if attr_name.startswith('_'):
                continue
                
            attr = getattr(module, attr_name)
            if isinstance(attr, type) and (
                issubclass(attr, BaseTool) or 
                issubclass(attr, LangChainBaseTool)
            ) and attr not in (BaseTool, LangChainBaseTool):
                # Return the class object instead of the name for compatibility with newer code
                tool_classes.append(attr)
                
        return tool_classes
    except ImportError as e:
        logger.error(f"Error importing tool module {module_path}: {e}")
        return []
    except Exception as e:
        logger.error(f"Error getting tool classes from {module_path}: {e}")
        return []

def get_tool_description(tool_class_obj):
    """Get a tool's description, prioritizing direct attributes and docstrings."""
    try:
        # Ensure we have a class object if a name was passed
        if isinstance(tool_class_obj, str):
            logger.warning(f"get_tool_description received a string '{tool_class_obj}', expected a class object. Attempting to resolve.")
            return f"Error: Expected class object, got string '{tool_class_obj}'"

        tool_class_name = tool_class_obj.__name__ if isinstance(tool_class_obj, type) else str(tool_class_obj)
        logger.debug(f"Getting description for tool: {tool_class_name}")

        description = None
        raw_value = None # Variable to store the raw retrieved value

        # 1. Direct Class Attribute Access (Highest Priority)
        if isinstance(tool_class_obj, type):
            if hasattr(tool_class_obj, 'description'):
                raw_value = getattr(tool_class_obj, 'description')
                logger.debug(f"Raw value from class attribute 'description': type={type(raw_value)}, value='{str(raw_value)[:150]}...'")
                if isinstance(raw_value, str):
                    description = raw_value
                    logger.debug("Using description as direct class attribute")

            # 2. LangChain specific attribute
            if not description and hasattr(tool_class_obj, 'description_for_model'):
                raw_value = getattr(tool_class_obj, 'description_for_model')
                logger.debug(f"Raw value from class attribute 'description_for_model': type={type(raw_value)}, value='{str(raw_value)[:150]}...'")
                if isinstance(raw_value, str):
                    description = raw_value
                    logger.debug("Using description_for_model as class attribute")

        # 3. Instance Attribute Access (If class access failed)
        if not description and isinstance(tool_class_obj, type):
            try:
                logger.debug("Trying to instantiate class to get description")
                instance = tool_class_obj()
                if hasattr(instance, 'description'):
                    raw_value = getattr(instance, 'description')
                    logger.debug(f"Raw value from instance attribute 'description': type={type(raw_value)}, value='{str(raw_value)[:150]}...'")
                    if isinstance(raw_value, str):
                        description = raw_value
                        logger.debug("Using description on instance")
                elif hasattr(instance, 'description_for_model'):
                    raw_value = getattr(instance, 'description_for_model')
                    logger.debug(f"Raw value from instance attribute 'description_for_model': type={type(raw_value)}, value='{str(raw_value)[:150]}...'")
                    if isinstance(raw_value, str):
                        description = raw_value
                        logger.debug("Using description_for_model on instance")
            except Exception as e:
                logger.debug(f"Could not instantiate or get description from instance: {e}")

        # 4. Docstring Fallback
        if not description and hasattr(tool_class_obj, '__doc__') and tool_class_obj.__doc__:
            raw_value = tool_class_obj.__doc__
            logger.debug(f"Raw value from __doc__: type={type(raw_value)}, value='{str(raw_value)[:150]}...'")
            if isinstance(raw_value, str):
                description = raw_value
                logger.debug("Using docstring for description")

        # 5. Final check and cleaning
        if not description:
            logger.warning(f"No description found for {tool_class_name}")
            return f"Description not found for {tool_class_name}"

        if isinstance(description, str):
            # Clean multiline string indentation
            description = description.strip()
            if "\\n" in description:
                lines = description.split("\\n")
                if lines and not lines[0].strip() and len(lines) > 1:
                    lines = lines[1:]
                if len(lines) > 1:
                    non_empty = [line for line in lines if line.strip()]
                    if non_empty:
                        try:
                            indented_lines = [line for line in non_empty if line.lstrip() != line]
                            if indented_lines:
                                min_indent = min(len(line) - len(line.lstrip()) for line in indented_lines)
                            else:
                                min_indent = 0
                            cleaned_lines = []
                            for line in lines:
                                if len(line) >= min_indent and line[:min_indent].isspace():
                                     cleaned_lines.append(line[min_indent:])
                                else:
                                     cleaned_lines.append(line)
                            lines = cleaned_lines
                        except ValueError:
                            logger.warning(f"Could not determine indentation for {tool_class_name}")
                            pass
                description = "\\n".join(lines).strip()

            # ADDED: Targeted cleaning for the observed problematic format
            # If the description still contains the complex pattern, try to extract the core part
            if "Tool Name:" in description and "Tool Arguments:" in description and "Tool Description:" in description:
                logger.debug("Complex pattern detected, attempting targeted extraction.")
                try:
                    # Extract text after the LAST occurrence of "Tool Description:"
                    parts = description.rsplit("Tool Description:", 1)
                    if len(parts) > 1:
                        core_desc = parts[1].strip()
                        # Further clean up potential trailing parameter definitions
                        param_match = re.search(r'([a-z][a-z0-9_]*):\s*(?:\'[^\']*\'|\"[^\"]*\"|[^\s,]+)', core_desc)
                        if param_match:
                            if param_match.start() > 20: # Only if there is some text before the first param
                                core_desc = core_desc[:param_match.start()].strip()
                        
                        # Check if the extracted part is meaningful
                        if len(core_desc) > 10: # Avoid returning empty or very short strings
                             logger.debug(f"Extracted core description from complex pattern: {core_desc[:100]}...")
                             description = core_desc # Use the extracted part
                        else:
                            logger.warning("Extraction from complex pattern resulted in short/empty string, keeping original cleaned description.")
                    else:
                         logger.warning("Could not split complex pattern using 'Tool Description:'")
                except Exception as extract_err:
                    logger.error(f"Error during targeted extraction: {extract_err}")
            
            logger.debug(f"Final description: {description[:100]}...")
            return description
        else:
            logger.warning(f"Description for {tool_class_name} was not a string, converting.")
            return str(description).strip()

    except Exception as e:
        logger.error(f"Critical error in get_tool_description for {tool_class_name}: {e}", exc_info=True)
        return "Description unavailable due to error"

def get_tool_class_obj(tool_class: str, tool_subclass: str = None) -> Type[BaseTool]:
    """
    Get the actual tool class object by name and optional subclass.
    
    Args:
        tool_class: The path to the tool module (e.g., 'web_search_tool')
        tool_subclass: Optional class name within the module
        
    Returns:
        The tool class object or None if not found
    """
    try:
        # Handle both formats: with or without .py extension
        tool_path = tool_class.replace('.py', '')
        
        # Import the module
        module_path = f"apps.agents.tools.{tool_path}"
        module = importlib.import_module(module_path)
        
        if tool_subclass:
            # If subclass specified, get that specific class
            if hasattr(module, tool_subclass):
                return getattr(module, tool_subclass)
            else:
                logger.error(f"Tool subclass {tool_subclass} not found in {module_path}")
                return None
        else:
            # Find the first available tool class
            for attr_name in dir(module):
                if attr_name.startswith('_'):
                    continue
                    
                attr = getattr(module, attr_name)
                if isinstance(attr, type) and (
                    issubclass(attr, BaseTool) or 
                    issubclass(attr, LangChainBaseTool)
                ) and attr not in (BaseTool, LangChainBaseTool):
                    return attr
                    
            logger.error(f"No tool class found in {module_path}")
            return None
    except ImportError as e:
        logger.error(f"Error importing tool module {tool_class}: {e}")
        return None
    except Exception as e:
        logger.error(f"Error getting tool class object: {e}")
        return None

def load_tool(tool_model) -> Optional[BaseTool]:
    """
    Load and instantiate a tool from the database model.
    Will adapt LangChain tools to CrewAI tools if needed.
    """
    try:
        # Get the tool class
        tool_class = get_tool_class_obj(tool_model.tool_class, tool_model.tool_subclass)
        if not tool_class:
            logger.error(f"Could not load tool class for {tool_model.tool_class}")
            return None
            
        # Handle different tool types
        if issubclass(tool_class, BaseTool):
            # CrewAI tool - instantiate directly
            return tool_class()
        elif issubclass(tool_class, LangChainBaseTool):
            # LangChain tool - needs wrapper
            langchain_tool = tool_class()
            
            # Create a wrapper class that adapts the LangChain tool to CrewAI
            class WrappedLangChainTool(BaseTool):
                name = tool_class.name
                description = get_tool_description(tool_class)
                
                def _run(self, *args, **kwargs):
                    # Forward the call to the LangChain tool
                    return langchain_tool._run(*args, **kwargs)
            
            return WrappedLangChainTool()
        else:
            logger.error(f"Unknown tool type for {tool_model.tool_class}")
            return None
    except Exception as e:
        logger.error(f"Error loading tool {tool_model.tool_class}: {e}")
        return None

def get_tool_info(tool_model):
    """
    Get basic information about a tool from its model.
    
    Args:
        tool_model: The tool model object from the database
        
    Returns:
        Dict with module_path and class_name
    """
    full_module_path = f"apps.agents.tools.{tool_model.tool_class}"
    
    return {
        'module_path': full_module_path,
        'class_name': tool_model.tool_subclass
    }

================
File: apps/agents/utils/url_utils.py
================
import re
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import logging

logger = logging.getLogger(__name__)

class URLDeduplicator:
    def __init__(self):
        # Common CMS page identifiers
        self.cms_patterns = {
            'wordpress': [
                r'(?:page_id|p|post)=\d+',
                r'\d{4}/\d{2}/\d{2}',  # Date-based permalinks
                r'(?:category|tag)/[\w-]+',
            ],
            'woocommerce': [
                r'product=\d+',
                r'product-category/[\w-]+',
            ],
        }
        
        # Patterns that indicate filter/sort URLs
        self.filter_patterns = [
            # E-commerce filters
            r'product_type=\d+',
            r'prefilter=',
            r'filter=',
            r'sort=',
            r'order=',
            r'orderby=',
            
            # Faceted navigation
            r'facet=',
            r'facets=',
            
            # Search parameters
            r'q=',
            r'query=',
            r'search=',
            
            # Pagination
            r'page=',
            r'pg=',
            r'p=',
            r'paged=',
            
            # View settings
            r'view=',
            r'layout=',
            r'display=',
            r'show=',
            
            # Session and tracking
            r'utm_',
            r'gclid=',
            r'fbclid=',
            r'sessionid=',
        ]
    
    def should_process_url(self, url: str) -> bool:
        """
        Determine if a URL should be processed based on its characteristics.
        Returns True if the URL should be processed, False otherwise.
        """
        if not url:
            return False

        # Skip URLs with fragments
        if '#' in url:
            return False

        # Skip common file extensions
        if url.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx', 
                               '.xls', '.xlsx', '.zip', '.tar', '.gz', '.css', '.js', '.xml')):
            return False

        # Skip URLs with tracking parameters
        parsed = urlparse(url)
        query_params = parse_qs(parsed.query)
        if any(param.startswith('utm_') or param in ['gclid', 'fbclid', 'sessionid'] 
               for param in query_params):
            return False

        # Skip URLs with specific patterns that indicate duplicate content
        if any(re.search(pattern, url) for pattern in self.filter_patterns):
            return False

        return True

    def is_likely_duplicate(self, url1, url2):
        """
        Determine if two URLs are likely duplicates by comparing their components
        and checking for common patterns that indicate they're the same content.
        """
        # Parse URLs
        parsed1 = urlparse(url1)
        parsed2 = urlparse(url2)
        
        # Different domains means definitely not duplicates
        if parsed1.netloc != parsed2.netloc:
            return False
        
        # Normalize paths (removing trailing slashes)
        path1 = parsed1.path.rstrip('/')
        path2 = parsed2.path.rstrip('/')
        
        # Exact path match is a strong indicator
        paths_match = (path1 == path2)
        
        # Check for CMS-specific patterns
        is_cms_page1 = any(re.search(pattern, url1) for patterns in self.cms_patterns.values() for pattern in patterns)
        is_cms_page2 = any(re.search(pattern, url2) for patterns in self.cms_patterns.values() for pattern in patterns)
        
        # Parse query parameters
        query1 = parse_qs(parsed1.query)
        query2 = parse_qs(parsed2.query)
        
        # If paths match and they're not special CMS pages, just check if filter params are different
        if paths_match and not (is_cms_page1 or is_cms_page2):
            # Remove known filter/sort/tracking parameters
            filtered_query1 = {k: v for k, v in query1.items() if not any(re.match(pattern, k) for pattern in self.filter_patterns)}
            filtered_query2 = {k: v for k, v in query2.items() if not any(re.match(pattern, k) for pattern in self.filter_patterns)}
            
            # If the only difference is in filter parameters, they're likely duplicates
            return filtered_query1 == filtered_query2
            
        # If one URL is a special CMS page and paths are different, check if they point to the same content
        if (is_cms_page1 or is_cms_page2) and path1 != path2:
            # Extract IDs from specific patterns - this is simplified and would need expansion
            id1 = self._extract_cms_id(url1)
            id2 = self._extract_cms_id(url2)
            
            if id1 and id2 and id1 == id2:
                return True
        
        # Otherwise, not duplicates
        return False
    
    def _extract_cms_id(self, url):
        """
        Extract CMS ID from a URL based on common patterns.
        Returns None if no ID can be extracted.
        """
        # Check for WordPress post ID
        wp_id_match = re.search(r'[?&](?:p|page_id|post)=(\d+)', url)
        if wp_id_match:
            return f"wp:{wp_id_match.group(1)}"
        
        # Check for WooCommerce product ID
        woo_id_match = re.search(r'[?&]product=(\d+)', url)
        if woo_id_match:
            return f"woo:{woo_id_match.group(1)}"
        
        # Add more CMS pattern extractors as needed
        
        return None
    
    def canonicalize_url(self, url):
        """
        Convert a URL to its canonical form by removing tracking parameters,
        sorting query parameters, and normalizing the path.
        """
        parsed = urlparse(url)
        
        # Normalize the path (ensure trailing slash consistency)
        path = parsed.path
        if not path:
            path = '/'
        elif path != '/' and not path.endswith('/'):
            path = path + '/'
        
        # Parse and filter query parameters
        query_params = parse_qs(parsed.query)
        
        # Remove tracking and session parameters
        tracking_patterns = [r'utm_', r'gclid', r'fbclid', r'sessionid']
        filtered_params = {k: v for k, v in query_params.items() 
                           if not any(re.match(pattern, k) for pattern in tracking_patterns)}
        
        # Sort parameters and rebuild query string
        sorted_query = urlencode(sorted(filtered_params.items()), doseq=True)
        
        # Rebuild the URL
        canonical = urlunparse((
            parsed.scheme.lower(),  # Normalize scheme to lowercase
            parsed.netloc.lower(),  # Normalize domain to lowercase
            path,
            parsed.params,
            sorted_query,
            ''  # Remove fragments
        ))
        
        return canonical

================
File: apps/agents/websockets/handlers/agent_handler.py
================
import logging
from apps.common.utils import create_box
from apps.agents.models import Agent
from channels.db import database_sync_to_async
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.exceptions import StopConsumer
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler
from apps.seo_manager.models import Client
from apps.agents.websockets.services.chat_service import AgentChatService
from django.utils import timezone

logger = logging.getLogger(__name__)

class AgentHandler:
    def __init__(self, consumer):
        self.consumer = consumer
        self.chat_service = None

    async def process_response(self, message, agent_id, model_name, client_id=None, organization=None):
        """Manages agent and chat service lifecycle"""
        try:
            # Get agent data
            agent = await self.get_agent(agent_id)
            if not agent:
                raise ValueError("Agent not found")

            # Get client data - the organization context should now be set by middleware
            client_data = None
            if client_id:
                # Just use the normal get_client_data method since organization context is set
                client_data = await self.consumer.client_manager.get_client_data(client_id)
            else:
                client_data = {
                    'client_id': None,
                    'current_date': timezone.now().date().isoformat(),
                }
            
            # Add user ID to client_data
            client_data['user_id'] = self.consumer.user.id

            # Check if we need to reinitialize the chat service (agent or model changed)
            should_reinitialize = (
                not self.chat_service or
                str(self.chat_service.agent.id) != str(agent_id) or
                self.chat_service.model_name != model_name
            )

            if should_reinitialize:
                # Create new chat service with new agent/model but preserve message history
                logger.info(create_box("AGENT HANDLER", f"Reinitializing chat service for agent {agent_id} with model {model_name}"))
                callback_handler = WebSocketCallbackHandler(self.consumer)
                
                # Preserve the existing conversation ID and message history if it exists
                conversation_id = self.chat_service.conversation_id if self.chat_service else None
                message_manager = self.chat_service.message_manager if self.chat_service else None
                
                self.chat_service = AgentChatService(
                    agent=agent,
                    model_name=model_name,
                    client_data=client_data,
                    callback_handler=callback_handler,
                    session_id=self.consumer.session_id
                )
                
                # Set the preserved conversation ID and message manager if they exist
                if conversation_id:
                    self.chat_service.conversation_id = conversation_id
                if message_manager:
                    self.chat_service.message_manager = message_manager
                    
                await self.chat_service.initialize()
            else:
                # Update client_data for tools to use, but not for chat messages
                # This ensures tools like Google Analytics have the credentials they need
                # without duplicating client_data in every message
                self.chat_service.client_data = client_data
            
            # Process message - no return value needed as everything goes through callbacks
            await self.chat_service.process_message(message)

        except Exception as e:
            logger.error(f"Error in agent handler: {str(e)}")
            raise

    @database_sync_to_async
    def get_agent(self, agent_id):
        """Get agent from database"""
        try:
            return Agent.objects.get(id=agent_id)
        except Exception as e:
            logger.error(f"Error getting agent: {str(e)}")
            raise

================
File: apps/agents/websockets/handlers/callback_handler.py
================
from langchain_core.callbacks import BaseCallbackHandler
import logging
import json
from typing import Any, Dict, List
from datetime import datetime
from langchain_core.agents import  AgentFinish
import asyncio
import textwrap
import uuid
from channels.db import database_sync_to_async
from apps.common.utils import create_box
from langchain.schema import SystemMessage, AIMessage
from django.utils import timezone

logger = logging.getLogger(__name__)

class UUIDEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, uuid.UUID):
            return str(obj)
        return super().default(obj)


class WebSocketCallbackHandler(BaseCallbackHandler):
    """Callback handler that sends only essential messages to the WebSocket."""
    
    def __init__(self, consumer, message_manager=None, token_manager=None):
        """Initialize the handler with a WebSocket consumer and managers"""
        super().__init__()
        self.consumer = consumer
        self.logger = logging.getLogger(__name__)
        self._message_lock = asyncio.Lock()
        self.message_history = []
        self._last_agent_finish = None  # Track last agent finish message
        self.message_manager = message_manager
        self.token_manager = token_manager

    def _log_message(self, title: str, content: Any):
        """Log a message with proper JSON serialization."""
        # get first 250 characters of content 
        content_str = str(content)[:250] + "..." if len(str(content)) > 250 else str(content)
        try:
            if isinstance(content, dict):
                content_str = json.dumps(content, indent=2, cls=UUIDEncoder)
            else:
                content_str = str(content)
            self.logger.debug(create_box(title, content_str))
        except Exception as e:
            self.logger.error(f"Error logging message: {str(e)}")

    async def _send_message(self, message_data):
        """Send message to WebSocket and store in history."""
        try:
            # Store message in history
            self.message_history.append({
                'timestamp': datetime.now().isoformat(),
                'type': message_data.get('type'),
                'content': message_data
            })
            
            # Format message if it's a tool message
            if message_data.get('type', '').startswith('tool_') and self.message_manager:
                message_data['message'] = self.message_manager.format_message(
                    message_data['message'],
                    message_data['type']
                )
            
            # Add message ID if this is a message that was stored in DB
            if hasattr(self, '_last_message_id') and self._last_message_id:
                message_data['id'] = self._last_message_id
                self._last_message_id = None  # Clear it after use
            
            async with self._message_lock:
                await self.consumer.send_json(message_data)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN SEND MESSAGE", str(e)), exc_info=True)

    async def on_agent_finish(self, finish: AgentFinish, **kwargs: Any) -> None:
        """Handle agent completion - send final answer and save to database."""
        try:
            if hasattr(finish, 'return_values'):
                output = finish.return_values.get('output', '')
                
                # Check if this is a duplicate message
                if self._last_agent_finish == output:
                    self.logger.debug("Skipping duplicate agent finish message")
                    return
                
                self._last_agent_finish = output
                
                # Extract token usage from kwargs
                token_usage = kwargs.get('token_usage', {})
                turn_tokens = token_usage.get('turn', {})
                
                # If we have nested structure, use it properly
                if 'turn' in token_usage and 'conversation' in token_usage:
                    # Use the 'turn' part for logging in this method
                    token_usage = turn_tokens
                
                # Make sure we always have token usage data to show
                if not token_usage or len(token_usage) == 0:
                    if self.token_manager:
                        token_usage = self.token_manager.get_current_usage()
                
                # Track tokens if we have a token manager
                if self.token_manager:
                    # Use the existing token usage rather than recounting
                    if 'prompt_tokens' in token_usage and 'completion_tokens' in token_usage:
                        pass  # already counted by LLM callback
                    else:
                        # Fall back to token manager tracking
                        self.token_manager.track_token_usage(
                            token_usage.get('prompt_tokens', 0),
                            token_usage.get('completion_tokens', 0)
                        )
                    
                    # Track conversation tokens AFTER tracking the current usage
                    await self.token_manager.track_conversation_tokens()
                
                debug_info = {
                    'output': output,
                    'token_usage': token_usage
                }
                self._log_message("AGENT FINISH EVENT RECEIVED", debug_info)
                # Convert dictionary output to string if necessary
                message_content = (
                    json.dumps(output, indent=2)
                    if isinstance(output, dict)
                    else str(output)
                )
                # Store message using message manager and get the message ID
                stored_message = None
                if self.message_manager:
                    stored_message = await self.message_manager.add_message(
                        AIMessage(content=message_content),
                        token_usage=token_usage
                    )
                
                message = {
                    'type': 'agent_finish',
                    'message': message_content,
                    'timestamp': datetime.now().isoformat(),
                    'token_usage': token_usage,
                    'id': str(stored_message.id) if stored_message else None
                }
                
                # Send message to websocket
                await self._send_message(message)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN AGENT FINISH", str(e)), exc_info=True)

    def on_tool_start_sync(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any) -> None:
        """Synchronous handler for tool start - required by LangChain."""
        self._log_message("TOOL START (SYNC)", {
            'tool': serialized.get('name', 'Unknown Tool'),
            'input': input_str,
            'kwargs': kwargs
        })

    async def on_tool_start(self, serialized: Dict[str, Any], input_str: str, **kwargs: Any):
        """Handle tool start - send tool name and input."""
        try:
            # Skip internal exceptions
            if serialized.get('name') == '_Exception':
                return
                
            # Get token usage and track it
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            tool_name = serialized.get('name', 'Unknown Tool')
            
            # Enhanced debugging: log detailed information about tool calls
            try:
                tool_input = input_str
                if isinstance(tool_input, str):
                    # Try to parse if it's a JSON string
                    try:
                        input_obj = json.loads(tool_input)
                        logger.info(f"TOOL PARAMETERS FOR {tool_name}: {json.dumps(input_obj, indent=2)}")
                    except json.JSONDecodeError:
                        logger.info(f"TOOL INPUT FOR {tool_name} (raw string): {tool_input}")
                else:
                    logger.info(f"TOOL INPUT FOR {tool_name} (non-string): {type(tool_input)}")
            except Exception as e:
                logger.error(f"Error during tool input logging: {str(e)}")
            
            # Store in message history if manager available
            stored_message = None
            if self.message_manager:
                stored_message = await self.message_manager.add_message(
                    SystemMessage(content=f"Tool Start: {tool_name}"),
                    token_usage=token_usage
                )
            
            # Send message to websocket
            message = {
                'type': 'tool_start',
                'content': {
                    'tool': tool_name
                },
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage,
                'id': str(stored_message.id) if stored_message else None
            }
            await self.consumer.send_json(message)
                
        except Exception as e:
            logger.error(create_box("ERROR IN TOOL START", str(e)), exc_info=True)
            await self.on_tool_error(str(e), **kwargs)

    async def on_tool_end(self, output: str, **kwargs: Any) -> None:
        """Handle tool completion."""
        try:
            # Get token usage from kwargs (current operation)
            token_usage = kwargs.get('token_usage', {})
            
            # Track tokens if we have a token manager
            if self.token_manager:
                # Track the token usage from this operation
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
                
                # Always ensure we have a valid token_usage to report
                # If the kwargs didn't include token usage, get the current usage
                if not token_usage or not token_usage.get('total_tokens'):
                    token_usage = self.token_manager.get_current_usage()

            # Log the output with token usage
            self._log_message("TOOL END EVENT RECEIVED", {
                "output": output,
                "token_usage": token_usage
            })
            
            # Parse output
            if isinstance(output, str):
                try:
                    data = json.loads(output)
                except json.JSONDecodeError:
                    data = {"text": output}
            else:
                data = output

            # Get tool name if available
            tool_name = kwargs.get('name', 'unknown_tool')
            
            # Store in message history if manager available
            stored_message = None
            if self.message_manager:
                # Create a SystemMessage with tool data in additional_kwargs
                tool_message = SystemMessage(
                    content="Tool Result",
                    additional_kwargs={
                        'tool_call': {
                            'name': tool_name,
                            'output': data
                        }
                    }
                )
                stored_message = await self.message_manager.add_message(
                    tool_message,
                    token_usage=token_usage
                )

            # Send message to websocket
            message = {
                'type': 'tool_result',
                'content': data,
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage,
                'id': str(stored_message.id) if stored_message else None,
                'additional_kwargs': {
                    'tool_call': {
                        'name': tool_name,
                        'output': data
                    }
                }
            }
            await self.consumer.send_json(message)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL END", str(e)), exc_info=True)

    async def on_tool_error(self, error: str, **kwargs: Any):
        """Handle tool errors"""
        try:
            # Get token usage from kwargs if available
            token_usage = kwargs.get('token_usage', {})
            if self.token_manager:
                self.token_manager.track_token_usage(
                    token_usage.get('prompt_tokens', 0),
                    token_usage.get('completion_tokens', 0)
                )
            
            error_info = {
                'error': error,
                'token_usage': token_usage
            }
            self._log_message("TOOL ERROR EVENT RECEIVED", error_info)
            
            # Get tool name if available
            tool_name = kwargs.get('name', 'unknown_tool')
            
            # Store error in message history if manager available
            stored_message = None
            if self.message_manager:
                # Create a SystemMessage with tool error data in additional_kwargs
                error_message = SystemMessage(
                    content=f"Tool Error: {error}",
                    additional_kwargs={
                        'tool_call': {
                            'name': tool_name,
                            'output': {'error': error}
                        }
                    }
                )
                stored_message = await self.message_manager.add_message(
                    error_message,
                    token_usage=token_usage
                )
            
            # Send error message to websocket
            message = {
                'type': 'tool_result',
                'content': {'error': error},
                'timestamp': datetime.now().isoformat(),
                'token_usage': token_usage,
                'id': str(stored_message.id) if stored_message else None,
                'additional_kwargs': {
                    'tool_call': {
                        'name': tool_name,
                        'output': {'error': error}
                    }
                }
            }
            await self.consumer.send_json(message)
                
        except Exception as e:
            self.logger.error(create_box("ERROR IN TOOL ERROR HANDLER", str(e)), exc_info=True)

    def _handle_tool_end(self, data):
        try:
            logger.debug("Processing tool end event")
            output = data.get('output')
            
            if not output:
                logger.error("Tool end event received with no output")
                return {"output": "No output received", "token_usage": {}}
            
            # Validate output structure
            if isinstance(output, dict):
                # Log successful processing with truncated preview
                output_preview = str(output)[:250] + "..." if len(str(output)) > 250 else str(output)
                logger.debug(f"Successfully processed tool output: {type(output)}, preview: {output_preview}")
                return data
            elif isinstance(output, str):
                # Handle string output with truncation
                output_preview = output[:250] + "..." if len(output) > 250 else output
                logger.debug(f"Received string output from tool: {output_preview}")
                return data
            else:
                logger.error(f"Unexpected output type: {type(output)}")
                return {"output": f"Unexpected output type: {type(output)}", "token_usage": {}}
            
        except Exception as e:
            logger.error(f"Error processing tool end event: {str(e)}", exc_info=True)
            return {"output": "Error processing tool output", "token_usage": {}}

================
File: apps/agents/websockets/services/base_chat_service.py
================
import logging
from typing import Dict, Optional, List, Any
import asyncio
from django.utils import timezone
from django.core.cache import cache
from django.conf import settings
from django.db import models
from functools import partial
from channels.db import database_sync_to_async

from langchain_core.messages import (
    BaseMessage,
    SystemMessage,
    AIMessage,
    HumanMessage
)
from langchain.memory import ConversationSummaryBufferMemory
from pydantic import Field

from apps.common.utils import create_box, get_llm
from apps.agents.chat.managers.token_manager import TokenManager
from apps.agents.chat.managers.message_manager import MessageManager

logger = logging.getLogger(__name__)

class ChatServiceError(Exception):
    """Base exception for chat service errors"""
    pass

class ToolExecutionError(ChatServiceError):
    """Raised when a tool execution fails"""
    pass

class TokenLimitError(ChatServiceError):
    """Raised when token limit is exceeded"""
    pass

class CustomConversationSummaryBufferMemory(ConversationSummaryBufferMemory):
    """
    A version of ConversationSummaryBufferMemory that works with any LLM, including Gemini.
    
    This class overrides the token counting method to use our TokenManager instead of
    relying on the LLM's built-in token counting, which may not be implemented for all models.
    """
    
    token_manager: Optional[TokenManager] = Field(default=None, exclude=True)
    
    def get_num_tokens_from_messages(self, messages: List[BaseMessage]) -> int:
        """Calculate number of tokens used by list of messages."""
        if not self.token_manager:
            # Fall back to a simple approximation if token_manager is not available
            buffer_string = "\n".join([f"{m.type}: {m.content}" for m in messages])
            # Approximation: ~4 chars per token as a rough estimate
            return len(buffer_string) // 4
            
        # Use our token manager's count_tokens method for each message
        total_tokens = 0
        for message in messages:
            # Count tokens in the message content
            content_tokens = self.token_manager.count_tokens(message.content)
            # Add a small overhead for message type and formatting
            total_tokens += content_tokens + 4  # 4 tokens overhead per message
            
        return total_tokens
    
    async def aprune(self) -> None:
        """Prune the memory if it exceeds max token limit, using our custom token counting.
        
        This method completely overrides the base class method to avoid calling
        self.llm.get_num_tokens_from_messages() which fails with non-OpenAI models.
        """
        buffer = self.chat_memory.messages
        if not buffer:
            return None
        
        # Use our own get_num_tokens_from_messages method
        curr_buffer_length = self.get_num_tokens_from_messages(buffer)
        
        # Check if we need to prune
        if curr_buffer_length > self.max_token_limit:
            # Number of messages to keep before summarization
            num_messages_to_keep = max(2, len(buffer) // 2)
            
            # Messages to summarize (oldest messages)
            messages_to_summarize = buffer[:-num_messages_to_keep]
            
            # Messages to keep (most recent messages)
            messages_to_keep = buffer[-num_messages_to_keep:]
            
            if not messages_to_summarize:
                # Nothing to summarize
                return None
            
            # Create a summary of older messages
            new_summary = await self._resample_summary(
                messages_to_summarize, 
                self.moving_summary_buffer
            )
            
            # Update the summary buffer
            self.moving_summary_buffer = new_summary
            
            # Update the chat memory with the summary and recent messages
            self.chat_memory.messages = [
                SystemMessage(content=new_summary)
            ] + messages_to_keep

class BaseChatService:
    """Base class for chat services with common functionality for agent and crew interactions"""
    
    def __init__(self, model_name, session_id=None, conversation_id=None):
        self.model_name = model_name
        self.session_id = session_id
        self.conversation_id = conversation_id or f"conv_{self.session_id}"
        self.llm = None
        self.processing = False
        self.processing_lock = asyncio.Lock()
        self.callback_handler = None
        
        # Initialize managers
        self.token_manager = TokenManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id,
            model_name=model_name
        )
        
        self.message_manager = MessageManager(
            conversation_id=self.conversation_id,
            session_id=self.session_id
        )
        
        self.message_history = self.message_manager
    
    def _create_memory(self) -> CustomConversationSummaryBufferMemory:
        """Create memory with summarization for token efficiency using standard LangChain patterns"""
        try:
            # Get the summarizer LLM using the utility function
            summarizer = get_llm(settings.SUMMARIZER)[0]  # Get just the LLM instance
            
            memory = CustomConversationSummaryBufferMemory(
                memory_key="chat_history",
                return_messages=True,
                output_key="output",
                input_key="input",
                llm=summarizer,  # Use just the LLM instance
                max_token_limit=self.token_manager.max_token_limit // 2,
                token_manager=self.token_manager
            )
            
            # Pre-load existing messages from our message store into the memory
            messages = self.message_manager.get_messages_sync()
            for message in messages:
                if isinstance(message, HumanMessage):
                    memory.chat_memory.add_user_message(message.content)
                elif isinstance(message, AIMessage):
                    memory.chat_memory.add_ai_message(message.content)
            
            return memory
        except Exception as e:
            logger.error(f"Error creating memory: {e}", exc_info=True)
            raise
    
    @database_sync_to_async
    def _create_or_get_conversation(self, **kwargs) -> Any:
        """
        Create or get a conversation record.
        This method should be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement _create_or_get_conversation")
    
    async def _count_previous_messages(self) -> int:
        """Count how many messages exist in this conversation before the current turn."""
        try:
            from apps.agents.models import ChatMessage, Conversation
            from channels.db import database_sync_to_async
            
            @database_sync_to_async
            def count_messages():
                if not self.conversation_id:
                    return 0
                try:
                    # Get conversation by its ID
                    conversation = Conversation.objects.filter(id=self.conversation_id).first()
                    if not conversation:
                        return 0
                    return ChatMessage.objects.filter(conversation=conversation).count()
                except Exception as inner_e:
                    logger.error(f"Error finding conversation: {inner_e}")
                    return 0
            
            return await count_messages()
        except Exception as e:
            logger.error(f"Error counting messages: {e}")
            return 0
    
    async def _handle_error(self, error_msg: str, exception: Exception, unexpected: bool = False) -> None:
        """Handle errors consistently"""
        try:
            # Log the error
            logger.error(f"Error in chat service: {error_msg}", exc_info=True)
            
            # Store error message in message history
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=f"Error: {error_msg}"),
                    token_usage=self.token_manager.get_current_usage()
                )
            
            # Send error through callback handler
            if self.callback_handler and hasattr(self.callback_handler, 'on_llm_error'):
                if asyncio.iscoroutinefunction(self.callback_handler.on_llm_error):
                    await self.callback_handler.on_llm_error(error_msg, run_id=None)
                else:
                    self.callback_handler.on_llm_error(error_msg, run_id=None)
                
            if unexpected:
                raise ChatServiceError(str(exception))
            else:
                raise exception
                
        except Exception as e:
            logger.error(f"Error in error handler: {str(e)}", exc_info=True)
            raise ChatServiceError(str(e))
    
    async def get_conversation_token_usage(self) -> Dict:
        """Get total token usage for the conversation"""
        return await self.token_manager.get_conversation_token_usage()

    async def track_tool_token_usage(self, token_usage: Dict, tool_name: str) -> None:
        """Track token usage for tool execution"""
        await self.token_manager.store_token_usage(
            message_id=f"tool_{tool_name}_{timezone.now().timestamp()}",
            token_usage={
                **token_usage,
                'metadata': {'tool_name': tool_name, 'type': 'tool_execution'}
            }
        )
    
    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing"""
        try:
            await self.message_manager.handle_edit(message_id)
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise ChatServiceError("Failed to handle message edit")
    
    async def initialize(self) -> Any:
        """
        Initialize the chat service.
        This method should be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement initialize")
    
    async def process_message(self, message: str, is_edit: bool = False) -> None:
        """
        Process a message.
        This method should be implemented by subclasses.
        """
        raise NotImplementedError("Subclasses must implement process_message")

================
File: apps/agents/websockets/services/chat_service.py
================
from langchain.agents import AgentExecutor, create_structured_chat_agent
from langchain.memory import ConversationSummaryBufferMemory
from langchain_core.messages import (
    BaseMessage,
    SystemMessage,
    AIMessage,
    HumanMessage
)
from channels.db import database_sync_to_async
from apps.common.utils import create_box
import logging
from django.utils import timezone
from apps.common.utils import get_llm
from django.core.cache import cache
from typing import Optional, List, Any, Dict
import asyncio
from apps.seo_manager.models import Client
from django.db import models
from pydantic import ValidationError, Field
from langchain_core.agents import AgentFinish
import re
import json
from django.conf import settings
from functools import partial

# Import our new managers
from apps.agents.chat.managers.token_manager import TokenManager
from apps.agents.chat.managers.tool_manager import ToolManager
from apps.agents.chat.managers.prompt_manager import PromptManager
from apps.agents.chat.managers.message_manager import MessageManager
from apps.agents.websockets.handlers.callback_handler import WebSocketCallbackHandler

# Import the base class
from apps.agents.websockets.services.base_chat_service import (
    BaseChatService,
    ChatServiceError,
    ToolExecutionError, 
    TokenLimitError,
    CustomConversationSummaryBufferMemory
)

logger = logging.getLogger(__name__)

class AgentChatService(BaseChatService):
    def __init__(self, agent, model_name, client_data, callback_handler, session_id=None):
        self.agent = agent
        self.client_data = client_data
        
        # Create session ID if not provided
        if not session_id:
            session_id = f"{agent.id}_{client_data['client_id'] if client_data else 'no_client'}"
        
        # Initialize base class
        super().__init__(
            model_name=model_name,
            session_id=session_id
        )
        
        self.callback_handler = callback_handler
        self.agent_executor = None
        self.tool_cache = {}  # Cache for tool results
        
        # Initialize specialized managers
        self.tool_manager = ToolManager()
        self.prompt_manager = PromptManager()
        
        # Update callback handler with managers
        if isinstance(self.callback_handler, WebSocketCallbackHandler):
            self.callback_handler.message_manager = self.message_manager
            self.callback_handler.token_manager = self.token_manager
            
    async def initialize(self) -> Optional[AgentExecutor]:
        """Initialize the chat service with LLM and agent"""
        try:
            # Get client if needed for conversation, but preserve original client_data
            client = None
            if self.client_data and self.client_data.get('client_id'):
                try:
                    client = await database_sync_to_async(Client.objects.get)(id=self.client_data['client_id'])
                except Client.DoesNotExist:
                    logger.error(f"Client not found with ID: {self.client_data['client_id']}")
                    raise ValueError(f"Client not found with ID: {self.client_data['client_id']}")

            # Create or get conversation - pass the client object directly, not in a dict
            conversation = await self._create_or_get_conversation(client=client)
            
            # Update managers with conversation ID
            self.conversation_id = str(conversation.id)
            self.token_manager.conversation_id = self.conversation_id
            self.message_manager.conversation_id = self.conversation_id

            # Get LLM with token tracking
            self.llm, token_callback = get_llm(
                model_name=self.model_name,
                temperature=0.7,
            )
            
            # Set up token tracking
            self.llm.callbacks = [token_callback]
            logger.debug(f"Setting up token tracking with callback: {token_callback}")
            self.token_manager.set_token_callback(token_callback)

            # Initialize memory with proper message handling
            # Need to use sync_to_async here since _create_memory makes sync DB calls
            create_memory_async = database_sync_to_async(partial(self._create_memory))
            memory = await create_memory_async()
            
            # Get chat history for the agent executor
            chat_history = await self.message_manager.get_messages()

            # Load tools using tool manager
            tools = await self.tool_manager.load_tools(self.agent)
            
            # Create the agent-specific system prompt with client context using prompt manager
            system_prompt = self.prompt_manager.create_agent_prompt(self.agent, self.client_data)
            
            # Create prompt using prompt manager - pass raw data
            prompt = self.prompt_manager.create_chat_prompt(
                system_prompt=system_prompt,
                tools=tools,
                chat_history=chat_history
            )

            # Create the agent
            agent = create_structured_chat_agent(
                llm=self.llm,
                tools=tools,
                prompt=prompt
            )

            # Create agent executor with memory
            self.agent_executor = AgentExecutor.from_agent_and_tools(
                agent=agent,
                tools=tools,
                memory=memory,
                verbose=True,
                max_iterations=25,
                handle_parsing_errors=True,
                return_intermediate_steps=True,
                callbacks=[self.callback_handler, token_callback]
            )
            logger.debug(f"Created agent executor with callbacks: {[self.callback_handler, token_callback]}")

            # Reset session token totals
            await self.token_manager._reset_session_token_totals()

            return self.agent_executor

        except Exception as e:
            logger.error(f"Error initializing chat service: {str(e)}", exc_info=True)
            raise
            
    @database_sync_to_async
    def _create_or_get_conversation(self, client=None) -> Any:
        """Create or get a conversation record."""
        try:
            from apps.agents.models import Conversation
            
            # Try to get existing conversation
            conversation = Conversation.objects.filter(
                session_id=self.session_id
            ).first()
            
            if not conversation:
                # Create new conversation
                conversation = Conversation.objects.create(
                    session_id=self.session_id,
                    agent_id=self.agent.id,
                    client=client,
                    user_id=self.client_data.get('user_id') if self.client_data else None
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error creating/getting conversation: {str(e)}", exc_info=True)
            raise

    async def process_message(self, message: str, is_edit: bool = False) -> None:
        async with self.processing_lock:
            try:
                # Reset token tracking
                self.token_manager.reset_tracking()
                logger.debug(create_box("Reset token tracking", ""))

                # Get chat history
                chat_history = await self.message_manager.get_messages()

                # Ensure chat history is a list of BaseMessage objects
                if not all(isinstance(msg, BaseMessage) for msg in chat_history):
                    logger.warning("Chat history contains non-BaseMessage objects")
                    chat_history = []

                logger.debug(create_box("Invoking agent with callbacks", f"{[self.callback_handler, self.llm.callbacks[0]]}"))
                # Get agent response
                response = await self.agent_executor.ainvoke(
                    {
                        "input": message,
                        "chat_history": chat_history
                    },
                    {"callbacks": [self.callback_handler, self.llm.callbacks[0]]}
                )
                
                # Log response safely by extracting output string
                response_str = response.get('output', str(response))
                if isinstance(response_str, str):
                    logger.debug(create_box("Agent response received", f"{response_str[-250:] if len(response_str) > 250 else response_str}"))
                else:
                    logger.debug(create_box("Agent response received", str(response)))
                    
                # Save the agent's response
                if isinstance(response, dict) and 'output' in response:
                    await self._handle_response(response['output'])
                    
                    # Only save the agent's response - user message is already saved by the consumer
                    # Check if this exact response content already exists in the database
                    # to avoid duplication during reconnections
                    existing_messages = await self.message_manager.get_messages()
                    duplicate_found = False
                    for msg in existing_messages:
                        if isinstance(msg, AIMessage) and msg.content == response['output']:
                            logger.debug(f"Skipping duplicate agent message: {response['output'][:50]}...")
                            duplicate_found = True
                            break
                    
                    if not duplicate_found:
                        await self.message_manager.add_message(AIMessage(content=response['output']))

            except Exception as e:
                logger.error(f"Error in process_message: {str(e)}", exc_info=True)
                await self._handle_error(str(e), e, unexpected=True)

    async def _handle_response(self, response: str) -> None:
        """Handle successful response"""
        try:
            # Get current token usage for this turn (this includes all tools + agent response)
            turn_token_usage = self.token_manager.get_current_usage()
                
            # For a brand new conversation, don't try to get previous conversation tokens
            # This fixes the bug where it shows 58k tokens for a first turn
            conversation_token_usage = {'total_tokens': 0, 'prompt_tokens': 0, 'completion_tokens': 0}
            
            # Check if this is actually a continuing conversation with previous turns
            message_count = await self._count_previous_messages()
            if message_count > 0:
                try:
                    # Only get previous conversation tokens if we have prior messages
                    conversation_token_usage = await self.token_manager.get_conversation_token_usage()
                    logger.debug(f"Found {message_count} previous messages in this conversation")
                except Exception as e:
                    logger.error(f"Error getting conversation token usage: {str(e)}")
            else:
                logger.debug("This is a new conversation with no previous turns")
            
            # Clear logging with just the essential information
            logger.debug(create_box("THIS TURN'S TOKENS", f"{turn_token_usage.get('total_tokens', 0)} tokens"))
            if message_count > 0:
                logger.debug(create_box("PREVIOUS TURNS' TOKENS", f"{conversation_token_usage.get('total_tokens', 0)} tokens"))
            
            # Send through callback handler for WebSocket communication
            await self.callback_handler.on_agent_finish(
                AgentFinish(
                    return_values={'output': response},
                    log='',
                ),
                token_usage=turn_token_usage  # Just pass the current turn usage
            )
        except Exception as e:
            logger.error(f"Error handling response: {str(e)}", exc_info=True)
            await self._handle_error("Failed to handle response", e)

    async def _count_previous_messages(self) -> int:
        """Count how many messages exist in this conversation before the current turn."""
        try:
            from apps.agents.models import ChatMessage, Conversation
            from channels.db import database_sync_to_async
            
            @database_sync_to_async
            def count_messages():
                if not self.conversation_id:
                    return 0
                try:
                    # Get conversation by its ID
                    conversation = Conversation.objects.filter(id=self.conversation_id).first()
                    if not conversation:
                        return 0
                    return ChatMessage.objects.filter(conversation=conversation).count()
                except Exception as inner_e:
                    logger.error(f"Error finding conversation: {inner_e}")
                    return 0
            
            return await count_messages()
        except Exception as e:
            logger.error(f"Error counting messages: {e}")
            return 0

    async def _handle_error(self, error_msg: str, exception: Exception, unexpected: bool = False) -> None:
        """Handle errors consistently"""
        try:
            # Log the error
            logger.error(f"Error in chat service: {error_msg}", exc_info=True)
            
            # Store error message in message history
            if self.message_manager:
                await self.message_manager.add_message(
                    SystemMessage(content=f"Error: {error_msg}"),
                    token_usage=self.token_manager.get_current_usage()
                )
            
            # Send error through callback handler
            if self.callback_handler and hasattr(self.callback_handler, 'on_llm_error'):
                if asyncio.iscoroutinefunction(self.callback_handler.on_llm_error):
                    await self.callback_handler.on_llm_error(error_msg, run_id=None)
                else:
                    self.callback_handler.on_llm_error(error_msg, run_id=None)
                
            if unexpected:
                raise ChatServiceError(str(exception))
            else:
                raise exception
                
        except Exception as e:
            logger.error(f"Error in error handler: {str(e)}", exc_info=True)
            raise ChatServiceError(str(e))

    async def handle_edit(self, message_id: str) -> None:
        """Handle message editing"""
        try:
            await self.message_manager.handle_edit(message_id)
        except Exception as e:
            logger.error(f"Error handling edit: {str(e)}")
            raise ChatServiceError("Failed to handle message edit")

    async def get_conversation_token_usage(self) -> Dict:
        """Get total token usage for the conversation"""
        return await self.token_manager.get_conversation_token_usage()

    async def track_tool_token_usage(self, token_usage: Dict, tool_name: str) -> None:
        """Track token usage for tool execution"""
        await self.token_manager.store_token_usage(
            message_id=f"tool_{tool_name}_{timezone.now().timestamp()}",
            token_usage={
                **token_usage,
                'metadata': {'tool_name': tool_name, 'type': 'tool_execution'}
            }
        )

================
File: apps/agents/websockets/services/crew_chat_service.py
================
import uuid
from typing import Optional, Any
from django.contrib.auth import get_user_model
from django.conf import settings
from apps.agents.models import (
    Conversation,
    CrewChatSession,
    ChatMessage,
    CrewExecution
)
from apps.agents.chat.managers.message_manager import MessageManager
from apps.agents.chat.managers.crew_manager import CrewManager
from apps.agents.chat.managers.token_manager import TokenManager
from apps.agents.chat.history import DjangoCacheMessageHistory
from langchain_core.messages import HumanMessage, AIMessage, BaseMessage
from langchain.memory import ConversationSummaryBufferMemory
from apps.common.utils import get_llm
import logging
import json
import re  # Add import for regex
from channels.db import database_sync_to_async
from functools import partial

# Import the base class
from apps.agents.websockets.services.base_chat_service import (
    BaseChatService,
    ChatServiceError,
    CustomConversationSummaryBufferMemory
)

User = get_user_model()
logger = logging.getLogger(__name__)

class CrewChatService(BaseChatService):
    """Service for handling crew chat operations"""
    def __init__(self, user, conversation=None, model_name="gemini/gemini-2.0-flash"):
        self.user = user
        self.conversation = conversation
        
        # Initialize base class with any available session/conversation info
        session_id = conversation.session_id if conversation else None
        conversation_id = conversation.id if conversation else None
        
        super().__init__(
            model_name=model_name,
            session_id=session_id,
            conversation_id=conversation_id
        )
        
        self.websocket_handler = None
        self.crew_manager = CrewManager()
        self.crew_execution = None
        
        # Initialize message history if conversation exists
        if conversation:
            self.message_history = DjangoCacheMessageHistory(
                session_id=conversation.session_id,
                conversation_id=conversation.id
            )
        
        # Initialize memory
        self.memory = None
    
    async def initialize(self, crew_execution):
        """Initialize a new crew chat session"""
        try:
            self.crew_execution = crew_execution
            
            if not self.conversation:
                self.conversation = await self._create_or_get_conversation(
                    user=self.user,
                    crew_execution=crew_execution
                )
            
            # Get or create chat session
            session = await CrewChatSession.objects.filter(
                conversation=self.conversation,
                crew_execution=crew_execution
            ).afirst()
            
            if not session:
                session = await CrewChatSession.objects.acreate(
                    conversation=self.conversation,
                    crew_execution=crew_execution,
                    status='active'
                )
            
            # Initialize message manager with conversation
            self.message_manager.conversation_id = self.conversation.id
            self.message_manager.session_id = self.conversation.session_id
            
            # Update token manager with conversation
            self.token_manager.conversation_id = self.conversation.id
            self.token_manager.session_id = self.conversation.session_id
            
            # Initialize message history if not already set
            if not self.message_history:
                self.message_history = DjangoCacheMessageHistory(
                    session_id=self.conversation.session_id,
                    conversation_id=self.conversation.id
                )
            
            # Initialize crew manager with execution
            await self.crew_manager.initialize(crew_execution)
            
            # Initialize memory using base class method
            create_memory_async = database_sync_to_async(partial(self._create_memory))
            self.memory = await create_memory_async()
            
            logger.info(f"Initialized crew chat for execution {crew_execution.id}")
            return self.conversation
            
        except Exception as e:
            logger.error(f"Error initializing crew chat: {str(e)}")
            raise
    
    @database_sync_to_async
    def _create_or_get_conversation(self, user=None, crew_execution=None) -> Any:
        """Create or get a conversation record."""
        try:
            if not self.session_id:
                session_id = uuid.uuid4()
            else:
                session_id = self.session_id
                
            # Try to get existing conversation first
            conversation = Conversation.objects.filter(
                session_id=session_id
            ).first()
            
            if not conversation:
                # Create new conversation
                conversation = Conversation.objects.create(
                    session_id=session_id,
                    user=user,
                    participant_type='crew',
                    crew_execution=crew_execution,
                    title="..."  # Add default title to match agent chat behavior
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error creating/getting conversation: {str(e)}")
            raise
    
    async def process_message(self, message: str, is_edit: bool = False) -> None:
        """Handle incoming user message for crew chat"""
        async with self.processing_lock:
            try:
                # Reset token tracking
                self.token_manager.reset_tracking()
                logger.debug(f"Processing user message: {message[:100]}...")
                
                # Get the crew chat session
                session = await CrewChatSession.objects.filter(conversation=self.conversation).afirst()
                if not session:
                    logger.error("No crew chat session found")
                    await self._handle_error("No active crew chat session", Exception("No session found"))
                    return
                
                # Add message to crew context if needed
                if self.crew_manager:
                    await self.crew_manager.add_message_to_context(message)
                
                # Store message in memory if available (for LLM context)
                if self.memory:
                    # Convert to HumanMessage for memory storage
                    human_message = HumanMessage(content=message)
                    
                    # Check if this message already exists in memory to avoid duplication
                    duplicate_found = False
                    if hasattr(self.memory, 'chat_memory') and self.memory.chat_memory:
                        for msg in self.memory.chat_memory.messages:
                            if isinstance(msg, HumanMessage) and msg.content == message:
                                logger.debug(f"Skipping duplicate user message: {message[:50]}...")
                                duplicate_found = True
                                break
                    
                    if not duplicate_found:
                        self.memory.chat_memory.add_message(human_message)
                
                # IMPORTANT: Don't add message to history here - the consumer already did this
                # The following code is commented out to prevent duplicate messages
                # but kept for reference
                """
                existing_messages = await self.message_manager.get_messages()
                duplicate_found = False
                for msg in existing_messages:
                    if isinstance(msg, HumanMessage) and msg.content == message:
                        logger.debug(f"Message already exists in history: {message[:50]}...")
                        duplicate_found = True
                        break
                
                if not duplicate_found:
                    await self.message_manager.add_message(HumanMessage(content=message))
                """
            
            except Exception as e:
                logger.error(f"Error processing message: {str(e)}")
                await self._handle_error(f"Failed to process message: {str(e)}", e)
    
    async def send_crew_message(self, content: str, task_id: Optional[int] = None):
        """Send message from crew to chat"""
        try:
            if not content:
                logger.warning("Empty content in crew message, skipping")
                return

            logger.debug(f"Sending crew message: {content[:100]}...")
            
            # Store in memory if available
            if self.memory:
                # Convert to AIMessage for memory storage
                ai_message = AIMessage(content=content)
                
                # Check if this message already exists in memory to avoid duplication
                duplicate_found = False
                if hasattr(self.memory, 'chat_memory') and self.memory.chat_memory:
                    for msg in self.memory.chat_memory.messages:
                        if isinstance(msg, AIMessage) and msg.content == content:
                            logger.debug(f"Skipping duplicate AI message: {content[:50]}...")
                            duplicate_found = True
                            break
                
                if not duplicate_found:
                    self.memory.chat_memory.add_message(ai_message)
                
            # Save message in history first
            if not self.message_history:
                logger.error("Message history not initialized")
                return
                
            stored_message = await self.message_history.add_message(
                AIMessage(content=content)
            )
            
            # Save in database
            message = await ChatMessage.objects.acreate(
                conversation=self.conversation,
                content=content,
                user=self.user,
                is_agent=True,
                task_id=task_id
            )
            
            if self.websocket_handler:
                message_data = {
                    'task_id': task_id,
                    'timestamp': message.timestamp.isoformat(),
                    'id': str(stored_message.id) if stored_message else str(message.id)
                }

                # Format message based on content type
                if content.startswith(('Using tool:', 'Tool Start:')):
                    # Extract tool name and input
                    tool_match = re.search(r'^(?:Using tool:|Tool Start:)\s*(.*?)(?:\s*-\s*|\n)(.*)$', content)
                    if tool_match:
                        tool_name = tool_match.group(1).strip()
                        tool_input = tool_match.group(2).strip()
                        message_data.update({
                            'type': 'tool_start',
                            'content': {
                                'tool': tool_name,
                                'input': tool_input
                            }
                        })
                    else:
                        # Fallback if parsing fails
                        message_data.update({
                            'type': 'crew_message',
                            'message': content
                        })

                elif content.startswith(('Tool Result:', 'Tool result:')):
                    try:
                        # Extract and parse JSON result
                        result_content = re.sub(r'^(?:Tool Result:|Tool result:)', '', content, 1).strip()
                        json_data = json.loads(result_content)
                        message_data.update({
                            'type': 'tool_result',
                            'content': json_data
                        })
                    except json.JSONDecodeError:
                        # Fallback if JSON parsing fails
                        message_data.update({
                            'type': 'tool_result',
                            'content': {
                                'type': 'text',
                                'data': result_content
                            }
                        })

                elif content.startswith('Tool Error:'):
                    error_message = content.replace('Tool Error:', '', 1).strip()
                    message_data.update({
                        'type': 'error',
                        'content': {
                            'error': error_message
                        }
                    })

                else:
                    # Regular crew message
                    message_data.update({
                        'type': 'crew_message',
                        'message': content
                    })

                # Send formatted message
                await self.websocket_handler.send_json(message_data)
            
            logger.debug(f"Crew message saved successfully with ID: {message.id}")
            return message
            
        except Exception as e:
            logger.error(f"Error sending crew message: {str(e)}")
            raise

================
File: apps/agents/websockets/__init__.py
================
from .chat_consumer import ChatConsumer
from .base import BaseWebSocketConsumer

__all__ = ['ChatConsumer', 'BaseWebSocketConsumer']

================
File: apps/agents/websockets/base.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
import json
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class BaseWebSocketConsumer(AsyncWebsocketConsumer):
    async def send_json(self, data):
        """Send JSON data as text"""
        try:
            await self.send(text_data=json.dumps(data))
        except Exception as e:
            logger.error(f"Error sending JSON: {str(e)}")
            await self.send(text_data=json.dumps({
                'error': True,
                'message': 'Error sending message'
            }))

    async def handle_binary_message(self, message):
        """Handle binary message data"""
        try:
            if isinstance(message, bytes):
                message = message.decode('utf-8')
            return json.loads(message)
        except Exception as e:
            logger.error(f"Error handling binary message: {str(e)}")
            return None

================
File: apps/agents/websockets/chat_consumer.py
================
from .base import BaseWebSocketConsumer
from .handlers.agent_handler import AgentHandler
from .services.crew_chat_service import CrewChatService
from ..tools.manager import AgentToolManager
from ..clients.manager import ClientDataManager
from ..chat.history import DjangoCacheMessageHistory
from ..models import Conversation, CrewExecution, ChatMessage
from django.core.cache import cache
import logging
import uuid
import json
from datetime import datetime
from urllib.parse import parse_qs
from langchain_core.chat_history import BaseChatMessageHistory
from langchain_core.messages import (
    BaseMessage, 
    HumanMessage, 
    AIMessage,
    messages_from_dict, 
    messages_to_dict
)
from channels.db import database_sync_to_async
from apps.organizations.utils import get_current_organization
import asyncio
from asgiref.sync import sync_to_async
from django.utils import timezone

logger = logging.getLogger(__name__)

class ChatConsumer(BaseWebSocketConsumer):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.tool_manager = AgentToolManager()
        self.client_manager = ClientDataManager()
        self.session_id = None
        self.group_name = None
        self.agent_handler = AgentHandler(self)
        self.is_connected = False
        self.message_history = None
        self.crew_chat_service = None  # Will be initialized if this is a crew chat

    @database_sync_to_async
    def get_crew_execution(self, conversation):
        """Safely get crew execution in async context"""
        try:
            return conversation.crew_execution
        except Exception as e:
            logger.error(f"Error getting crew execution: {str(e)}")
            return None

    @database_sync_to_async
    def get_crew(self, crew_execution):
        """Safely get crew in sync context"""
        try:
            return crew_execution.crew
        except Exception as e:
            logger.error(f"Error getting crew: {str(e)}")
            return None

    async def send_json(self, content):
        """Override to add logging"""
        #logger.debug(f"Sending message: {content}")
        await super().send_json(content)

    async def connect(self):
        if self.is_connected:
            return

        try:
            # Get session ID from query parameters
            query_string = self.scope.get('query_string', b'').decode()
            params = dict(param.split('=') for param in query_string.split('&') if param)
            self.session_id = params.get('session')
            
            if not self.session_id:
                logger.error("No session ID provided")
                await self.close()
                return
                
            self.user = self.scope.get("user")
            if not self.user or not self.user.is_authenticated:
                logger.error("User not authenticated")
                await self.close()
                return
        
            logger.debug(f"Connecting websocket for user {self.user.id} with session {self.session_id}")
            
            # Get or create conversation first
            conversation = await self.get_or_create_conversation()
            if not conversation:
                logger.error("Failed to get/create conversation")
                await self.close()
                return
            
            logger.debug(f"Found conversation {conversation.id} with title: {conversation.title}")
            logger.debug(f"Conversation participant type: {conversation.participant_type}")
            
            # Log that organization context is set (this helps debug middleware functionality)
            current_org = get_current_organization()
            if current_org:
                logger.info(f"Organization context in WebSocket: {current_org.name} (ID: {current_org.id})")
            else:
                logger.warning("No organization context set in WebSocket connection")
                
            self.group_name = f"chat_{self.session_id}"

            # Initialize appropriate service based on participant type
            if conversation.participant_type == 'crew':
                self.crew_chat_service = CrewChatService(self.user, conversation)
                self.crew_chat_service.websocket_handler = self
                crew_execution = await self.get_crew_execution(conversation)
                if crew_execution:
                    await self.crew_chat_service.initialize(crew_execution)
            
            # Initialize message history (used by both agent and crew chats)
            self.message_history = DjangoCacheMessageHistory(
                session_id=self.session_id,
                agent_id=conversation.agent_id if conversation.participant_type == 'agent' else None,
                conversation_id=conversation.id
            )
            
            await self.channel_layer.group_add(self.group_name, self.channel_name)
            await self.accept()
            self.is_connected = True
            
            # Send historical messages directly
            async for msg in self.get_historical_messages(conversation):
                await self.send_json(msg)
            
            await self.send_json({
                'type': 'system_message',
                'message': 'Connected to chat server',
                'connection_status': 'connected',
                'session_id': self.session_id,
                'participant_type': conversation.participant_type
            })
            
        except Exception as e:
            logger.error(f"Error in connect: {str(e)}", exc_info=True)
            await self.close()
            return

    async def get_historical_messages(self, conversation):
        """Simple async generator for historical messages"""
        try:
            messages = await self.message_history.aget_messages()
            logger.debug(f"Retrieved {len(messages)} historical messages")
            
            for msg in messages:
                # Determine message type based on message class
                message_type = 'agent_message' if isinstance(msg, AIMessage) else 'user_message'
                if conversation.participant_type == 'crew':
                    message_type = 'crew_message' if isinstance(msg, AIMessage) else 'user_message'
                
                # Create a simple dict representing the message
                yield {
                    'type': message_type,
                    'message': msg.content,
                    'timestamp': conversation.updated_at.isoformat(),
                    'id': msg.additional_kwargs.get('id', None),
                    'additional_kwargs': msg.additional_kwargs
                }
                
                # Add a small delay to prevent overwhelming the client
                await asyncio.sleep(0.01)
                
        except Exception as e:
            logger.error(f"Error retrieving historical messages: {str(e)}", exc_info=True)
            # Yield an error message in case of exception
            yield {
                'type': 'error',
                'message': 'Error retrieving message history',
                'timestamp': datetime.now().isoformat()
            }

    async def disconnect(self, close_code):
        """Override to clean up resources"""
        # Clear organization context
        await super().disconnect(close_code)
        
        # Clear group membership
        if self.group_name:
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )
        
        # Set connected flag to false
        self.is_connected = False
        
        logger.debug(f"WebSocket disconnected with code {close_code}")

    async def get_or_create_conversation(self):
        try:
            # Get existing conversation
            conversation = await Conversation.objects.filter(
                session_id=self.session_id,
                user=self.user
            ).afirst()
            
            if not conversation:
                # Create new conversation with placeholder title
                conversation = await Conversation.objects.acreate(
                    session_id=self.session_id,
                    user=self.user,
                    title="...",  # Will be updated with first message
                    participant_type='agent'  # Default to agent chat
                )
            
            return conversation
            
        except Exception as e:
            logger.error(f"Error getting/creating conversation: {str(e)}")
            return None

    @database_sync_to_async
    def set_cache_value(self, key, value):
        """Safely set cache value in async context"""
        cache.set(key, value)

    @database_sync_to_async
    def get_conversation_details(self, conversation):
        """Get conversation details in sync context"""
        details = {
            'participant_type': conversation.participant_type,
            'has_crew_execution': hasattr(conversation, 'crew_execution'),
            'title': conversation.title
        }
        
        # Get crew name if this is a crew chat
        if conversation.participant_type == 'crew' and conversation.crew_execution:
            details['crew_name'] = conversation.crew_execution.crew.name
        
        return details

    async def update_conversation(self, message, agent_id=None, client_id=None):
        """Update conversation details"""
        try:
            conversation = await Conversation.objects.filter(
                session_id=self.session_id
            ).afirst()
            
            if conversation:
                # Get conversation details in sync context
                details = await self.get_conversation_details(conversation)
                
                # Update title if it's still the default and we have a message
                if details['title'] == "..." and message:
                    # Format the message part of the title
                    title_message = message.strip().replace('\n', ' ')[:50]
                    if len(message) > 50:
                        title_message += "..."
                    
                    # Set title to just the message - participant name is shown separately in UI
                    conversation.title = title_message
                
                # Update agent/crew info based on participant type
                if details['participant_type'] == 'agent' and agent_id:
                    conversation.agent_id = agent_id
                
                # Update client if provided
                if client_id:
                    conversation.client_id = client_id
                    
                await conversation.asave()
                
        except Exception as e:
            logger.error(f"Error updating conversation: {str(e)}")
            raise

    async def execution_update(self, event):
        """Handle execution status updates from crew tasks"""
        try:
            status = event.get('status')
            message = event.get('message')
            task_index = event.get('task_index')
            
            # Only send status update - no message content
            await self.send_json({
                'type': 'execution_update',
                'status': status,
                'task_index': task_index,
                'timestamp': datetime.now().isoformat()
            })

            # If there's a message, send it as a crew message
            if message and self.crew_chat_service:
                await self.crew_chat_service.send_crew_message(
                    content=message,
                    task_id=task_index
                )

        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")

    async def crew_message(self, event):
        """Handle crew messages from tasks"""
        try:
            if self.crew_chat_service:
                await self.crew_chat_service.send_crew_message(
                    content=event.get('message'),
                    task_id=event.get('task_id')
                )
        except Exception as e:
            logger.error(f"Error handling crew message: {str(e)}")

    async def receive(self, text_data=None, bytes_data=None):
        try:
            # Handle binary data if present
            if bytes_data:
                data = await self.handle_binary_message(bytes_data)
            else:
                # Handle text data
                if isinstance(text_data, dict):
                    # Already parsed JSON (from websocket_receive)
                    data = text_data
                else:
                    try:
                        data = json.loads(text_data)
                    except (json.JSONDecodeError, TypeError):
                        # If not JSON or None, treat as plain text message
                        data = {
                            'type': 'user_message',
                            'message': text_data or ''
                        }

            logger.debug(f"Received data: {data}")

            # Process keep-alive messages
            if data.get('type') == 'keep_alive':
                return

            # Process message
            await self.process_message(data)

        except Exception as e:
            logger.error(f"❌ Error: {str(e)}", exc_info=True)
            await self.send_json({
                'type': 'error',
                'message': f'Error processing message: {str(e)}',
                'timestamp': datetime.now().isoformat()
            })

    async def process_message(self, data):
        """Primary entry point for all messages"""
        try:
            message_type = data.get('type', 'user_message')
            logger.debug(f"Processing message of type: {message_type} with keys: {', '.join(data.keys())}")
            
            # Handle human input response
            if data.get('context', {}).get('is_human_input'):
                context = data.get('context', {})
                message = data.get('message')
                
                logger.info(f"HUMAN_INPUT_RESPONSE: Received response '{message}' with context {context}")
                
                # Get key components
                execution_id = context.get('execution_id')
                task_index = context.get('task_index')
                
                if not execution_id or task_index is None:
                    logger.error(f"Invalid human input context: {context}")
                    await self.send_json({
                        'type': 'error',
                        'message': 'Invalid human input response context',
                        'timestamp': datetime.now().isoformat()
                    })
                    return
                
                # Store response in cache with additional logging
                input_key = f"execution_{execution_id}_task_{task_index}_input"
                logger.info(f"Storing human input response in cache with key: {input_key}, value: {message}")
                
                # Use Django cache directly for more reliable storage
                cache.set(input_key, message, timeout=3600)  # 1 hour timeout
                
                # Store in Redis channel to notify waiting task
                await sync_to_async(cache.set)(f"{input_key}_ready", "true", timeout=3600)
                
                # Send user message back to show in chat
                await self.send_json({
                    'type': 'user_message',
                    'message': message,
                    'timestamp': datetime.now().isoformat()
                })
                return

            # Handle crew start request
            if data.get('type') == 'start_crew':
                crew_id = data.get('crew_id')
                client_id = data.get('client_id')
                if not crew_id:
                    raise ValueError('Missing crew ID')
                
                # Get client if client_id is provided
                client = None
                if client_id:
                    from apps.seo_manager.models import Client
                    try:
                        client = await database_sync_to_async(Client.objects.get)(id=client_id)
                    except Client.DoesNotExist:
                        logger.warning(f"Client with ID {client_id} not found")
                    except Exception as e:
                        logger.warning(f"Error retrieving client with ID {client_id}: {str(e)}")

                # Get conversation
                conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
                if not conversation:
                    raise ValueError('No active conversation found')

                # Create crew execution
                execution = await CrewExecution.objects.acreate(
                    crew_id=crew_id,
                    status='PENDING',
                    user=self.scope['user'],
                    conversation=conversation,
                    client=client,  # Set the client
                    inputs={
                        'client_id': client_id if client_id else None
                    }
                )
                
                # Update conversation
                conversation.participant_type = 'crew'
                conversation.crew_execution = execution
                await conversation.asave()

                # Initialize crew chat service
                self.crew_chat_service = CrewChatService(self.scope['user'], conversation)
                self.crew_chat_service.websocket_handler = self
                await self.crew_chat_service.initialize(execution)

                # Start the execution
                from ..tasks import execute_crew
                task = execute_crew.delay(execution.id)
                
                # Update execution with task ID
                execution.task_id = task.id
                await execution.asave()

                # Send confirmation
                await self.send_json({
                    'type': 'system_message',
                    'message': 'Starting crew execution...',
                    'timestamp': datetime.now().isoformat()
                })
                return

            # Extract message data
            message = data.get('message', '').strip()
            agent_id = data.get('agent_id')
            model_name = data.get('model')
            client_id = data.get('client_id')
            is_edit = data.get('type') == 'edit'  # Check for edit type
            message_id = data.get('message_id')  # Get message ID for edits

            #logger.debug(f"Processing message: type={data.get('type')}, message_id={message_id}, is_edit={is_edit}")

            if not message and not is_edit:  # Allow empty message for edit
                raise ValueError('Missing required fields')

            # Handle message editing if needed
            if is_edit:
                if not message_id:
                    raise ValueError('Missing message ID for edit')
                logger.debug(f"Handling edit for message {message_id}")
                await self.message_history.handle_edit(message_id)
                return  # Return early for edit messages

            # Get current conversation to check participant type
            conversation = await Conversation.objects.filter(session_id=self.session_id).afirst()
            if not conversation:
                raise ValueError('No active conversation found')

            # Get conversation details in sync context
            details = await self.get_conversation_details(conversation)

            # Initialize crew chat service if needed
            if details['participant_type'] == 'crew' and not self.crew_chat_service:
                self.crew_chat_service = CrewChatService(self.scope['user'], conversation)
                self.crew_chat_service.websocket_handler = self
                self.crew_chat_service.message_history = self.message_history  # Share the same message history

            # Update conversation with agent and client info
            await self.update_conversation(message, agent_id, client_id)

            # Store user message in history and database
            stored_message = await self.message_history.add_message(
                HumanMessage(content=message)
            )

            # Send user message with ID
            await self.send_json({
                'type': 'user_message',
                'message': message,
                'timestamp': datetime.now().isoformat(),
                'id': str(stored_message.id) if stored_message else None
            })
            
            # Handle crew chat messages if this is a crew chat
            if details['participant_type'] == 'crew':
                if not self.crew_chat_service:
                    raise ValueError('Crew chat service not initialized')
                await self.crew_chat_service.process_message(message)
                return

            # Process with agent - responses come via callback_handler
            await self.agent_handler.process_response(
                message, agent_id, model_name, client_id
            )

        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            await self.send_json({
                'type': 'error',
                'message': f'Error processing message: {str(e)}',
                'timestamp': datetime.now().isoformat()
            })

    async def receive_json(self, content):
        """Disabled in favor of receive() to prevent duplicate message processing"""
        pass

    async def human_input_request(self, event):
        """Handle human input request from crew tasks"""
        try:
            # Extract prompt from event - it could be in different fields
            prompt = event.get('human_input_request') or event.get('prompt') or event.get('message', 'Input required')
            context = event.get('context', {})
            task_index = event.get('task_index')
            
            logger.info(f"HUMAN_INPUT_REQUEST: Received request with task_index={task_index}, context={context}")
            
            # Send as a crew message
            await self.send_json({
                'type': 'crew_message',
                'message': str(prompt),  # Ensure it's a string
                'context': {  # Include context for handling the response
                    'is_human_input': True,
                    'execution_id': context.get('execution_id'),
                    'task_index': task_index
                },
                'timestamp': datetime.now().isoformat()
            })
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")

================
File: apps/agents/admin.py
================
from django.contrib import admin
from .models import (
    Crew, CrewExecution, CrewMessage, Agent, Task, Tool, CrewTask, SlackChannelClientMapping,
    ToolRun, AgentToolSettings, ExecutionStage, Conversation, CrewChatSession, ChatMessage,
    TokenUsage, UserSlackIntegration, Flow, FlowCrew, FlowExecution, CrewOutput
)
from .forms import AgentForm, TaskForm, CrewForm

class CrewTaskInline(admin.TabularInline):
    model = CrewTask
    extra = 1

@admin.register(Crew)
class CrewAdmin(admin.ModelAdmin):
    list_display = ('name', 'process', 'verbose')
    filter_horizontal = ('agents',)
    inlines = [CrewTaskInline]
    fieldsets = (
        (None, {
            'fields': ('name', 'agents', 'process', 'verbose', 'manager_llm', 'function_calling_llm', 'config', 'max_rpm', 'language', 'language_file', 'memory', 'cache', 'embedder', 'full_output', 'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks', 'prompt_file', 'planning', 'planning_llm')
        }),
    )

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        form.base_fields['agents'].widget.can_add_related = True
        form.base_fields['agents'].widget.can_change_related = True
        return form

@admin.register(CrewExecution)
class CrewExecutionAdmin(admin.ModelAdmin):
    list_display = ('crew', 'user', 'client', 'status', 'created_at', 'updated_at')
    list_filter = ('status', 'created_at', 'updated_at')
    search_fields = ('crew__name', 'user__username', 'client__name')
    readonly_fields = ('created_at', 'updated_at', 'human_input_request', 'human_input_response', 'error_message')
    fieldsets = (
        (None, {
            'fields': ('crew', 'user', 'client', 'status', 'inputs', 'crew_output')
        }),
        ('Human Input', {
            'fields': ('human_input_request', 'human_input_response')
        }),
        ('Error Information', {
            'fields': ('error_message',)
        }),
        ('Timestamps', {
            'fields': ('created_at', 'updated_at')
        }),
    )

@admin.register(CrewMessage)
class CrewMessageAdmin(admin.ModelAdmin):
    list_display = ('execution', 'timestamp')
    list_filter = ('timestamp',)
    search_fields = ('execution__crew__name', 'content')

@admin.register(Agent)
class AgentAdmin(admin.ModelAdmin):
    form = AgentForm
    list_display = ('name', 'role', 'llm', 'function_calling_llm', 'verbose', 'allow_delegation', 'allow_code_execution')
    list_filter = ('verbose', 'allow_delegation', 'allow_code_execution', 'use_system_prompt', 'respect_context_window')
    search_fields = ('name', 'role', 'goal', 'backstory')
    filter_horizontal = ('tools',)
    fieldsets = (
        (None, {
            'fields': ('name', 'role', 'goal', 'backstory', 'llm', 'tools')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('function_calling_llm', 'max_iter', 'max_rpm', 'max_execution_time', 'verbose', 'allow_delegation', 'step_callback', 'cache', 'system_template', 'prompt_template', 'response_template', 'allow_code_execution', 'max_retry_limit', 'use_system_prompt', 'respect_context_window'),
        }),
    )

@admin.register(Task)
class TaskAdmin(admin.ModelAdmin):
    form = TaskForm
    list_display = ('description', 'agent', 'async_execution', 'human_input', 'output_type')
    list_filter = ('async_execution', 'human_input')
    filter_horizontal = ('tools', 'context')
    search_fields = ('description', 'agent__name', 'expected_output')
    readonly_fields = ('output',)

    def output_type(self, obj):
        if obj.output_json:
            return 'JSON'
        elif obj.output_pydantic:
            return 'Pydantic'
        elif obj.output_file:
            return 'File'
        else:
            return 'Default'
    output_type.short_description = 'Output Type'

    fieldsets = (
        (None, {
            'fields': ('description', 'agent', 'expected_output', 'tools', 'async_execution', 'context')
        }),
        ('Advanced options', {
            'classes': ('collapse',),
            'fields': ('config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls'),
        }),
        ('Output', {
            'fields': ('output',),
        }),
    )

@admin.register(Tool)
class ToolAdmin(admin.ModelAdmin):
    list_display = ('name', 'description')
    search_fields = ('name', 'description', 'function')

@admin.register(SlackChannelClientMapping)
class SlackChannelClientMappingAdmin(admin.ModelAdmin):
    list_display = ('channel_id', 'team_id', 'client', 'created_at')
    search_fields = ('channel_id', 'team_id')
    list_filter = ('team_id', 'created_at')

@admin.register(ToolRun)
class ToolRunAdmin(admin.ModelAdmin):
    list_display = ('tool', 'status', 'created_at', 'updated_at')
    list_filter = ('status', 'created_at', 'is_deleted')
    search_fields = ('tool__name', 'error')
    readonly_fields = ('created_at', 'updated_at')

@admin.register(AgentToolSettings)
class AgentToolSettingsAdmin(admin.ModelAdmin):
    list_display = ('agent', 'tool', 'force_output_as_result')
    list_filter = ('force_output_as_result',)
    search_fields = ('agent__name', 'tool__name')

@admin.register(ExecutionStage)
class ExecutionStageAdmin(admin.ModelAdmin):
    list_display = ('execution', 'stage_type', 'title', 'status', 'created_at')
    list_filter = ('stage_type', 'status', 'created_at')
    search_fields = ('title', 'content', 'execution__crew__name')
    readonly_fields = ('created_at', 'updated_at')

@admin.register(Conversation)
class ConversationAdmin(admin.ModelAdmin):
    list_display = ('session_id', 'user', 'agent', 'client', 'participant_type', 'created_at', 'updated_at')
    list_filter = ('participant_type', 'is_active', 'created_at')
    search_fields = ('session_id', 'user__username', 'agent__name', 'title')
    readonly_fields = ('created_at', 'updated_at')

@admin.register(CrewChatSession)
class CrewChatSessionAdmin(admin.ModelAdmin):
    list_display = ('conversation', 'crew_execution', 'status', 'last_activity')
    list_filter = ('status', 'last_activity')
    search_fields = ('conversation__title', 'crew_execution__crew__name')
    readonly_fields = ('last_activity',)

@admin.register(ChatMessage)
class ChatMessageAdmin(admin.ModelAdmin):
    list_display = ('conversation', 'is_agent', 'timestamp', 'is_deleted')
    list_filter = ('is_agent', 'is_deleted', 'timestamp')
    search_fields = ('content', 'conversation__session_id', 'user__username')
    readonly_fields = ('timestamp',)

@admin.register(TokenUsage)
class TokenUsageAdmin(admin.ModelAdmin):
    list_display = ('conversation', 'model', 'prompt_tokens', 'completion_tokens', 'total_tokens', 'timestamp')
    list_filter = ('model', 'timestamp')
    search_fields = ('conversation__session_id', 'model')
    readonly_fields = ('timestamp',)

@admin.register(UserSlackIntegration)
class UserSlackIntegrationAdmin(admin.ModelAdmin):
    list_display = ('user', 'team_name', 'is_active', 'created_at')
    list_filter = ('is_active', 'created_at')
    search_fields = ('user__username', 'team_name', 'team_id')
    readonly_fields = ('created_at', 'updated_at')

@admin.register(Flow)
class FlowAdmin(admin.ModelAdmin):
    list_display = ('name', 'created_at', 'updated_at')
    search_fields = ('name', 'description')
    readonly_fields = ('created_at', 'updated_at')

class FlowCrewInline(admin.TabularInline):
    model = FlowCrew
    extra = 1

@admin.register(FlowCrew)
class FlowCrewAdmin(admin.ModelAdmin):
    list_display = ('flow', 'crew', 'order')
    list_filter = ('flow', 'crew')
    search_fields = ('flow__name', 'crew__name')

@admin.register(FlowExecution)
class FlowExecutionAdmin(admin.ModelAdmin):
    list_display = ('flow', 'status', 'created_at', 'updated_at')
    list_filter = ('status', 'created_at')
    search_fields = ('flow__name',)
    readonly_fields = ('created_at', 'updated_at')

@admin.register(CrewOutput)
class CrewOutputAdmin(admin.ModelAdmin):
    list_display = ('__str__',)
    search_fields = ('raw',)

================
File: apps/agents/apps.py
================
from django.apps import AppConfig
import os
import logging
import sys
from django.conf import settings

logger = logging.getLogger(__name__)

class AgentsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.agents'
    verbose_name = 'CrewAI Agents'
    
    def ready(self):
        """Initialize the Slack bot only once under Daphne"""
        # Get the current process name
        process_name = sys.argv[0] if sys.argv else ''
        #logger.info(f"AgentsConfig.ready() called with process_name: {process_name}")
        #logger.info(f"RUN_MAIN: {os.environ.get('RUN_MAIN')}")
        #logger.info(f"Already initialized: {getattr(self, '_slack_initialized', False)}")
        
        # Only initialize if:
        # 1. We're running under Daphne
        # 2. We haven't already initialized in this process
        # 3. We're not in an auto-reload cycle
        if ('daphne' not in process_name or 
            getattr(self, '_slack_initialized', False) or
            os.environ.get('RUN_MAIN') == 'true'):
            logger.info("Skipping Slack bot initialization due to conditions not met")
            return
            
        # Check if Slack bot token is configured
        slack_bot_token = getattr(settings, 'DSLACK_BOT_TOKEN', None)
        logger.info(f"DSLACK_BOT_TOKEN: {slack_bot_token}")
        if not slack_bot_token:
            logger.info("Skipping Slack bot initialization: DSLACK_BOT_TOKEN not configured")
            return
            
        #logger.info("All conditions met, proceeding with Slack bot initialization...")
        
        try:
            from .integrations.slack_bot import start_slack_bot
            start_slack_bot()
            self._slack_initialized = True
            logger.info("Slack bot initialization completed and flag set")
        except Exception as e:
            logger.error(f"Failed to initialize Slack bot: {e}", exc_info=True)

================
File: apps/agents/celery.py
================
from celery import Celery
import os
from django.conf import settings

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

app = Celery('core')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
# - namespace='CELERY' means all celery-related configuration keys
#   should have a `CELERY_` prefix.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django app configs.
app.autodiscover_tasks(lambda: settings.INSTALLED_APPS)

================
File: apps/agents/consumers.py
================
import json
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
from .models import CrewExecution, CrewMessage, ChatMessage, Agent
from django.core.cache import cache
from apps.common.utils import format_message, get_llm
from .utils import get_tool_classes
import logging
import uuid
from langchain_core.messages import SystemMessage, HumanMessage, AIMessage, FunctionMessage, BaseMessage, messages_from_dict, messages_to_dict
import asyncio
import tiktoken
from langchain_community.chat_models import ChatLiteLLM
from langchain_core.tools import Tool
from django.utils import timezone
from apps.seo_manager.models import Client
from langchain.prompts import ChatPromptTemplate
from langchain.agents import initialize_agent, AgentType, AgentExecutor, create_structured_chat_agent
from langchain.agents.format_scratchpad import format_to_openai_function_messages
from langchain.agents.output_parsers import JSONAgentOutputParser
from langchain_core.callbacks import BaseCallbackHandler
import datetime
from langchain.tools import StructuredTool
from typing import Dict, Any, List
from pydantic import create_model
from langchain.memory import ConversationBufferMemory
from langchain_core.chat_history import BaseChatMessageHistory
import re
import time

logger = logging.getLogger(__name__)

def count_tokens(text):
    """Count tokens in text using tiktoken"""
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

class ConnectionTestConsumer(OrganizationAwareConsumer):
    async def connect(self):
        # Set organization context
        await super().connect()
        
        await self.accept()
        await self.send(text_data=json.dumps({
            'message': 'Connected to server'
        }))

    async def disconnect(self, close_code):
        # Clear organization context
        await super().disconnect(close_code)

    async def receive(self, text_data):
        try:
            text_data_json = json.loads(text_data)
            message = text_data_json['message']

            # Echo the received message back to the client
            await self.send(text_data=json.dumps({
                'message': f'Server received: {message}'
            }))
        except json.JSONDecodeError:
            await self.send(text_data=json.dumps({
                'error': 'Invalid JSON format'
            }))
        except KeyError:
            await self.send(text_data=json.dumps({
                'error': 'Missing "message" key in JSON'
            }))

class CrewExecutionConsumer(OrganizationAwareConsumer):
    async def connect(self):
        # Set organization context first
        await super().connect()
        
        self.execution_id = self.scope['url_route']['kwargs']['execution_id']
        self.execution_group_name = f'crew_execution_{self.execution_id}'

        # Join room group
        await self.channel_layer.group_add(
            self.execution_group_name,
            self.channel_name
        )

        await self.accept()

        # Send initial status
        await self.send_execution_status()

    async def disconnect(self, close_code):
        # Leave room group
        await self.channel_layer.group_discard(
            self.execution_group_name,
            self.channel_name
        )
        
        # Clear organization context
        await super().disconnect(close_code)

    async def receive(self, text_data):
        text_data_json = json.loads(text_data)
        message_type = text_data_json.get('type')

        if message_type == 'human_input':
            input_key = text_data_json.get('input_key')
            user_input = text_data_json.get('input')
            await self.handle_human_input(input_key, user_input)

    async def crew_execution_update(self, event):
        status = event.get('status', '')  # No formatting applied
        formatted_messages = [
            {
                'agent': msg.get('agent', 'System'),
                'content': format_message(msg.get('content', ''))
            } for msg in event.get('messages', []) if msg.get('content')
        ]
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
            'human_input_request': event.get('human_input_request')
        }))

    @database_sync_to_async
    def handle_human_input(self, input_key, user_input):
        cache.set(f"{input_key}_response", user_input, timeout=3600)
        execution = CrewExecution.objects.get(id=self.execution_id)
        CrewMessage.objects.create(
            execution=execution,
            agent='Human',
            content=f"Human input received: {user_input}"
        )

    @database_sync_to_async
    def get_execution_status(self):
        execution = CrewExecution.objects.get(id=self.execution_id)
        messages = CrewMessage.objects.filter(execution=execution).order_by('-timestamp')[:10]
        return {
            'status': execution.status,
            'messages': [{'agent': msg.agent, 'content': msg.content} for msg in messages],
        }

    async def send_execution_status(self):
        status_data = await self.get_execution_status()
        status = status_data['status']  # No formatting applied
        formatted_messages = [
            {
                'agent': msg['agent'],
                'content': format_message(msg['content'])
            } for msg in status_data['messages'] if msg.get('content')
        ]
        
        # logger.info(f"Sending status: {status}")
        # logger.info(f"Sending formatted messages: {formatted_messages}")
        
        await self.send(text_data=json.dumps({
            'status': status,
            'messages': formatted_messages,
        }))

================
File: apps/agents/forms.py
================
import random
from django.conf import settings
from django import forms
from .models import CrewExecution, Agent, Task, Tool, Crew, get_available_tools, AVATAR_CHOICES
from apps.seo_manager.models import Client
from apps.common.utils import get_models
import json
import logging
from .utils import get_available_tools, get_tool_classes

logger = logging.getLogger(__name__)

class CrewExecutionForm(forms.ModelForm):
    inputs = forms.JSONField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = CrewExecution
        fields = ['inputs']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields['inputs'].widget.attrs['class'] = 'form-control'
        self.fields['inputs'].help_text = 'Enter JSON formatted inputs for the crew execution.'

    def clean_inputs(self):
        inputs = self.cleaned_data.get('inputs')
        if inputs:
            try:
                return json.loads(inputs)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in inputs field")
        return {}

class HumanInputForm(forms.Form):
    response = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=True)

class AgentForm(forms.ModelForm):
    avatar = forms.ChoiceField(
        choices=[(choice, choice) for choice in AVATAR_CHOICES],
        widget=forms.RadioSelect(),
        required=False
    )
    llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=True
    )
    function_calling_llm = forms.ChoiceField(
        choices=[(model, model) for model in get_models()],
        widget=forms.Select(attrs={'class': 'form-select'}),
        required=False
    )
    
    tools = forms.ModelMultipleChoiceField(
        queryset=Tool.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False
    )

    class Meta:
        model = Agent
        fields = '__all__'  # Include all fields from the model
        widgets = {
            'goal': forms.Textarea(attrs={'rows': 3}),
            'backstory': forms.Textarea(attrs={'rows': 3}),
            'system_template': forms.Textarea(attrs={'rows': 4}),
            'prompt_template': forms.Textarea(attrs={'rows': 4}),
            'response_template': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.SelectMultiple(attrs={'class': 'form-select'}),
            'llm': forms.Select(attrs={'class': 'form-select'}),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        for field in self.fields:
            if isinstance(self.fields[field].widget, forms.CheckboxInput):
                self.fields[field].widget.attrs['class'] = 'form-check-input'
            elif not isinstance(self.fields[field].widget, (forms.SelectMultiple, forms.RadioSelect)):
                self.fields[field].widget.attrs['class'] = 'form-control'

        # Ensure avatar choices are set
        self.fields['avatar'].choices = [(choice, choice) for choice in AVATAR_CHOICES]

        # Ensure the initial values are set correctly
        self.initial['llm'] = self.initial.get('llm', settings.GENERAL_MODEL)
        self.initial['function_calling_llm'] = self.initial.get('function_calling_llm', settings.GENERAL_MODEL)

    def clean(self):
        cleaned_data = super().clean()
        logger.debug(f"Cleaned form data: {cleaned_data}")
        return cleaned_data

    def save(self, commit=True):
        logger.debug(f"Saving form with data: {self.cleaned_data}")
        instance = super().save(commit=False)
        # Ensure LLM values are set on the instance
        instance.llm = self.cleaned_data.get('llm')
        instance.function_calling_llm = self.cleaned_data.get('function_calling_llm')
        if commit:
            instance.save()
            self.save_m2m()
        logger.debug(f"Saved instance: {instance.__dict__}")
        return instance

class TaskForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)

    class Meta:
        model = Task
        fields = ['description', 'agent', 'expected_output', 'tools', 'async_execution', 'context', 'config', 'output_json', 'output_pydantic', 'output_file', 'human_input', 'converter_cls']
        widgets = {
            'description': forms.Textarea(attrs={'rows': 4}),
            'expected_output': forms.Textarea(attrs={'rows': 4}),
            'tools': forms.CheckboxSelectMultiple(),
            'context': forms.CheckboxSelectMultiple(),
            'output_json': forms.TextInput(),
            'output_pydantic': forms.TextInput(),
            'output_file': forms.TextInput(attrs={'placeholder': 'e.g., outputs/task_result.txt'}),
            'converter_cls': forms.TextInput(),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)

    def clean_config(self):
        config = self.cleaned_data.get('config')
        if config:
            try:
                return json.loads(config)
            except json.JSONDecodeError:
                raise forms.ValidationError("Invalid JSON format in config field")
        return None

    def clean_output_file(self):
        output_file = self.cleaned_data.get('output_file')
        if output_file:
            # You can add additional validation here if needed
            # For example, check if the path is within allowed directories
            pass
        return output_file

class ToolForm(forms.ModelForm):
    tool_class = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    tool_subclass = forms.ChoiceField(
        choices=[],
        widget=forms.Select(attrs={'class': 'form-control'}),
        required=True
    )
    description = forms.CharField(widget=forms.Textarea(attrs={'readonly': 'readonly'}), required=False)

    class Meta:
        model = Tool
        fields = ['tool_class', 'tool_subclass', 'name', 'description']

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_tools = get_available_tools()
        # Sort the tools alphabetically
        available_tools = sorted(available_tools)
        self.fields['tool_class'].choices = [(tool, tool) for tool in available_tools]
        self.fields['name'].widget = forms.HiddenInput()
        self.fields['name'].required = False
        
        if self.data.get('tool_class'):
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.data['tool_class'])
        elif self.instance.pk:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(self.instance.tool_class)

    def get_subclass_choices(self, tool_class):
        subclasses = get_tool_classes(tool_class)
        return [(cls.__name__, cls.__name__) for cls in subclasses]

    def clean(self):
        cleaned_data = super().clean()
        tool_class = cleaned_data.get('tool_class')
        tool_subclass = cleaned_data.get('tool_subclass')

        if tool_class:
            self.fields['tool_subclass'].choices = self.get_subclass_choices(tool_class)

        if tool_class and tool_subclass:
            subclasses = dict(self.fields['tool_subclass'].choices)
            if tool_subclass not in subclasses:
                raise forms.ValidationError(f"Invalid tool subclass '{tool_subclass}' for tool class '{tool_class}'")

        # Set the name field to the value of tool_subclass
        cleaned_data['name'] = tool_subclass

        return cleaned_data

    def save(self, commit=True):
        instance = super().save(commit=False)
        instance.name = self.cleaned_data['tool_subclass']
        if commit:
            instance.save()
        return instance

class CrewForm(forms.ModelForm):
    config = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    manager_callbacks = forms.CharField(widget=forms.Textarea(attrs={'rows': 4}), required=False)
    agents = forms.ModelMultipleChoiceField(
        queryset=Agent.objects.all(),
        required=False,
        widget=forms.SelectMultiple(attrs={'class': 'form-control form-select'})
    )

    class Meta:
        model = Crew
        fields = [
            'name', 'agents', 'tasks', 'process', 'verbose', 'manager_llm',
            'function_calling_llm', 'config', 'max_rpm', 'language',
            'language_file', 'memory', 'cache', 'embedder', 'full_output',
            'share_crew', 'output_log_file', 'manager_agent', 'manager_callbacks',
            'prompt_file', 'planning', 'planning_llm'
        ]
        # Note: input_variables is not included here as it's handled separately in the view

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        available_models = get_models()
        self.fields['manager_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['function_calling_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['planning_llm'] = forms.ChoiceField(
            choices=[(model, model) for model in available_models],
            widget=forms.Select(attrs={'class': 'form-control'}),
            required=False
        )
        self.fields['max_rpm'].widget.attrs['min'] = 0
        self.fields['max_rpm'].widget.attrs['step'] = 1

        if self.instance.config:
            self.initial['config'] = json.dumps(self.instance.config, indent=2)
        if self.instance.manager_callbacks:
            self.initial['manager_callbacks'] = json.dumps(self.instance.manager_callbacks, indent=2)
        if self.instance.embedder:
            self.initial['embedder'] = json.dumps(self.instance.embedder, indent=2)

        # Remove the 'required' attribute from the agents field
        if 'agents' in self.fields:
            self.fields['agents'].required = False

        print(f"Initial manager_llm: {self.initial.get('manager_llm')}")  # Debugging line
        print(f"Initial function_calling_llm: {self.initial.get('function_calling_llm')}")  # Debugging line

    def clean_config(self):
        return self._clean_json_field('config')

    def clean_manager_callbacks(self):
        return self._clean_json_field('manager_callbacks')

    def clean_embedder(self):
        return self._clean_json_field('embedder')

    def _clean_json_field(self, field_name):
        data = self.cleaned_data.get(field_name)
        if data:
            try:
                return json.loads(data)
            except json.JSONDecodeError:
                raise forms.ValidationError(f"Invalid JSON format in {field_name} field")
        return None

================
File: apps/agents/kanban_consumers.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
import json
from channels.db import database_sync_to_async
from django.contrib.auth import get_user_model
import logging

logger = logging.getLogger(__name__)
User = get_user_model()

class CrewKanbanConsumer(OrganizationAwareConsumer):
    async def connect(self):
        """
        Handle WebSocket connection setup with organization context
        """
        # Set organization context first
        await super().connect()
        
        self.crew_id = self.scope['url_route']['kwargs']['crew_id']
        self.room_group_name = f'crew_{self.crew_id}_kanban'
        self.is_connected = False
        
        try:
            # Ensure channel layer is available
            if not hasattr(self, 'channel_layer') or not self.channel_layer:
                logger.error("Channel layer not initialized")
                await self.close()
                return
                
            # Add to crew group
            await self.channel_layer.group_add(
                self.room_group_name,
                self.channel_name
            )
            
            # Accept the connection
            await self.accept()
            
            self.is_connected = True
            logger.info(f"WebSocket connection established for crew {self.crew_id}")
        except Exception as e:
            logger.error(f"Error establishing WebSocket connection: {str(e)}")
            if not self.is_connected:
                await self.close()
    
    async def disconnect(self, close_code):
        """
        Handle WebSocket disconnection cleanup with organization context
        """
        try:
            self.is_connected = False
            if hasattr(self, 'channel_layer') and self.channel_layer:
                await self.channel_layer.group_discard(
                    self.room_group_name,
                    self.channel_name
                )
                logger.info(f"WebSocket connection closed for crew {self.crew_id} with code {close_code}")
            else:
                logger.warning("Channel layer not available during disconnect")
        except Exception as e:
            logger.error(f"Error during WebSocket disconnect: {str(e)}")
            
        # Clear organization context
        await super().disconnect(close_code)
    
    async def receive(self, text_data):
        """
        Handle incoming WebSocket messages
        """
        if not self.is_connected:
            logger.warning("Received message but WebSocket is not connected")
            return
            
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            logger.debug(f"Received WebSocket message: {message_type}")
            
            # Handle ping messages immediately
            if message_type == 'ping':
                await self.send(text_data=json.dumps({
                    'type': 'pong'
                }))
                return
            
            handlers = {
                'execution_update': self.handle_execution_update,
                'agent_step': self.handle_agent_step,
                'human_input_request': self.handle_human_input_request,
                'task_complete': self.handle_task_complete
            }
            
            handler = handlers.get(message_type)
            if handler:
                await handler(data)
            else:
                logger.warning(f"Unknown message type received: {message_type}")
        
        except json.JSONDecodeError:
            logger.error(f"Failed to decode WebSocket message: {text_data}")
        except Exception as e:
            logger.error(f"Error processing WebSocket message: {str(e)}")
            if self.is_connected:
                await self.send(text_data=json.dumps({
                    'type': 'error',
                    'message': 'Internal server error occurred'
                }))
    
    async def handle_execution_update(self, data):
        """Handle execution status updates"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id from execution
            execution_id = data.get('execution_id')
            if execution_id:
                crewai_task_id = await self.get_task_id_for_execution(execution_id)
                data['crewai_task_id'] = crewai_task_id
            
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'execution_update',
                    **data
                }
            )
            logger.debug(f"Sent execution update for execution {execution_id}")
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            # Don't try to send error message if we already know connection is broken
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def handle_agent_step(self, data):
        """Handle individual agent step updates"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'agent_step',
                    'execution_id': data.get('execution_id'),
                    'agent': data.get('agent', ''),
                    'content': data.get('content', ''),
                    'step_type': data.get('step_type', ''),
                    'is_final_step': data.get('is_final_step', False)
                }
            )
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def handle_human_input_request(self, data):
        """Handle requests for human input"""
        if not self.is_connected:
            logger.warning("Cannot send human input request - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'human_input_request',
                    'execution_id': data.get('execution_id'),
                    'prompt': data.get('prompt', ''),
                    'context': data.get('context', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending human input request: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send human input request'
                    }))
                except:
                    pass

    async def handle_task_complete(self, data):
        """Handle task completion notifications"""
        if not self.is_connected:
            logger.warning("Cannot send task complete - WebSocket not connected")
            return
            
        try:
            await self.channel_layer.group_send(
                self.room_group_name,
                {
                    'type': 'task_complete',
                    'execution_id': data.get('execution_id'),
                    'message': data.get('message', ''),
                    'results': data.get('results', {})
                }
            )
        except Exception as e:
            logger.error(f"Error sending task complete: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send task complete'
                    }))
                except:
                    pass
    
    # WebSocket send handlers
    async def execution_update(self, event):
        """Send execution updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send execution update - WebSocket not connected")
            return
            
        try:
            # Ensure stage data has all required fields
            stage = event.get('stage', {})
            if stage:
                stage.setdefault('stage_type', 'processing')
                stage.setdefault('title', 'Processing...')
                stage.setdefault('content', '')
                stage.setdefault('status', 'in_progress')
                stage.setdefault('agent', 'System')
                stage.setdefault('completed', False)
                
                if stage.get('status') == 'completed':
                    stage['completed'] = True
                
                if 'chat_message_prompts' not in stage:
                    stage['chat_message_prompts'] = [{
                        'role': 'system',
                        'content': stage.get('content', 'Processing task...')
                    }]
            
            message = {
                'type': 'execution_update',
                'execution_id': event['execution_id'],
                'status': event['status'],
                'crewai_task_id': event.get('crewai_task_id'),
                'task_index': event.get('task_index'),
                'message': event.get('message'),
                'stage': stage,
                'human_input_request': event.get('human_input_request')
            }
            #logger.debug(f"Consumer sending message: {message}")
            await self.send(text_data=json.dumps(message))
        except Exception as e:
            logger.error(f"Error sending execution update: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send execution update'
                    }))
                except:
                    pass

    async def agent_step(self, event):
        """Send agent step updates to WebSocket"""
        if not self.is_connected:
            logger.warning("Cannot send agent step - WebSocket not connected")
            return
            
        try:
            # Get crewai_task_id for this execution
            execution_id = event['execution_id']
            crewai_task_id = await self.get_task_id_for_execution(execution_id)
            
            # Format agent step as a stage update with chat_message_prompts
            stage_data = {
                'stage_type': event.get('step_type', 'agent_step'),
                'title': f"Agent: {event.get('agent', 'System')}",
                'content': event.get('content', ''),
                'status': 'in_progress',
                'agent': event.get('agent', 'System'),
                'completed': False,
                'chat_message_prompts': [{
                    'role': 'assistant',
                    'content': event.get('content', '')
                }]
            }
            
            await self.send(text_data=json.dumps({
                'type': 'execution_update',
                'execution_id': execution_id,
                'crewai_task_id': crewai_task_id,
                'stage': stage_data
            }))
            
            # Send a completion update for this stage if it's the final step
            if event.get('is_final_step', False):
                stage_data.update({
                    'status': 'completed',
                    'completed': True
                })
                await self.send(text_data=json.dumps({
                    'type': 'execution_update',
                    'execution_id': execution_id,
                    'crewai_task_id': crewai_task_id,
                    'stage': stage_data
                }))
        except Exception as e:
            logger.error(f"Error sending agent step: {str(e)}")
            if self.is_connected:
                try:
                    await self.send(text_data=json.dumps({
                        'type': 'error',
                        'message': 'Failed to send agent step'
                    }))
                except:
                    pass

    async def human_input_request(self, event):
        """Send human input requests to WebSocket"""
        logger.debug(f"Consumer received human_input_request event: {event}")
        try:
            message = {
                'type': 'human_input_request',
                'execution_id': event['execution_id'],
                'prompt': event['prompt'],
                'context': event.get('context', {})
            }
            #logger.debug(f"Consumer attempting to send message: {message}")
            await self.send(text_data=json.dumps(message))
            logger.debug("Consumer successfully sent message")
        except Exception as e:
            logger.error(f"Consumer failed to send message: {e}")

    async def task_complete(self, event):
        """Send task completion notifications to WebSocket"""
        execution_id = event['execution_id']
        crewai_task_id = await self.get_task_id_for_execution(execution_id)
        
        await self.send(text_data=json.dumps({
            'type': 'task_complete',
            'execution_id': execution_id,
            'crewai_task_id': crewai_task_id,
            'message': event['message'],
            'results': event['results']
        }))

    @database_sync_to_async
    def get_task_id_for_execution(self, execution_id):
        """Get CrewAI task ID for a given execution"""
        from .models import CrewExecution
        try:
            execution = CrewExecution.objects.get(id=execution_id)
            # Get the latest execution stage for this execution
            latest_stage = execution.executionstage_set.order_by('-created_at').first()
            return latest_stage.crewai_task_id if latest_stage else None
        except CrewExecution.DoesNotExist:
            return None

================
File: apps/agents/models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from apps.common.utils import get_models
from pydantic import BaseModel
import os
import importlib
import logging
import uuid
import random
import json
from django.contrib.postgres.fields import ArrayField
from django.conf import settings
from apps.agents.utils import load_tool, get_tool_description
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from datetime import datetime, timedelta
from django.utils import timezone
import re
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.utils.translation import gettext_lazy as _
from core.storage import SecureFileStorage
from apps.organizations.models.mixins import OrganizationModelMixin, OrganizationModelManager, OrganizationUnfilteredManager

logger = logging.getLogger(__name__)

User = get_user_model()

import glob

def get_agent_avatars():
    # Get the default avatar list
    default_avatars = [
        'team-5.jpg', 'team-4.jpg', 'team-3.jpg', 'team-2.jpg', 'kal-visuals-square.jpg',
        'team-1.jpg', 'marie.jpg', 'ivana-squares.jpg', 'ivana-square.jpg'
    ]
    
    # Get additional avatars from static directory
    static_path = os.path.join('static', 'assets', 'img', 'agent-avatar*')
    additional_avatars = [os.path.basename(f) for f in glob.glob(static_path)]
    
    return default_avatars + additional_avatars

AVATAR_CHOICES = get_agent_avatars()

def random_avatar():
    return random.choice(AVATAR_CHOICES)

def get_available_tools():
    tools_dir = os.path.join('apps', 'agents', 'tools')
    available_tools = []

    for root, dirs, files in os.walk(tools_dir):
        for dir_name in dirs:
            if not dir_name.startswith('__'):  # Exclude directories like __pycache__
                tool_path = os.path.relpath(os.path.join(root, dir_name), tools_dir)
                available_tools.append(tool_path.replace(os.path.sep, '.'))

    return available_tools

def default_embedder():
    return {'provider': 'openai'}

# Create storage for agent task files
task_output_storage = SecureFileStorage(
    private=True,
    collection='agent_task_outputs'
)

def user_directory_path(instance, filename):
    # Return only the filename since the collection is handled by SecureFileStorage
    return filename

class Tool(models.Model):
    tool_class = models.CharField(max_length=255)
    tool_subclass = models.CharField(max_length=255)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    module_path = models.CharField(max_length=255)

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        if not self.module_path:
            self.module_path = f"apps.agents.tools.{self.tool_class}"
        
        try:
            # Log at the start of save method
            logger.debug(f"Tool.save: Starting save for {self.tool_subclass}")
            
            # Load the tool class to get its name and possibly update description
            tool = load_tool(self)
            if tool:
                self.name = getattr(tool, 'name', self.tool_subclass)
                
                # Only update description if it's not set or empty
                if not self.description:
                    logger.debug(f"Tool.save: Getting description for {self.tool_subclass}")
                    self.description = get_tool_description(tool.__class__)
                    logger.debug(f"Tool.save: Description set to: {self.description[:100]}...")
                else:
                    logger.debug(f"Tool.save: Using existing description: {self.description[:100]}...")
            else:
                raise ValueError(f"Failed to load tool: {self.module_path}.{self.tool_subclass}. Check the logs for more details.")
        except Exception as e:
            logger.error(f"Error in Tool.save: {str(e)}")
            raise ValidationError(f"Error loading tool: {str(e)}")

        super().save(*args, **kwargs)

class ToolRun(models.Model):
    """Model to track tool executions"""
    TOOL_RUN_STATUS = (
        ('pending', 'Pending'),
        ('running', 'Running'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )
    
    tool = models.ForeignKey(Tool, on_delete=models.CASCADE)
    conversation = models.ForeignKey('Conversation', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    message = models.ForeignKey('ChatMessage', on_delete=models.CASCADE, related_name='tool_runs', null=True, blank=True)
    status = models.CharField(max_length=20, choices=TOOL_RUN_STATUS, default='pending')
    inputs = models.JSONField()
    result = models.JSONField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_deleted = models.BooleanField(default=False)
    
    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"{self.tool.name} - {self.status} ({self.created_at})"

class Agent(models.Model):
    name = models.CharField(max_length=255)
    role = models.CharField(max_length=100)
    goal = models.TextField()
    backstory = models.TextField()
    llm = models.CharField(max_length=100, default=settings.GENERAL_MODEL)
    tools = models.ManyToManyField(Tool, blank=True)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    max_iter = models.IntegerField(default=25)
    max_rpm = models.IntegerField(null=True, blank=True)
    max_execution_time = models.IntegerField(null=True, blank=True)
    verbose = models.BooleanField(default=False)
    allow_delegation = models.BooleanField(default=False)
    step_callback = models.CharField(max_length=255, null=True, blank=True)
    cache = models.BooleanField(default=True)
    system_template = models.TextField(null=True, blank=True)
    prompt_template = models.TextField(null=True, blank=True)
    response_template = models.TextField(null=True, blank=True)
    allow_code_execution = models.BooleanField(default=False)
    max_retry_limit = models.IntegerField(default=2)
    use_system_prompt = models.BooleanField(default=True)
    respect_context_window = models.BooleanField(default=True)
    avatar = models.CharField(max_length=100, default=random_avatar)

    def __str__(self):
        return self.name

    def clean(self):
        super().clean()
        available_models = get_models()
        if self.llm not in available_models:
            raise ValidationError({'llm': f"Selected LLM '{self.llm}' is not available. Please choose from: {', '.join(available_models)}"})

    def get_tool_settings(self, tool):
        """Get settings for a specific tool."""
        return self.tool_settings.filter(tool=tool).first()

    def get_forced_output_tools(self):
        """Get all tools that have force_output_as_result=True."""
        return self.tools.filter(
            id__in=self.tool_settings.filter(
                force_output_as_result=True
            ).values_list('tool_id', flat=True)
        )

    def has_force_output_enabled(self, tool):
        """Check if force output is enabled for a specific tool."""
        tool_setting = self.tool_settings.filter(tool=tool).first()
        return tool_setting.force_output_as_result if tool_setting else False

class Task(models.Model):
    description = models.TextField()
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    expected_output = models.TextField()
    tools = models.ManyToManyField(Tool, blank=True)
    async_execution = models.BooleanField(default=False)
    context = models.ManyToManyField('self', symmetrical=False, blank=True)
    config = models.JSONField(null=True, blank=True)
    output_json = models.CharField(max_length=255, null=True, blank=True)
    output_pydantic = models.CharField(max_length=255, null=True, blank=True)
    output_file = models.CharField(max_length=255, null=True, blank=True)
    output = models.TextField(null=True, blank=True)
    callback = models.CharField(max_length=255, null=True, blank=True)
    human_input = models.BooleanField(default=False)
    converter_cls = models.CharField(max_length=255, null=True, blank=True)

    def __str__(self):
        return self.description[:50]

    def save_output_file(self, content):
        if self.output_file:
            file_name = os.path.basename(self.output_file)
        else:
            file_name = f"task_{self.id}_output.txt"
        
        try:
            # Create a ContentFile with the content
            content_file = ContentFile(content)
            
            # Save using our secure storage
            file_path = task_output_storage.save(file_name, content_file)
            
            # Update the model's output_file field
            self.output_file = file_path
            self.save()
        except Exception as e:
            logger.error(f"Error saving output file for task {self.id}: {e}")
            raise

class Crew(models.Model):
    name = models.CharField(max_length=100)
    agents = models.ManyToManyField(Agent)
    tasks = models.ManyToManyField(Task, through='CrewTask')
    process = models.CharField(max_length=20, choices=[('sequential', 'Sequential'), ('hierarchical', 'Hierarchical')], default='sequential')
    verbose = models.BooleanField(default=False)
    manager_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    function_calling_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    config = models.JSONField(null=True, blank=True)
    max_rpm = models.IntegerField(null=True, blank=True)
    language = models.CharField(max_length=50, default='English')
    language_file = models.CharField(max_length=255, null=True, blank=True)
    memory = models.BooleanField(default=False)
    cache = models.BooleanField(default=True)
    embedder = models.JSONField(default=default_embedder)
    full_output = models.BooleanField(default=False)
    share_crew = models.BooleanField(default=False)
    output_log_file = models.CharField(max_length=255, null=True, blank=True)
    manager_agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True, related_name='managed_crews')
    manager_callbacks = models.JSONField(null=True, blank=True)
    prompt_file = models.CharField(max_length=255, null=True, blank=True)
    planning = models.BooleanField(default=False)
    planning_llm = models.CharField(max_length=100, null=True, blank=True, default=settings.GENERAL_MODEL)
    input_variables = models.JSONField(null=True, blank=True, default=list)

    def __str__(self):
        return self.name

class NullableOrganizationModelMixin(models.Model):
    """
    Abstract model mixin with nullable organization field.
    Useful for migrating existing models to use organization-based access control.
    """
    organization = models.ForeignKey(
        'organizations.Organization',
        on_delete=models.CASCADE,
        related_name="%(class)ss",
        null=True,
        blank=True
    )
    
    # Organization-filtered manager
    objects = OrganizationModelManager()
    
    # Unfiltered manager
    unfiltered_objects = OrganizationUnfilteredManager()
    
    # Access via the 'organization_objects' property for compatibility
    @property
    def organization_objects(self):
        return self.objects
    
    class Meta:
        abstract = True

class CrewExecution(OrganizationModelMixin, models.Model):
    """Represents a single execution of a crew"""
    # Override the organization field to make it nullable
    organization = models.ForeignKey(
        'organizations.Organization',
        on_delete=models.CASCADE,
        related_name="%(class)ss",
        null=True,
        blank=True
    )
    
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE, null=True)
    status = models.CharField(max_length=50, default='PENDING')
    task_id = models.CharField(max_length=50, null=True)
    inputs = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    conversation = models.ForeignKey('Conversation', on_delete=models.SET_NULL, null=True, related_name='crew_executions')
    crew_output = models.OneToOneField('CrewOutput', on_delete=models.SET_NULL, null=True, blank=True, related_name='crew_execution')
    human_input_request = models.JSONField(null=True, blank=True)
    human_input_response = models.JSONField(null=True, blank=True)
    error_message = models.TextField(blank=True, null=True)
    chat_enabled = models.BooleanField(default=False)

    def get_conversation_history(self):
        """Get formatted conversation history including messages and tool results"""
        if not self.conversation:
            return []
            
        messages = ChatMessage.objects.filter(
            conversation=self.conversation,
            is_deleted=False
        ).order_by('timestamp')
        
        # Use the formatted_message property for each message
        return [msg.formatted_message for msg in messages]

    def __str__(self):
        return f"{self.crew.name} - {self.status} ({self.created_at})"

    def save_task_output_file(self, task, content):
        task.save_output_file(content)

class CrewMessage(models.Model):
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='messages')
    content = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)
    agent = models.CharField(max_length=255, null=True, blank=True)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement

    def __str__(self):
        return f"{self.timestamp}: {self.content[:50]}"

class CrewOutput(models.Model):
    raw = models.TextField()
    pydantic = models.JSONField(null=True, blank=True)
    json_dict = models.JSONField(null=True, blank=True)
    token_usage = models.JSONField(null=True, blank=True)

    @property
    def json(self):
        return json.dumps(self.json_dict) if self.json_dict else None

    def to_dict(self):
        return self.json_dict or (self.pydantic.dict() if self.pydantic else None) or {}

    def __str__(self):
        if self.pydantic:
            return str(self.pydantic)
        elif self.json_dict:
            return json.dumps(self.json_dict)
        else:
            return self.raw

    def save(self, *args, **kwargs):
        # Convert UsageMetrics to a dictionary if it's not already
        if self.token_usage and hasattr(self.token_usage, 'dict'):
            self.token_usage = self.token_usage.dict()
        super().save(*args, **kwargs)

class CrewTask(models.Model):
    crew = models.ForeignKey(Crew, on_delete=models.CASCADE, related_name='crew_tasks')
    task = models.ForeignKey(Task, on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)

    class Meta:
        ordering = ['order']
        unique_together = ('crew', 'task')

    def __str__(self):
        return f"{self.crew.name} - {self.task.description} (Order: {self.order})"

class AgentToolSettings(models.Model):
    agent = models.ForeignKey('Agent', on_delete=models.CASCADE, related_name='tool_settings')
    tool = models.ForeignKey('Tool', on_delete=models.CASCADE)
    force_output_as_result = models.BooleanField(default=False)

    class Meta:
        unique_together = ('agent', 'tool')

class SlackChannelClientMapping(models.Model):
    """Map Slack channels to clients for automatic client identification"""
    channel_id = models.CharField(max_length=32)
    team_id = models.CharField(max_length=32)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('channel_id', 'team_id')
        db_table = 'slack_channel_client_mappings'

    def __str__(self):
        return f"Slack Channel {self.channel_id} -> Client {self.client_id}"

class ExecutionStage(models.Model):
    STAGE_TYPES = [
        ('task_start', 'Task Start'),
        ('thinking', 'Thinking'),
        ('tool_usage', 'Tool Usage'),
        ('tool_results', 'Tool Results'),
        ('human_input', 'Human Input'),
        ('completion', 'Completion')
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed')
    ]
    
    execution = models.ForeignKey(CrewExecution, on_delete=models.CASCADE, related_name='stages')
    stage_type = models.CharField(max_length=20, choices=STAGE_TYPES)
    title = models.CharField(max_length=200)
    content = models.TextField()
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True, blank=True)
    metadata = models.JSONField(default=dict)
    crewai_task_id = models.IntegerField(null=True, blank=True)  # For kanban board placement
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['created_at']
        verbose_name = 'Execution Stage'
        verbose_name_plural = 'Execution Stages'
    
    def __str__(self):
        return f"{self.get_stage_type_display()} - {self.title}"

class Conversation(models.Model):
    session_id = models.UUIDField(unique=True)
    user = models.ForeignKey(get_user_model(), on_delete=models.CASCADE)
    agent = models.ForeignKey('Agent', on_delete=models.SET_NULL, null=True)
    client = models.ForeignKey('seo_manager.Client', on_delete=models.SET_NULL, null=True)
    participant_type = models.CharField(
        max_length=50, 
        choices=[
            ('agent', 'Agent Chat'),
            ('crew', 'Crew Chat')
        ],
        default='agent'
    )
    crew_execution = models.ForeignKey(
        'CrewExecution',
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='chat_conversations'
    )
    title = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_active = models.BooleanField(default=True)

    class Meta:
        ordering = ['-updated_at']

    def __str__(self):
        return f"{self.title} ({self.session_id})"

    async def get_recent_messages(self, limit=10):
        """Get recent messages for this conversation"""
        return await self.chatmessage_set.filter(
            is_deleted=False
        ).order_by('-timestamp')[:limit]

    async def get_task_outputs(self, limit=5):
        """Get recent task outputs from crew execution"""
        if self.crew_execution and self.crew_execution.crew_output:
            return self.crew_execution.crew_output.to_dict()
        return None

class CrewChatSession(models.Model):
    conversation = models.OneToOneField(
        'Conversation',
        on_delete=models.CASCADE,
        related_name='crew_chat_session'
    )
    crew_execution = models.OneToOneField(
        'CrewExecution',
        on_delete=models.CASCADE,
        related_name='chat_session'
    )
    last_activity = models.DateTimeField(auto_now=True)
    status = models.CharField(
        max_length=50,
        choices=[
            ('active', 'Active'),
            ('paused', 'Paused'),
            ('completed', 'Completed'),
            ('cleaned', 'Cleaned')
        ],
        default='active'
    )
    context_data = models.JSONField(default=dict)

    class Meta:
        indexes = [
            models.Index(fields=['last_activity', 'status'])
        ]

    def __str__(self):
        return f"Crew Chat Session - {self.conversation.title}"

    async def get_full_context(self):
        """Get full context including messages, task outputs, and context data"""
        messages = await self.conversation.get_recent_messages()
        task_outputs = await self.conversation.get_task_outputs()
        
        return {
            'messages': messages,
            'task_outputs': task_outputs,
            'context_data': self.context_data
        }

    def update_context(self, key, value):
        """Update a specific context value"""
        if self.context_data is None:
            self.context_data = {}
        self.context_data[key] = value
        self.save(update_fields=['context_data', 'last_activity'])

class ChatMessage(models.Model):
    """Model for storing chat messages."""
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE)
    session_id = models.CharField(max_length=255)
    agent = models.ForeignKey(Agent, on_delete=models.SET_NULL, null=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField()
    is_agent = models.BooleanField(default=False)
    is_deleted = models.BooleanField(default=False)
    timestamp = models.DateTimeField(auto_now_add=True)
    model = models.CharField(max_length=255, default='unknown')
    task_id = models.IntegerField(null=True, blank=True)
    
    @property
    def formatted_message(self):
        """Get message with associated tool results"""
        base = {
            'type': 'agent_message' if self.is_agent else 'user_message',
            'content': self.content,
            'timestamp': self.timestamp.isoformat(),
            'model': self.model,
            'task_id': self.task_id
        }
        
        # Add tool results if any exist
        tool_runs = self.tool_runs.all()
        if tool_runs:
            base['tool_results'] = [
                {
                    'tool': run.tool.name,
                    'inputs': run.inputs,
                    'result': run.result,
                    'status': run.status
                }
                for run in tool_runs
            ]
            
        return base

    class Meta:
        ordering = ['timestamp']
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
            models.Index(fields=['session_id']),
            models.Index(fields=['is_deleted']),  # Add index for is_deleted field
        ]

    def __str__(self):
        return f"{self.timestamp}: {'Agent' if self.is_agent else 'User'} - {self.content[:50]}..."

class TokenUsage(models.Model):
    conversation = models.ForeignKey(Conversation, on_delete=models.CASCADE, related_name='token_usage')
    message = models.ForeignKey('ChatMessage', on_delete=models.SET_NULL, null=True, blank=True)
    tool_run = models.ForeignKey('ToolRun', on_delete=models.SET_NULL, null=True, blank=True)
    prompt_tokens = models.IntegerField(default=0)
    completion_tokens = models.IntegerField(default=0)
    total_tokens = models.IntegerField(default=0)
    model = models.CharField(max_length=100)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)  # Changed from JSONField to models.JSONField

    class Meta:
        indexes = [
            models.Index(fields=['conversation', 'timestamp']),
        ]

    def __str__(self):
        return f"{self.conversation_id} - {self.total_tokens} tokens"

class UserSlackIntegration(models.Model):
    """Store Slack integration details for users"""
    user = models.OneToOneField(get_user_model(), on_delete=models.CASCADE)
    access_token = models.CharField(max_length=255)
    team_id = models.CharField(max_length=32)
    team_name = models.CharField(max_length=255)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'user_slack_integrations'

    def __str__(self):
        return f"{self.user.username} - {self.team_name}"

class Flow(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    crews = models.ManyToManyField('Crew', through='FlowCrew')
    state_schema = models.JSONField(help_text="JSON schema for flow state validation")
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name

class FlowCrew(models.Model):
    flow = models.ForeignKey(Flow, on_delete=models.CASCADE)
    crew = models.ForeignKey('Crew', on_delete=models.CASCADE)
    order = models.PositiveIntegerField(default=0)
    trigger_condition = models.TextField(blank=True, 
        help_text="Python condition for triggering this crew")

    class Meta:
        ordering = ['order']

class FlowExecution(models.Model):
    flow = models.ForeignKey(Flow, on_delete=models.CASCADE)
    state = models.JSONField(default=dict)
    status = models.CharField(max_length=20, default='pending', 
        choices=(
            ('pending', 'Pending'),
            ('running', 'Running'),
            ('completed', 'Completed'),
            ('failed', 'Failed')
        ))
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

================
File: apps/agents/routing.py
================
from django.urls import re_path
from .consumers import ConnectionTestConsumer, ChatConsumer, CrewExecutionConsumer
from .kanban_consumers import CrewKanbanConsumer

websocket_urlpatterns = [
    re_path(r'ws/chat/$', ChatConsumer.as_asgi()),
    re_path(r'ws/crew_execution/(?P<execution_id>\w+)/$', CrewExecutionConsumer.as_asgi()),
    re_path(r'ws/test-connection/$', ConnectionTestConsumer.as_asgi()),
]

================
File: apps/agents/tasks.py
================
from celery import shared_task
import asyncio
import logging
from .utils import load_tool
from django.shortcuts import get_object_or_404
from .models import Tool, ToolRun
import inspect
import json
import traceback
from apps.agents.tools.wordpress.meta_tool import WordPressMetaTool

logger = logging.getLogger(__name__)

@shared_task(bind=True)
def run_tool(self, tool_id: int, inputs: dict):
    """Generic Celery task to run any tool"""
    try:
        # Load the tool
        tool = get_object_or_404(Tool, id=tool_id)
        tool_instance = load_tool(tool)
        
        if tool_instance is None:
            raise ValueError('Failed to load tool')

        # Create a tool run record
        tool_run = ToolRun.objects.create(
            tool=tool,
            status='running',
            inputs=inputs
        )
        
        try:
            # Process inputs if tool has args_schema
            if hasattr(tool_instance, 'args_schema'):
                processed_inputs = {}
                for key, value in inputs.items():
                    if value != '':
                        try:
                            processed_inputs[key] = json.loads(value)
                        except json.JSONDecodeError:
                            processed_inputs[key] = value
                            
                validated_inputs = tool_instance.args_schema(**processed_inputs)
                inputs = validated_inputs.dict()
            
            # Run the tool
            if inspect.iscoroutinefunction(tool_instance._run):
                # Create event loop for async tools
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                try:
                    result = loop.run_until_complete(tool_instance._run(**inputs))
                finally:
                    loop.close()
            else:
                # Run sync tools directly
                result = tool_instance._run(**inputs)
            
            # Update tool run record with success
            tool_run.status = 'completed'
            tool_run.result = result
            tool_run.save()
            
            return {
                'status': 'completed',
                'result': result,
                'tool_run_id': tool_run.id
            }
            
        except Exception as e:
            # Update tool run record with error
            tool_run.status = 'failed'
            tool_run.error = str(e)
            tool_run.save()
            raise
            
    except Exception as e:
        logger.error(f"Error running tool: {str(e)}\n{traceback.format_exc()}")
        return {
            'status': 'failed',
            'error': str(e)
        }

@shared_task
def update_wordpress_meta(**kwargs):
    tool = WordPressMetaTool()
    return tool._run(**kwargs)

================
File: apps/agents/tools.py
================


================
File: apps/agents/urls.py
================
from django.urls import path, re_path
from . import views
from . import views_agents
from . import views_tasks
from . import views_tools
from . import views_crews
from . import views_kanban
from . import views_chat
from .views_chat import ChatView


app_name = 'agents'

urlpatterns = [
    path('', views.crewai_home, name='crewai_home'),
    path('crews/', views.crew_list, name='crew_list'),
    path('crew/<int:crew_id>/', views.crew_detail, name='crew_detail'),
    path('crew/<int:crew_id>/kanban/', views_kanban.crew_kanban, name='crew_kanban'),
    path('crew/<int:crew_id>/start-execution/', views_kanban.start_execution, name='start_execution'),
    path('crew/<int:crew_id>/active-executions/', views_kanban.get_active_executions, name='get_active_executions'),
    path('crew/execution/<int:execution_id>/input/', views_kanban.submit_human_input, name='submit_human_input'),
    path('executions/', views.execution_list, name='execution_list'),
    path('execution/<int:execution_id>/', views_kanban.execution_detail, name='execution_detail'),
    path('execution/<int:execution_id>/status/', views_kanban.get_active_executions, name='execution_status'),
    path('execution/<int:execution_id>/submit_human_input/', views.submit_human_input, name='submit_human_input'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    path('execution/<int:execution_id>/cancel/', views_kanban.cancel_execution, name='cancel_execution'),
    
    # Admin views
    path('manage/agents/', views_agents.manage_agents, name='manage_agents'),
    path('manage/agents/add/', views_agents.add_agent, name='add_agent'),
    path('manage/agents/edit/<int:agent_id>/', views_agents.edit_agent, name='edit_agent'),
    path('manage/agents/delete/<int:agent_id>/', views_agents.delete_agent, name='delete_agent'),
    path('manage/agents/duplicate/<int:agent_id>/', views_agents.duplicate_agent, name='duplicate_agent'),
    
    path('manage/tasks/', views_tasks.manage_tasks, name='manage_tasks'),
    path('manage/tasks/add/', views_tasks.add_task, name='add_task'),
    path('manage/tasks/edit/<int:task_id>/', views_tasks.edit_task, name='edit_task'),
    path('manage/tasks/delete/<int:task_id>/', views_tasks.delete_task, name='delete_task'),
    path('manage/tasks/duplicate/<int:task_id>/', views_tasks.duplicate_task, name='duplicate_task'),
    
    path('manage/tools/', views_tools.manage_tools, name='manage_tools'),
    path('manage/tools/add/', views_tools.add_tool, name='add_tool'),
    path('manage/tools/edit/<int:tool_id>/', views_tools.edit_tool, name='edit_tool'),
    path('manage/tools/delete/<int:tool_id>/', views_tools.delete_tool, name='delete_tool'),
    path('tool-schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test-tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),
    path('tool-status/<str:task_id>/', views_tools.get_tool_status, name='get_tool_status'),
    path('get_tool_info/', views_tools.get_tool_info, name='get_tool_info'),
    path('get_tool_schema/<int:tool_id>/', views_tools.get_tool_schema, name='get_tool_schema'),
    path('test_tool/<int:tool_id>/', views_tools.test_tool, name='test_tool'),  # Django 3.1+ automatically handles async views
    
    # Tool testing client endpoints - ensure these match the paths in JavaScript
    path('tools/clients/', views_tools.get_clients, name='get_clients'),
    path('tools/client-attributes/<int:client_id>/', views_tools.get_client_attributes, name='get_client_attributes'),
    
    path('manage/crews/', views_crews.manage_crews, name='manage_crews'),
    path('manage/crews/add/', views_crews.crew_create_or_update, name='add_crew'),
    path('manage/crews/edit/<int:crew_id>/', views_crews.crew_create_or_update, name='edit_crew'),
    path('manage/crews/delete/<int:crew_id>/', views_crews.delete_crew, name='delete_crew'),
    path('manage/crews/duplicate/<int:crew_id>/', views_crews.duplicate_crew, name='duplicate_crew'),
    path('manage/crews/update_agents/<int:crew_id>/', views_crews.update_crew_agents, name='update_crew_agents'),
    
    path('manage/agents/card-view/', views_agents.manage_agents_card_view, name='manage_agents_card_view'),
    path('manage/crews/card-view/', views_crews.manage_crews_card_view, name='manage_crews_card_view'),
    
    path('connection-test/', views.connection_test, name='connection_test'),
    path('chat/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/', ChatView.as_view(), name='chat'),
    path('chat/<uuid:session_id>/delete/', views_chat.delete_conversation, name='delete_conversation'),
    
    # Slack OAuth
    path('slack/oauth/start/', views.slack_oauth_start, name='slack_oauth_start'),
    path('slack/oauth/callback/', views.slack_oauth_callback, name='slack_oauth_callback'),
]

================
File: apps/agents/views_agents.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Agent, AgentToolSettings
from .forms import AgentForm
import traceback
from django.conf import settings

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_agents(request):
    agents = Agent.objects.all().order_by('name')
    return render(request, 'agents/manage_agents.html', {'agents': agents})

@login_required
def manage_agents_card_view(request):
    agents = Agent.objects.prefetch_related('crew_set', 'task_set', 'tools').all().order_by('name')
    form = AgentForm()  # Now AgentForm is defined
    context = {
        'page_title': 'Manage Agents',
        'agents': agents,
        'form': form,
    }
    return render(request, 'agents/manage_agents_card_view.html', context)

@login_required
@user_passes_test(is_admin)
def add_agent(request):
    if request.method == 'POST':
        form = AgentForm(request.POST)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                
                # Save many-to-many fields
                form.save_m2m()
                
                # Handle tool settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent added successfully.')
                return redirect('agents:manage_agents')
            except Exception as e:
                messages.error(request, f"Error adding agent: {str(e)}")
    else:
        form = AgentForm()

    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Agent',
    }
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        form = AgentForm(request.POST, instance=agent)
        if form.is_valid():
            try:
                agent = form.save(commit=False)
                agent.avatar = form.cleaned_data['avatar']
                agent.save()
                form.save_m2m()
                
                # Update tool settings
                agent.tool_settings.all().delete()  # Remove existing settings
                for tool in agent.tools.all():
                    force_output = request.POST.get(f'force_tool_output_{tool.id}') == 'on'
                    AgentToolSettings.objects.create(
                        agent=agent,
                        tool=tool,
                        force_output_as_result=force_output
                    )
                
                messages.success(request, 'Agent updated successfully.')
                return redirect('agents:manage_agents_card_view')
            except Exception as e:
                messages.error(request, f"Error updating agent: {str(e)}")
    else:
        form = AgentForm(instance=agent)
    
    # Add page_title to the context
    context = {
        'form': form,
        'agent': agent,
        'page_title': 'Edit Agent',
    }
    
    return render(request, 'agents/agent_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_agent(request, agent_id):
    agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        agent.delete()
        messages.success(request, 'Agent deleted successfully.')
        return redirect('agents:manage_agents')
    context = {
        'object': agent,
        'type': 'agent',
        'page_title': 'Delete Agent',
    }
    return render(request, 'agents/confirm_delete.html', context)

@login_required
@user_passes_test(is_admin)
def duplicate_agent(request, agent_id):
    original_agent = get_object_or_404(Agent, id=agent_id)
    if request.method == 'POST':
        try:
            # Get all field values except id and auto-generated fields
            field_values = {
                field.name: getattr(original_agent, field.name)
                for field in original_agent._meta.fields
                if not field.primary_key and not field.auto_created
            }
            
            # Modify the name for the copy
            field_values['name'] = f"{field_values['name']} (Copy)"
            
            # Create new agent with copied values
            new_agent = Agent.objects.create(**field_values)
            
            # Copy many-to-many relationships
            for field in original_agent._meta.many_to_many:
                getattr(new_agent, field.name).set(getattr(original_agent, field.name).all())
            
            # Copy tool settings
            for tool_setting in original_agent.tool_settings.all():
                AgentToolSettings.objects.create(
                    agent=new_agent,
                    tool=tool_setting.tool,
                    force_output_as_result=tool_setting.force_output_as_result
                )
            
            messages.success(request, 'Agent duplicated successfully.')
            
            # Check for next URL in POST data first, then GET, then fall back to referer
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            
            # If no next parameter, check the referer
            referer = request.META.get('HTTP_REFERER', '')
            if 'card-view' in referer:
                return redirect('agents:manage_agents_card_view')
            return redirect('agents:manage_agents')
            
        except Exception as e:
            logger.error(f"Error duplicating agent: {str(e)}\n{traceback.format_exc()}")
            messages.error(request, f"Error duplicating agent: {str(e)}")
            # Check for next URL in POST data first, then GET, then fall back to referer
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            
            # If no next parameter, check the referer
            referer = request.META.get('HTTP_REFERER', '')
            if 'card-view' in referer:
                return redirect('agents:manage_agents_card_view')
            return redirect('agents:manage_agents')
            
    return redirect('agents:manage_agents')

================
File: apps/agents/views_chat.py
================
from django.views.generic import TemplateView
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.mixins import LoginRequiredMixin
from django.urls import reverse
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from apps.agents.models import Agent, Conversation, Crew
from apps.common.utils import get_models
from django.conf import settings
from apps.seo_manager.models import Client
import logging
import uuid

logger = logging.getLogger(__name__)

@login_required
@require_POST
def delete_conversation(request, session_id):
    try:
        conversation = get_object_or_404(Conversation, session_id=session_id, user=request.user)
        conversation.delete()
        logger.info(f"Deleted conversation: {conversation.id}")
        return JsonResponse({'status': 'success'})
    except Exception as e:
        logger.error(f"Error deleting conversation: {str(e)}")
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

class ChatView(LoginRequiredMixin, TemplateView):
    template_name = 'agents/chat.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        try:
            # Get session_id from URL parameters or generate new one
            session_id = self.kwargs.get('session_id', str(uuid.uuid4()))
            
            # Get base queryset for conversations
            conversations_qs = Conversation.objects.filter(
                user=self.request.user,
                is_active=True
            ).select_related('agent', 'client').order_by('-updated_at')
            
            # Get current conversation if exists
            current_conversation = None
            if 'session_id' in self.kwargs:
                try:
                    current_conversation = conversations_qs.get(session_id=session_id)
                    logger.info(f"Found existing conversation: {current_conversation}")
                except Conversation.DoesNotExist:
                    logger.warning(f"No conversation found for session_id: {session_id}")
            
            # Get recent conversations (limited to 50)
            conversations = conversations_qs[:50]
            logger.info(f"Found {conversations.count()} conversations")
            
            # Get all agents
            agents = Agent.objects.all().order_by('name')
            
            # Get all crews
            crews = Crew.objects.all().order_by('name')
            
            # Get all clients
            clients = Client.objects.all().order_by('name')
            
            # Get models list
            models = get_models()
            
            # Get default model
            default_model = settings.GENERAL_MODEL
            
            context.update({
                'page_title': 'Chat',
                'agents': agents,
                'crews': crews,
                'clients': clients,
                'models': models,
                'conversations': conversations,
                'current_conversation': current_conversation,
                'add_agent_url': reverse('agents:add_agent'),
                'segment': 'chat',
                'default_model': default_model,
                'session_id': session_id,
            })
            
        except Exception as e:
            logger.error(f"Error preparing chat view context: {str(e)}", exc_info=True)
            raise
            
        return context

================
File: apps/agents/views_crews.py
================
# This file was previously named views_admin.py
# The content remains the same, but you might want to remove any unused imports

import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Crew, CrewTask
from .forms import CrewForm
import json
from apps.seo_manager.models import Client
from django.conf import settings
































































































import traceback

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_crews(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews.html', context)

@login_required
@user_passes_test(is_admin)
def add_crew(request):
    if request.method == 'POST':
        form = CrewForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew added successfully.')
            return redirect('agents:manage_crews')
    else:
        initial_data = {
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        }
        logger.debug(f"Initial data for form: {initial_data}")
        form = CrewForm(initial=initial_data)
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            form.save()
            messages.success(request, 'Crew updated successfully.')
            return redirect('agents:manage_crews')
    else:
        form = CrewForm(instance=crew, initial={
            'manager_llm': settings.GENERAL_MODEL,
            'function_calling_llm': settings.GENERAL_MODEL
        })
    # Add page_title to the context
    context = {
        'form': form,
        'crew': crew,
        'page_title': 'Edit Crew',
    }
    return render(request, 'agents/crew_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_crew(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        crew.delete()
        messages.success(request, 'Crew deleted successfully.')
        return redirect('agents:manage_crews')
    context = {
        'object': crew,
        'type': 'crew',
        'page_title': 'Delete Crew',
    }
    return render(request, 'agents/confirm_delete.html', context)

@login_required
@user_passes_test(is_admin)
def duplicate_crew(request, crew_id):
    original_crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        try:
            # Get all field values except id and auto-generated fields
            field_values = {
                field.name: getattr(original_crew, field.name)
                for field in original_crew._meta.fields
                if not field.primary_key and not field.auto_created
            }
            
            # Modify the name for the copy
            field_values['name'] = f"{field_values['name']} (Copy)"
            
            # Create new crew with copied values
            new_crew = Crew.objects.create(**field_values)
            
            # Copy many-to-many relationships except tasks (which we'll handle separately)
            for field in original_crew._meta.many_to_many:
                if field.name != 'tasks':  # Skip tasks as we handle them through CrewTask
                    getattr(new_crew, field.name).set(getattr(original_crew, field.name).all())
            
            # Copy crew tasks with their order
            crew_tasks = CrewTask.objects.filter(crew=original_crew).order_by('order')
            for crew_task in crew_tasks:
                CrewTask.objects.create(
                    crew=new_crew,
                    task=crew_task.task,
                    order=crew_task.order
                )
            
            messages.success(request, 'Crew duplicated successfully.')
            
            # Check for next URL in POST data first, then GET, then fall back to referer
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            
            # If no next parameter, check the referer
            referer = request.META.get('HTTP_REFERER', '')
            if 'card-view' in referer:
                return redirect('agents:manage_crews_card_view')
            return redirect('agents:manage_crews')
            
        except Exception as e:
            logger.error(f"Error duplicating crew: {str(e)}\n{traceback.format_exc()}")
            messages.error(request, f"Error duplicating crew: {str(e)}")
            # Check for next URL in POST data first, then GET, then fall back to referer
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            
            # If no next parameter, check the referer
            referer = request.META.get('HTTP_REFERER', '')
            if 'card-view' in referer:
                return redirect('agents:manage_crews_card_view')
            return redirect('agents:manage_crews')
            
    return redirect('agents:manage_crews')

@login_required
@user_passes_test(is_admin)
def update_crew_agents(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    if request.method == 'POST':
        agent_ids = request.POST.getlist('agents')
        crew.agents.set(agent_ids)
        
        # Update manager_agent if it's in the POST data
        manager_agent_id = request.POST.get('manager_agent')
        if manager_agent_id:
            crew.manager_agent_id = manager_agent_id
        else:
            crew.manager_agent = None
        
        crew.save()
        messages.success(request, 'Crew agents updated successfully.')
    return redirect('agents:manage_crews')

@login_required
@user_passes_test(is_admin)
def manage_crews_card_view(request):
    crews = Crew.objects.all().order_by('name')
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
        # Optionally, you can filter crews by the selected client if there's a relationship
        # crews = crews.filter(client=selected_client)
    
    context = {
        'page_title': 'Manage Crews',
        'crews': crews,
        'selected_client': selected_client,
    }
    return render(request, 'agents/manage_crews_card_view.html', context)

@login_required
def crew_create_or_update(request, crew_id=None):
    if crew_id:
        crew = get_object_or_404(Crew, id=crew_id)
    else:
        crew = None

    next_url = request.GET.get('next') or request.POST.get('next')

    if request.method == 'POST':
        form = CrewForm(request.POST, instance=crew)
        if form.is_valid():
            crew = form.save(commit=False)
            
            # Handle input variables - ensure it's a proper JSON array
            input_variables = request.POST.getlist('input_variables[]')
            # Filter out empty strings and convert to list
            input_variables = [var.strip() for var in input_variables if var.strip()]
            # Store as JSON array
            crew.input_variables = input_variables if input_variables else []
            
            crew.save()
            form.save_m2m()  # This is important for saving many-to-many relationships
            
            # Handle task order
            task_order = request.POST.getlist('task_order[]')
            CrewTask.objects.filter(crew=crew).delete()
            for index, task_id in enumerate(task_order):
                CrewTask.objects.create(crew=crew, task_id=task_id, order=index)
            
            messages.success(request, f'Crew {"updated" if crew_id else "created"} successfully.')
            
            if next_url:
                return redirect(next_url)
            else:
                return redirect('agents:manage_crews')
        else:
            messages.error(request, f'Error {"updating" if crew_id else "creating"} crew. Please check the form.')
    else:
        form = CrewForm(instance=crew)
        input_variables = crew.input_variables if crew and crew.input_variables else []

    context = {
        'page_title': 'Create or Update Crew',
        'form': form,
        'crew': crew,
        'input_variables_json': json.dumps(input_variables if input_variables else []),
        'next': next_url,
    }

    return render(request, 'agents/crew_form.html', context)

================
File: apps/agents/views_kanban.py
================
from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_protect
from django.utils import timezone
import json
from django.core.cache import cache
from celery import current_app

from .models import Crew, CrewExecution, ExecutionStage, Task, Agent, CrewTask
from apps.seo_manager.models import Client
from apps.agents.tasks.messaging.execution_bus import ExecutionMessageBus

import logging
logger = logging.getLogger(__name__)

@login_required
def crew_kanban(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    client_id = request.GET.get('client_id')
    client = get_object_or_404(Client, id=client_id) if client_id else None
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        # Get executions for this crew
        executions = CrewExecution.objects.filter(
            crew=crew,
            client=client
        ).prefetch_related('stages')
        
        execution_data = []
        for execution in executions:
            stages = execution.stages.all()
            stage_data = {}
            
            for stage in stages:
                stage_data[stage.stage_type] = {
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None
                }
                
                # Add stage-specific metadata
                if stage.metadata:
                    stage_data[stage.stage_type].update(stage.metadata)
            
            execution_data.append({
                'id': execution.id,
                'name': f'Execution #{execution.id}',
                'status': execution.status,
                'stages': stage_data
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'executions': execution_data
        })
    
    # Add page_title to the context
    context = {
        'crew': crew,
        'client': client,
        'tasks': kanban_tasks,
        'page_title': 'Crew Run',
    }
    return render(request, 'agents/crew_kanban.html', context)

@login_required
@require_http_methods(['POST'])
@csrf_protect
def start_execution(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    
    try:
        data = json.loads(request.body)
        client_id = data.get('client_id')
        client = None
            
        # Only try to get a client if client_id is provided and not "null"
        if client_id and client_id != "null":
            client = get_object_or_404(Client, id=client_id)
        
        # Get the first task for this crew
        crew_task = CrewTask.objects.filter(crew=crew).order_by('order').first()
        if not crew_task:
            return JsonResponse({
                'status': 'error',
                'message': 'No tasks found for this crew'
            }, status=400)
        
        # Create new execution with optional client
        execution_data = {
            'crew': crew,
            'status': 'PENDING',
            'inputs': {'client_id': client_id} if client_id and client_id != "null" else {},
            'user': request.user
        }
        
        # Only include client if we have one
        if client:
            execution_data['client'] = client
            
        execution = CrewExecution.objects.create(**execution_data)
        
        # Create initial stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='task_start',
            title='Starting New Execution',
            content='Initializing crew execution workflow',
            status='pending'
        )
        
        # Start the Celery task
        from .tasks import execute_crew
        task = execute_crew.delay(execution.id)
        
        # Update execution with task_id immediately
        execution.task_id = task.id
        execution.save()
        
        # Use ExecutionMessageBus for notifications
        message_bus = ExecutionMessageBus(execution.id)
        message_bus.publish('execution_update', {
            'status': 'PENDING',
            'message': 'New execution started',
            'crewai_task_id': crew_task.task.id,  # For proper board placement
            'stage': {
                'stage_type': 'task_start',
                'title': 'Starting New Execution',
                'content': 'Initializing crew execution workflow',
                'status': 'pending'
            }
        })
        
        return JsonResponse({
            'status': 'success',
            'execution_id': execution.id,
            'task_id': crew_task.task.id
        })
        
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        logger.error(f'Error starting execution: {str(e)}', exc_info=True)
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(['GET'])
def get_active_executions(request, crew_id):
    """Get all active executions for a crew"""
    crew = get_object_or_404(Crew, id=crew_id)
    
    # Get all in-progress executions for this crew
    executions = CrewExecution.objects.filter(
        crew=crew,
        status__in=['pending', 'in_progress']
    ).prefetch_related('stages')
    
    execution_data = []
    for execution in executions:
        stages = execution.stages.all()
        stage_data = {}
        
        for stage in stages:
            stage_data[stage.stage_type] = {
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None
            }
            
            if stage.metadata:
                stage_data[stage.stage_type].update(stage.metadata)
        
        execution_data.append({
            'execution_id': execution.id,
            'task_id': execution.task_id if hasattr(execution, 'task_id') else None,
            'name': f'Execution #{execution.id}',
            'status': execution.status,
            'stages': stage_data
        })
    
    return JsonResponse({'executions': execution_data})

@login_required
@require_http_methods(['POST'])
@csrf_protect
def submit_human_input(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    try:
        data = json.loads(request.body)
        input_text = data.get('input')
        
        if not input_text:
            return JsonResponse({
                'status': 'error',
                'message': 'Input text is required'
            }, status=400)
        
        # Update execution with human input
        execution.human_input_response = {'input': input_text}
        execution.status = 'RUNNING'
        execution.save()
        
        # Set response in cache with correct key format
        input_key = f"execution_{execution_id}_task_0_input"  # We use task 0 as that's the current task
        cache.set(input_key, input_text, timeout=3600)
        
        # Create human input stage
        stage = ExecutionStage.objects.create(
            execution=execution,
            stage_type='human_input',
            title='Human Input Received',
            content=input_text,
            status='completed',
            metadata={
                'input_timestamp': timezone.now().isoformat()
            }
        )
        
        # Use ExecutionMessageBus for notifications
        message_bus = ExecutionMessageBus(execution_id)
        message_bus.publish('execution_update', {
            'status': 'RUNNING',
            'message': 'Human input received',
            'stage': {
                'stage_type': 'human_input',
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'completed': True,
                'agent': 'Human'
            }
        })
        
        return JsonResponse({'status': 'success'})
        
    except json.JSONDecodeError:
        return JsonResponse({
            'status': 'error',
            'message': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
@require_http_methods(["POST"])
def cancel_execution(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    if execution.task_id:
        # Revoke the Celery task
        current_app.control.revoke(task_id=execution.task_id, terminate=True)
        
        # Update execution status
        execution.status = 'CANCELLED'
        execution.save()
        
        # Notify about cancellation
        message_bus = ExecutionMessageBus(execution_id)
        message_bus.publish('execution_update', {
            'status': 'CANCELLED',
            'message': 'Execution cancelled by user',
            'stage': {
                'stage_type': 'cancellation',
                'title': 'Execution Cancelled',
                'content': 'The execution was cancelled by the user',
                'status': 'cancelled',
                'agent': 'System'
            }
        })
        
        return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error', 'message': 'No task ID found'}, status=404)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution.objects.select_related('crew', 'crew_output'), id=execution_id)
    crew = execution.crew
    
    # Define the columns we want to show
    columns = [
        {'id': 'task_start', 'name': 'Task Start'},
        {'id': 'thinking', 'name': 'Thinking'},
        {'id': 'tool_usage', 'name': 'Tool Usage'},
        {'id': 'tool_results', 'name': 'Tool Results'},
        {'id': 'human_input', 'name': 'Human Input'},
        {'id': 'completion', 'name': 'Completion'}
    ]
    
    # Get all stages for this execution
    stages = execution.stages.all().select_related('agent').order_by('created_at')
    
    # Get all messages for this execution
    messages = execution.messages.all().order_by('timestamp')
    
    # Organize stages by stage_type
    kanban_columns = []
    for column in columns:
        column_stages = []
        
        # Add stages for this column
        for stage in stages:
            if stage.stage_type == column['id']:
                stage_data = {
                    'id': stage.id,
                    'title': stage.title,
                    'content': stage.content,
                    'status': stage.status,
                    'agent': stage.agent.name if stage.agent else None,
                    'created_at': stage.created_at,
                    'metadata': stage.metadata or {},
                    'type': 'stage'
                }
                column_stages.append(stage_data)
        
        # Add messages that might be related to this stage type
        if column['id'] == 'thinking':
            for message in messages:
                column_stages.append({
                    'id': f'msg_{message.id}',
                    'title': f'Message from {message.agent}',
                    'content': message.content,
                    'status': 'completed',
                    'agent': message.agent,
                    'created_at': message.timestamp,
                    'type': 'message'
                })
        
        # Add crew output to completion column
        if column['id'] == 'completion' and execution.crew_output:
            output_data = {
                'id': 'output',
                'title': 'Final Output',
                'content': execution.crew_output.raw,
                'status': 'completed',
                'created_at': execution.updated_at,
                'type': 'output',
                'metadata': {
                    'json_output': execution.crew_output.json_dict,
                    'token_usage': execution.crew_output.token_usage
                }
            }
            column_stages.append(output_data)
        
        kanban_columns.append({
            'id': column['id'],
            'name': column['name'],
            'stages': sorted(column_stages, key=lambda x: x['created_at'])
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': crew,
        'columns': kanban_columns
    }
    
    return render(request, 'agents/execution_detail.html', context)

================
File: apps/agents/views_tasks.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from .models import Task
from .forms import TaskForm
import traceback

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

@login_required
@user_passes_test(is_admin)
def manage_tasks(request):
    tasks = Task.objects.all().order_by('description')
    # Add page_title to the context
    context = {
        'tasks': tasks,
        'page_title': 'Manage Tasks',
    }
    return render(request, 'agents/manage_tasks.html', context)

@login_required
@user_passes_test(is_admin)
def add_task(request):
    if request.method == 'POST':
        form = TaskForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task added successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        form = TaskForm(request.POST, instance=task)
        if form.is_valid():
            form.save()
            messages.success(request, 'Task updated successfully.')
            return redirect('agents:manage_tasks')
    else:
        form = TaskForm(instance=task)
    # Add page_title to the context
    context = {
        'form': form,
        'task': task,
        'page_title': 'Edit Task',
    }
    return render(request, 'agents/task_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_task(request, task_id):
    task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        task.delete()
        messages.success(request, 'Task deleted successfully.')
        return redirect('agents:manage_tasks')
    context = {
        'object': task,
        'type': 'task',
        'page_title': 'Delete Task',
    }
    return render(request, 'agents/confirm_delete.html', context)

@login_required
@user_passes_test(is_admin)
def duplicate_task(request, task_id):
    original_task = get_object_or_404(Task, id=task_id)
    if request.method == 'POST':
        try:
            # Get all field values except id and auto-generated fields
            field_values = {
                field.name: getattr(original_task, field.name)
                for field in original_task._meta.fields
                if not field.primary_key and not field.auto_created
            }
            
            # Modify the description for the copy
            field_values['description'] = f"{field_values['description']} (Copy)"
            
            # Create new task with copied values
            new_task = Task.objects.create(**field_values)
            
            # Copy many-to-many relationships if any
            for field in original_task._meta.many_to_many:
                getattr(new_task, field.name).set(getattr(original_task, field.name).all())
            
            messages.success(request, 'Task duplicated successfully.')
            
            # Check for next URL in POST data first, then GET
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            return redirect('agents:manage_tasks')
            
        except Exception as e:
            logger.error(f"Error duplicating task: {str(e)}\n{traceback.format_exc()}")
            messages.error(request, f"Error duplicating task: {str(e)}")
            next_url = request.POST.get('next') or request.GET.get('next')
            if next_url:
                return redirect(next_url)
            return redirect('agents:manage_tasks')
            
    return redirect('agents:manage_tasks')

================
File: apps/agents/views_tools.py
================
import logging
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, user_passes_test
from django.contrib import messages
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
import traceback
from .models import Tool
from .forms import ToolForm
from .utils import get_available_tools, get_tool_classes, get_tool_description, get_tool_class_obj, load_tool
from pydantic import BaseModel
import inspect
import json
import tiktoken
import csv
from io import StringIO
import asyncio
from asgiref.sync import sync_to_async

# Import the generic run_tool task
from .tasks.tools import run_tool

logger = logging.getLogger(__name__)

def is_admin(user):
    return user.is_staff or user.is_superuser

def count_tokens(text):
    encoding = tiktoken.encoding_for_model("gpt-3.5-turbo")
    return len(encoding.encode(text))

@login_required
@user_passes_test(is_admin)
def manage_tools(request):
    tools = Tool.objects.all().order_by('name')
    return render(request, 'agents/manage_tools.html', {'tools': tools, 'page_title': 'Manage Tools'})

@login_required
@user_passes_test(is_admin)
def add_tool(request):
    if request.method == 'POST':
        form = ToolForm(request.POST)
        #logger.debug(f"POST data: {request.POST}")
        if form.is_valid():
            tool = form.save(commit=False)
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            logger.debug(f"Adding tool: class={tool_class}, subclass={tool_subclass}")
            
            # Get the tool class object and its description
            tool_classes = get_tool_classes(tool_class)
            logger.debug(f"Available tool classes: {[cls.__name__ for cls in tool_classes]}")
            if tool_classes:
                tool_class_obj = next((cls for cls in tool_classes if cls.__name__ == tool_subclass), None)
                if tool_class_obj:
                    logger.debug(f"Tool class object: {tool_class_obj}")
                    
                    # Log before and after getting tool description
                    logger.debug(f"Before getting description for {tool_subclass}")
                    tool.description = get_tool_description(tool_class_obj)
                    logger.debug(f"After getting description: {tool.description[:100]}...")
                    
                    # Save the tool
                    tool.save()
                    
                    messages.success(request, 'Tool added successfully.')
                    return redirect('agents:manage_tools')
                else:
                    messages.error(request, f'Tool subclass {tool_subclass} not found.')
            else:
                messages.error(request, 'Tool class not found.')
        else:
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
            logger.error(f"Form errors: {form.errors}")
    else:
        form = ToolForm()
    # Add page_title to the context
    context = {
        'form': form,
        'page_title': 'Add Tool',
    }
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def edit_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        form = ToolForm(request.POST, instance=tool)
        if form.is_valid():
            tool = form.save(commit=False)
            tool.name = form.cleaned_data['tool_subclass']
            tool_class = form.cleaned_data['tool_class']
            tool_subclass = form.cleaned_data['tool_subclass']
            
            tool_class_obj = get_tool_class_obj(tool_class, tool_subclass)
            tool.description = get_tool_description(tool_class_obj)
            tool.save()
            messages.success(request, 'Tool updated successfully.')
            return redirect('agents:manage_tools')
    else:
        form = ToolForm(instance=tool)
    # Add page_title to the context
    context = {
        'form': form,
        'tool': tool,
        'page_title': 'Edit Tool',
    }
    
    return render(request, 'agents/tool_form.html', context)

@login_required
@user_passes_test(is_admin)
def delete_tool(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    if request.method == 'POST':
        tool.delete()
        messages.success(request, 'Tool deleted successfully.')
        return redirect('agents:manage_tools')
    return render(request, 'agents/confirm_delete.html', {'object': tool, 'type': 'tool', 'page_title': 'Delete Tool'})

@login_required
@user_passes_test(is_admin)
def get_tool_info(request):
    tool_class = request.GET.get('tool_class')
    logger.info(f"Received request for tool_class: {tool_class}")
    
    if tool_class:
        try:
            tool_objects = get_tool_classes(tool_class)
            #logger.debug(f"Found tool objects: {[obj.__name__ for obj in tool_objects]}")
            
            class_info = []
            for obj in tool_objects:
                description = get_tool_description(obj)
                #logger.debug(f"Tool: {obj.__name__}, Description: {description}")
                class_info.append({
                    'name': obj.__name__,
                    'description': description
                })
            
            #logger.debug(f"Returning class_info: {class_info}")
            return JsonResponse({
                'classes': class_info
            })
        except ImportError as e:
            logger.error(f"ImportError: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"Failed to import tool module: {str(e)}"}, status=500)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            logger.error(f"Traceback: {traceback.format_exc()}")
            return JsonResponse({'error': f"An unexpected error occurred: {str(e)}"}, status=500)
    
    logger.warning("Invalid request: tool_class parameter is missing")
    return JsonResponse({'error': 'Invalid request: tool_class parameter is missing'}, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_schema(request, tool_id):
    tool = get_object_or_404(Tool, id=tool_id)
    try:
        tool_class = get_tool_class_obj(tool.tool_class, tool.tool_subclass)
        
        
        manual_schema = {
            "type": "object",
            "properties": {}
        }

        # Access schema through Pydantic's model fields
        if hasattr(tool_class, 'model_fields') and 'args_schema' in tool_class.model_fields:
            
            schema_class = tool_class.model_fields['args_schema'].default
            
            if issubclass(schema_class, BaseModel):
                # Use Pydantic v2 method if available
                if hasattr(schema_class, 'model_json_schema'):
                    schema = schema_class.model_json_schema()
                else:
                    schema = schema_class.schema()
                
                for field_name, field_info in schema.get('properties', {}).items():
                    manual_schema['properties'][field_name] = {
                        "type": field_info.get('type', 'string'),
                        "title": field_info.get('title', field_name.capitalize()),
                        "description": field_info.get('description', '')
                    }

        if not manual_schema["properties"]:
            logger.warning("No properties found in schema")
            return JsonResponse({'error': 'No input fields found for this tool'}, status=400)

        return JsonResponse(manual_schema)
    except Exception as e:
        logger.error(f"Schema error: {str(e)}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@user_passes_test(is_admin)
def get_clients(request):
    """Get a list of clients for the tool testing form using organization context"""
    try:
        from apps.seo_manager.models import Client
        
        # First try to get organization from request
        organization = getattr(request, 'organization', None)
        
        # If not found, try to get from session
        if not organization and 'active_organization_id' in request.session:
            from django.apps import apps
            Organization = apps.get_model('organizations', 'Organization')
            try:
                organization = Organization.objects.get(id=request.session['active_organization_id'])
            except Exception as e:
                logger.warning(f"Failed to get organization from session: {e}")
        
        # If still not found, try to get the user's primary organization
        if not organization:
            from django.apps import apps
            OrganizationMembership = apps.get_model('organizations', 'OrganizationMembership')
            try:
                # Get the first active membership
                membership = OrganizationMembership.objects.filter(
                    user=request.user, 
                    status='active'
                ).select_related('organization').first()
                
                if membership:
                    organization = membership.organization
            except Exception as e:
                logger.warning(f"Failed to get user's organization membership: {e}")
        
        # If we still don't have an organization, fail with a clear message
        if not organization:
            logger.warning("No organization context found when fetching clients")
            return JsonResponse({
                'error': 'No active organization found. Please select an organization from the dropdown in the navigation bar.'
            }, status=400)
        
        # Log the organization we're using
        logger.info(f"Using organization: {organization.name} (ID: {organization.id}) for client list")
        
        # Get clients for the current organization
        clients = Client.objects.filter(organization=organization).values('id', 'name', 'website_url')
        clients_list = list(clients)
        
        # Log the number of clients found
        logger.info(f"Found {len(clients_list)} clients for organization {organization.name}")
        
        return JsonResponse(clients_list, safe=False)
    except Exception as e:
        logger.error(f"Error getting clients: {str(e)}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@user_passes_test(is_admin)
def get_client_attributes(request, client_id):
    """Get client attributes needed for tools, respecting organization context"""
    try:
        from apps.seo_manager.models import Client
        
        # First try to get organization from request
        organization = getattr(request, 'organization', None)
        
        # If not found, try to get from session
        if not organization and 'active_organization_id' in request.session:
            from django.apps import apps
            Organization = apps.get_model('organizations', 'Organization')
            try:
                organization = Organization.objects.get(id=request.session['active_organization_id'])
            except Exception as e:
                logger.warning(f"Failed to get organization from session: {e}")
        
        # If still not found, try to get the user's primary organization
        if not organization:
            from django.apps import apps
            OrganizationMembership = apps.get_model('organizations', 'OrganizationMembership')
            try:
                # Get the first active membership
                membership = OrganizationMembership.objects.filter(
                    user=request.user, 
                    status='active'
                ).select_related('organization').first()
                
                if membership:
                    organization = membership.organization
            except Exception as e:
                logger.warning(f"Failed to get user's organization membership: {e}")
        
        # If we still don't have an organization, fail with a clear message
        if not organization:
            logger.warning("No organization context found when fetching client attributes")
            return JsonResponse({
                'error': 'No active organization found. Please select an organization from the dropdown in the navigation bar.'
            }, status=400)
        
        # Log the organization we're using
        logger.info(f"Using organization: {organization.name} (ID: {organization.id}) for client attributes")
        
        # Get the client, ensuring it belongs to the current organization
        client = get_object_or_404(Client, id=client_id, organization=organization)
        
        # Begin with basic client information
        client_attributes = {
            'client_id': str(client.id),
            'client_name': client.name,
            'website_url': client.website_url,
        }
        
        # Add flags for available related models
        has_models = {}
        
        # Function to safely get attributes from a model instance
        def get_safe_model_attributes(model_instance, exclude_fields=None):
            if not model_instance:
                return {}
                
            if exclude_fields is None:
                exclude_fields = ['_state']
                
            # Try to convert the model to a dictionary
            model_dict = {}
            
            try:
                # First try model's to_dict method if it exists
                if hasattr(model_instance, 'to_dict') and callable(getattr(model_instance, 'to_dict')):
                    model_dict = model_instance.to_dict()
                # Otherwise use the model's fields
                else:
                    for field in model_instance._meta.fields:
                        field_name = field.name
                        if field_name not in exclude_fields:
                            model_dict[field_name] = getattr(model_instance, field_name)
                            
                # Handle special serialization cases
                safe_dict = {}
                for key, value in model_dict.items():
                    # Skip None values
                    if value is None:
                        safe_dict[key] = None
                        continue
                        
                    # Convert datetime objects to isoformat strings
                    if hasattr(value, 'isoformat'):
                        safe_dict[key] = value.isoformat()
                    # Convert UUID objects to strings
                    elif hasattr(value, 'hex'):
                        safe_dict[key] = str(value)
                    # Convert model instances to their ID or string representation
                    elif hasattr(value, '_meta') and hasattr(value, 'pk'):
                        # This is likely a Django model instance
                        safe_dict[key] = str(value.pk)
                    # Convert binary data to base64
                    elif isinstance(value, bytes):
                        import base64
                        safe_dict[key] = base64.b64encode(value).decode('utf-8')
                    # Handle querysets
                    elif hasattr(value, 'all') and callable(getattr(value, 'all')):
                        # Skip querysets/managers to prevent recursion
                        continue
                    # Handle any other types that might be serializable
                    else:
                        try:
                            # Test if it's JSON serializable
                            json.dumps(value)
                            safe_dict[key] = value
                        except (TypeError, OverflowError):
                            # If not serializable, use string representation
                            safe_dict[key] = str(value)
                
                # Replace model_dict with the sanitized version
                model_dict = safe_dict
                
                # Add any accessor methods that return useful data
                if hasattr(model_instance, 'get_property_id') and callable(getattr(model_instance, 'get_property_id')):
                    try:
                        property_id = model_instance.get_property_id()
                        # Make sure it's serializable
                        model_dict['property_id'] = str(property_id) if property_id is not None else None
                    except Exception as e:
                        logger.warning(f"Failed to get property_id: {e}")
                        
                if hasattr(model_instance, 'get_property_url') and callable(getattr(model_instance, 'get_property_url')):
                    try:
                        property_url = model_instance.get_property_url()
                        # Make sure it's serializable
                        model_dict['property_url'] = str(property_url) if property_url is not None else None
                    except Exception as e:
                        logger.warning(f"Failed to get property_url: {e}")
                
                return model_dict
            except Exception as e:
                logger.warning(f"Failed to convert model to dictionary: {e}")
                return {}
        
        # Handle Google Analytics credentials
        if hasattr(client, 'ga_credentials') and client.ga_credentials:
            has_models['has_analytics'] = True
            ga_creds = get_safe_model_attributes(client.ga_credentials)
            if ga_creds:
                client_attributes['analytics_credentials'] = ga_creds
                # Try to extract a property ID if not already included
                if 'property_id' in ga_creds:
                    client_attributes['analytics_property_id'] = ga_creds['property_id']
                elif 'view_id' in ga_creds:  # Fallback for older GA3 structure
                    client_attributes['analytics_property_id'] = ga_creds['view_id']
        else:
            has_models['has_analytics'] = False
        
        # Handle Search Console credentials
        if hasattr(client, 'sc_credentials') and client.sc_credentials:
            has_models['has_search_console'] = True
            sc_creds = get_safe_model_attributes(client.sc_credentials)
            if sc_creds:
                client_attributes['search_console_credentials'] = sc_creds
                # Try to extract a property URL if not already included
                if 'property_url' in sc_creds:
                    client_attributes['search_console_property_url'] = sc_creds['property_url']
                elif 'property_id' in sc_creds:  # Alternative property identifier
                    client_attributes['search_console_property_url'] = sc_creds['property_id']
        else:
            has_models['has_search_console'] = False
        
        # Handle targeted keywords - get only fields that exist
        if hasattr(client, 'targeted_keywords'):
            try:
                # First check which fields exist
                keyword_fields = [f.name for f in client.targeted_keywords.model._meta.fields 
                                if f.name not in ['id', 'client', 'client_id']]
                
                # Always include id
                keyword_fields = ['id'] + keyword_fields
                
                # Get keywords with available fields
                keywords = list(client.targeted_keywords.all().values(*keyword_fields))
                
                if keywords:
                    client_attributes['targeted_keywords'] = keywords
                    has_models['has_targeted_keywords'] = True
                    logger.info(f"Added {len(keywords)} targeted keywords with fields: {keyword_fields}")
                else:
                    has_models['has_targeted_keywords'] = False
            except Exception as e:
                logger.warning(f"Failed to fetch targeted keywords: {e}")
                has_models['has_targeted_keywords'] = False
        else:
            has_models['has_targeted_keywords'] = False
        
        # Add availability flags to the response
        client_attributes.update(has_models)
        
        return JsonResponse(client_attributes)
        
    except Exception as e:
        logger.error(f"Error getting client attributes: {str(e)}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@user_passes_test(is_admin)
@require_http_methods(["POST"])
def test_tool(request, tool_id):
    """Run a tool test using Celery for both sync and async tools"""
    logger.debug(f"Starting test_tool for tool_id: {tool_id}")
    tool = get_object_or_404(Tool, id=tool_id)
    logger.debug(f"Found tool: {tool.name}")
    
    # Get inputs from request
    inputs = {key: value for key, value in request.POST.items() if key != 'csrfmiddlewaretoken'}
    logger.debug(f"Raw POST inputs for test_tool: {inputs}") # Log raw inputs
    
    # Check if this is a tool that uses client attributes
    client_attributes_json = inputs.pop('client_attributes', None)
    if client_attributes_json:
        try:
            client_attributes = json.loads(client_attributes_json)
            for key, value in client_attributes.items():
                if key.startswith('has_'):
                    continue
                inputs[key] = value
            logger.debug(f"Inputs after merging client_attributes: {inputs}")
        except json.JSONDecodeError:
            logger.error("Failed to parse client attributes JSON")
    
    # Serialize complex inputs
    serialized_inputs = {}
    for key, value in inputs.items():
        if key == 'analytics_property_id' and value is not None:
            serialized_inputs[key] = str(value)
        elif isinstance(value, (dict, list)):
            try:
                serialized_inputs[key] = json.dumps(value)
            except (TypeError, ValueError) as e:
                logger.error(f"Failed to serialize {key}: {e}")
                serialized_inputs[key] = str(value)
        else:
            serialized_inputs[key] = value
    
    logger.debug(f"Serialized inputs being sent to task: {serialized_inputs}") # Log final serialized inputs
    
    # Get organization_id from request
    organization = getattr(request, 'organization', None)
    if not organization:
        logger.error("Organization context not found in request object for test_tool.")
        return JsonResponse({'error': 'Organization context missing.'}, status=500)
    organization_id = str(organization.id)
    
    try:
        # Use the generic run_tool task
        logger.debug(f"Using generic task function: {run_tool.__name__}")

        # Prepare task arguments for the generic run_tool task
        task_args = (tool_id, serialized_inputs, organization_id)

        # Start Celery task
        task = run_tool.delay(*task_args)
        logger.debug(f"Task queued successfully with ID: {task.id}")
        
        return JsonResponse({
            'status': 'started',
            'task_id': task.id,
            'message': f'Tool execution started. Task ID: {task.id}'
        })
        
    except Exception as e:
        logger.error(f"Error starting tool execution: {str(e)}", exc_info=True)
        return JsonResponse({
            'error': str(e)
        }, status=400)

@login_required
@user_passes_test(is_admin)
def get_tool_status(request, task_id):
    """Get the status of a tool execution"""
    from celery.result import AsyncResult
    
    task = AsyncResult(task_id)
    
    response = {
        'status': task.status,
        'token_count': 0
    }
    
    # Get task meta information
    if task.status in ['PENDING', 'STARTED', 'PROGRESS']:
        # Try to get state meta information from different possible sources
        meta = None
        if hasattr(task, 'info') and task.info:
            meta = task.info
        elif hasattr(task, 'result') and isinstance(task.result, dict):
            meta = task.result
        elif task.backend and hasattr(task.backend, 'get_task_meta'):
            try:
                meta = task.backend.get_task_meta(task_id)
                if 'result' in meta and isinstance(meta['result'], dict):
                    meta = meta['result']
            except Exception as e:
                logger.warning(f"Failed to get task meta: {e}")
        
        if meta:
            # Include all meta information
            if isinstance(meta, dict):
                response.update(meta)
            #logger.debug(f"Task meta information: {meta}")
    
    if task.ready():
        if task.successful():
            try:
                result = task.get()
                #logger.debug(f"Raw task result: {result} (Type: {type(result)})")
                
                # Preserve existing response structure
                if isinstance(result, dict):
                    response.update({
                        'result': result.get('result', ''),
                        'error': result.get('error')
                    })
                else:
                    response['result'] = str(result)
                
                # Calculate tokens from the original result
                if isinstance(result, (dict, list)):
                    output_text = json.dumps(result, indent=2)
                else:
                    output_text = str(result)
                
                #logger.debug(f"Formatted output text for token counting: {output_text[:200]}...")  # Log first 200 chars
                token_count = count_tokens(output_text)
                #logger.debug(f"Calculated token count: {token_count}")
                response['token_count'] = token_count
                
            except Exception as e:
                logger.error(f"Error processing task result: {str(e)}")
                response.update({
                    'status': 'FAILURE',
                    'error': str(e)
                })
        else:
            logger.error(f"Task failed: {task.result}")
            response.update({
                'error': str(task.result)
            })
    
    #logger.debug(f"Returning status response: {response}")
    return JsonResponse(response)

================
File: apps/agents/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.paginator import Paginator
from django.http import JsonResponse
from django.views.decorators.http import require_POST, require_http_methods
from django.views.decorators.csrf import csrf_exempt, csrf_protect
from .models import Crew, CrewExecution, CrewMessage, Agent, CrewTask, Task, UserSlackIntegration
from .forms import CrewExecutionForm, HumanInputForm, AgentForm
from .tasks import execute_crew
from django.core.exceptions import ValidationError
import logging
import json
from django.urls import reverse
from django.core.cache import cache
from django.conf import settings
import os
from apps.seo_manager.models import Client  # Import the Client model
from markdown_it import MarkdownIt  # Import markdown-it
from apps.common.utils import get_models
from slack_sdk.oauth import AuthorizeUrlGenerator
from slack_sdk.web import WebClient
from apps.agents.tasks.messaging.execution_bus import ExecutionMessageBus

logger = logging.getLogger(__name__)

# Initialize the MarkdownIt instance
md = MarkdownIt()

@login_required
@csrf_exempt
def connection_test(request):
    return render(request, 'agents/connection_test.html')

@login_required
def crewai_home(request):
    crews = Crew.objects.all()  # Get the first 3 crews for the summary
    recent_executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')[:10]
    clients = Client.objects.all()  # Get all clients
    
    # Get the selected client_id from the request, fallback to session
    selected_client_id = request.GET.get('client_id') or request.session.get('selected_client_id')
    
    if selected_client_id:
        request.session['selected_client_id'] = selected_client_id
    else:
        # If no client is selected, remove it from the session
        request.session.pop('selected_client_id', None)
    
    context = {
        'page_title': 'Crews Home',
        'crews': crews,
        'recent_executions': recent_executions,
        'clients': clients,
        'selected_client_id': selected_client_id,
    }
    return render(request, 'agents/crewai_home.html', context)

@login_required
def crew_list(request):
    logger.debug("Entering crew_list view")
    crews = Crew.objects.all()
    # Add page_title to the context
    context = {
        'crews': crews,
        'page_title': 'Crew List',
    }
    return render(request, 'agents/crew_list.html', context)

@login_required
def crew_detail(request, crew_id):
    crew = get_object_or_404(Crew, id=crew_id)
    recent_executions = CrewExecution.objects.filter(crew=crew).order_by('-created_at')[:5]
    
    # Get the selected client_id from the session
    selected_client_id = request.session.get('selected_client_id')
    selected_client = None
    if selected_client_id:
        selected_client = get_object_or_404(Client, id=selected_client_id)
    
    if request.method == 'POST':
        form = CrewExecutionForm(request.POST)
        if form.is_valid():
            execution = form.save(commit=False)
            execution.crew = crew
            execution.user = request.user
            execution.client = selected_client  # Associate the selected client with the execution
            
            # Handle input variables
            input_variables = json.loads(request.POST.get('input_variables', '{}'))
            execution.inputs = input_variables
            
            execution.save()
            
            # Start the execution
            execute_crew.delay(execution.id)
            
            messages.success(request, 'Crew execution started.')
            return JsonResponse({'status': 'success', 'execution_id': execution.id})
    else:
        form = CrewExecutionForm()
    
    context = {
        'page_title': 'Crew Detail',
        'crew': crew,
        'form': form,
        'recent_executions': recent_executions,
        'selected_client': selected_client,
    }
    return render(request, 'agents/crew_detail.html', context)

@login_required
def execution_list(request):
    logger.debug("Entering execution_list view")
    executions = CrewExecution.objects.filter(user=request.user).order_by('-created_at')
    crews = Crew.objects.all()

    # Apply filters
    crew_id = request.GET.get('crew')
    status = request.GET.get('status')

    if crew_id:
        executions = executions.filter(crew_id=crew_id)
    if status:
        executions = executions.filter(status=status)

    # Pagination
    paginator = Paginator(executions, 10)  # Show 10 executions per page
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_title': 'Execution List',
        'executions': page_obj,
        'crews': crews,
    }
    return render(request, 'agents/execution_list.html', context)

@login_required
def execution_detail(request, execution_id):
    execution = get_object_or_404(CrewExecution, id=execution_id)
    
    # Get all tasks for this crew through CrewTask
    crew_tasks = CrewTask.objects.filter(crew=execution.crew).select_related('task')
    kanban_tasks = []
    
    for crew_task in crew_tasks:
        task = crew_task.task
        stages = execution.stages.filter(task=task).order_by('created_at')
        
        stage_data = []
        for stage in stages:
            stage_data.append({
                'id': stage.id,
                'title': stage.title,
                'content': stage.content,
                'status': stage.status,
                'agent': stage.agent.name if stage.agent else None,
                'created_at': stage.created_at,
                'metadata': stage.metadata or {}
            })
        
        kanban_tasks.append({
            'id': task.id,
            'name': task.description,
            'stages': stage_data
        })
    
    context = {
        'page_title': 'Execution Detail',
        'execution': execution,
        'crew': execution.crew,
        'tasks': kanban_tasks
    }
    
    return render(request, 'agents/execution_detail.html', context)

@login_required
def execution_status(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        
        # Get the last message ID from the request
        last_message_id = request.GET.get('last_message_id')
        
        # Only fetch new messages if there are any
        if last_message_id:
            messages = CrewMessage.objects.filter(
                execution=execution,
                id__gt=last_message_id
            ).order_by('timestamp')
        else:
            messages = CrewMessage.objects.filter(
                execution=execution
            ).order_by('timestamp')
        
        # Get status badge class
        status_classes = {
            'PENDING': 'info',
            'RUNNING': 'primary',
            'WAITING_FOR_HUMAN_INPUT': 'warning',
            'COMPLETED': 'success',
            'FAILED': 'danger'
        }
        status_class = status_classes.get(execution.status, 'secondary')
        
        response_data = {
            'status': execution.get_status_display(),
            'status_class': status_class,
            'updated_at': execution.updated_at.isoformat(),
            'outputs': execution.outputs,
            'human_input_request': execution.human_input_request,
            'messages': [{
                'id': msg.id,
                'agent': msg.agent,
                'content': msg.content,
                'timestamp': msg.timestamp.strftime("%d %b %H:%M")
            } for msg in messages],
        }
        return JsonResponse(response_data)
    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)

@login_required
@csrf_protect
@require_POST
def provide_human_input(request, execution_id):
    try:
        execution = CrewExecution.objects.get(id=execution_id, user=request.user)
        if execution.status != 'WAITING_FOR_HUMAN_INPUT':
            return JsonResponse({'error': 'Execution is not waiting for human input'}, status=400)

        data = json.loads(request.body)
        user_input = data.get('input')

        if user_input is None:
            return JsonResponse({'error': 'No input provided'}, status=400)

        # Store the user input in the cache
        cache.set(f'human_input_response_{execution_id}', user_input, timeout=3600)
        logger.info(f"Stored user input for execution {execution_id}: {user_input}")

        # Update execution status
        execution.status = 'RUNNING'
        execution.save()

        # Use ExecutionMessageBus for consistent messaging
        message_bus = ExecutionMessageBus(execution_id)
        message_bus.publish('execution_update', {
            'status': 'RUNNING',
            'message': f'Input provided: {user_input}',
            'stage': {
                'stage_type': 'human_input',
                'title': 'Human Input',
                'content': f'Input provided: {user_input}',
                'status': 'completed',
                'agent': 'Human'
            }
        })

        return JsonResponse({
            'message': 'Human input received and processing resumed', 
            'input': user_input
        })

    except CrewExecution.DoesNotExist:
        return JsonResponse({'error': 'Execution not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    except Exception as e:
        logger.error(f"Error in provide_human_input: {str(e)}")
        return JsonResponse({'error': 'An unexpected error occurred'}, status=500)


@login_required
@require_POST
def submit_human_input(request, execution_id):
    input_key = request.POST.get('input_key')
    response = request.POST.get('response')
    
    if not input_key or not response:
        return JsonResponse({'error': 'Missing input_key or response'}, status=400)
    
    execution = get_object_or_404(CrewExecution, id=execution_id, user=request.user)
    
    # Store the response in the cache
    cache_key = f"{input_key}_response"
    cache.set(cache_key, response, timeout=3600)
    logger.info(f"Stored human input in cache for execution {execution_id}: key={cache_key}, value={response}")
    
    # Update execution status
    execution.status = 'RUNNING'
    execution.save()
    
    # Use ExecutionMessageBus for consistent messaging
    message_bus = ExecutionMessageBus(execution_id)
    message_bus.publish('execution_update', {
        'status': 'RUNNING',
        'message': f'Human input received: {response}',
        'stage': {
            'stage_type': 'human_input',
            'title': 'Human Input',
            'content': f'Input received: {response}',
            'status': 'completed',
            'agent': 'Human'
        }
    })
    
    return JsonResponse({'message': 'Human input received and processed'})

@login_required
def chat_view(request):
    clients = Client.objects.all().order_by('name')
    print(f"Found {clients.count()} clients")  # Debug print
    
    context = {
        'agents': Agent.objects.all(),
        'models': get_models(),
        'default_model': settings.GENERAL_MODEL,
        'clients': clients,
    }
    return render(request, 'agents/chat.html', context)

@login_required
def slack_oauth_start(request):
    """Start Slack OAuth flow"""
    redirect_uri = f"https://{settings.APP_DOMAIN}/agents/slack/oauth/callback/"
    authorize_url_generator = AuthorizeUrlGenerator(
        client_id=settings.DSLACK_CLIENT_ID,
        scopes=["chat:write", "channels:read", "channels:history"],
        redirect_uri=redirect_uri
    )
    authorize_url = authorize_url_generator.generate("")
    return redirect(authorize_url)

@login_required
def slack_oauth_callback(request):
    """Handle Slack OAuth callback"""
    code = request.GET.get('code')
    if not code:
        return JsonResponse({"error": "No code provided"}, status=400)
    
    try:
        client = WebClient()
        response = client.oauth_v2_access(
            client_id=settings.DSLACK_CLIENT_ID,
            client_secret=settings.DSLACK_CLIENT_SECRET,
            code=code
        )
        
        # Save the tokens
        integration, created = UserSlackIntegration.objects.update_or_create(
            user=request.user,
            defaults={
                'access_token': response['access_token'],
                'team_id': response['team']['id'],
                'team_name': response['team']['name'],
                'is_active': True
            }
        )
        
        messages.success(request, "Successfully connected to Slack!")
        return redirect('profile')
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)

================
File: apps/api/serializers.py
================
from rest_framework import serializers
from apps.agents.models import Agent, Task, Tool, Crew, CrewTask

# Tool Serializers
class GoogleAnalyticsToolSerializer(serializers.Serializer):
    client_id = serializers.IntegerField(required=True)
    start_date = serializers.CharField(default="28daysAgo")
    end_date = serializers.CharField(default="today") 
    metrics = serializers.CharField(default="totalUsers,sessions")
    dimensions = serializers.CharField(default="date")
    dimension_filter = serializers.CharField(required=False, allow_null=True)
    metric_filter = serializers.CharField(default="sessions>10")
    currency_code = serializers.CharField(required=False, allow_null=True)
    keep_empty_rows = serializers.BooleanField(default=False)
    limit = serializers.IntegerField(default=1000)
    offset = serializers.IntegerField(required=False, allow_null=True)
    data_format = serializers.ChoiceField(
        choices=['raw', 'summary', 'compact'],
        default='raw'
    )
    top_n = serializers.IntegerField(required=False, allow_null=True)
    time_granularity = serializers.ChoiceField(
        choices=['daily', 'weekly', 'monthly', 'auto'],
        default='auto'
    )
    aggregate_by = serializers.ListField(
        child=serializers.CharField(),
        required=False,
        allow_null=True
    )
    metric_aggregation = serializers.ChoiceField(
        choices=['sum', 'average', 'min', 'max'],
        default='sum'
    )
    include_percentages = serializers.BooleanField(default=False)
    normalize_metrics = serializers.BooleanField(default=False)
    round_digits = serializers.IntegerField(required=False, allow_null=True)
    include_period_comparison = serializers.BooleanField(default=False)
    detect_anomalies = serializers.BooleanField(default=False)
    moving_average_window = serializers.IntegerField(required=False, allow_null=True)

class ImageConversionSerializer(serializers.Serializer):
    image = serializers.ImageField(required=True)
    quality = serializers.IntegerField(
        min_value=1, 
        max_value=100, 
        default=65,  
        required=False
    )
    max_width = serializers.IntegerField(
        min_value=1,
        default=1920,  # Standard HD width
        required=False,
        allow_null=True
    )
    max_height = serializers.IntegerField(
        min_value=1,
        default=1080,  # Standard HD height
        required=False,
        allow_null=True
    )
from rest_framework import serializers
from apps.agents.models import Agent, Task, Tool, Crew, CrewTask

class ToolSerializer(serializers.ModelSerializer):
    class Meta:
        model = Tool
        fields = ['id', 'tool_class', 'tool_subclass', 'name', 'description', 'module_path']

class AgentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Agent
        fields = [
            'id', 'name', 'role', 'goal', 'backstory', 'llm', 'tools',
            'function_calling_llm', 'max_iter', 'max_rpm', 'max_execution_time',
            'verbose', 'allow_delegation', 'step_callback', 'cache',
            'system_template', 'prompt_template', 'response_template',
            'allow_code_execution', 'max_retry_limit', 'use_system_prompt',
            'respect_context_window', 'avatar'
        ]

class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        fields = [
            'id', 'description', 'agent', 'expected_output', 'tools',
            'async_execution', 'context', 'config', 'output_json',
            'output_pydantic', 'output_file', 'output', 'callback',
            'human_input', 'converter_cls'
        ]

class CrewTaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = CrewTask
        fields = ['crew', 'task', 'order']

class CrewSerializer(serializers.ModelSerializer):
    tasks = CrewTaskSerializer(source='crew_tasks', many=True, read_only=True)

    class Meta:
        model = Crew
        fields = [
            'id', 'name', 'agents', 'tasks', 'process', 'verbose',
            'manager_llm', 'function_calling_llm', 'config', 'max_rpm',
            'language', 'language_file', 'memory', 'cache', 'embedder',
            'full_output', 'share_crew', 'output_log_file', 'manager_agent',
            'manager_callbacks', 'prompt_file', 'planning', 'planning_llm',
            'input_variables'
        ]

================
File: apps/api/urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from rest_framework.authtoken.views import obtain_auth_token
from apps.api.views import *

router = DefaultRouter()
router.register(r'agents', AgentViewSet)
router.register(r'tasks', TaskViewSet)
router.register(r'tools', ToolViewSet)
router.register(r'crews', CrewViewSet)

urlpatterns = [
    # Existing endpoints
    path('token/', obtain_auth_token, name='api_token_auth'),
    path('tools/google-analytics/', GoogleAnalyticsToolView.as_view(), name='google-analytics-tool'),
    path('tools/image-optimize/', ImageOptimizeView.as_view(), name='image-optimize'),

    # New API endpoints
    path('', include(router.urls)),
]

================
File: apps/api/views.py
================
from http import HTTPStatus
from django.http import Http404
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.generics import get_object_or_404
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import TokenAuthentication, SessionAuthentication
from rest_framework.throttling import UserRateThrottle, AnonRateThrottle
from rest_framework.parsers import MultiPartParser
from PIL import Image
import io
from django.http import HttpResponse
import os

from apps.api.serializers import *
from apps.agents.tools.google_analytics_tool.generic_google_analytics_tool import GenericGoogleAnalyticsTool
import logging

from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated
from apps.agents.models import Agent, Task, Tool, Crew
from .serializers import AgentSerializer, TaskSerializer, ToolSerializer, CrewSerializer

logger = logging.getLogger(__name__)

class BaseToolView(APIView):
    """Base view for tool endpoints"""
    # permission_classes = (IsAuthenticated,)
    # authentication_classes = [TokenAuthentication, SessionAuthentication]
    tool_class = None
    serializer_class = None
    
    def post(self, request):
        serializer = self.serializer_class(data=request.data)
        if not serializer.is_valid():
            return Response(data={
                **serializer.errors,
                'success': False
            }, status=HTTPStatus.BAD_REQUEST)
            
        try:
            # Initialize the tool
            tool = self.tool_class()
            
            # Execute the tool with validated data
            result = tool._run(**serializer.validated_data)
            
            return Response(data={
                'data': result,
                'success': True
            }, status=HTTPStatus.OK)
            
        except Exception as e:
            return Response(data={
                'message': str(e),
                'success': False
            }, status=HTTPStatus.INTERNAL_SERVER_ERROR)

class GoogleAnalyticsToolView(BaseToolView):
    tool_class = GenericGoogleAnalyticsTool
    serializer_class = GoogleAnalyticsToolSerializer

class ImageOptimizeUserThrottle(UserRateThrottle):
    rate = '100/day'

    def allow_request(self, request, view):
        if request.user.is_authenticated:
            # Exempt staff and superusers from rate limiting
            if request.user.is_staff or request.user.is_superuser:
                return True
            
            # Exempt users with specific permissions
            if request.user.has_perm('api.unlimited_image_optimize'):
                return True
                
            # Exempt specific users by username or other criteria
            if request.user.username in ['premium_user1', 'premium_user2']:
                return True
                
        # For all other users, apply normal rate limiting
        return super().allow_request(request, view)

class ImageOptimizeAnonThrottle(AnonRateThrottle):
    rate = '10/day'

class ImageOptimizeView(APIView):
    authentication_classes = [TokenAuthentication, SessionAuthentication]
    permission_classes = [IsAuthenticated]
    throttle_classes = [ImageOptimizeUserThrottle, ImageOptimizeAnonThrottle]
    parser_classes = [MultiPartParser]
    
    SUPPORTED_FORMATS = {'JPEG', 'JPG', 'PNG', 'WEBP', 'GIF', 'BMP', 'TIFF'}
    MAX_DIMENSION = 3840  # 4K resolution max
    serializer_class = ImageConversionSerializer
    
    def process_image(self, image_file, quality, max_width=None, max_height=None):
        """Process a single image file and return optimized WebP response"""
        try:
            # Get original filename and size
            original_name = os.path.splitext(image_file.name)[0]
            original_size = image_file.size / 1024  # Convert to KB
            
            # Open image and get format
            img = Image.open(image_file)
            input_format = img.format  # Store format before any operations
            logger.info(f"Initial image: format={input_format}, mode={img.mode}, size={img.size}")
            
            # Add EXIF orientation handling
            try:
                exif = img._getexif()
                if exif:
                    orientation = exif.get(274)  # 274 is the orientation tag
                    if orientation:
                        # Rotate or flip the image according to EXIF orientation
                        rotate_values = {
                            3: Image.Transpose.ROTATE_180,
                            6: Image.Transpose.ROTATE_270,
                            8: Image.Transpose.ROTATE_90
                        }
                        if orientation in rotate_values:
                            img = img.transpose(rotate_values[orientation])
                            img.format = input_format  # Restore the format after rotation
                            logger.info(f"Applied EXIF rotation: {orientation}")
            except (AttributeError, KeyError, IndexError):
                logger.debug("No EXIF data found or unable to process EXIF")
                pass

            if not input_format:
                input_format = 'JPEG'  # Default to JPEG if format is unknown
                logger.warning(f"No format detected, defaulting to {input_format}")
                
            input_format = input_format.upper()
            logger.info(f"Processing image: format={input_format}, mode={img.mode}, size={img.size}")
            
            # Check if format is supported
            if input_format not in self.SUPPORTED_FORMATS:
                return Response(data={
                    'message': f'Unsupported image format: {input_format}',
                    'success': False
                }, status=HTTPStatus.BAD_REQUEST)
            
            # Handle alpha channel and color mode conversion
            if img.mode in ('RGBA', 'LA'):
                logger.info("Converting image with alpha channel")
                background = Image.new('RGB', img.size, (255, 255, 255))
                if img.mode == 'RGBA':
                    background.paste(img, mask=img.split()[3])
                else:
                    background.paste(img, mask=img.split()[1])
                img = background
            elif img.mode != 'RGB':
                logger.info(f"Converting {img.mode} image to RGB")
                img = img.convert('RGB')
            
            # Handle resizing
            if max_width or max_height or img.size[0] > self.MAX_DIMENSION or img.size[1] > self.MAX_DIMENSION:
                orig_width, orig_height = img.size
                target_width = min(max_width or self.MAX_DIMENSION, self.MAX_DIMENSION)
                target_height = min(max_height or self.MAX_DIMENSION, self.MAX_DIMENSION)
                
                ratio = min(target_width/orig_width, target_height/orig_height)
                
                if ratio < 1:
                    new_size = (int(orig_width * ratio), int(orig_height * ratio))
                    logger.info(f"Resizing image from {img.size} to {new_size}")
                    img = img.resize(new_size, Image.Resampling.LANCZOS)
            
            # Convert to WebP
            webp_buffer = io.BytesIO()
            img.save(
                webp_buffer,
                format='WEBP',
                quality=quality,
                method=6,  # Maximum compression
                lossless=False,  # Use lossy compression for better file size
                exact=False  # Allow WebP encoder to optimize
            )
            
            webp_buffer.seek(0)
            webp_content = webp_buffer.getvalue()
            new_size = len(webp_content) / 1024  # Convert to KB
            
            # Calculate size reduction
            size_reduction = ((original_size - new_size) / original_size) * 100
            
            logger.info(
                f"WebP conversion successful - Original: {original_size:.1f}K, "
                f"New: {new_size:.1f}K, "
                f"Reduction: {size_reduction:.1f}%"
            )
            
            response = HttpResponse(
                webp_content,
                content_type='image/webp'
            )
            response['Content-Disposition'] = f'attachment; filename="{original_name}.webp"'
            return response
            
        except Exception as e:
            logger.error(f"Error processing image: {str(e)}", exc_info=True)
            return Response(data={
                'message': str(e),
                'success': False
            }, status=HTTPStatus.INTERNAL_SERVER_ERROR)
    
    def post(self, request):
        try:
            logger.info(f"ImageOptimizeView received request: data={request.data}, FILES={request.FILES}")
            serializer = self.serializer_class(data=request.data)
            if not serializer.is_valid():
                logger.error(f"Serializer validation failed: {serializer.errors}")
                return Response(data={
                    **serializer.errors,
                    'success': False
                }, status=HTTPStatus.BAD_REQUEST)
            
            # Log the user making the request
            logger.info(f"Processing request for user: {request.user.username}")
            
            return self.process_image(
                serializer.validated_data['image'],
                serializer.validated_data['quality'],
                serializer.validated_data.get('max_width'),
                serializer.validated_data.get('max_height')
            )
            
        except Exception as e:
            logger.error(f"Error processing request: {str(e)}", exc_info=True)
            return Response(data={
                'message': str(e),
                'success': False
            }, status=HTTPStatus.INTERNAL_SERVER_ERROR)
class BaseViewSet(viewsets.ModelViewSet):
    authentication_classes = [TokenAuthentication, SessionAuthentication]
    permission_classes = [IsAuthenticated]

class AgentViewSet(BaseViewSet):
    queryset = Agent.objects.all()
    serializer_class = AgentSerializer

class TaskViewSet(BaseViewSet):
    queryset = Task.objects.all()
    serializer_class = TaskSerializer

class ToolViewSet(BaseViewSet):
    queryset = Tool.objects.all()
    serializer_class = ToolSerializer

class CrewViewSet(BaseViewSet):
    queryset = Crew.objects.all()
    serializer_class = CrewSerializer

================
File: apps/common/services/llm/providers/__init__.py
================
"""LLM providers package."""

from .base import BaseLLMProvider
from .gemini import GeminiProvider
from .openai import OpenAIProvider
from .anthropic import AnthropicProvider
from .openrouter import OpenRouterProvider
from .ollama import OllamaProvider

__all__ = [
    'BaseLLMProvider',
    'GeminiProvider',
    'OpenAIProvider',
    'AnthropicProvider',
    'OpenRouterProvider',
    'OllamaProvider'
]

================
File: apps/common/services/llm/providers/anthropic.py
================
"""Anthropic API provider implementation."""

import logging
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union
import anthropic
import httpx

from django.conf import settings
from apps.common.models import LLMConfiguration
from .base import BaseLLMProvider

logger = logging.getLogger(__name__)

class AnthropicProvider(BaseLLMProvider):
    """Direct Anthropic API provider."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize Anthropic provider with configuration."""
        super().__init__(config)
        
        # Get provider settings
        self.api_base = config.api_base_url
        self.api_version = config.api_version
        self.max_retries = config.max_retries
        
        # Initialize client with proper settings
        self.client = anthropic.AsyncAnthropic(
            api_key=config.api_key,
            base_url=self.api_base,
            max_retries=self.max_retries,
            timeout=config.timeout
        )
        
        # Get model parameters
        model_params = config.get_model_parameters()
        self.temperature = model_params.get('temperature', 0.7)
        self.max_tokens = model_params.get('max_tokens', 200000)
        
        # Set default model if not specified
        self.model_name = config.default_model or 'claude-3-sonnet-20240229'
        
        # Cache settings
        self._cache_config = config.get_cache_config()
        self._rate_limits = config.get_rate_limits()
        self._streaming_config = config.get_streaming_config()
        
        # Initialize models cache
        self.available_models = {}
    
    async def initialize(self):
        """Initialize provider and fetch available models."""
        try:
            if self._cache_config['enable_model_cache']:
                # TODO: Check cache first
                pass
                
            self.available_models = await self._fetch_available_models()
            
            # Validate model name
            if self.model_name not in self.available_models:
                logger.warning(f"Model {self.model_name} not found, falling back to claude-3-sonnet-20240229")
                self.model_name = 'claude-3-sonnet-20240229'
            
            # Update max tokens based on model limits
            self.max_tokens = min(
                self.max_tokens,
                self.available_models[self.model_name]['max_output_tokens']
            )
            
            if self._cache_config['enable_model_cache']:
                # TODO: Cache the models
                pass
                
        except Exception as e:
            logger.error(f"Error initializing Anthropic provider: {str(e)}")
            raise
    
    async def get_completion(
        self,
        messages: list,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[Any, None]]:
        """Get completion using Anthropic API."""
        try:
            # Get model parameters with overrides
            model_params = self.config.get_model_parameters(
                kwargs.get('model_name', self.model_name)
            )
            
            # Convert messages to Anthropic format
            anthropic_messages = []
            system_message = None
            
            for msg in messages:
                role = msg.get('role', 'user')
                content = msg.get('content', '')
                
                if role == 'system':
                    system_message = content
                    continue
                
                # Handle vision content
                if isinstance(content, list):
                    message_content = []
                    
                    for part in content:
                        if isinstance(part, dict) and 'mime_type' in part and 'data' in part:
                            # Clean and validate image data
                            data = part['data']
                            if ',' in data:  # Remove data URL prefix if present
                                data = data.split(',', 1)[1]
                            
                            # Add image content block
                            message_content.append({
                                "type": "image",
                                "source": {
                                    "type": "base64",
                                    "media_type": part['mime_type'],
                                    "data": data
                                }
                            })
                        else:
                            # Add text content block
                            text = str(part).strip()
                            if text:
                                message_content.append({
                                    "type": "text",
                                    "text": text
                                })
                else:
                    # Handle text-only content
                    message_content = [{
                        "type": "text",
                        "text": str(content)
                    }]
                
                anthropic_messages.append({
                    "role": "user" if role == "user" else "assistant",
                    "content": message_content
                })
            
            # Get streaming config if needed
            stream_config = self._streaming_config if stream else {}
            
            # Prepare request parameters
            request_params = {
                "model": kwargs.get('model_name', self.model_name),
                "messages": anthropic_messages,
                "temperature": kwargs.get('temperature', model_params.get('temperature', self.temperature)),
                "max_tokens": kwargs.get('max_tokens', model_params.get('max_tokens', self.max_tokens)),
                "stream": stream,
                "metadata": {
                    "user_id": str(self.config.user.id) if hasattr(self.config, 'user') else None
                }
            }
            
            # Only add system message if it exists
            if system_message:
                request_params["system"] = system_message
            
            # Get response
            response = await self.client.messages.create(**request_params)
            
            if stream:
                return response
            
            # Calculate costs
            model_info = self.available_models[self.model_name]
            input_cost = (response.usage.input_tokens / 1_000_000) * model_info['input_cost']
            output_cost = (response.usage.output_tokens / 1_000_000) * model_info['output_cost']
            
            return response.content[0].text, {
                'usage': {
                    'prompt_tokens': response.usage.input_tokens,
                    'completion_tokens': response.usage.output_tokens,
                    'total_tokens': response.usage.input_tokens + response.usage.output_tokens
                },
                'model': self.model_name,
                'cost': {
                    'input_cost': input_cost,
                    'output_cost': output_cost,
                    'total_cost': input_cost + output_cost
                }
            }
            
        except Exception as e:
            logger.error(f"Anthropic completion error: {str(e)}", exc_info=True)
            raise
    
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings using Anthropic API."""
        raise NotImplementedError("Anthropic does not currently support embeddings")
    
    async def _load_image_from_url(self, url: str) -> str:
        """Load image data from URL."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url)
                response.raise_for_status()
                return response.content
        except Exception as e:
            logger.error(f"Error loading image from URL: {str(e)}")
            raise 
    
    async def _fetch_available_models(self) -> Dict[str, dict]:
        """Fetch available models from Anthropic API."""
        try:
            response = await self.client.models.list()
            
            models = {}
            for model in response.data:
                model_id = model.id
                
                # Determine model capabilities and pricing tiers
                is_opus = 'opus' in model_id.lower()
                is_sonnet = 'sonnet' in model_id.lower()
                is_haiku = 'haiku' in model_id.lower()
                
                # Set pricing based on model tier (in USD per million tokens)
                if is_opus:
                    input_cost = 15.0
                    output_cost = 75.0
                    max_tokens = 8192
                elif is_sonnet:
                    input_cost = 3.0
                    output_cost = 15.0
                    max_tokens = 8192
                else:  # Haiku
                    input_cost = 0.25
                    output_cost = 1.25
                    max_tokens = 8192
                
                # Build model info
                models[model_id] = {
                    'description': f"Anthropic {model_id} model",
                    'input_tokens': 200000,
                    'max_output_tokens': max_tokens,
                    'input_cost': input_cost,
                    'output_cost': output_cost,
                    'supports_vision': hasattr(model, 'capabilities') and getattr(model.capabilities, 'vision', False),
                    'supports_json': True,
                    'supports_functions': False,
                    'status': 'stable',
                    'default_parameters': {
                        'temperature': 0.7,
                        'top_p': 0.95,
                        'top_k': None,
                        'frequency_penalty': 0,
                        'presence_penalty': 0
                    },
                    'system_info': {
                        'id': model_id,
                        'display_name': getattr(model, 'name', model_id)
                    }
                }
            
            # If no models found, return default set
            if not models:
                return {
                    'claude-3-5-sonnet-20241022': {
                        'description': 'Claude 3 Sonnet',
                        'input_tokens': 200000,
                        'max_output_tokens': 8192,
                        'input_cost': 3.0,
                        'output_cost': 15.0,
                        'supports_vision': True,
                        'supports_json': True,
                        'supports_functions': False,
                        'status': 'stable',
                        'default_parameters': {
                            'temperature': 0.7,
                            'top_p': 0.95,
                            'frequency_penalty': 0,
                            'presence_penalty': 0
                        }
                    }
                }
            
            return models
            
        except Exception as e:
            logger.error(f"Error fetching Anthropic models: {str(e)}")
            # Return a minimal set of known models as fallback
            return {
                'claude-3-5-sonnet-20241022': {
                    'description': 'Claude 3 Sonnet',
                    'input_tokens': 200000,
                    'max_output_tokens': 8192,
                    'input_cost': 3.0,
                    'output_cost': 15.0,
                    'supports_vision': True,
                    'supports_json': True,
                    'supports_functions': False,
                    'status': 'stable',
                    'default_parameters': {
                        'temperature': 0.7,
                        'top_p': 0.95,
                        'frequency_penalty': 0,
                        'presence_penalty': 0
                    }
                }
            }

================
File: apps/common/services/llm/providers/base.py
================
"""Base class for LLM providers."""

from abc import ABC, abstractmethod
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union

from apps.common.models import LLMConfiguration

class BaseLLMProvider(ABC):
    """Abstract base class for LLM providers."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize base provider with configuration."""
        self.config = config
        self.model_name = config.default_model
        self.max_output_tokens = 1000
        self.temperature = 0.7
        self.available_models = {}
    
    @abstractmethod
    async def initialize(self):
        """Initialize provider and fetch available models."""
        pass
    
    @abstractmethod
    async def get_completion(
        self,
        messages: list,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[Any, None]]:
        """Get completion from provider."""
        pass
    
    @abstractmethod
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings from provider."""
        pass
    
    async def get_available_models(self) -> Dict[str, dict]:
        """Get available models from provider."""
        return self.available_models

================
File: apps/common/services/llm/providers/gemini.py
================
"""Google Gemini API provider implementation."""

import logging
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union
import google.generativeai as genai
import httpx
import tiktoken

from django.conf import settings
from apps.common.models import LLMConfiguration
from .base import BaseLLMProvider

logger = logging.getLogger(__name__)

class GeminiProvider(BaseLLMProvider):
    """Direct Google Gemini API provider."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize Gemini provider with configuration."""
        super().__init__(config)
        
        # Initialize client
        genai.configure(api_key=config.api_key)
        self.model = None
        
        # Initialize tokenizer
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
        
        # Get model parameters
        model_params = config.get_model_parameters()
        self.temperature = model_params.get('temperature', 0.7)
        self.max_tokens = model_params.get('max_tokens', 1000000)
        
        # Set default model if not specified
        if not self.model_name:
            self.model_name = 'gemini-pro'  # Default to Gemini Pro
    
    async def initialize(self):
        """Initialize provider and fetch available models."""
        try:
            self.AVAILABLE_MODELS = await self._fetch_available_models()
            
            # Validate model name
            if self.model_name not in self.AVAILABLE_MODELS:
                logger.warning(f"Model {self.model_name} not found, falling back to gemini-pro")
                self.model_name = 'gemini-pro'
            
            # Update max tokens based on model limits
            model_info = self.AVAILABLE_MODELS[self.model_name]
            self.max_tokens = min(
                self.max_tokens,
                model_info.get('output_tokens', 2048)
            )
            
            # Initialize the model
            self.model = genai.GenerativeModel(self.model_name)
            
        except Exception as e:
            logger.error(f"Error initializing Gemini provider: {str(e)}")
            raise
    
    async def _fetch_available_models(self) -> dict:
        """Fetch available models from Gemini API."""
        try:
            # List all available models
            models = {}
            available_models = genai.list_models()
            
            if not available_models:
                logger.error("No models returned from Gemini API")
                raise Exception("No models returned from Gemini API")
            
            for model in available_models:
                # Only include Gemini models that support text generation
                if (model.name.startswith('models/gemini-') and 
                    not model.name.endswith('vision') and 
                    not model.name.endswith('embedding')):
                    
                    # Extract the model name without the 'models/' prefix
                    model_name = model.name.split('/')[-1]
                    # Extract the base model ID (e.g., gemini-1.5-pro from gemini-1.5-pro-latest)
                    base_model = model_name.split('-latest')[0] if '-latest' in model_name else model_name
                    
                    models[base_model] = {
                        "name": base_model,
                        "description": model.description,
                        "context_window": model.input_token_limit,
                        "input_tokens": model.input_token_limit,
                        "output_tokens": model.output_token_limit,
                        "supports_vision": False,
                        "supports_json": True,
                        "supports_functions": True,
                        "temperature": getattr(model, 'temperature', 0.7),
                        "max_temperature": getattr(model, 'max_temperature', 1.0),
                        "top_p": getattr(model, 'top_p', 1.0),
                        "top_k": getattr(model, 'top_k', 1)
                    }
                
                # Handle vision models separately
                elif model.name.startswith('models/gemini-') and model.name.endswith('vision'):
                    model_name = model.name.split('/')[-1]
                    base_model = model_name.split('-latest')[0] if '-latest' in model_name else model_name
                    
                    models[base_model] = {
                        "name": base_model,
                        "description": model.description,
                        "context_window": model.input_token_limit,
                        "input_tokens": model.input_token_limit,
                        "output_tokens": model.output_token_limit,
                        "supports_vision": True,
                        "supports_json": True,
                        "supports_functions": True,
                        "temperature": getattr(model, 'temperature', 0.7),
                        "max_temperature": getattr(model, 'max_temperature', 1.0),
                        "top_p": getattr(model, 'top_p', 1.0),
                        "top_k": getattr(model, 'top_k', 1)
                    }
                else:
                    pass
            
            if not models:
                logger.error("No Gemini models found after processing API response")
                raise Exception("No Gemini models found")
            
            # Log final models dictionary
            #logger.debug(f"Final available models: {models}")
            return models
            
        except Exception as e:
            logger.error(f"Error fetching Gemini models: {str(e)}", exc_info=True)
            raise
        
    async def get_completion(self, messages: List[dict], **kwargs) -> Tuple[str, dict]:
        """Get completion from Gemini."""
        try:
            # Initialize model if needed
            if not self.model:
                self.model = genai.GenerativeModel(self.model_name)
                
            # Convert messages to Gemini format
            gemini_messages = []
            for msg in messages:
                role = msg.get('role', 'user')
                content = msg.get('content', '')
                
                # Handle vision content
                if isinstance(content, list):
                    parts = []
                    for part in content:
                        if isinstance(part, dict) and 'mime_type' in part:
                            parts.append({
                                'inline_data': {
                                    'mime_type': part['mime_type'],
                                    'data': part['data']
                                }
                            })
                        else:
                            parts.append({'text': str(part)})
                    
                    gemini_messages.append({
                        'role': 'user' if role == 'user' else 'model',
                        'parts': parts
                    })
                else:
                    # Handle text-only content
                    gemini_messages.append({
                        'role': 'user' if role == 'user' else 'model',
                        'parts': [{'text': str(content)}]
                    })
            
            # Get generation config
            generation_config = genai.types.GenerationConfig(
                temperature=kwargs.get('temperature', self.temperature),
                max_output_tokens=kwargs.get('max_tokens', self.max_tokens),
                top_p=kwargs.get('top_p', 1.0),
                top_k=kwargs.get('top_k', 1)
            )
            
            # Generate response
            response = self.model.generate_content(
                gemini_messages,
                generation_config=generation_config
            )
            
            if not response.text:
                raise Exception("Empty response from Gemini")
                
            # Count tokens using tiktoken
            prompt_text = str(gemini_messages)  # Convert messages to string for token counting
            prompt_tokens = len(self.tokenizer.encode(prompt_text))
            completion_tokens = len(self.tokenizer.encode(response.text))
            total_tokens = prompt_tokens + completion_tokens
            
            # Extract usage info
            metadata = {
                "usage": {
                    "prompt_tokens": prompt_tokens,
                    "completion_tokens": completion_tokens,
                    "total_tokens": total_tokens
                },
                "model": self.model_name
            }
            
            return response.text, metadata
            
        except Exception as e:
            logger.error(f"Error in Gemini completion: {str(e)}", exc_info=True)
            raise
    
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings using Gemini API."""
        try:
            embedding_model = genai.GenerativeModel('embedding-001')
            result = await embedding_model.embed_content(
                {"text": text},
                task_type="retrieval_query"
            )
            return result.embedding
        except Exception as e:
            logger.error(f"Gemini embeddings error: {str(e)}")
            raise
    
    async def _load_image_from_url(self, url: str) -> str:
        """Load image data from URL."""
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url)
                response.raise_for_status()
                return response.content
        except Exception as e:
            logger.error(f"Error loading image from URL: {str(e)}")
            raise 
    
    def _convert_messages_to_prompt(self, messages: List[dict]) -> str:
        """Convert messages to Gemini prompt format."""
        prompt = []
        system_message = None
        
        for msg in messages:
            role = msg.get('role', 'user')
            content = msg.get('content', '')
            
            if role == 'system':
                system_message = content
                continue
                
            if role == 'assistant':
                prompt.append(f"Assistant: {content}")
            else:
                prompt.append(f"User: {content}")
                
        # Add system message at the start if present
        if system_message:
            prompt.insert(0, f"Instructions: {system_message}")
            
        return "\n\n".join(prompt) 
    
    async def get_available_models(self) -> Dict[str, dict]:
        """Get available models from provider."""
        if not self.available_models:
            try:
                self.available_models = await self._fetch_available_models()
            except Exception as e:
                logger.error(f"Error fetching models: {str(e)}")
                raise
        
        return self.available_models

================
File: apps/common/services/llm/providers/ollama.py
================
"""Ollama API provider implementation."""

import json
import logging
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union
import httpx

from django.conf import settings
from apps.common.models import LLMConfiguration
from .base import BaseLLMProvider

logger = logging.getLogger(__name__)

class OllamaProvider(BaseLLMProvider):
    """Direct Ollama API provider."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize Ollama provider with configuration."""
        super().__init__(config)
        
        
        # Get API base from provider settings
        self.api_base = config.api_base_url
        
        if not self.api_base:
            raise ValueError("No api_base specified in provider settings for Ollama")
            
        self.api_version = config.api_version
        self.max_retries = config.max_retries
        
        
        # Initialize client with proper settings
        self.client = httpx.AsyncClient(
            base_url=self.api_base,
            timeout=config.timeout
        )
        
        # Get model parameters
        model_params = config.get_model_parameters()
        self.temperature = model_params.get('temperature', 0.7)
        self.max_tokens = model_params.get('max_tokens', 8192)
        
        # Set default model from config
        self.model_name = config.default_model
        if not self.model_name:
            raise ValueError("No default model specified in configuration")
        
        # Cache settings
        self._cache_config = config.get_cache_config()
        self._rate_limits = config.get_rate_limits()
        self._streaming_config = config.get_streaming_config()
        
        # Initialize models cache
        self.available_models = {}
    
    async def initialize(self):
        """Initialize provider and fetch available models."""
        try:
            if self._cache_config['enable_model_cache']:
                # TODO: Check cache first
                pass
                
            self.available_models = await self._fetch_available_models()
            
            # Validate model name
            if self.model_name not in self.available_models:
                logger.error(f"Model {self.model_name} not found in available models")
                raise ValueError(f"Model {self.model_name} not found in available models")
            
            # Get model info and set parameters
            model_info = self.available_models[self.model_name]
            self.default_parameters = {
                **model_info['default_parameters'],
                'temperature': self.temperature
            }
            
            if self._cache_config['enable_model_cache']:
                # TODO: Cache the models
                pass
                
        except Exception as e:
            logger.error(f"Error initializing Ollama provider: {str(e)}")
            raise
    
    async def get_completion(
        self,
        messages: list,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[Any, None]]:
        """Get completion using Ollama API."""
        try:
            # Get model parameters with overrides
            model_name = kwargs.get('model_name', self.model_name)
            model_params = self.config.get_model_parameters(model_name)
            
            # Verify model supports vision if images are present
            model_info = self.available_models.get(model_name)
            if not model_info:
                raise ValueError(f"Model {model_name} not found in available models")
            
            # Get streaming config if needed
            stream_config = self._streaming_config if stream else {}
            
            # Convert messages to Ollama format
            prompt = ""
            system_message = None
            image_data = None  # Only store one image as per Ollama API
            has_vision_content = False
            
            for msg in messages:
                role = msg.get('role', 'user')
                content = msg.get('content', '')
                
                if role == 'system':
                    system_message = content
                    continue
                
                # Handle vision content
                if isinstance(content, list):
                    has_vision_content = True
                    current_text = []
                    
                    for part in content:
                        if isinstance(part, dict) and 'mime_type' in part and 'data' in part:
                            # Clean and validate image data
                            data = part['data']
                            if ',' in data:  # Remove data URL prefix if present
                                data = data.split(',', 1)[1]
                            
                            # Validate MIME type
                            mime_type = part['mime_type'].lower()
                            if not mime_type.startswith('image/'):
                                raise ValueError(f"Invalid MIME type for image: {mime_type}")
                            
                            # Store image data (only keep the last one as Ollama only supports one image)
                            image_data = data
                        else:
                            # Collect text parts
                            text = str(part).strip()
                            if text:
                                current_text.append(text)
                    
                    # Add collected text to prompt
                    if current_text:
                        text_content = ' '.join(current_text)
                        if role == 'assistant':
                            prompt += f"Assistant: {text_content}\n"
                        else:
                            prompt += f"Human: {text_content}\n"
                else:
                    # Handle text-only content
                    if role == 'assistant':
                        prompt += f"Assistant: {content}\n"
                    else:
                        prompt += f"Human: {content}\n"
            
            # Verify vision support if needed
            if has_vision_content and not model_info.get('supports_vision'):
                raise ValueError(f"Model {model_name} does not support vision tasks")
            
            prompt += "Assistant:"
            
            # Prepare request data
            request_data = {
                "model": model_name,
                "prompt": prompt.strip(),
                "stream": stream,
                "options": {
                    "temperature": kwargs.get('temperature', model_params.get('temperature', self.temperature)),
                    "num_predict": kwargs.get('max_tokens', model_params.get('max_tokens', self.max_tokens)),
                    "top_p": kwargs.get('top_p', model_params.get('top_p', 0.9)),
                    "repeat_penalty": kwargs.get('repeat_penalty', model_params.get('repeat_penalty', 1.1))
                }
            }
            
            # Add system message if present
            if system_message:
                request_data["system"] = system_message
            
            # Add image if present (as a string, not an array)
            if image_data:
                request_data["images"] = [image_data]  # Ollama expects an array of base64 strings
            
            # Log request data for debugging (excluding image data)
            debug_data = request_data.copy()
            if 'images' in debug_data:
                debug_data['images'] = [f"<{len(img)} bytes>" for img in debug_data['images']]
            
            # Make request
            try:
                response = await self.client.post(
                    "/api/generate",
                    json=request_data
                )
                response.raise_for_status()
            except httpx.HTTPStatusError as e:
                error_text = e.response.text
                logger.error(f"Ollama API error: {error_text}")
                raise ValueError(f"Ollama API error: {error_text}")
            
            if stream:
                return self._process_stream(response)
            
            data = response.json()
            
            # Extract response and metadata
            response_text = data['response']
            total_duration = data.get('total_duration', 0)
            load_duration = data.get('load_duration', 0)
            prompt_eval_count = data.get('prompt_eval_count', 0)
            eval_count = data.get('eval_count', 0)
            
            # Estimate token counts (Ollama doesn't provide these)
            prompt_tokens = len(prompt.split())
            completion_tokens = len(response_text.split())
            
            return response_text, {
                'usage': {
                    'prompt_tokens': prompt_tokens,
                    'completion_tokens': completion_tokens,
                    'total_tokens': prompt_tokens + completion_tokens
                },
                'model': model_name,
                'timings': {
                    'total_duration': total_duration,
                    'load_duration': load_duration,
                    'prompt_eval_count': prompt_eval_count,
                    'eval_count': eval_count
                }
            }
            
        except Exception as e:
            logger.error(f"Ollama completion error: {str(e)}", exc_info=True)
            raise
    
    async def _process_stream(self, response) -> AsyncGenerator[str, None]:
        """Process streaming response from Ollama."""
        try:
            async for line in response.aiter_lines():
                if line:
                    try:
                        data = json.loads(line)
                        if 'response' in data:
                            yield data['response']
                    except json.JSONDecodeError:
                        continue
        except Exception as e:
            logger.error(f"Error processing Ollama stream: {str(e)}")
            raise
    
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings using Ollama API."""
        try:
            response = await self.client.post("/api/embeddings", json={
                "model": self.model_name,
                "prompt": text
            })
            response.raise_for_status()
            data = response.json()
            return data['embedding']
        except Exception as e:
            logger.error(f"Ollama embeddings error: {str(e)}")
            raise 
    
    async def _fetch_available_models(self) -> Dict[str, dict]:
        """Fetch available models from Ollama API."""
        try:
            # First try to connect to Ollama server
            try:
                response = await self.client.get("/api/tags")
                response.raise_for_status()
            except Exception as e:
                logger.error(f"Could not connect to Ollama server at {self.client.base_url}: {str(e)}")
                raise ConnectionError(f"Could not connect to Ollama server at {self.client.base_url}. Please ensure Ollama is running and accessible.")
            
            data = response.json()
            
            models = {}
            for model in data.get('models', []):
                model_name = model['name']
                
                try:
                    # Get model details
                    details_response = await self.client.post("/api/show", json={"name": model_name})
                    details_response.raise_for_status()
                    details = details_response.json()
                    
                    # Extract parameters from modelfile
                    parameters = {}
                    modelfile = details.get('modelfile', '')
                    for line in modelfile.split('\n'):
                        if line.startswith('PARAMETER'):
                            try:
                                _, key, value = line.split()
                                parameters[key] = float(value) if '.' in value else int(value)
                            except (ValueError, IndexError):
                                continue
                    
                    # Detect vision capabilities
                    modelfile_lower = modelfile.lower()
                    supports_vision = any(x in modelfile_lower for x in [
                        'clip',  # CLIP vision models
                        'llava',  # LLaVA models
                        'vision',  # Generic vision indicator
                        'image',   # Image processing
                        'multimodal'  # Multimodal models
                    ])
                    
                    # Detect code/JSON capabilities
                    supports_json = any(x in model_name.lower() for x in [
                        'starcoder',
                        'codellama',
                        'wizard-coder',
                        'deepseek-coder'
                    ])
                    
                    # Build model info
                    models[model_name] = {
                        'description': details.get('description', f"Ollama model: {model_name}"),
                        'context_window': parameters.get('num_ctx', 4096),
                        'max_output_tokens': parameters.get('num_ctx', 4096),
                        'supports_vision': supports_vision,
                        'supports_json': supports_json,
                        'supports_functions': False,
                        'status': 'stable',
                        'default_parameters': {
                            'num_ctx': parameters.get('num_ctx', 4096),
                            'temperature': parameters.get('temperature', 0.7),
                            'top_p': parameters.get('top_p', 0.9),
                            'repeat_penalty': parameters.get('repeat_penalty', 1.1)
                        },
                        'system_info': {
                            'size': model.get('size', 0),
                            'digest': model.get('digest', ''),
                            'modified_at': model.get('modified_at', ''),
                            'details': details
                        }
                    }
                except Exception as e:
                    logger.warning(f"Error getting details for model {model_name}: {str(e)}")
                    continue
            
            # If no models found, raise error
            if not models:
                raise ValueError("No models found in Ollama server. Please ensure models are installed.")
            
            return models
            
        except Exception as e:
            if isinstance(e, (ConnectionError, ValueError)):
                raise
            
            logger.error(f"Error fetching Ollama models: {str(e)}")
            raise ValueError(f"Failed to fetch models from Ollama server: {str(e)}")

================
File: apps/common/services/llm/providers/openai.py
================
"""OpenAI API provider implementation."""

import logging
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union
from openai import AsyncOpenAI
import httpx

from django.conf import settings
from apps.common.models import LLMConfiguration
from .base import BaseLLMProvider

logger = logging.getLogger(__name__)

class OpenAIProvider(BaseLLMProvider):
    """Direct OpenAI API provider."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize OpenAI provider with configuration."""
        super().__init__(config)
        
        # Get provider settings
        self.api_base = config.api_base_url
        self.api_version = config.api_version
        self.max_retries = config.max_retries
        
        # Initialize client with proper settings
        self.client = AsyncOpenAI(
            api_key=config.api_key,
            base_url=self.api_base or "https://api.openai.com/v1",
            max_retries=self.max_retries,
            timeout=httpx.Timeout(config.timeout)
        )
        
        # Get model parameters
        model_params = config.get_model_parameters()
        self.temperature = model_params.get('temperature', 0.7)
        self.max_tokens = model_params.get('max_tokens', 200000)
        
        # Set default model if not specified
        self.model_name = config.default_model or 'gpt-3.5-turbo'
        
        # Cache settings
        self._cache_config = config.get_cache_config()
        self._rate_limits = config.get_rate_limits()
        self._streaming_config = config.get_streaming_config()
        
        # Initialize models cache
        self.available_models = {}
    
    async def initialize(self):
        """Initialize provider and fetch available models."""
        try:
            if self._cache_config['enable_model_cache']:
                # TODO: Check cache first
                pass
                
            self.available_models = await self._fetch_available_models()
            
            # Validate model name
            if self.model_name not in self.available_models:
                logger.warning(f"Model {self.model_name} not found, falling back to gpt-3.5-turbo")
                self.model_name = 'gpt-3.5-turbo'
            
            # Update max tokens based on model limits
            self.max_tokens = min(
                self.max_tokens,
                self.available_models[self.model_name]['output_tokens']
            )
            
            if self._cache_config['enable_model_cache']:
                # TODO: Cache the models
                pass
                
        except Exception as e:
            logger.error(f"Error initializing OpenAI provider: {str(e)}")
            raise
    
    async def get_completion(
        self,
        messages: list,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[Any, None]]:
        """Get completion using OpenAI API."""
        try:
            # Get model parameters with overrides
            model_params = self.config.get_model_parameters(
                kwargs.get('model_name', self.model_name)
            )
            
            # Convert messages to OpenAI format
            openai_messages = []
            
            for msg in messages:
                role = msg.get('role', 'user')
                content = msg.get('content', '')
                
                # Handle vision content
                if isinstance(content, list):
                    message_content = []
                    
                    # Add text first if present
                    text_parts = [part for part in content if not isinstance(part, dict) or 'mime_type' not in part]
                    if text_parts:
                        message_content.append({
                            "type": "text",
                            "text": " ".join(str(part) for part in text_parts)
                        })
                    
                    # Add images
                    for part in content:
                        if isinstance(part, dict) and 'mime_type' in part and 'data' in part:
                            # Clean and validate image data
                            data = part['data']
                            if ',' in data:  # Remove data URL prefix if present
                                data = data.split(',', 1)[1]
                            
                            # Add image content block
                            message_content.append({
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/jpeg;base64,{data}",
                                    "detail": kwargs.get('image_detail', 'auto')
                                }
                            })
                    
                    openai_messages.append({
                        "role": role,
                        "content": message_content
                    })
                else:
                    # Handle text-only content
                    openai_messages.append({
                        "role": role,
                        "content": [{
                            "type": "text",
                            "text": str(content)
                        }]
                    })
            
            # Prepare request parameters
            request_params = {
                "model": kwargs.get('model_name', self.model_name),
                "messages": openai_messages,
                "temperature": kwargs.get('temperature', model_params.get('temperature', self.temperature)),
                "max_tokens": kwargs.get('max_tokens', model_params.get('max_tokens', self.max_tokens)),
                "stream": stream
            }
            
            # Add optional parameters if specified
            for param in ['top_p', 'presence_penalty', 'frequency_penalty']:
                if param in kwargs:
                    request_params[param] = kwargs[param]
            
            # Handle response_format parameter separately
            if 'response_format' in kwargs:
                response_format = kwargs['response_format']
                if isinstance(response_format, dict) and 'schema' in response_format:
                    # Remove schema property if present
                    response_format = {k: v for k, v in response_format.items() if k != 'schema'}
                request_params['response_format'] = response_format
            
            # Make request
            response = await self.client.chat.completions.create(**request_params)
            
            if stream:
                return self._process_stream(response)
            
            # Extract response and metadata
            completion = response.choices[0].message.content
            
            return completion, {
                'usage': {
                    'prompt_tokens': response.usage.prompt_tokens,
                    'completion_tokens': response.usage.completion_tokens,
                    'total_tokens': response.usage.total_tokens
                },
                'model': response.model,
                'finish_reason': response.choices[0].finish_reason
            }
            
        except Exception as e:
            logger.error(f"OpenAI completion error: {str(e)}", exc_info=True)
            raise
    
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings using OpenAI API."""
        try:
            response = await self.client.embeddings.create(
                model="text-embedding-3-small",
                input=text
            )
            return response.data[0].embedding
        except Exception as e:
            logger.error(f"OpenAI embeddings error: {str(e)}")
            raise 
    
    async def _fetch_available_models(self) -> Dict[str, dict]:
        """Fetch available models from OpenAI API."""
        try:
            response = await self.client.models.list()
            
            models = {}
            for model in response.data:
                model_id = model.id
                
                # Skip non-chat and non-embedding models
                if not (model_id.startswith('gpt-') or model_id.startswith('text-embedding-')):
                    continue
                
                # Determine model capabilities and pricing tiers
                is_gpt4 = 'gpt-4' in model_id
                is_gpt4_turbo = 'gpt-4-turbo' in model_id
                is_gpt4_vision = 'vision' in model_id
                is_gpt35 = 'gpt-3.5' in model_id
                is_embedding = 'embedding' in model_id
                is_preview = 'preview' in model_id
                
                if is_embedding:
                    # Embedding models
                    is_large = 'large' in model_id
                    models[model_id] = {
                        'description': f"OpenAI embedding model: {model_id}",
                        'input_tokens': 8191,
                        'output_dimension': 3072 if is_large else 1536,
                        'input_cost': 0.13 if is_large else 0.02,
                        'supports_batch': True,
                        'status': 'stable',
                        'system_info': {
                            'id': model.id,
                            'created': model.created,
                            'owned_by': model.owned_by
                        }
                    }
                else:
                    # Chat models
                    if is_gpt4_turbo:
                        input_cost = 10.0
                        output_cost = 30.0
                        context_window = 128000
                    elif is_gpt4:
                        input_cost = 30.0
                        output_cost = 60.0
                        context_window = 32768 if is_preview else 8192
                    else:  # GPT-3.5
                        input_cost = 0.5
                        output_cost = 1.5
                        context_window = 16385
                    
                    models[model_id] = {
                        'description': f"OpenAI {'GPT-4' if is_gpt4 else 'GPT-3.5'} model",
                        'input_tokens': context_window,
                        'output_tokens': 4096,
                        'input_cost': input_cost,
                        'output_cost': output_cost,
                        'supports_vision': is_gpt4_vision,
                        'supports_json': True,
                        'supports_functions': True,
                        'status': 'preview' if is_preview else 'stable',
                        'default_parameters': {
                            'temperature': 0.7,
                            'top_p': 0.95,
                            'frequency_penalty': 0,
                            'presence_penalty': 0
                        },
                        'system_info': {
                            'id': model.id,
                            'created': model.created,
                            'owned_by': model.owned_by
                        }
                    }
            
            # If no models found, return default set
            if not models:
                return {
                    'gpt-3.5-turbo': {
                        'description': 'OpenAI GPT-3.5 model',
                        'input_tokens': 16385,
                        'output_tokens': 4096,
                        'input_cost': 0.5,
                        'output_cost': 1.5,
                        'supports_vision': False,
                        'supports_json': True,
                        'supports_functions': True,
                        'status': 'stable',
                        'default_parameters': {
                            'temperature': 0.7,
                            'top_p': 0.95,
                            'frequency_penalty': 0,
                            'presence_penalty': 0
                        }
                    }
                }
            
            return models
            
        except Exception as e:
            logger.error(f"Error fetching OpenAI models: {str(e)}")
            # Return a minimal set of known models as fallback
            return {
                'gpt-3.5-turbo': {
                    'description': 'OpenAI GPT-3.5 model',
                    'input_tokens': 16385,
                    'output_tokens': 4096,
                    'input_cost': 0.5,
                    'output_cost': 1.5,
                    'supports_vision': False,
                    'supports_json': True,
                    'supports_functions': True,
                    'status': 'stable',
                    'default_parameters': {
                        'temperature': 0.7,
                        'top_p': 0.95,
                        'frequency_penalty': 0,
                        'presence_penalty': 0
                    }
                }
            }

================
File: apps/common/services/llm/providers/openrouter.py
================
"""OpenRouter API provider implementation."""

import json
import logging
from typing import Any, AsyncGenerator, Dict, List, Optional, Tuple, Union
import httpx

from django.conf import settings
from apps.common.models import LLMConfiguration
from .base import BaseLLMProvider

logger = logging.getLogger(__name__)

class OpenRouterProvider(BaseLLMProvider):
    """Direct OpenRouter API provider."""
    
    def __init__(self, config: LLMConfiguration):
        """Initialize OpenRouter provider with configuration."""
        super().__init__(config)
        
        # Get provider settings
        self.api_base = config.api_base_url
        self.api_version = config.api_version
        self.max_retries = config.max_retries
        
        # Initialize client with proper settings
        self.client = httpx.AsyncClient(
            base_url=self.api_base or "https://openrouter.ai/api/v1",
            headers={
                "Authorization": f"Bearer {config.api_key}",
                "HTTP-Referer": settings.ALLOWED_HOSTS[0],  # Required by OpenRouter
                "X-Title": "NeuralAMI Control",  # Application name
                "Content-Type": "application/json"
            },
            timeout=config.timeout
        )
        
        # Get model parameters
        model_params = config.get_model_parameters()
        self.temperature = model_params.get('temperature', 0.7)
        self.max_tokens = model_params.get('max_tokens', 32767)
        
        # Set default model if not specified
        self.model_name = config.default_model or 'openai/gpt-3.5-turbo'
        
        # Cache settings
        self._cache_config = config.get_cache_config()
        self._rate_limits = config.get_rate_limits()
        self._streaming_config = config.get_streaming_config()
        
        # Initialize models cache
        self.available_models = {}
    
    async def initialize(self):
        """Initialize provider and fetch available models."""
        try:
            if self._cache_config['enable_model_cache']:
                # TODO: Check cache first
                pass
                
            self.available_models = await self._fetch_available_models()
            
            # Validate model name
            if self.model_name not in self.available_models:
                logger.warning(f"Model {self.model_name} not found, falling back to openai/gpt-3.5-turbo")
                self.model_name = 'openai/gpt-3.5-turbo'
            
            # Update max tokens based on model limits
            self.max_tokens = min(
                self.max_tokens,
                self.available_models[self.model_name]['max_output_tokens']
            )
            
            if self._cache_config['enable_model_cache']:
                # TODO: Cache the models
                pass
                
        except Exception as e:
            logger.error(f"Error initializing OpenRouter provider: {str(e)}")
            raise
    
    async def get_completion(
        self,
        messages: list,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[Any, None]]:
        """Get completion using OpenRouter API."""
        try:
            # Get model parameters with overrides
            model_params = self.config.get_model_parameters(
                kwargs.get('model_name', self.model_name)
            )
            
            # Get streaming config if needed
            stream_config = self._streaming_config if stream else {}
            
            # Prepare request data
            request_data = {
                "model": kwargs.get('model_name', self.model_name),
                "messages": messages,
                "stream": stream,
                "temperature": kwargs.get('temperature', model_params.get('temperature', self.temperature)),
                "max_tokens": kwargs.get('max_tokens', model_params.get('max_tokens', self.max_tokens)),
                "top_p": kwargs.get('top_p', model_params.get('top_p', 1.0)),
                "frequency_penalty": kwargs.get('frequency_penalty', model_params.get('frequency_penalty', 0)),
                "presence_penalty": kwargs.get('presence_penalty', model_params.get('presence_penalty', 0))
            }
            
            # Add provider routing if specified
            if kwargs.get('provider_order'):
                request_data["provider"] = {
                    "order": kwargs['provider_order'],
                    "allow_fallbacks": kwargs.get('allow_fallbacks', True)
                }
            
            # Add required parameters if specified
            if kwargs.get('require_parameters'):
                request_data["provider"] = {
                    "require_parameters": True
                }
            
            # Add response format if specified
            if kwargs.get('response_format'):
                request_data["response_format"] = kwargs['response_format']
            
            # Make request
            response = await self.client.post(
                "/chat/completions",
                json=request_data
            )
            response.raise_for_status()
            
            if stream:
                return self._process_stream(response)
            
            data = response.json()
            
            # Calculate costs
            model_info = self.available_models[self.model_name]
            input_tokens = data['usage']['prompt_tokens']
            output_tokens = data['usage']['completion_tokens']
            input_cost = (input_tokens / 1_000_000) * model_info['input_cost']
            output_cost = (output_tokens / 1_000_000) * model_info['output_cost']
            
            return data['choices'][0]['message']['content'], {
                'usage': {
                    'prompt_tokens': input_tokens,
                    'completion_tokens': output_tokens,
                    'total_tokens': data['usage']['total_tokens']
                },
                'model': data['model'],
                'cost': {
                    'input_cost': input_cost,
                    'output_cost': output_cost,
                    'total_cost': input_cost + output_cost
                },
                'finish_reason': data['choices'][0]['finish_reason']
            }
            
        except Exception as e:
            logger.error(f"OpenRouter completion error: {str(e)}")
            raise
    
    async def _process_stream(self, response) -> AsyncGenerator[str, None]:
        """Process streaming response from OpenRouter."""
        try:
            async for line in response.aiter_lines():
                if line.startswith('data: '):
                    data = json.loads(line[6:])
                    if data.get('choices'):
                        content = data['choices'][0].get('delta', {}).get('content', '')
                        if content:
                            yield content
        except Exception as e:
            logger.error(f"Error processing OpenRouter stream: {str(e)}")
            raise
    
    async def get_embeddings(self, text: str) -> list[float]:
        """Get embeddings using OpenRouter API."""
        try:
            response = await self.client.post("/embeddings", json={
                "model": "openai/text-embedding-3-small",
                "input": text
            })
            response.raise_for_status()
            data = response.json()
            return data['data'][0]['embedding']
        except Exception as e:
            logger.error(f"OpenRouter embeddings error: {str(e)}")
            raise 
    
    async def _fetch_available_models(self) -> Dict[str, dict]:
        """Fetch available models from OpenRouter API."""
        try:
            response = await self.client.get("/models")
            response.raise_for_status()
            data = response.json()
            
            models = {}
            for model in data:
                model_id = model['id']
                
                # Get pricing info
                pricing = model.get('pricing', {})
                input_cost = pricing.get('prompt', 0.0) * 1_000_000  # Convert to per million tokens
                output_cost = pricing.get('completion', 0.0) * 1_000_000  # Convert to per million tokens
                
                # Get context window info
                context_length = model.get('context_length', 4096)
                max_completion_tokens = model.get('max_completion_tokens', min(4096, context_length))
                
                # Get model capabilities
                supports_vision = model.get('multimodal', False)
                supports_functions = model.get('supports_functions', False)
                supports_json = model.get('format', '').lower() == 'json'
                
                # Get model status
                is_moderated = model.get('moderated', False)
                is_deprecated = model.get('deprecated', False)
                status = 'deprecated' if is_deprecated else ('stable' if is_moderated else 'experimental')
                
                # Build model info
                models[model_id] = {
                    'description': model.get('description', f"OpenRouter model: {model_id}"),
                    'input_tokens': context_length,
                    'output_tokens': max_completion_tokens,
                    'input_cost': input_cost,
                    'output_cost': output_cost,
                    'supports_vision': supports_vision,
                    'supports_json': supports_json,
                    'supports_functions': supports_functions,
                    'status': status,
                    'default_parameters': {
                        'temperature': model.get('default_temperature', 0.7),
                        'top_p': model.get('default_top_p', 0.95),
                        'top_k': model.get('default_top_k'),
                        'frequency_penalty': model.get('default_frequency_penalty', 0),
                        'presence_penalty': model.get('default_presence_penalty', 0)
                    },
                    'system_info': {
                        'id': model_id,
                        'provider': model.get('provider', {}).get('name'),
                        'architecture': model.get('architecture'),
                        'format': model.get('format'),
                        'created': model.get('created'),
                        'updated': model.get('updated'),
                        'status': status,
                        'context_length': context_length,
                        'max_completion_tokens': max_completion_tokens,
                        'moderated': is_moderated,
                        'deprecated': is_deprecated,
                        'pricing': {
                            'prompt': input_cost,
                            'completion': output_cost,
                            'currency': pricing.get('currency', 'USD')
                        }
                    }
                }
            
            # If no models found, return default set
            if not models:
                return {
                    'openai/gpt-3.5-turbo': {
                        'description': 'OpenAI GPT-3.5 Turbo via OpenRouter',
                        'input_tokens': 16385,
                        'output_tokens': 4096,
                        'input_cost': 0.5,
                        'output_cost': 1.5,
                        'supports_vision': False,
                        'supports_json': True,
                        'supports_functions': True,
                        'status': 'stable',
                        'default_parameters': {
                            'temperature': 0.7,
                            'top_p': 0.95,
                            'frequency_penalty': 0,
                            'presence_penalty': 0
                        }
                    }
                }
            
            return models
            
        except Exception as e:
            logger.error(f"Error fetching OpenRouter models: {str(e)}")
            # Return a minimal set of known models as fallback
            return {
                'openai/gpt-3.5-turbo': {
                    'description': 'OpenAI GPT-3.5 Turbo via OpenRouter',
                    'input_tokens': 16385,
                    'output_tokens': 4096,
                    'input_cost': 0.5,
                    'output_cost': 1.5,
                    'supports_vision': False,
                    'supports_json': True,
                    'supports_functions': True,
                    'status': 'stable',
                    'default_parameters': {
                        'temperature': 0.7,
                        'top_p': 0.95,
                        'frequency_penalty': 0,
                        'presence_penalty': 0
                    }
                }
            }

================
File: apps/common/services/llm/utils/cache.py
================
"""Caching utility for LLM responses."""

import json
import time
from typing import Any, Dict, Optional, Tuple

class LLMCache:
    """Cache for LLM responses."""
    
    def __init__(self, ttl: int = 3600):
        self.ttl = ttl
        self.cache = {}
        self.hits = 0
        self.misses = 0
    
    def _get_cache_key(self, messages: list, provider_type: str, model: str, **kwargs) -> str:
        """Generate cache key from request parameters."""
        key_data = {
            'messages': messages,
            'provider': provider_type,
            'model': model,
            **kwargs
        }
        return json.dumps(key_data, sort_keys=True)
    
    def get_cached_response(
        self,
        messages: list,
        provider_type: str,
        model: str,
        **kwargs
    ) -> Optional[Dict[str, Any]]:
        """Get cached response if available and not expired."""
        key = self._get_cache_key(messages, provider_type, model, **kwargs)
        
        if key in self.cache:
            cached = self.cache[key]
            if time.time() - cached['timestamp'] < self.ttl:
                self.hits += 1
                return cached
            else:
                del self.cache[key]
        
        self.misses += 1
        return None
    
    def cache_response(
        self,
        messages: list,
        provider_type: str,
        model: str,
        content: str,
        metadata: dict,
        **kwargs
    ):
        """Cache a response."""
        key = self._get_cache_key(messages, provider_type, model, **kwargs)
        self.cache[key] = {
            'content': content,
            'metadata': metadata,
            'timestamp': time.time()
        }
    
    def get_cache_stats(self) -> Tuple[int, int]:
        """Get cache hit/miss statistics."""
        return self.hits, self.misses
    
    def clear(self):
        """Clear the cache."""
        self.cache = {}
        self.hits = 0
        self.misses = 0

================
File: apps/common/services/llm/utils/rate_limiter.py
================
"""Rate limiting utility for LLM providers."""

import time
from typing import Tuple

class RateLimiter:
    """Rate limiter for managing API request and token limits."""
    
    def __init__(
        self,
        provider_type: str,
        requests_per_minute: int = 60,
        tokens_per_minute: int = 40000
    ):
        self.provider_type = provider_type
        self.requests_per_minute = requests_per_minute
        self.tokens_per_minute = tokens_per_minute
        
        # Initialize counters
        self.request_timestamps = []
        self.token_counts = []
        self.last_reset = time.time()
    
    def check_rate_limit(self) -> Tuple[bool, str]:
        """Check if current request is within rate limits."""
        current_time = time.time()
        window_start = current_time - 60  # 1 minute window
        
        # Clean up old timestamps and counts
        self.request_timestamps = [ts for ts in self.request_timestamps if ts > window_start]
        self.token_counts = self.token_counts[-self.requests_per_minute:]
        
        # Check request limit
        if len(self.request_timestamps) >= self.requests_per_minute:
            return False, "Request rate limit exceeded"
        
        # Check token limit
        tokens_used = sum(self.token_counts)
        if tokens_used >= self.tokens_per_minute:
            return False, "Token rate limit exceeded"
        
        return True, ""
    
    def increment_counters(self, tokens_used: int = 0):
        """Increment request and token counters."""
        current_time = time.time()
        
        # Reset counters if window has passed
        if current_time - self.last_reset >= 60:
            self.request_timestamps = []
            self.token_counts = []
            self.last_reset = current_time
        
        # Add new request
        self.request_timestamps.append(current_time)
        if tokens_used > 0:
            self.token_counts.append(tokens_used)
    
    def get_current_usage(self) -> Tuple[int, int]:
        """Get current request and token usage."""
        current_time = time.time()
        window_start = current_time - 60
        
        # Clean up old data
        self.request_timestamps = [ts for ts in self.request_timestamps if ts > window_start]
        self.token_counts = self.token_counts[-self.requests_per_minute:]
        
        return len(self.request_timestamps), sum(self.token_counts)

================
File: apps/common/services/llm/utils/streaming.py
================
"""Streaming utilities for LLM responses."""

import asyncio
from typing import AsyncGenerator, Any

class StreamingManager:
    """Manager for handling streaming responses from different providers."""
    
    def __init__(self, chunk_size: int = 100, timeout: int = 30):
        self.chunk_size = chunk_size
        self.timeout = timeout
    
    async def stream_with_timeout(
        self,
        stream: AsyncGenerator[str, None]
    ) -> AsyncGenerator[str, None]:
        """Stream with timeout handling."""
        try:
            async for chunk in stream:
                yield chunk
        except asyncio.TimeoutError:
            yield "Error: Stream timeout"
    
    async def process_openai_stream(
        self,
        response_stream: AsyncGenerator[Any, None]
    ) -> AsyncGenerator[str, None]:
        """Process OpenAI streaming response."""
        buffer = ""
        async for chunk in response_stream:
            if chunk.choices:
                content = chunk.choices[0].delta.content
                if content:
                    buffer += content
                    if len(buffer) >= self.chunk_size:
                        yield buffer
                        buffer = ""
        if buffer:
            yield buffer
    
    async def process_anthropic_stream(
        self,
        response_stream: AsyncGenerator[Any, None]
    ) -> AsyncGenerator[str, None]:
        """Process Anthropic streaming response."""
        buffer = ""
        async for chunk in response_stream:
            if chunk.completion:
                buffer += chunk.completion
                if len(buffer) >= self.chunk_size:
                    yield buffer
                    buffer = ""
        if buffer:
            yield buffer
    
    async def process_gemini_stream(
        self,
        response_stream: AsyncGenerator[Any, None]
    ) -> AsyncGenerator[str, None]:
        """Process Gemini streaming response."""
        buffer = ""
        async for chunk in response_stream:
            if chunk.text:
                buffer += chunk.text
                if len(buffer) >= self.chunk_size:
                    yield buffer
                    buffer = ""
        if buffer:
            yield buffer
    
    async def process_ollama_stream(
        self,
        response_stream: AsyncGenerator[Any, None]
    ) -> AsyncGenerator[str, None]:
        """Process Ollama streaming response."""
        buffer = ""
        async for chunk in response_stream:
            if chunk.response:
                buffer += chunk.response
                if len(buffer) >= self.chunk_size:
                    yield buffer
                    buffer = ""
        if buffer:
            yield buffer

================
File: apps/common/services/llm/__init__.py
================
"""LLM service package."""

from .service import LLMService
from .providers.base import BaseLLMProvider
from .providers.gemini import GeminiProvider
from .utils.cache import LLMCache
from .utils.rate_limiter import RateLimiter
from .utils.streaming import StreamingManager

__all__ = [
    'LLMService',
    'BaseLLMProvider',
    'GeminiProvider',
    'LLMCache',
    'RateLimiter',
    'StreamingManager'
]

================
File: apps/common/services/llm/service.py
================
"""Core LLM service implementation."""

import asyncio
import logging
from typing import Any, AsyncGenerator, Dict, Optional, Tuple, Union
import tiktoken
from tenacity import retry, stop_after_attempt, wait_exponential

from django.conf import settings
from apps.common.models import LLMConfiguration, TokenUsage, ProviderType

from .providers.base import BaseLLMProvider
from .providers.gemini import GeminiProvider
from .providers.openai import OpenAIProvider
from .providers.anthropic import AnthropicProvider
from .providers.openrouter import OpenRouterProvider
from .providers.ollama import OllamaProvider
from .utils.cache import LLMCache
from .utils.rate_limiter import RateLimiter
from .utils.streaming import StreamingManager

logger = logging.getLogger(__name__)

class LLMService:
    """
    Centralized service for managing LLM interactions.
    Handles model initialization, authentication, token tracking, and error handling.
    """
    
    PROVIDER_MAP = {
        'gemini': GeminiProvider,
        'openai': OpenAIProvider,
        'anthropic': AnthropicProvider,
        'openrouter': OpenRouterProvider,
        'ollama': OllamaProvider
    }
    
    def __init__(self, user=None, cache_ttl: int = 3600):
        """Initialize the LLM service with optional user context."""
        self.user = user
        self._provider_instances: Dict[str, BaseLLMProvider] = {}
        self._rate_limiters: Dict[str, RateLimiter] = {}
        self.tokenizer = tiktoken.get_encoding("cl100k_base")
        
        # Initialize cache
        self.cache = LLMCache(ttl=cache_ttl)
        
        # Initialize config
        self._config = None
        self._config_task = None
    
    @property
    async def config(self) -> Optional[LLMConfiguration]:
        """Get the active LLM configuration."""
        if self._config is None and not self._config_task:
            self._config_task = asyncio.create_task(self._load_config())
        if self._config_task:
            await self._config_task
        return self._config
        
    async def _load_config(self):
        """Load the configuration for the specified provider type."""
        try:
            # Get the most recently updated configuration for each provider type
            self._config = await LLMConfiguration.objects.order_by('-updated_at').afirst()
            if not self._config:
                logger.warning("No LLM configuration found")
        except Exception as e:
            logger.error(f"Error loading LLM configuration: {str(e)}")
            self._config = None
        finally:
            self._config_task = None
    
    async def get_provider(
        self,
        provider_type: str = "gemini",
        **kwargs
    ) -> BaseLLMProvider:
        """Get or create a provider instance."""
        # Convert provider type to lowercase for lookup
        provider_type_lower = provider_type.lower()
        
        # Get configuration matching provider type (case insensitive)
        from django.db import models
        config = await models.QuerySet(LLMConfiguration).filter(provider_type__iexact=provider_type).afirst()
        if not config:
            raise ValueError(f"No configuration found for provider type: {provider_type}")
            
        cache_key = f"{provider_type_lower}_{config.name}"
        
        if cache_key in self._provider_instances:
            return self._provider_instances[cache_key]
        
        provider_class = self.PROVIDER_MAP.get(provider_type_lower)
        if not provider_class:
            raise ValueError(f"Unsupported provider type: {provider_type}")
        
        provider = provider_class(config)
        
        # Initialize provider if it has initialize method
        if hasattr(provider, 'initialize'):
            try:
                await provider.initialize()
            except Exception as e:
                logger.error(f"Error initializing provider {provider_type}: {str(e)}")
                raise
        
        self._provider_instances[cache_key] = provider
        return provider
    
    async def _get_rate_limiter(self, provider_type: str) -> RateLimiter:
        """Get or create rate limiter for provider."""
        provider_type_lower = provider_type.lower()
        if provider_type_lower not in self._rate_limiters:
            from django.db import models
            config = await models.QuerySet(LLMConfiguration).filter(provider_type__iexact=provider_type).afirst()
            if not config:
                raise ValueError(f"No configuration found for provider type: {provider_type}")
                
            self._rate_limiters[provider_type_lower] = RateLimiter(
                provider_type=provider_type_lower,
                requests_per_minute=config.requests_per_minute,
                tokens_per_minute=config.tokens_per_minute
            )
        return self._rate_limiters[provider_type_lower]
    
    async def get_available_models(self, provider_type: str) -> dict:
        """Get available models for a provider."""
        provider = await self.get_provider(provider_type)
        models = await provider.get_available_models()
        
        # If models is empty or None, try initializing the provider again
        if not models:
            try:
                await provider.initialize()
                models = provider.available_models
            except Exception as e:
                logger.error(f"Error getting models after reinitialization: {str(e)}")
                raise
        
        return models
    
    async def get_provider_config(self, provider_type: str) -> Optional[LLMConfiguration]:
        """Get configuration for a specific provider type."""
        try:
            return await LLMConfiguration.objects.filter(
                provider_type__iexact=provider_type
            ).order_by('-updated_at').afirst()
        except Exception as e:
            logger.error(f"Error getting provider config: {str(e)}")
            return None
    
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry_error_callback=lambda retry_state: retry_state.outcome.result()
    )
    async def get_completion(
        self,
        messages: list,
        provider_type: str = None,
        use_cache: bool = True,
        stream: bool = False,
        **kwargs
    ) -> Union[Tuple[str, dict], AsyncGenerator[str, None]]:
        """
        Get completion from the configured provider with caching and rate limiting.
        
        Args:
            messages: List of messages for the completion
            provider_type: Type of provider to use (required)
            use_cache: Whether to use response caching
            stream: Whether to stream the response
            **kwargs: Additional completion parameters
            
        Returns:
            Either (completion text, metadata) tuple or streaming generator
        """
        if stream:
            return self.get_streaming_completion(
                messages=messages,
                provider_type=provider_type,
                **kwargs
            )
        
        if not provider_type:
            raise ValueError("provider_type is required")
            
        config = await self.get_provider_config(provider_type)
        if not config:
            raise ValueError(f"No configuration found for provider type: {provider_type}")
        
        provider_type = provider_type or config.provider_type
        model = kwargs.pop('model', None) or kwargs.pop('model_name', config.default_model)
        
        # Check cache if enabled
        if use_cache:
            cached = self.cache.get_cached_response(
                messages=messages,
                provider_type=provider_type.lower(),  # Normalize for cache key
                model=model,
                **kwargs
            )
            if cached:
                return cached.content, cached.metadata
        
        # Check rate limits
        rate_limiter = await self._get_rate_limiter(provider_type)
        is_allowed, reason = rate_limiter.check_rate_limit()
        if not is_allowed:
            raise ValueError(f"Rate limit exceeded: {reason}")
        
        # Get provider
        provider = await self.get_provider(provider_type)
        
        try:
            # Get completion from provider
            completion, metadata = await provider.get_completion(
                messages=messages,
                stream=False,
                model=model,  # Pass model explicitly
                **kwargs
            )
            
            # Track token usage
            if 'usage' in metadata:
                await self.track_token_usage(
                    model=model,
                    prompt_tokens=metadata['usage'].get('prompt_tokens', 0),
                    completion_tokens=metadata['usage'].get('completion_tokens', 0),
                    provider_type=provider_type.lower()  # Normalize for tracking
                )
                rate_limiter.increment_counters(
                    tokens_used=metadata['usage'].get('total_tokens', 0)
                )
            
            # Cache response if enabled
            if use_cache:
                self.cache.cache_response(
                    messages=messages,
                    provider_type=provider_type.lower(),  # Normalize for cache key
                    model=model,
                    content=completion,
                    metadata=metadata,
                    **kwargs
                )
            
            return completion, metadata
            
        except Exception as e:
            logger.error(f"Error in completion: {str(e)}")
            raise
    
    async def get_streaming_completion(
        self,
        messages: list,
        provider_type: str = None,
        **kwargs
    ) -> AsyncGenerator[str, None]:
        """
        Get streaming completion from the configured provider.
        
        Args:
            messages: List of messages for the completion
            provider_type: Type of provider to use (defaults to config's provider_type)
            **kwargs: Additional completion parameters
            
        Yields:
            Chunks of completion text
        """
        config = await self.config
        if not config:
            raise ValueError("No active LLM configuration found")
        
        provider_type = provider_type or config.provider_type
        model = kwargs.get('model_name', config.default_model)
        
        # Check rate limits
        rate_limiter = await self._get_rate_limiter(provider_type)
        is_allowed, reason = rate_limiter.check_rate_limit()
        if not is_allowed:
            raise ValueError(f"Rate limit exceeded: {reason}")
        
        # Get provider and streaming manager
        provider = await self.get_provider(provider_type)
        streaming_config = config.get_streaming_config()
        streaming_manager = StreamingManager(
            chunk_size=streaming_config['stream_chunk_size'],
            timeout=streaming_config['stream_timeout']
        )
        
        try:
            # Set streaming flag in kwargs
            kwargs['stream'] = True
            
            # Get streaming response from provider
            response_stream = await provider.get_completion(messages, **kwargs)
            
            # Process stream based on provider type
            if provider_type == ProviderType.OPENAI:
                chunk_stream = streaming_manager.process_openai_stream(response_stream)
            elif provider_type == ProviderType.ANTHROPIC:
                chunk_stream = streaming_manager.process_anthropic_stream(response_stream)
            elif provider_type == ProviderType.GEMINI:
                chunk_stream = streaming_manager.process_gemini_stream(response_stream)
            elif provider_type == ProviderType.OLLAMA:
                chunk_stream = streaming_manager.process_ollama_stream(response_stream)
            else:
                raise ValueError(f"Streaming not supported for provider: {provider_type}")
            
            # Stream with timeout
            async for content in streaming_manager.stream_with_timeout(chunk_stream):
                yield content
            
        except Exception as e:
            logger.error(f"Error in streaming completion: {str(e)}")
            
            # Try fallback provider if configured
            if config.fallback_provider:
                logger.info(f"Attempting fallback to {config.fallback_provider.provider_type}")
                async for content in self.get_streaming_completion(
                    messages=messages,
                    provider_type=config.fallback_provider.provider_type,
                    **kwargs
                ):
                    yield content
            else:
                yield f"Error: {str(e)}"
    
    async def track_token_usage(
        self,
        model: str,
        prompt_tokens: int,
        completion_tokens: int,
        provider_type: str = None
    ):
        """Track token usage in database."""
        try:
            from asgiref.sync import sync_to_async
            create_token_usage = sync_to_async(TokenUsage.objects.create)
            await create_token_usage(
                user=self.user,
                model=model,
                prompt_tokens=prompt_tokens,
                completion_tokens=completion_tokens,
                provider_type=provider_type or self.config.provider_type,
                request_type='completion'
            )
        except Exception as e:
            logger.error(f"Error tracking token usage: {str(e)}")
    
    async def validate_api_key(self) -> bool:
        """Validate the current API key configuration."""
        config = await self.config
        if not config:
            return False
            
        try:
            # Try a simple completion request to validate
            messages = [{"role": "user", "content": "test"}]
            await self.get_completion(messages, use_cache=False)
            return True
        except Exception as e:
            logger.error(f"API key validation failed: {str(e)}")
            return False

================
File: apps/common/services/__init__.py
================
"""
Services package for common functionality.
"""

================
File: apps/common/services/llm_cache.py
================
"""
Caching service for LLM responses.
"""

import logging
import hashlib
import json
from typing import Optional, Any, Tuple
from django.core.cache import cache
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)

@dataclass
class CachedResponse:
    """Cached LLM response."""
    content: str
    metadata: dict
    created_at: datetime
    provider_type: str
    model: str

class LLMCache:
    """Cache for LLM responses."""
    
    def __init__(self, ttl: int = 3600):
        """
        Initialize cache.
        
        Args:
            ttl: Cache TTL in seconds (default: 1 hour)
        """
        self.ttl = ttl
        self.cache_key_prefix = "llm_cache"
    
    def _generate_cache_key(self, messages: list, provider_type: str, model: str, **kwargs) -> str:
        """Generate cache key from request parameters."""
        # Create deterministic string from parameters
        cache_data = {
            'messages': messages,
            'provider_type': provider_type,
            'model': model,
            # Include relevant kwargs that affect output
            'temperature': kwargs.get('temperature', 0.7),
            'max_tokens': kwargs.get('max_tokens'),
            'top_p': kwargs.get('top_p', 1.0),
        }
        
        # Create hash of parameters
        cache_str = json.dumps(cache_data, sort_keys=True)
        key_hash = hashlib.sha256(cache_str.encode()).hexdigest()
        
        return f"{self.cache_key_prefix}:{provider_type}:{model}:{key_hash}"
    
    def get_cached_response(
        self,
        messages: list,
        provider_type: str,
        model: str,
        **kwargs
    ) -> Optional[CachedResponse]:
        """
        Get cached response if available.
        
        Args:
            messages: List of messages
            provider_type: Provider type
            model: Model name
            **kwargs: Additional parameters
            
        Returns:
            Cached response if available, None otherwise
        """
        key = self._generate_cache_key(messages, provider_type, model, **kwargs)
        cached = cache.get(key)
        
        if cached:
            logger.debug(f"Cache hit for {provider_type}/{model}")
            return CachedResponse(**cached)
        
        return None
    
    def cache_response(
        self,
        messages: list,
        provider_type: str,
        model: str,
        content: str,
        metadata: dict,
        **kwargs
    ):
        """
        Cache LLM response.
        
        Args:
            messages: List of messages
            provider_type: Provider type
            model: Model name
            content: Response content
            metadata: Response metadata
            **kwargs: Additional parameters
        """
        key = self._generate_cache_key(messages, provider_type, model, **kwargs)
        
        cached_response = CachedResponse(
            content=content,
            metadata=metadata,
            created_at=datetime.now(),
            provider_type=provider_type,
            model=model
        )
        
        # Cache with TTL
        cache.set(key, cached_response.__dict__, timeout=self.ttl)
        logger.debug(f"Cached response for {provider_type}/{model}")
    
    def invalidate_cache(
        self,
        messages: list,
        provider_type: str,
        model: str,
        **kwargs
    ):
        """
        Invalidate cached response.
        
        Args:
            messages: List of messages
            provider_type: Provider type
            model: Model name
            **kwargs: Additional parameters
        """
        key = self._generate_cache_key(messages, provider_type, model, **kwargs)
        cache.delete(key)
        logger.debug(f"Invalidated cache for {provider_type}/{model}")
    
    def get_cache_stats(self) -> Tuple[int, int]:
        """
        Get cache statistics.
        
        Returns:
            Tuple of (hits, misses)
        """
        stats = cache.get_stats()
        return stats.get('hits', 0), stats.get('misses', 0)

================
File: apps/common/services/llm_service.py
================
"""LLM service module."""

from .llm import LLMService

__all__ = ['LLMService']

================
File: apps/common/services/rate_limiter.py
================
"""
Rate limiter service for LLM requests.
"""

import time
import logging
from typing import Optional, Tuple
from django.core.cache import cache
from dataclasses import dataclass
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

@dataclass
class RateLimitInfo:
    """Rate limit information."""
    window_start: float
    request_count: int
    token_count: int

class RateLimiter:
    """Rate limiter for LLM requests."""
    
    def __init__(self, provider_type: str, requests_per_minute: int, tokens_per_minute: int):
        self.provider_type = provider_type
        self.requests_per_minute = requests_per_minute
        self.tokens_per_minute = tokens_per_minute
        self.cache_key_prefix = f"ratelimit:{provider_type}"
    
    def _get_window_key(self) -> str:
        """Get cache key for current minute window."""
        return f"{self.cache_key_prefix}:{int(time.time() / 60)}"
    
    def _get_rate_limit_info(self) -> RateLimitInfo:
        """Get current rate limit information."""
        key = self._get_window_key()
        info = cache.get(key)
        if not info:
            info = RateLimitInfo(
                window_start=time.time(),
                request_count=0,
                token_count=0
            )
        return info
    
    def _save_rate_limit_info(self, info: RateLimitInfo):
        """Save rate limit information."""
        key = self._get_window_key()
        # Save with TTL of 2 minutes to ensure cleanup
        cache.set(key, info, timeout=120)
    
    def check_rate_limit(self, estimated_tokens: Optional[int] = None) -> Tuple[bool, str]:
        """
        Check if request is within rate limits.
        
        Args:
            estimated_tokens: Estimated token count for request
            
        Returns:
            Tuple of (is_allowed, reason)
        """
        info = self._get_rate_limit_info()
        
        # Check request limit
        if info.request_count >= self.requests_per_minute:
            return False, f"Request limit of {self.requests_per_minute}/min exceeded"
        
        # Check token limit if provided
        if estimated_tokens and info.token_count + estimated_tokens > self.tokens_per_minute:
            return False, f"Token limit of {self.tokens_per_minute}/min exceeded"
        
        return True, ""
    
    def increment_counters(self, tokens_used: Optional[int] = None):
        """
        Increment request and token counters.
        
        Args:
            tokens_used: Number of tokens used in request
        """
        info = self._get_rate_limit_info()
        info.request_count += 1
        if tokens_used:
            info.token_count += tokens_used
        self._save_rate_limit_info(info)
    
    def get_current_usage(self) -> Tuple[int, int]:
        """
        Get current usage counts.
        
        Returns:
            Tuple of (requests_used, tokens_used)
        """
        info = self._get_rate_limit_info()
        return info.request_count, info.token_count

================
File: apps/common/services/streaming.py
================
"""
Streaming support for LLM responses.
"""

import logging
import asyncio
import json
from typing import AsyncGenerator, Optional, Any, Dict
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)

@dataclass
class StreamingChunk:
    """Chunk of streaming response."""
    content: str
    metadata: Optional[Dict[str, Any]] = None
    delta_usage: Optional[Dict[str, int]] = None
    is_error: bool = False
    error_message: Optional[str] = None
    timestamp: datetime = datetime.now()

class StreamingManager:
    """Manager for streaming LLM responses."""
    
    def __init__(self, chunk_size: int = 100, timeout: int = 60):
        """
        Initialize streaming manager.
        
        Args:
            chunk_size: Size of chunks to buffer
            timeout: Streaming timeout in seconds
        """
        self.chunk_size = chunk_size
        self.timeout = timeout
        self._buffer = []
    
    async def process_openai_stream(
        self,
        response_stream: Any
    ) -> AsyncGenerator[StreamingChunk, None]:
        """
        Process OpenAI streaming response.
        
        Args:
            response_stream: OpenAI streaming response
            
        Yields:
            StreamingChunk objects
        """
        try:
            async for chunk in response_stream:
                if hasattr(chunk.choices[0].delta, "content"):
                    content = chunk.choices[0].delta.content
                    if content:
                        yield StreamingChunk(
                            content=content,
                            metadata={'model': chunk.model},
                            delta_usage=chunk.usage.dict() if chunk.usage else None
                        )
        except Exception as e:
            logger.error(f"Error processing OpenAI stream: {str(e)}")
            yield StreamingChunk(
                content="",
                is_error=True,
                error_message=str(e)
            )
    
    async def process_anthropic_stream(
        self,
        response_stream: Any
    ) -> AsyncGenerator[StreamingChunk, None]:
        """
        Process Anthropic streaming response.
        
        Args:
            response_stream: Anthropic streaming response
            
        Yields:
            StreamingChunk objects
        """
        try:
            async for chunk in response_stream:
                if chunk.type == "content_block_delta":
                    yield StreamingChunk(
                        content=chunk.delta.text,
                        metadata={'model': chunk.model}
                    )
                elif chunk.type == "message_delta":
                    if chunk.usage:
                        yield StreamingChunk(
                            content="",
                            delta_usage={
                                'input_tokens': chunk.usage.input_tokens,
                                'output_tokens': chunk.usage.output_tokens
                            }
                        )
        except Exception as e:
            logger.error(f"Error processing Anthropic stream: {str(e)}")
            yield StreamingChunk(
                content="",
                is_error=True,
                error_message=str(e)
            )
    
    async def process_gemini_stream(
        self,
        response_stream: Any
    ) -> AsyncGenerator[StreamingChunk, None]:
        """
        Process Gemini streaming response.
        
        Args:
            response_stream: Gemini streaming response
            
        Yields:
            StreamingChunk objects
        """
        try:
            async for chunk in response_stream:
                if chunk.text:
                    yield StreamingChunk(
                        content=chunk.text,
                        metadata={'model': 'gemini-pro'}
                    )
        except Exception as e:
            logger.error(f"Error processing Gemini stream: {str(e)}")
            yield StreamingChunk(
                content="",
                is_error=True,
                error_message=str(e)
            )
    
    async def process_ollama_stream(
        self,
        response_stream: Any
    ) -> AsyncGenerator[StreamingChunk, None]:
        """
        Process Ollama streaming response.
        
        Args:
            response_stream: Ollama streaming response
            
        Yields:
            StreamingChunk objects
        """
        try:
            async for line in response_stream:
                try:
                    data = json.loads(line)
                    if 'response' in data:
                        yield StreamingChunk(
                            content=data['response'],
                            metadata={
                                'model': data.get('model', 'unknown'),
                                'eval_count': data.get('eval_count'),
                                'eval_duration': data.get('eval_duration')
                            }
                        )
                except json.JSONDecodeError:
                    continue
        except Exception as e:
            logger.error(f"Error processing Ollama stream: {str(e)}")
            yield StreamingChunk(
                content="",
                is_error=True,
                error_message=str(e)
            )
    
    async def buffer_stream(
        self,
        stream: AsyncGenerator[StreamingChunk, None]
    ) -> AsyncGenerator[str, None]:
        """
        Buffer streaming response into chunks.
        
        Args:
            stream: Stream of chunks
            
        Yields:
            Buffered content strings
        """
        try:
            async for chunk in stream:
                if chunk.is_error:
                    yield f"Error: {chunk.error_message}"
                    return
                
                self._buffer.append(chunk.content)
                
                if len(''.join(self._buffer)) >= self.chunk_size:
                    yield ''.join(self._buffer)
                    self._buffer = []
            
            # Yield remaining buffer
            if self._buffer:
                yield ''.join(self._buffer)
                self._buffer = []
                
        except asyncio.TimeoutError:
            logger.error("Streaming timeout")
            yield "Error: Streaming timeout"
        except Exception as e:
            logger.error(f"Error buffering stream: {str(e)}")
            yield f"Error: {str(e)}"
    
    async def stream_with_timeout(
        self,
        stream: AsyncGenerator[StreamingChunk, None]
    ) -> AsyncGenerator[str, None]:
        """
        Stream with timeout.
        
        Args:
            stream: Stream of chunks
            
        Yields:
            Content with timeout handling
        """
        try:
            async with asyncio.timeout(self.timeout):
                async for content in self.buffer_stream(stream):
                    yield content
        except asyncio.TimeoutError:
            logger.error("Streaming timeout")
            yield "Error: Streaming timeout"
        except Exception as e:
            logger.error(f"Error in stream_with_timeout: {str(e)}")
            yield f"Error: {str(e)}"

================
File: apps/common/static/admin/js/llm_test_harness.js
================
// LLM Test Harness JavaScript
jQuery(function($) {
    'use strict';
    
    // Get configs from window
    const configs = window.llmConfigs;
    
    // Cache for model information
    let modelCache = {};
    let dropzoneCounter = 0;
    
    const form = document.getElementById('test-form');
    const providerSelect = document.getElementById('provider');
    const modelSelect = document.getElementById('model');
    const modelInfo = document.getElementById('model-info');
    const addMessageBtn = document.getElementById('add-message');
    const messagesContainer = document.getElementById('messages');
    const completionContainer = document.getElementById('completion');
    const completionText = document.querySelector('.completion-text');
    const metadataDiv = document.querySelector('.metadata');
    const loading = document.querySelector('.loading');
    const errorAlert = document.getElementById('error-alert');
    const errorMessage = document.getElementById('error-message');
    const enableVision = document.getElementById('enable_vision');
    
    function showError(message) {
        errorMessage.textContent = message;
        $(errorAlert).fadeIn(300);
    }
    
    // Initialize Dropzone for a message
    function initDropzone(container) {
        const dropzoneEl = container.querySelector('.dropzone');
        if (!dropzoneEl) return null;
        
        // Generate unique ID if not already set
        if (!dropzoneEl.id) {
            dropzoneEl.id = `message-dropzone-${++dropzoneCounter}`;
        }
        
        try {
            const dropzone = new Dropzone(`#${dropzoneEl.id}`, {
                url: "/file-upload",
                addRemoveLinks: true,
                acceptedFiles: 'image/jpeg,image/png',
                autoProcessQueue: false,
                uploadMultiple: true,
                parallelUploads: 5,
                maxFilesize: 5,
                dictDefaultMessage: `
                    <i class="fas fa-cloud-upload-alt me-2"></i>
                    Drop images here or click to upload (JPEG, PNG only)
                `,
                init: function() {
                    this.on("addedfile", function(file) {
                        
                        // Check both MIME type and file extension
                        const needsConversion = file.type !== 'image/jpeg' && file.type !== 'image/png' ||
                                             file.name.toLowerCase().endsWith('.jfif');
                        
                        if (needsConversion) {
                            const img = new Image();
                            img.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0);
                                
                                // Convert to JPEG data URL and create new blob
                                canvas.toBlob((blob) => {
                                    // Create a new File object with JPEG type
                                    const convertedFile = new File([blob], file.name.replace(/\.[^/.]+$/, '.jpg'), {
                                        type: 'image/jpeg',
                                        lastModified: new Date().getTime()
                                    });
                                    
                                    // Replace the file in dropzone
                                    const index = this.files.indexOf(file);
                                    if (index !== -1) {
                                        this.files[index] = convertedFile;
                                    }
                                    
                                    // Store the data URL
                                    convertedFile.dataURL = canvas.toDataURL('image/jpeg', 0.9);
                                }, 'image/jpeg', 0.9);
                            };
                            img.onerror = (error) => {
                                console.error("Error loading image for conversion:", error);
                                showError(`Failed to convert image ${file.name}`);
                            };
                            img.src = URL.createObjectURL(file);
                        } else {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                file.dataURL = e.target.result;
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                    
                    this.on("thumbnail", function(file, dataUrl) {
                        if (!file.dataURL) {
                            file.dataURL = dataUrl;
                        }
                    });
                    
                    this.on("error", function(file, message) {
                        console.error("Dropzone error:", message);
                        showError(message);
                        this.removeFile(file);
                    });
                }
            });
            
            return dropzone;
        } catch (error) {
            console.error('Error initializing dropzone:', error);
            return null;
        }
    }
    
    // Initialize existing dropzones after a short delay
    setTimeout(() => {
        document.querySelectorAll('.message').forEach(initDropzone);
    }, 100);
    
    // Add message button handler with animation
    $(addMessageBtn).on('click', function() {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message';
        messageDiv.style.display = 'none';  // Hide initially for animation
        messageDiv.innerHTML = `
            <div class="message-role">
                <select class="form-control" name="role">
                    <option value="system">System</option>
                    <option value="user" selected>User</option>
                    <option value="assistant">Assistant</option>
                </select>
            </div>
            <div class="message-content">
                <textarea class="form-control" name="content" rows="4" required></textarea>
                <div class="image-upload mt-2" style="display: ${enableVision.checked ? 'block' : 'none'}">
                    <div action="/file-upload" class="form-control dropzone" id="message-dropzone-${dropzoneCounter + 1}"></div>
                </div>
            </div>
            <button type="button" class="btn btn-danger btn-sm mt-2 remove-message">
                <i class="fas fa-trash"></i> Remove
            </button>
        `;
        
        messagesContainer.appendChild(messageDiv);
        
        // Initialize dropzone and show message
        initDropzone(messageDiv);
        $(messageDiv).slideDown(300);
    });
    
    // Handle vision checkbox change
    $(enableVision).on('change', function() {
        const imageUploads = document.querySelectorAll('.image-upload');
        if (this.checked) {
            imageUploads.forEach(upload => $(upload).slideDown(300));
        } else {
            imageUploads.forEach(upload => $(upload).slideUp(300));
        }
    });
    
    // Remove message button handler with animation
    $(messagesContainer).on('click', '.remove-message', function() {
        const messageDiv = $(this).closest('.message');
        const dropzoneEl = messageDiv.find('.dropzone')[0];
        
        // Cleanup dropzone instance
        if (dropzoneEl) {
            const dropzone = Dropzone.forElement(dropzoneEl);
            if (dropzone) {
                dropzone.destroy();
            }
        }
        
        messageDiv.slideUp(300, function() {
            messageDiv.remove();
        });
    });

    // Modify the form submission to include images
    async function getMessageData() {
        const messages = [];
        const messageElements = messagesContainer.querySelectorAll('.message');
        
        for (const messageEl of messageElements) {
            const role = messageEl.querySelector('select[name="role"]').value;
            const content = messageEl.querySelector('textarea[name="content"]').value;
            const dropzoneEl = messageEl.querySelector('.dropzone');
            const dropzone = dropzoneEl ? Dropzone.forElement(dropzoneEl) : null;
            
            if (enableVision.checked && dropzone && dropzone.files.length > 0) {
                const parts = [];
                
                // Get the first image file
                const file = dropzone.files[0];
                
                try {
                    // Get the image data
                    const imageData = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const base64Data = reader.result.split(',')[1];
                            resolve(base64Data);
                        };
                        reader.onerror = reject;
                        reader.readAsDataURL(file);
                    });
                    
                    // Add image first
                    parts.push({
                        mime_type: file.type,
                        data: imageData
                    });
                    
                    // Add prompt after image
                    if (content.trim()) {
                        parts.push(content.trim());
                    } else {
                        parts.push("Describe the image");
                    }
                    
                    messages.push({
                        role: role,
                        content: parts
                    });
                    
                } catch (error) {
                    console.error('Error processing image:', error);
                    showError(`Failed to process image ${file.name}: ${error.message}`);
                }
            } else {
                messages.push({
                    role: role,
                    content: content
                });
            }
        }
        
        // Debug log to verify message structure
        const debugMessages = JSON.parse(JSON.stringify(messages));
        debugMessages.forEach(msg => {
            if (Array.isArray(msg.content)) {
                msg.content.forEach(part => {
                    if (part.data) {
                        part.data = part.data.substring(0, 50) + '...';
                    }
                });
            }
        });
        
        return messages;
    }
    
    // Load models when provider changes
    $(providerSelect).on('change', async function() {
        const provider = this.value;
        modelSelect.innerHTML = '<option value="">Loading models...</option>';
        modelInfo.innerHTML = '';
        
        if (!provider) {
            modelSelect.innerHTML = '<option value="">Select Provider First</option>';
            return;
        }
        
        try {
            // Show loading state
            $(modelSelect).addClass('loading').prop('disabled', true);
            
            // Try to get models from cache first
            if (!modelCache[provider]) {
                const response = await fetch(window.llmModelsUrl + '?provider=' + provider);
                if (!response.ok) throw new Error('Failed to load models');
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                if (!data || Object.keys(data).length === 0) {
                    throw new Error('No models available for this provider');
                }
                
                modelCache[provider] = data;
            }
            
            const models = modelCache[provider];
            modelSelect.innerHTML = '<option value="">Select Model</option>';
            
            Object.entries(models).forEach(([modelId, modelData]) => {
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = modelId;
                option.dataset.info = JSON.stringify(modelData);
                modelSelect.appendChild(option);
            });
            
            // Set default model if specified in config
            const activeConfig = configs.find(c => c.provider_type === provider && c.is_active);
            if (activeConfig && activeConfig.default_model) {
                modelSelect.value = activeConfig.default_model;
                updateModelInfo();
            }
        } catch (error) {
            console.error('Error loading models:', error);
            showError('Failed to load models. Please try again.');
            modelSelect.innerHTML = '<option value="">Failed to load models</option>';
        } finally {
            $(modelSelect).removeClass('loading').prop('disabled', false);
        }
    });
    
    // Update model info when model changes with animation
    $(modelSelect).on('change', function() {
        $(modelInfo).fadeOut(200, function() {
            updateModelInfo();
            $(modelInfo).fadeIn(200);
        });
    });
    
    function updateModelInfo() {
        const selectedOption = modelSelect.selectedOptions[0];
        if (selectedOption && selectedOption.dataset.info) {
            const modelData = JSON.parse(selectedOption.dataset.info);
            modelInfo.innerHTML = `
                <div class="mt-2">
                    <strong>Description:</strong> ${modelData.description || 'N/A'}<br>
                    <strong>Context Window:</strong> ${modelData.context_window || modelData.input_tokens || 'N/A'} tokens<br>
                    <strong>Features:</strong> 
                    ${modelData.supports_vision ? '<span class="badge bg-info me-1">🖼️ Vision</span>' : ''}
                    ${modelData.supports_json ? '<span class="badge bg-success me-1">📋 JSON</span>' : ''}
                    ${modelData.supports_functions ? '<span class="badge bg-warning me-1">⚙️ Functions</span>' : ''}
                </div>
            `;
            
            // Update max tokens based on model limits
            const maxTokensInput = document.getElementById('max_tokens');
            if (modelData.output_tokens) {
                maxTokensInput.max = modelData.output_tokens;
                maxTokensInput.value = Math.min(maxTokensInput.value, modelData.output_tokens);
            }
        } else {
            modelInfo.innerHTML = '';
        }
    }
    
    // Form submission handler
    $(form).on('submit', async function(e) {
        e.preventDefault();
        
        const provider = providerSelect.value;
        const model = modelSelect.value;
        const temperature = parseFloat(document.getElementById('temperature').value) || 0.7;
        const maxTokens = parseInt(document.getElementById('max_tokens').value) || 1000;
        const stream = document.getElementById('stream').checked;
        
        // Show loading with animation
        $(loading).fadeIn(300);
        $(completionContainer).fadeOut(300);
        completionText.textContent = '';
        metadataDiv.textContent = '';
        $(errorAlert).fadeOut(300);
        
        try {
            const messages = await getMessageData();
            
            // Transform to Gemini vision API format
            const requestData = {
                provider_type: provider,
                model,
                messages: messages,  // Send all messages instead of just first message content
                temperature,
                max_tokens: maxTokens,
                stream
            };
            
            // Log request data for debugging
            const debugRequestData = JSON.parse(JSON.stringify(requestData));
            if (debugRequestData.messages) {
                debugRequestData.messages.forEach(msg => {
                    if (Array.isArray(msg.content)) {
                        msg.content.forEach(part => {
                            if (part.data) {
                                part.data = part.data.substring(0, 50) + '...';
                            }
                        });
                    }
                });
            }
            
            if (stream) {
                // Handle streaming response
                const response = await fetch(window.llmCompletionUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': window.csrfToken
                    },
                    body: JSON.stringify(requestData)
                });
                
                if (!response.ok) {
                    throw new Error('Failed to get streaming response');
                }
                
                $(completionContainer).fadeIn(300);
                const reader = response.body.getReader();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    const text = new TextDecoder().decode(value);
                    completionText.textContent += text;
                    // Auto-scroll to bottom of completion
                    completionText.scrollTop = completionText.scrollHeight;
                }
            } else {
                // Handle regular response
                const response = await fetch(window.llmCompletionUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': window.csrfToken
                    },
                    body: JSON.stringify(requestData)
                });
                
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to get completion');
                }
                
                $(completionContainer).fadeIn(300);
                completionText.textContent = data.completion;
                
                if (data.metadata) {
                    const usage = data.metadata.usage || {};
                    const promptTokens = usage.prompt_tokens || usage.input_tokens || data.metadata.prompt_tokens || data.metadata.input_tokens || 'N/A';
                    const completionTokens = usage.completion_tokens || usage.output_tokens || data.metadata.completion_tokens || data.metadata.output_tokens || 'N/A';
                    const totalTokens = usage.total_tokens || data.metadata.total_tokens || (promptTokens !== 'N/A' && completionTokens !== 'N/A' ? promptTokens + completionTokens : 'N/A');

                    metadataDiv.innerHTML = `
                        <div class="metadata-content">
                            <h5 class="mb-3">Usage Statistics</h5>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="card bg-light">
                                        <div class="card-body">
                                            <h6 class="card-title">Prompt Tokens</h6>
                                            <p class="card-text">${promptTokens}</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card bg-light">
                                        <div class="card-body">
                                            <h6 class="card-title">Completion Tokens</h6>
                                            <p class="card-text">${completionTokens}</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card bg-light">
                                        <div class="card-body">
                                            <h6 class="card-title">Total Tokens</h6>
                                            <p class="card-text">${totalTokens}</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }
        } catch (error) {
            console.error('Error:', error);
            showError(error.message || 'An error occurred');
        } finally {
            $(loading).fadeOut(300);
        }
    });
});

================
File: apps/common/static/common/js/services/websocket.js
================
// Base WebSocket service for handling common WebSocket functionality
export class BaseWebSocketService {
    constructor(config) {
        this.config = config;
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.handlers = new Map();
        this.lastPongTime = Date.now();
    }

    connect() {
        if (this.socket?.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }

        if (this.socket) {
            this.socket.close();
        }

        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}${this.config.endpoint}`;

        try {
            this.socket = new WebSocket(wsUrl);
            this.setupEventHandlers();
            this.startPingInterval();
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            this.handleReconnect();
        }
    }

    setupEventHandlers() {
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.emit('connectionStatus', 'connected');
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') {
                    this.lastPongTime = Date.now();
                    return;
                }
                this.handleMessage(data);
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };

        this.socket.onclose = (event) => {
            this.isConnected = false;
            this.stopPingInterval();
            this.emit('connectionStatus', 'disconnected');
            
            if (event.code !== 1000 && event.code !== 1001) {
                this.handleReconnect();
            }
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.emit('connectionStatus', 'error');
        };
    }

    handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            const jitter = Math.random() * 1000;
            setTimeout(() => this.connect(), delay + jitter);
        } else {
            this.emit('error', 'Max reconnection attempts reached');
        }
    }

    send(data) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
        } else {
            console.warn('WebSocket not connected, message not sent:', data);
        }
    }

    on(event, handler) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, new Set());
        }
        this.handlers.get(event).add(handler);
    }

    emit(event, data) {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }

    disconnect() {
        this.stopPingInterval();
        if (this.socket) {
            this.socket.close();
        }
    }

    startPingInterval() {
        this.stopPingInterval();
        this.pingInterval = setInterval(() => {
            if (this.socket?.readyState === WebSocket.OPEN) {
                if (Date.now() - this.lastPongTime > 45000) {
                    this.socket.close();
                    this.connect();
                    return;
                }
                this.send({ type: 'ping' });
            }
        }, 15000);
    }

    stopPingInterval() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
    }

    handleMessage(data) {
        console.log('Received message:', data);
        if (data.type === 'research_update') {
            if (this.handlers.has(data.type)) {
                this.handlers.get(data.type).forEach(handler => handler(data.data));
            }
        } else if (data.type && this.handlers.has(data.type)) {
            this.handlers.get(data.type).forEach(handler => handler(data));
        }
    }
}

================
File: apps/common/static/js/services/websocket.js
================
// Base WebSocket service for handling common WebSocket functionality
export class BaseWebSocketService {
    constructor(config) {
        this.config = config;
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.handlers = new Map();
        this.lastPongTime = Date.now();
        this.messageQueue = [];
        this.connecting = false;
        
        // Cloudflare optimized settings
        this.pingInterval = 25000; // 25 seconds
        this.pongTimeout = 10000;  // 10 seconds to wait for pong
    }

    connect() {
        if (this.connecting) {
            console.log('WebSocket already connecting or reconnecting in progress');
            return;
        }

        if (this.socket?.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }

        this.connecting = true;

        if (this.socket) {
            this.socket.close();
        }

        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}${this.config.endpoint}`;

        try {
            console.log('Establishing WebSocket connection...');
            this.socket = new WebSocket(wsUrl);
            this.setupEventHandlers();
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            this.connecting = false;
            this.handleReconnect();
        }
    }

    setupEventHandlers() {
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.connecting = false;
            this.reconnectAttempts = 0;
            this.emit('connectionStatus', 'connected');
            this.startPingInterval();
            
            // Process any queued messages
            while (this.messageQueue.length > 0) {
                const data = this.messageQueue.shift();
                this.send(data);
            }
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') {
                    this.lastPongTime = Date.now();
                    return;
                }
                this.handleMessage(data);
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };

        this.socket.onclose = (event) => {
            console.log(`WebSocket closed: ${event.code} - ${event.reason}`);
            this.isConnected = false;
            this.connecting = false;
            this.stopPingInterval();
            this.emit('connectionStatus', 'disconnected');
            
            if (event.code !== 1000 && event.code !== 1001) {
                this.handleReconnect();
            }
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.connecting = false;
            this.emit('connectionStatus', 'error');
        };
    }

    handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            const jitter = Math.random() * 1000;
            const totalDelay = delay + jitter;
            
            console.log(`Attempting to reconnect in ${totalDelay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);
            
            setTimeout(() => {
                console.log('Reconnecting...');
                this.connect();
            }, totalDelay);
        } else {
            console.error('Max reconnection attempts reached');
            this.emit('error', 'Max reconnection attempts reached');
        }
    }

    send(data) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
        } else {
            console.log('WebSocket not connected, queueing message:', data);
            this.messageQueue.push(data);
            if (!this.isConnected && !this.connecting) {
                this.connect();
            }
        }
    }

    on(event, handler) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, new Set());
        }
        this.handlers.get(event).add(handler);
    }

    emit(event, data) {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }

    disconnect() {
        this.stopPingInterval();
        if (this.socket) {
            this.socket.close();
        }
    }

    startPingInterval() {
        this.stopPingInterval();
        this.pingIntervalId = setInterval(() => {
            if (this.socket?.readyState === WebSocket.OPEN) {
                // Check if we haven't received a pong in too long
                if (Date.now() - this.lastPongTime > this.pingInterval + this.pongTimeout) {
                    console.log('Pong timeout - reconnecting WebSocket');
                    this.socket.close();
                    this.connect();
                    return;
                }
                this.send({ type: 'ping' });
            }
        }, this.pingInterval);
    }

    stopPingInterval() {
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
            this.pingIntervalId = null;
        }
    }
}

================
File: apps/common/templates/admin/common/llm_test_harness.html
================
{% extends "admin/base_site.html" %}
{% load static %}

{% block extrastyle %}
{{ block.super }}
<style>
    .test-harness-container {
        padding: 24px;
        max-width: 1200px;
        margin: 0 auto;
        background: #f8f9fa;
    }
    .card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
        padding: 24px;
        margin-bottom: 24px;
        border: none;
    }
    .card-header {
        border-bottom: 1px solid #eee;
        padding-bottom: 16px;
        margin-bottom: 20px;
        background: none;
    }
    .card-header h3 {
        margin: 0;
        color: #344767;
        font-weight: 600;
        font-size: 1.5rem;
    }
    h4 {
        color: #344767;
        font-weight: 600;
        font-size: 1.2rem;
        margin-bottom: 1.5rem;
    }
    .message-container {
        margin-bottom: 20px;
    }
    .message {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
        border: 1px solid #e9ecef;
    }
    .message-role {
        margin-bottom: 12px;
    }
    .message-content {
        width: 100%;
    }
    .message-content textarea {
        border-radius: 8px;
        border: 1px solid #dee2e6;
        padding: 12px;
        min-height: 120px;
        font-size: 14px;
        line-height: 1.6;
        width: 100%;
        background: white;
    }
    .completion-container {
        margin-top: 24px;
        padding: 24px;
        border-radius: 12px;
        background-color: white;
        border: 1px solid #e9ecef;
    }
    .completion-text {
        white-space: pre-wrap;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
        font-size: 14px;
        line-height: 1.6;
        color: #2d3748;
        padding: 16px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        margin-bottom: 20px;
    }
    .metadata {
        margin-top: 24px;
    }
    .metadata-content {
        background: white;
        padding: 20px;
        border-radius: 12px;
    }
    .metadata h5 {
        color: #344767;
        font-weight: 600;
        font-size: 1.1rem;
        margin-bottom: 1.5rem;
    }
    .metadata .card {
        border: 1px solid #e9ecef;
        box-shadow: none;
        padding: 16px;
        text-align: center;
        height: 100%;
    }
    .metadata .card-title {
        color: #718096;
        font-size: 0.9rem;
        font-weight: 600;
        margin-bottom: 8px;
    }
    .metadata .card-text {
        color: #2d3748;
        font-size: 1.5rem;
        font-weight: 600;
    }
    .loading {
        display: none;
        margin: 24px 0;
        text-align: center;
    }
    .loading .spinner-border {
        width: 3rem;
        height: 3rem;
        color: #5e72e4;
    }
    .model-info {
        margin-top: 12px;
        padding: 16px;
        background: #f8f9fa;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        font-size: 0.9rem;
        color: #4a5568;
        line-height: 1.6;
    }
    .model-info strong {
        color: #2d3748;
    }
    .form-label {
        font-weight: 600;
        color: #4a5568;
        margin-bottom: 8px;
        font-size: 0.9rem;
    }
    .form-control {
        border-radius: 8px;
        padding: 8px 12px;
        border: 1px solid #e2e8f0;
        height: 42px;
        font-size: 0.95rem;
        color: #020916;
        background: white;
    }
    select.form-control {
        height: 42px;
        padding: 8px 12px;
        line-height: 1.5;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
        background-repeat: no-repeat;
        background-position: right 0.75rem center;
        background-size: 16px 12px;
        appearance: none;
    }
    .form-control:focus {
        border-color: #5e72e4;
        box-shadow: 0 0 0 3px rgba(94, 114, 228, 0.1);
    }
    .btn {
        border-radius: 8px;
        padding: 8px 16px;
        font-weight: 500;
        transition: all 0.2s;
        font-size: 0.95rem;
    }
    .btn-primary {
        background: #5e72e4;
        border-color: #5e72e4;
        color: white;
    }
    .btn-primary:hover {
        background: #4454c3;
        border-color: #4454c3;
    }
    .btn-secondary {
        background: #f8f9fa;
        border-color: #e9ecef;
        color: #4a5568;
    }
    .btn-secondary:hover {
        background: #e9ecef;
        border-color: #dee2e6;
    }
    .btn-danger {
        background: #f5365c;
        border-color: #f5365c;
    }
    .btn-danger:hover {
        background: #d92550;
        border-color: #d92550;
    }
    .remove-message {
        margin-top: 8px;
    }
    #error-alert {
        display: none;
        margin: 20px 0;
        padding: 16px;
        border-radius: 8px;
        background-color: #fff5f5;
        border: 1px solid #feb2b2;
        color: #c53030;
    }
    .badge {
        padding: 6px 10px;
        font-weight: 500;
        font-size: 0.85rem;
        border-radius: 6px;
    }
    .form-check {
        padding-left: 1.8rem;
    }
    .form-check-input {
        margin-left: -1.8rem;
    }
    .form-check-label {
        color: #4a5568;
        font-size: 0.95rem;
    }
    
    .image-upload {
        border: 2px dashed #e2e8f0;
        border-radius: 8px;
        padding: 16px;
        background: #f8f9fa;
        transition: all 0.3s ease;
    }
    
    .image-upload:hover {
        border-color: #5e72e4;
        background: #fff;
    }
    
    .image-preview {
        min-height: 50px;
    }
    
    .image-preview img {
        object-fit: cover;
        border-radius: 4px;
    }
    
    .image-preview .btn-danger {
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 50%;
        margin: 4px;
    }
    
    .dropzone {
        border: 2px dashed #e2e8f0;
        border-radius: 8px;
        padding: 20px;
        background: #f8f9fa;
        transition: all 0.3s ease;
        min-height: 120px;
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        justify-content: flex-start;
        gap: 16px;
        cursor: pointer;
    }
    
    .dropzone .dz-message {
        width: 100%;
        text-align: center;
        margin: 2em 0;
        font-size: 0.95rem;
        color: #4a5568;
    }
    
    .dropzone .dz-preview {
        position: relative;
        margin: 0;
        width: 120px;
        height: 120px;
    }
    
    .dropzone .dz-preview .dz-image {
        border-radius: 8px;
        overflow: hidden;
        width: 120px;
        height: 120px;
        position: relative;
        display: block;
        z-index: 10;
        border: 2px solid #e2e8f0;
    }
    
    .dropzone .dz-preview .dz-image img {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .dropzone .dz-preview .dz-details {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        opacity: 0;
        text-align: center;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        transition: opacity .2s linear;
        padding: 8px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        border-radius: 8px;
        z-index: 20;
        font-size: 12px;
    }
    
    .dropzone .dz-preview:hover .dz-details {
        opacity: 1;
    }
    
    .dropzone .dz-preview .dz-remove {
        position: absolute;
        top: -8px;
        right: -8px;
        z-index: 30;
        width: 20px;
        height: 20px;
        line-height: 16px;
        text-align: center;
        border-radius: 50%;
        background: #f5365c;
        color: white !important;
        text-decoration: none;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .dropzone .dz-preview .dz-remove:hover {
        background: #d92550;
        transform: scale(1.1);
        transition: all 0.2s ease;
    }
    
    .dropzone .dz-preview .dz-filename {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 100%;
        padding: 4px;
        font-size: 11px;
    }
    
    .dropzone.dz-started .dz-message {
        display: none;
    }
</style>
{% endblock %}

{% block extrahead %}
{{ block.super }}
<script src="{% static 'admin/js/vendor/jquery/jquery.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/dropzone.min.js' %}"></script>
<script>
    // Disable Dropzone auto-discover immediately
    Dropzone.autoDiscover = false;
    
    // Ensure jQuery is properly initialized
    if (typeof jQuery === 'undefined') {
        console.error('jQuery is not loaded');
    } else {
        window.$ = window.jQuery = jQuery;
    }
    window.llmModelsUrl = "{% url 'admin:common_llmtestharnessmodel_llm-models' %}";
    window.llmCompletionUrl = "{% url 'admin:common_llmtestharnessmodel_llm-test-completion' %}";
    window.csrfToken = "{{ csrf_token }}";
    window.llmConfigs = JSON.parse('{{ configs|escapejs }}');
</script>
<script src="{% static 'admin/js/llm_test_harness.js' %}?v={{ request.timestamp|date:'YmdHis' }}"></script>
{% endblock %}

{% block content %}
<div class="test-harness-container">
    <div class="card">
        <div class="card-header">
            <h3>LLM Test Harness</h3>
        </div>
        
        <div id="error-alert" role="alert">
            <span id="error-message"></span>
            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
        </div>
        
        <form id="test-form" class="form">
            {% csrf_token %}
            <div class="card">
                <h4 class="mb-4">Model Configuration</h4>
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label class="form-label" for="provider">Provider:</label>
                            <select class="form-control" id="provider" name="provider" required>
                                <option value="">Select Provider</option>
                                {% for config in configs_list %}
                                    <option value="{{ config.provider_type }}" data-config-id="{{ config.id }}">
                                        {{ config.provider_display }}
                                    </option>
                                {% endfor %}
                            </select>
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label class="form-label" for="model">Model:</label>
                            <select class="form-control" id="model" name="model" required>
                                <option value="">Select Provider First</option>
                            </select>
                            <div id="model-info" class="model-info"></div>
                        </div>
                    </div>
                </div>
                
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label class="form-label" for="temperature">Temperature:</label>
                            <input type="number" class="form-control" id="temperature" name="temperature" 
                                   value="0.7" min="0" max="2" step="0.1">
                        </div>
                    </div>
                    
                    <div class="col-md-6">
                        <div class="form-group mb-3">
                            <label class="form-label" for="max_tokens">Max Tokens:</label>
                            <input type="number" class="form-control" id="max_tokens" name="max_tokens" 
                                   value="1000" min="1" max="32000">
                        </div>
                    </div>
                </div>
            </div>

            <div class="card mt-4">
                <h4 class="mb-4">Messages</h4>
                <div id="messages">
                    <div class="message">
                        <div class="message-role">
                            <select class="form-control" name="role">
                                <option value="system">System</option>
                                <option value="user" selected>User</option>
                                <option value="assistant">Assistant</option>
                            </select>
                        </div>
                        <div class="message-content">
                            <textarea class="form-control" name="content" rows="4" required></textarea>
                            <div class="image-upload mt-2" style="display: none;">
                                <div action="/file-upload" class="form-control dropzone" id="message-dropzone"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <button type="button" class="btn btn-secondary mt-3" id="add-message">
                    <i class="fas fa-plus"></i> Add Message
                </button>
            </div>

            <div class="form-check mt-4">
                <input type="checkbox" class="form-check-input" id="stream" name="stream">
                <label class="form-check-label" for="stream">Stream Response</label>
            </div>

            <div class="form-check mt-2">
                <input type="checkbox" class="form-check-input" id="enable_vision" name="enable_vision">
                <label class="form-check-label" for="enable_vision">Enable Vision</label>
            </div>
            
            <button type="submit" class="btn btn-primary mt-4">
                <i class="fas fa-play"></i> Test Completion
            </button>
        </form>
        
        <div class="loading">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2">Processing request...</p>
        </div>
        
        <div id="completion" class="completion-container" style="display: none;">
            <h4 class="mb-3">Completion Result</h4>
            <div class="completion-text"></div>
            <div class="metadata"></div>
        </div>
    </div>
</div>
{% endblock %}

================
File: apps/common/templatetags/__init__.py
================


================
File: apps/common/templatetags/markdown_filters.py
================
from django import template
from django.utils.safestring import mark_safe
from ..utils import md

register = template.Library()

@register.filter(name='markdown')
def markdown_filter(text):
    """Convert markdown text to HTML."""
    if not text:
        return ''
    return mark_safe(md.render(text))

================
File: apps/common/tools/user_activity_tool.py
================
from typing import Any, Optional, Type 
from typing import Any, Optional
from pydantic import BaseModel, Field
from crewai.tools.base_tool import BaseTool
from apps.seo_manager.models import UserActivity
import logging

logger = logging.getLogger(__name__)

"""
You can use the UserActivityTool by 
 1. importing 'from apps.common.tools.user_activity_tool import user_activity_tool' and 
 2. calling its run method with the required arguments: 'result = user_activity_tool.run(user=user, category=category, action=action, client=client, details=details)'
"""

class UserActivityToolSchema(BaseModel):
    """Input schema for UserActivityTool."""
    user: Any = Field(..., description="The user performing the action.")
    category: str = Field(..., description="The category of the action.")
    action: str = Field(..., description="The action performed.")
    client: Optional[Any] = Field(None, description="The client associated with the action (optional).")
    details: Optional[str] = Field(None, description="Additional details about the action (optional).")

class UserActivityTool(BaseTool):
    name: str = "Log User Activity"
    description: str = "Logs user activity in the system."
    args_schema: Type[BaseModel] = UserActivityToolSchema
    
    def _run(
        self, 
        user: Any,
        category: str,
        action: str,
        client: Optional[Any] = None,
        details: Optional[str] = None,
        **kwargs: Any
    ) -> Any:
        try:
            UserActivity.objects.create(
                user=user,
                client=client,
                category=category,
                action=action,
                details=details
            )
            logger.debug(f"User activity logged: {user.username} - {category} - {action} - {client} - {details}")
            return {"success": True, "message": "User activity logged successfully."}
        except Exception as e:
            return {"success": False, "error": str(e)}

# Initialize the tool
user_activity_tool = UserActivityTool()

================
File: apps/common/websockets/base_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
from .organization_consumer import OrganizationAwareConsumer
import json
import logging

logger = logging.getLogger(__name__)

class BaseWebSocketConsumer(OrganizationAwareConsumer):
    async def connect(self):
        # Set organization context (added from OrganizationAwareConsumer)
        await super().connect()
        
        self.group_name = self.get_group_name()
        if self.group_name:
            await self.channel_layer.group_add(
                self.group_name,
                self.channel_name
            )
        await self.accept()

    async def disconnect(self, close_code):
        # Clear organization context (added from OrganizationAwareConsumer)
        await super().disconnect(close_code)
        
        if self.group_name:
            await self.channel_layer.group_discard(
                self.group_name,
                self.channel_name
            )

    async def receive(self, text_data):
        try:
            data = json.loads(text_data)
            if data.get('type') == 'ping':
                await self.send_json({'type': 'pong'})
                return
            await self.handle_message(data)
        except json.JSONDecodeError as e:
            logger.error(f"Invalid message format: {str(e)}")
            await self.send_error("Invalid message format")
        except Exception as e:
            logger.error(f"Error handling message: {str(e)}")
            await self.send_error(str(e))

    async def send_error(self, message):
        await self.send_json({
            'type': 'error',
            'message': message
        })

    async def send_json(self, content):
        await self.send(text_data=json.dumps(content))

    def get_group_name(self):
        """Override in child classes to set group name"""
        return None

    async def handle_message(self, data):
        """Override in child classes to handle specific messages"""
        pass

================
File: apps/common/websockets/organization_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
from asgiref.sync import sync_to_async
import json
import logging

# Import OrganizationContext
try:
    from apps.organizations.utils import OrganizationContext
except ImportError:
    OrganizationContext = None
    logging.getLogger(__name__).warning("OrganizationContext not available, organization isolation may not work properly in WebSocket consumers")

logger = logging.getLogger(__name__)

class OrganizationAwareConsumer(AsyncWebsocketConsumer):
    """
    Base WebSocket consumer that sets organization context from session.
    
    This consumer ensures organization isolation is maintained in WebSocket connections
    by setting the organization context from the session when the connection is established.
    """
    
    async def set_organization_context(self):
        """
        Set organization context based on session data.
        
        WebSockets have access to the session via the scope, so we can extract
        the active organization ID from there.
        """
        if not OrganizationContext:
            logger.error("OrganizationContext not available, skipping context setup")
            return False
            
        try:
            # Get session from scope
            session = self.scope.get('session', {})
            logger.debug(f"Session in WebSocket scope: {session}")
            
            # Get organization ID from session
            org_id = session.get('active_organization_id')
            logger.debug(f"Active organization ID from session: {org_id}")
            
            if not org_id:
                logger.warning("No active organization ID in session")
                return False
                
            # Set organization context
            # Import here to avoid circular imports
            from apps.organizations.models import Organization
            
            # Get organization object asynchronously
            organization = await self.get_organization(org_id)
            
            if organization:
                # Set as current organization in context
                OrganizationContext.set_current(organization)
                logger.debug(f"Set organization context to {organization.name} (ID: {organization.id})")
                return True
            else:
                logger.error(f"Organization with ID {org_id} not found")
                return False
                
        except Exception as e:
            logger.error(f"Error setting organization context: {str(e)}", exc_info=True)
            return False
            
    @sync_to_async
    def get_organization(self, org_id):
        """Get organization object synchronously, wrapped in sync_to_async"""
        from apps.organizations.models import Organization
        try:
            return Organization.objects.get(id=org_id)
        except Organization.DoesNotExist:
            return None
            
    async def clear_organization_context(self):
        """Clear organization context when disconnecting"""
        if OrganizationContext:
            from apps.organizations.utils import clear_organization_context
            clear_organization_context()
            
    async def connect(self):
        """
        Set organization context from session.
        
        Note: Child classes should call this with super().connect() 
        at the beginning of their connect method, but should not
        expect any additional functionality like group joining or
        connection acceptance. Those should be implemented in the
        child class.
        """
        # Just set organization context
        await self.set_organization_context()
        # Child classes need to handle their own connection logic
        
    async def disconnect(self, close_code):
        """Disconnect and clear organization context"""
        # Clear organization context
        await self.clear_organization_context()
        
        # Child classes should override and call super().disconnect(close_code)
        pass

================
File: apps/common/__init__.py
================
# Package initialization

================
File: apps/common/admin.py
================
"""
Admin interface for common app models.
"""

from django.contrib import admin
from django.utils.html import format_html
from django.urls import reverse
from django.db.models import Sum
from django.http import JsonResponse, StreamingHttpResponse
from django.urls import path
from django.shortcuts import render
from asgiref.sync import async_to_sync
import json
import logging
from django.utils import timezone

from .models import LLMConfiguration, TokenUsage, LLMTestHarnessModel

logger = logging.getLogger(__name__)


@admin.register(LLMConfiguration)
class LLMConfigurationAdmin(admin.ModelAdmin):
    """Admin interface for LLM configurations."""
    
    list_display = [
        'name',
        'provider_type',
        'default_model',
        'updated_at'
    ]
    list_filter = [
        'provider_type',
        'created_at'
    ]
    search_fields = ['name', 'description', 'default_model']
    readonly_fields = ['created_at', 'updated_at']
    
    fieldsets = [
        (None, {
            'fields': [
                'name',
                'description'
            ]
        }),
        ('Provider Configuration', {
            'fields': [
                'provider_type',
                'fallback_provider',
                'api_key',
                'api_key_secondary',
                'organization_id'
            ]
        }),
        ('Model Settings', {
            'fields': [
                'default_model',
                'model_parameters'
            ]
        }),
        ('Rate Limiting', {
            'fields': [
                'requests_per_minute',
                'tokens_per_minute'
            ]
        }),
        ('Caching', {
            'fields': [
                'enable_response_cache',
                'response_cache_ttl',
                'enable_model_cache',
                'model_cache_ttl'
            ]
        }),
        ('Advanced Settings', {
            'fields': [
                'provider_settings',
                'streaming_config'
            ],
            'classes': ['collapse']
        })
    ]

@admin.register(TokenUsage)
class TokenUsageAdmin(admin.ModelAdmin):
    list_display = ('user', 'model', 'prompt_tokens', 'completion_tokens', 'total_cost', 'timestamp', 'request_type')
    list_filter = ('model', 'request_type', 'provider_type', 'timestamp')
    search_fields = ('user__username', 'model', 'session_id')
    readonly_fields = ('timestamp',)

@admin.register(LLMTestHarnessModel)
class LLMTestHarnessAdmin(admin.ModelAdmin):
    """Admin interface for testing LLM providers."""
    
    change_list_template = 'admin/common/llm_test_harness.html'

    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path('llmtestharnessmodel/models/', self.get_models_view, name='common_llmtestharnessmodel_llm-models'),
            path('llmtestharnessmodel/completion/', self.test_completion_view, name='common_llmtestharnessmodel_llm-test-completion'),
        ]
        return custom_urls + urls

    def changelist_view(self, request, extra_context=None):
        """Override to redirect to test harness view."""
        return self.test_harness_view(request)

    def test_harness_view(self, request):
        # Get available configurations
        configs = LLMConfiguration.objects.all()
        
        # Serialize configs for JavaScript
        configs_data = [
            {
                'id': config.id,
                'provider_type': config.provider_type,
                'provider_display': config.get_provider_type_display(),
                'default_model': config.default_model
            }
            for config in configs
        ]
        
        context = {
            'configs': json.dumps(configs_data),  # For JavaScript
            'configs_list': configs_data,         # For template rendering
            'title': 'LLM Test Harness',
            'opts': self.model._meta,
            'is_nav_sidebar_enabled': True,
            'available_apps': self.admin_site.get_app_list(request),
            'has_permission': self.has_module_permission(request),
            'timestamp': timezone.now(),  # Add current timestamp
        }
        return render(request, 'admin/common/llm_test_harness.html', context)

    def test_completion_view(self, request):
        """Synchronous wrapper for async test_completion."""
        return async_to_sync(self._test_completion)(request)

    async def _test_completion(self, request):
        """Async implementation of test completion."""
        try:
            from .services.llm_service import LLMService
            
            # Parse JSON data from request
            data = json.loads(request.body)
            
            # Get parameters from request
            provider_type = data.get('provider_type')
            model = data.get('model')
            messages = data.get('messages', [])
            temperature = float(data.get('temperature', 0.7))
            max_tokens = int(data.get('max_tokens', 1000))
            stream = data.get('stream', False)
            
            # Initialize service
            service = LLMService(user=request.user)
            
            # Get completion
            if stream:
                # Return streaming response
                async def stream_response():
                    async for chunk in service.get_streaming_completion(
                        messages=messages,
                        provider_type=provider_type,
                        model_name=model,
                        temperature=temperature,
                        max_tokens=max_tokens
                    ):
                        yield chunk
                
                # Create a synchronous wrapper for the asynchronous generator
                from asgiref.sync import async_to_sync
                
                def sync_stream_generator():
                    # Get event loop or create one
                    import asyncio
                    loop = asyncio.get_event_loop()
                    # Create the asynchronous generator
                    agen = stream_response().__aiter__()
                    # Keep getting values until StopAsyncIteration
                    try:
                        while True:
                            # Run the coroutine in the event loop
                            yield loop.run_until_complete(agen.__anext__())
                    except StopAsyncIteration:
                        pass
                
                response = StreamingHttpResponse(
                    sync_stream_generator(),
                    content_type='text/event-stream'
                )
                response['Cache-Control'] = 'no-cache'
                return response
            else:
                # Return regular response
                completion, metadata = await service.get_completion(
                    messages=messages,
                    provider_type=provider_type,
                    model_name=model,
                    temperature=temperature,
                    max_tokens=max_tokens
                )
                return JsonResponse({
                    'completion': completion,
                    'metadata': metadata
                })
                
        except Exception as e:
            logger.error(f"Error in test completion: {str(e)}", exc_info=True)
            return JsonResponse({
                'error': str(e)
            }, status=500)

    def has_add_permission(self, request):
        return False

    def has_delete_permission(self, request, obj=None):
        return False

    def has_change_permission(self, request, obj=None):
        return True

    def has_module_permission(self, request):
        return True

    def get_models_view(self, request):
        """Synchronous wrapper for async get_models."""
        return async_to_sync(self._get_models)(request)

    async def _get_models(self, request):
        """Async implementation of get_models."""
        try:
            from .services.llm_service import LLMService
            
            provider_type = request.GET.get('provider')
            if not provider_type:
                return JsonResponse({'error': 'Provider type is required'}, status=400)
            
            service = LLMService(user=request.user)
            try:
                models = await service.get_available_models(provider_type)
            except Exception as e:
                logger.error(f"Error getting models from provider {provider_type}: {str(e)}")
                return JsonResponse({'error': str(e)}, status=500)
            
            # Format models for frontend dropdown
            formatted_models = {}
            if not models:
                logger.error(f"No models returned from provider {provider_type}")
                return JsonResponse({'error': 'No models available for this provider'}, status=404)
                
            for model_id, model_info in models.items():
                formatted_models[model_id] = {
                    'name': model_info.get('name', model_id),
                    'description': model_info.get('description', ''),
                    'context_window': model_info.get('context_window'),
                    'input_tokens': model_info.get('input_tokens'),
                    'output_tokens': model_info.get('output_tokens'),
                    'supports_vision': model_info.get('supports_vision', False),
                    'supports_json': model_info.get('supports_json', False),
                    'supports_functions': model_info.get('supports_functions', False)
                }
            
            if not formatted_models:
                logger.error(f"No formatted models for provider {provider_type}")
                return JsonResponse({'error': 'No models available for this provider'}, status=404)
            
            return JsonResponse(formatted_models)
            
        except Exception as e:
            logger.error(f"Error in _get_models: {str(e)}", exc_info=True)
            return JsonResponse({'error': str(e)}, status=500)

================
File: apps/common/apps.py
================
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class CommonConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.common'
    verbose_name = 'Common'

    def ready(self):
        """Initialize app when Django starts."""
        #logger.info("Common app ready() called")
        
        # Log admin site state
        from django.contrib import admin
        #logger.info(f"Admin site registry: {list(admin.site._registry.keys())}")
        
        # Log all installed apps
        from django.apps import apps
        #logger.info(f"All installed apps: {[app.name for app in apps.get_app_configs()]}")
        
        # Log database configuration
        from django.conf import settings
        #logger.info(f"Database config: {settings.DATABASES}")
        
        # Log middleware
        #logger.info(f"Middleware: {settings.MIDDLEWARE}")

================
File: apps/common/chat_model_handler.py
================
from apps.common.utils import get_llm

from langchain.prompts.chat import (
    ChatPromptTemplate,
    SystemMessagePromptTemplate,
    HumanMessagePromptTemplate,
)
from langchain.schema import AIMessage, HumanMessage, SystemMessage

class ChatModelHandler:
    def __init__(self, model_name: str):
        self.model_name = model_name
        self.chat_model, _ = get_llm(model=model_name, temperature=0.05)
        self.summarize_prompt = self._create_summarize_prompt()

    def _create_summarize_prompt(self) -> ChatPromptTemplate:
        """ Create a prompt template for summarization """
        system_message_prompt = SystemMessagePromptTemplate.from_template(
            "You are an AI assistant that summarizes text while preserving key details, using markdown formatting."
        )
        human_message_prompt = HumanMessagePromptTemplate.from_template("{text}")
        return ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])

    def _generate_messages(self, query: str) -> list:
        """ Generate messages for the chat model based on the query """
        human_message = HumanMessage(content=self.summarize_prompt.format_prompt(text=query).to_messages()[1].content)
        return [human_message]

    def generate_response(self, query: str) -> str:
        """ Generate a response from the chat model based on the query """
        messages = self._generate_messages(query)
        response = self.chat_model(messages)
        return response.content

================
File: apps/common/content_loader.py
================
from .utils import is_pdf_url, is_youtube, is_stock_symbol
from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from apps.agents.utils.scrape_url import scrape_url
from langchain_community.document_loaders import YoutubeLoader, PyMuPDFLoader
import logging
from sec_edgar_downloader import Downloader
import os
from bs4 import BeautifulSoup
from django.conf import settings
import json

logger = logging.getLogger(__name__)

class ContentLoader:
    def __init__(self):
        self.crawl_tool = CrawlWebsiteTool()

    def load_content(self, query: str, user_id: int = None, crawl_website: bool = False, max_pages: int = 10) -> str:
        """Load content from various sources"""
        logging.info(f"Loading content from website: {query} (crawl_website={crawl_website}, max_pages={max_pages})")
        
        # Check if it's a URL
        if query.startswith('http://') or query.startswith('https://'):
            if crawl_website and max_pages > 1:
                # Use CrawlWebsiteTool to get content from multiple pages
                result_json = self.crawl_tool.run(
                    website_url=query,
                    user_id=user_id,
                    max_pages=max_pages,
                    output_type="markdown"
                )
                
                # Parse JSON result
                try:
                    result = json.loads(result_json)
                except (json.JSONDecodeError, TypeError):
                    # If it's not valid JSON, use it as a string
                    result = result_json
                
                # Handle both dictionary and string responses
                if isinstance(result, dict):
                    if result.get('status') == 'success':
                        results = result.get('results', [])
                        if results:
                            return "\n\n".join(page.get('content', '') for page in results)
                        else:
                            return "Error: No content found in crawled pages"
                    else:
                        return f"Error crawling website: {result.get('message', 'Unknown error')}"
                else:
                    # If result is a string, it's likely an error message
                    return f"Error crawling website: {result}"
            else:
                # Use scrape_url to get content from the URL (handles regular URLs, PDFs, and YouTube)
                scrape_result = scrape_url(query)
                
                if scrape_result is None:
                    return f"Error: Failed to scrape content from {query}"
                
                # Extract content based on content type
                content_type = scrape_result.get('meta', {}).get('contentType', 'html')
                
                if content_type == 'youtube':
                    # For YouTube, return the formatted content
                    return scrape_result.get('content', '')
                elif content_type == 'pdf':
                    # For PDF, return the text content
                    return scrape_result.get('textContent', '')
                else:
                    # For regular webpages, return the markdown content
                    return scrape_result.get('textContent', '')
        elif is_stock_symbol(query):
                logger.info(f"Loading content from SEC EDGAR: {query}")
                return self._load_from_sec(query)
        else:
            logger.info("Loading as text")
            return query

    def _load_from_sec(self, query: str) -> str:
        """ Load and return content from SEC EDGAR """
        # Provide a company name and email address to comply with SEC EDGAR's fair access policy
        company_name = settings.COMPANY_NAME
        email_address = settings.EMAIL_ADDRESS

        # Create a Downloader instance with the specified download folder
        download_folder = settings.DOWNLOAD_FOLDER + "/sec-edgar-files"
        
        dl = Downloader(company_name, email_address, download_folder)

        num_filings_downloaded = dl.get("10-K", query, limit=1, download_details=True)
        logging.info(f"Downloaded {num_filings_downloaded} 10-K filing(s) for {query}.")

        print(f"Downloaded {num_filings_downloaded} 10-K filing(s) for {query}.")

        # Access the downloaded HTML filing
        if num_filings_downloaded > 0:
            logging.info("getting filings dir")
            filings_dir = os.path.join(download_folder, "sec-edgar-filings", query, "10-K")
            filing_subdirs = os.listdir(filings_dir)
            # latest_filing_subdir = sorted(filing_subdirs)[-1]
            # latest_filing_path = os.path.join(filings_dir, latest_filing_subdir, "primary-document.html")
            logging.info("getting latest_filings_subdir")
            latest_filing_subdir = sorted(filing_subdirs)[-1]
            # Convert set to string if necessary
            if not isinstance(latest_filing_subdir, str):
                latest_filing_subdir = str(latest_filing_subdir)
            logging.info("getting latest_filing_path")
            latest_filing_path = os.path.join(filings_dir, latest_filing_subdir, "primary-document.html")

            
            
            with open(latest_filing_path, "r") as f:
                html_content = f.read()
            
            # Parse the HTML content using BeautifulSoup
            soup = BeautifulSoup(html_content, 'html.parser')
            
            # Extract the text content
            text_content = soup.get_text()
            
            return text_content

================
File: apps/common/models.py
================
"""
Models for common functionality including LLM configuration and tracking.
"""

from django.db import models
from django.utils import timezone
from django.contrib.auth import get_user_model
from django.core.exceptions import ValidationError
from django.conf import settings
import json
from typing import Any, Optional

User = get_user_model()

class ProviderType(models.TextChoices):
	"""Available LLM providers."""
	LITELLM = 'litellm', 'LiteLLM'
	OPENAI = 'openai', 'OpenAI'
	ANTHROPIC = 'anthropic', 'Anthropic'
	GEMINI = 'gemini', 'Google Gemini'
	OPENROUTER = 'openrouter', 'OpenRouter'
	OLLAMA = 'ollama', 'Ollama'

class ModelFamily(models.TextChoices):
	"""Model families for cost tracking and capabilities."""
	GPT4 = 'gpt4', 'GPT-4'
	GPT35 = 'gpt35', 'GPT-3.5'
	CLAUDE3 = 'claude3', 'Claude 3'
	CLAUDE2 = 'claude2', 'Claude 2'
	GEMINI = 'gemini', 'Gemini'
	LLAMA = 'llama', 'Llama'
	MISTRAL = 'mistral', 'Mistral'
	CUSTOM = 'custom', 'Custom'

class LLMConfiguration(models.Model):
	"""Configuration for LLM providers and settings."""
	
	name = models.CharField(max_length=100, unique=True)
	description = models.TextField(blank=True)
	created_at = models.DateTimeField(auto_now_add=True)
	updated_at = models.DateTimeField(auto_now=True)
	
	# Provider Settings
	provider_type = models.CharField(
		max_length=20,
		choices=ProviderType.choices,
		default=ProviderType.GEMINI
	)
	fallback_provider = models.ForeignKey(
		'self',
		null=True,
		blank=True,
		on_delete=models.SET_NULL,
		related_name='fallback_configs'
	)
	
	# Model Settings
	default_model = models.CharField(max_length=100)
	model_parameters = models.JSONField(
		default=dict,
		blank=True,
		help_text="Default parameters for model (temperature, top_p, etc.)",
		null=True
	)
	
	# Rate Limiting
	requests_per_minute = models.IntegerField(default=60)
	tokens_per_minute = models.IntegerField(default=40000)
	
	# Caching Settings
	enable_response_cache = models.BooleanField(
		default=True,
		help_text="Enable caching of LLM responses"
	)
	response_cache_ttl = models.IntegerField(
		default=3600,
		help_text="Time to live for cached responses in seconds"
	)
	enable_model_cache = models.BooleanField(
		default=True,
		help_text="Enable caching of available models"
	)
	model_cache_ttl = models.IntegerField(
		default=3600,
		help_text="Time to live for cached model information in seconds"
	)
	
	# Provider-Specific Settings
	provider_settings = models.JSONField(
		default=dict,
		blank=True,
		null=True,
		help_text="Provider-specific settings and overrides"
	)
	
	# API Authentication
	api_key = models.CharField(
		max_length=255,
		blank=True,
		help_text="Primary API key for the provider"
	)
	api_key_secondary = models.CharField(
		max_length=255,
		blank=True,
		help_text="Secondary/backup API key"
	)
	organization_id = models.CharField(
		max_length=255,
		blank=True,
		help_text="Organization ID for providers that require it"
	)
	
	# Streaming Settings
	streaming_config = models.JSONField(
		default=dict,
		blank=True,
		null=True,
		help_text="Configuration for streaming responses"
	)
	
	class Meta:
		verbose_name = "LLM Configuration"
		verbose_name_plural = "LLM Configurations"
		ordering = ['-created_at']
	
	def __str__(self):
		return self.name
	
	def get_provider_setting(self, key: str, default: Any = None) -> Any:
		"""Get a provider-specific setting with fallback to default."""
		default_settings = {
			'rate_limits': {},
			'credentials': {},
			'model_parameters': {},
			'api_base': None,
			'api_version': None,
			'timeout': 30,
			'max_retries': 3
		}
		settings = self.provider_settings or {}
		settings = {**default_settings, **settings}
		return settings.get(self.provider_type, {}).get(key, default)
	
	def get_model_parameters(self, model_name: str = None) -> dict:
		"""Get model parameters with optional model-specific overrides."""
		default_params = {
			"temperature": 0.7,
			"top_p": 1.0,
			"max_tokens": 8192,
			"presence_penalty": 0,
			"frequency_penalty": 0
		}
		params = self.model_parameters or {}
		params = {**default_params, **params}  # Merge with defaults
		if model_name:
			model_specific = self.provider_settings.get(self.provider_type, {}).get('model_parameters', {})
			params.update(model_specific.get(model_name, {}))
		return params
	
	def get_streaming_config(self) -> dict:
		"""Get streaming configuration with defaults."""
		defaults = {
			'stream_chunk_size': 100,
			'stream_timeout': 30,
			'max_tokens_per_chunk': 50,
			'chunk_separator': '\n',
			'retry_on_timeout': True,
			'buffer_size': 4096
		}
		config = self.streaming_config or {}
		return {**defaults, **config}
	
	def get_rate_limits(self) -> dict:
		"""Get rate limiting configuration with provider-specific overrides."""
		limits = {
			'requests_per_minute': self.requests_per_minute,
			'tokens_per_minute': self.tokens_per_minute
		}
		provider_limits = self.get_provider_setting('rate_limits', {})
		return {**limits, **provider_limits}
	
	def get_cache_config(self) -> dict:
		"""Get caching configuration."""
		return {
			'enable_response_cache': self.enable_response_cache,
			'response_cache_ttl': self.response_cache_ttl,
			'enable_model_cache': self.enable_model_cache,
			'model_cache_ttl': self.model_cache_ttl
		}
	
	def get_api_credentials(self) -> dict:
		"""Get API credentials with provider-specific overrides."""
		creds = {
			'api_key': self.api_key,
			'api_key_secondary': self.api_key_secondary,
			'organization_id': self.organization_id
		}
		provider_creds = self.get_provider_setting('credentials', {})
		return {**creds, **provider_creds}
	
	@property
	def timeout(self) -> int:
		"""Get provider timeout from settings."""
		return self.provider_settings.get('timeout', 30)
		
	@property
	def api_base_url(self) -> Optional[str]:
		"""Get provider API base URL from settings."""
		return self.provider_settings.get('api_base')
		
	@property
	def api_version(self) -> Optional[str]:
		"""Get provider API version from settings."""
		return self.provider_settings.get('api_version')
		
	@property
	def max_retries(self) -> int:
		"""Get provider max retries from settings."""
		return self.provider_settings.get('max_retries', 3)

class TokenUsage(models.Model):
	"""Track token usage for LLM interactions."""
	
	user = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)
	model = models.CharField(max_length=100)
	prompt_tokens = models.IntegerField()
	completion_tokens = models.IntegerField()
	total_cost = models.DecimalField(max_digits=10, decimal_places=6, null=True)
	timestamp = models.DateTimeField(default=timezone.now)
	
	# Optional metadata
	request_type = models.CharField(max_length=50, blank=True)  # e.g., 'chat', 'completion', etc.
	session_id = models.CharField(max_length=100, blank=True)
	provider_type = models.CharField(
		max_length=20,
		choices=ProviderType.choices,
		null=True,
		blank=True
	)
	
	class Meta:
		indexes = [
			models.Index(fields=['user', 'timestamp']),
			models.Index(fields=['model', 'timestamp']),
			models.Index(fields=['provider_type', 'timestamp']),
		]
	
	def __str__(self):
		return f"{self.model} - {self.prompt_tokens + self.completion_tokens} tokens"

class LLMTestHarnessModel(models.Model):
	"""Model for LLM test harness. This is a proxy model for admin interface."""
	
	class Meta:
		managed = False  # No database table needed
		verbose_name = 'LLM Test Harness'
		verbose_name_plural = 'LLM Test Harness'
		app_label = 'common'

================
File: apps/common/summarizer.py
================
from langchain_community.chat_models import ChatOllama
from langchain.prompts.chat import (
    ChatPromptTemplate,
)
from langchain_core.output_parsers import StrOutputParser
import re
import tiktoken

from langchain_community.document_loaders import YoutubeLoader
from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from django.utils import timezone
from apps.seo_manager.models import SummarizerUsage
from langchain.text_splitter import TokenTextSplitter
import json

class Summarizer:
    def __init__(self):
        self.llm_tokens_sent=0
        self.llm_tokens_r=0
        self.encoder=tiktoken.get_encoding("gpt2")
        self.crawl_tool = CrawlWebsiteTool()

def is_pdf_url(url: str) -> bool:
    """
    Returns True if the URL points to a PDF, False otherwise.
    """
    try:
        # 1. Check if the URL has a .pdf extension
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.path.endswith('.pdf'):
            return True

        # 2. Send a HEAD request to the URL to get the Content-Type header
        response = requests.head(url, allow_redirects=True, timeout=5)

        # 3. Check if the Content-Type header is application/pdf
        content_type = response.headers.get('Content-Type')
        if content_type and content_type.startswith('application/pdf'):
            return True

        # 4. Check if the URL returns a PDF MIME type
        mime_type, _ = mimetypes.guess_type(url)
        if mime_type and mime_type.startswith('application/pdf'):
            return True

        # 5. If all else fails, try to download a small chunk of the file and check its magic number
        response = requests.get(url, stream=True, timeout=5)
        chunk = response.raw.read(1024)
        if chunk.startswith(b'%PDF-'):
            return True

        # If none of the above checks pass, it's likely not a PDF
        return False

    except requests.exceptions.RequestException as e:
        # Handle requests exceptions (e.g. connection errors, timeouts)
        print(f"Error checking URL: {e}")
        return False

    except Exception as e:
        # Handle any other unexpected exceptions
        print(f"Error checking URL: {e}")
        return False



    def compress_content(self, content, llm , task_instance, max_tokens):
        """
        Compress the given content using the provided compression chain.
        The content is split into chunks with an overlap of 100 characters, and each chunk is compressed.
        The compressed chunks are then combined, and the process is repeated if the total token count is still greater than the max_tokens.

        Args:
            content (str): The content to be compressed.
            compression_chain: The chain to use for compressing the content.
            max_tokens (int): The maximum number of tokens allowed for the compressed content.

        Returns:
            str: The compressed content.
        """
        tokenizer = tiktoken.get_encoding("gpt2")
        
        chunk_size = max_tokens*3
        overlap = round(chunk_size*.1)

        compressed_content = ""

        compress_prompt = ChatPromptTemplate.from_messages([
            ("system",
            """
            <INSTRUCTION>
            Process the text in the following guidelines, no preamble or postamble:
            <GUIDELINES>
            - preserve all details
            - use markdown
            - do not summarize
            - remove redundancies, fluff, filler content, advertisements, sponsors, and other distracting elements    
            </GUIDELINES>
            """),
            ("human", "<TEXT>{query}</TEXT>"),
        ])

        text_splitter = TokenTextSplitter(chunk_size=chunk_size, chunk_overlap=overlap)

        chunks = text_splitter.split_text(content)
        compress_chain = compress_prompt | llm | StrOutputParser()
        i=0
        chunks = [content[i:i+chunk_size] for i in range(0, len(content), chunk_size-overlap)]
        continue_compression = True
        last_chunk_size=len(chunks)
        while continue_compression:
            i+=1
            compressed_chunks = []
            last_token_size=0
            num_chunks = len(chunks)
            last_chunk_size=num_chunks
            print(f"Compressing iteration {i} with {num_chunks} chunks...")
            j=0
            task_instance.update_state(
                state='start compressing',
                meta={'current_chunk': j, 'total_chunks': num_chunks}
            )
            for chunk in chunks:
                j+=1
                print(f"Compressing chunk {j} of {num_chunks}...")
                compressed_chunk = compress_chain.invoke({'query': chunk})
                compressed_chunks.append(compressed_chunk)
                self.llm_tokens_sent += len(self.encoder.encode(compress_prompt.format(query=chunk), disallowed_special=()))
                self.llm_tokens_r += len(self.encoder.encode(compressed_chunk))
                print (f"LLM tokens received: {len(self.encoder.encode(compressed_chunk))}")
                # Send progress update
                task_instance.update_state(
                    state='compressing',
                    meta={'current_chunk': j, 'total_chunks': num_chunks}
                )

            compressed_content = "\n".join(compressed_chunks)
            print(compressed_content)
            compressed_tokens = tokenizer.encode(compressed_content, disallowed_special=())
            compressed_token_count = len(compressed_tokens)
            print(f"The compressed content has {compressed_token_count} tokens.")

            if compressed_token_count <= max_tokens:
                continue_compression = False
            else:
                chunks = text_splitter.split_text(compressed_content)
                print(f"Splitting into {len(chunks)} chunks. Last chunk size: {last_chunk_size}")
                if len(chunks) >= last_chunk_size: # if compression isn't getting much smaller then stop
                    continue_compression= False 

        return compressed_content

    def summarize(self, query, user, task_instance, base_url="http://192.168.30.100:11434"):
        """
        Generate a response to a user's query using the ChatOllama model.

        Args:
            query (str): The user's query (text or URL).
            base_url (str, optional): The base URL for the API endpoint. Defaults to "https://api.example.com/v1/chat".

        Returns:
            str: The response to the user's query, formatted in Markdown.
        """
        
        max_tokens=8192

        start_time = timezone.now()
        model = 'wizardlm2:7b-q8_0' # very very good
        #model = 'qwen:1.8b'        # bad
        #model = 'phi:latest'        # bad
        #model = 'openhermes:latest' # bad
        #model = 'mistral:7b-instruct-v0.2-q6_K' # ok
        #model = 'nous-hermes2-mixtral:8x7b-dpo-q4_K_M' # good
        #model = 'gemma:7b-instruct-v1.1-q8_0'  # worth investigating more, but not bad
        #model = 'adrienbrault/nous-hermes2pro:Q8_0' # not good
        #model = 'command-r:latest'
        #model = 'eramax/senku:latest' # bad
        #model = 'yi:6b-200k-fp16' # not enough vram
        #model = 'yi:6b-chat-fp16' # only outputted chinese -> didn't pursue
        #model = 'qwen:32b' # not great
        #model = 'dolphin-llama3:8b-v2.9-q8_0'
        #model = 'phi3:3.8b-mini-instruct-4k-fp16' # not that good
        #model = 'llama3:8b-instruct-fp16' # broken
        #model = 'dolphin-llama3:latest' # not that good
        #model = 'mixtral:8x7b-instruct-v0.1-q4_K_M'
        #model = 'herald/phi3-128k'


        # Initialize the ChatOllama model with the base_url parameter
        llm = ChatOllama(model=model, base_url=base_url, temperature=0.4, num_ctx=max_tokens)
        #    llm = ChatOllama(model="llama3:latest", base_url=base_url, num_ctx="8000",)

        # Define the prompt templates
        summarize_prompt = ChatPromptTemplate.from_messages([
            ("system",
            """
            <INSTRUCTION>
            Process the text in the following guidelines, no preamble or postamble:
            <GUIDELINES>
            - preserve all details
            - use markdown
            - do not summarize
            - remove redundancies, fluff, filler content, advertisements, sponsors, and other distracting elements    
            </GUIDELINES>
            </INSTRUCTION>
            """),
            ("human", """<TEXT>{query}\n</TEXT>
            <EXPECTED OUTPUT>
            "##### Title: create a pithy and insightful title\n
            ##### Date: provide the date if cited in source material, else 'not indicated'\n
            ##### Author(s): list the author(s) of the content(if available), else 'not indicated'\n
            ###### TLDR: write a concise, pithy summary of the content and it's conclusions\n\n

            """),
        ])

        summarize_chain = summarize_prompt | llm | StrOutputParser()

        # Check if the input is a URL
        url_pattern = r'^https?://\S+$'
        if re.match(url_pattern, query):
            # Scrape the website content
            youtube_regex = r"(?:https?:\/\/)?(?:www\.)?youtu(?:\.be|be\.com)\/(?:watch\?v=)?([\w-]{11})"
            match = re.match(youtube_regex, query)
            if match:
                # Use langchain YoutubeLoader to get the transcription
                loader = YoutubeLoader.from_youtube_url(query)
                docs = loader.load()

                content = ""
                for doc in docs:
                    content += doc.page_content + "\n"  # Combine page contents

            else: 
                if self.is_pdf_url(query):
                    pdfloader = PDFDocumentLoad()
                    docs = pdfloader.load_from_url(query)
                    content = ""
                    for doc in docs:
                        content += doc.page_content + "\n"  # Combine page contents
                else:
                    # Use CrawlWebsiteTool to get the content
                    try:
                        result = self.crawl_tool._run(
                            website_url=query,
                            user_id=user.id,
                            max_pages=1,  # Only get the main page
                            max_depth=0,  # No recursive crawling
                            output_type="markdown"  # Get markdown formatted content
                        )
                        
                        # Parse the result
                        result_data = json.loads(result)
                        if result_data.get("status") != "success" or not result_data.get("results"):
                            raise Exception("Failed to get content from URL")
                            
                        content = result_data["results"][0].get("content", "")
                        if not content:
                            raise Exception("No content found in the crawl result")
                            
                    except Exception as e:
                        print(f"Error crawling website: {str(e)}")
                        content = "Error: Failed to retrieve content from the URL"

            #print("scraped content: ", content)
        else:
            # Summarize the provided text
            content = query

        tokenizer = tiktoken.get_encoding("gpt2")
        print(f"The content precompression has {len(tokenizer.encode(content,disallowed_special=()))} tokens.")
        cleaned_content=""
        cleaned_content = self.summarize_nlp(content)
        if cleaned_content:
            content = cleaned_content
        #print(f"cleaned content: {content}")
#        print(f"The content is:\n{content}")
        # Count the tokens in the content using tiktoken
        tokens = tokenizer.encode(content, disallowed_special=())
        token_count = len(tokens)

        print(f"The content now has {len(tokenizer.encode(content,disallowed_special=()))} tokens.")

        # Compress the content if it's greater than max tokens
        if token_count > max_tokens:
            compressed_content = self.compress_content(content, llm, task_instance, max_tokens)

            token_count = len(tokenizer.encode(compressed_content,disallowed_special=()))
            print(f"The compressed_content has {token_count} tokens.")
            # Update state to indicate summarization
            content=compressed_content

        task_instance.update_state(
            state='summarizing',
            meta={'current_chunk': 1,  'total_chunks': 1}
        )

        response = summarize_chain.invoke({'query': content})

        result = response

        end_time = timezone.now()
        duration = end_time - start_time
        
        #save the usage data to the database
        usage = SummarizerUsage.objects.create(
            user=user,
            query=query,
            response=result,
            duration = duration,
            content_token_size=token_count,
            content_character_count=len(content),
            total_input_tokens=self.llm_tokens_sent,
            total_output_tokens=self.llm_tokens_r,
            model_used = model
        )
        usage.save()
        return result

================
File: apps/common/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/common/urls.py
================
from django.urls import path
from . import views

app_name = 'common'

urlpatterns = [
    path('api/llm/models/', views.get_llm_models, name='llm-models'),
]

================
File: apps/common/utils.py
================
import requests
import mimetypes
import urllib.parse
import re
from django.core.cache import cache
import logging
import tiktoken
from django.conf import settings
from langchain_community.chat_models import ChatOpenAI
from langchain_community.chat_models import ChatLiteLLM
from langchain.callbacks.base import BaseCallbackHandler
from langchain.callbacks.manager import CallbackManager
import openai
from langchain.schema import HumanMessage
from markdown_it import MarkdownIt
from bs4 import BeautifulSoup
from datetime import datetime, timedelta
from dateutil.relativedelta import relativedelta
import textwrap
from langchain_openai import ChatOpenAI
from crewai.llm import LLM

logger = logging.getLogger(__name__)

# Initialize markdown-it instance at module level for reuse
md = MarkdownIt('commonmark', {'html': True})

class TokenCounterCallback(BaseCallbackHandler):
    def __init__(self, tokenizer):
        self.llm = None
        self.input_tokens = 0
        self.output_tokens = 0
        self.tokenizer = tokenizer

    def on_llm_start(self, serialized, prompts, **kwargs):
        for prompt in prompts:
            self.input_tokens += len(self.tokenizer.encode(prompt, disallowed_special=()))

    def on_llm_end(self, response, **kwargs):
        for generation in response.generations:
            for result in generation:
                self.output_tokens += len(self.tokenizer.encode(result.text, disallowed_special=()))

class ExtendedChatOpenAI(ChatOpenAI):
    """Extended ChatOpenAI with CrewAI required methods"""
    
    def supports_stop_words(self) -> bool:
        """Whether the LLM supports stop words"""
        return False

def get_models():
    """
    Fetches available models from the API with improved error handling and logging
    """
    try:
        # Check if we have cached models
        cached_models = cache.get('available_models')
        if cached_models:
            #logger.debug(f"Returning cached models: {len(cached_models)}")
            return cached_models

        # Construct URL and headers
        url = f'{settings.API_BASE_URL}/models'
        headers = {
            'accept': 'application/json',
            'Authorization': f'Bearer {settings.LITELLM_MASTER_KEY}'
        }
        
        # Log the request attempt with more details
        #logger.debug(f"Fetching models from {url}")
        #logger.debug(f"Using API base URL: {settings.API_BASE_URL}")
        #logger.debug(f"Authorization header: Bearer {settings.LITELLM_MASTER_KEY[:5]}...{settings.LITELLM_MASTER_KEY[-5:]}")
        
        # Make the request
        response = requests.get(url, headers=headers, timeout=10)
        

        if response.status_code == 200:
            try:
                data = response.json()
                
                if 'data' in data and isinstance(data['data'], list):
                    # Sort the models by ID
                    models = sorted([item['id'] for item in data['data']])
                    
                    # Cache the results for 15 seconds
                    cache.set('available_models', models, 15)
                    
                    #logger.debug(f"Successfully fetched {len(models)} models")
                    return models
                else:
                    logger.error(f"Unexpected API response structure: {data}")
                    return []
            except ValueError as e:
                logger.error(f"Failed to parse JSON response: {e}")
                return []
        else:
            logger.error(f"API request failed with status {response.status_code}: {response.text}")
            # Try alternative authentication format if 401 Unauthorized
            if response.status_code == 401:
                logger.info("Trying alternative authentication format...")
                # Try without 'Bearer' prefix
                headers['Authorization'] = settings.LITELLM_MASTER_KEY
                response = requests.get(url, headers=headers, timeout=10)
                logger.debug(f"Alternative auth response status: {response.status_code}")
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if 'data' in data and isinstance(data['data'], list):
                            models = sorted([item['id'] for item in data['data']])
                            cache.set('available_models', models, 15)
                            logger.debug(f"Successfully fetched {len(models)} models with alternative auth")
                            return models
                    except ValueError:
                        pass
            return []
            
    except requests.exceptions.RequestException as e:
        logger.error(f"Request failed: {str(e)}")
        return []
    except Exception as e:
        logger.error(f"Unexpected error in get_models: {str(e)}")
        return []

def get_llm(model_name: str, temperature: float = 0.7, streaming: bool = False):
    """Get LLM instance through LiteLLM proxy"""
    try:
        #logger.debug(f"Initializing LLM with base URL: {settings.API_BASE_URL}")
        
        # Initialize tokenizer and token counter
        tokenizer = tiktoken.get_encoding("cl100k_base")
        token_counter = TokenCounterCallback(tokenizer)
        
        # Create a callback manager with the token counter
        callback_manager = CallbackManager([token_counter])
        
        # Initialize ChatOpenAI with proxy settings and callback manager
        llm = ChatOpenAI(
            model=model_name,
            temperature=temperature,
            streaming=streaming,
            base_url=settings.API_BASE_URL,
            api_key=settings.LITELLM_MASTER_KEY,
            callbacks=[token_counter],  # Use callbacks instead of callback_manager
        )
        
        #logger.debug(f"LLM initialized with model: {model_name}")
        return llm, token_counter
        
    except Exception as e:
        logger.error(f"Error initializing LLM: {str(e)}")
        logger.error(f"LLM configuration: base_url={settings.API_BASE_URL}, model={model_name}")
        raise

def is_pdf_url(url: str) -> bool:
    """Determine if the given URL points to a PDF document."""
    try:
        parsed_url = urllib.parse.urlparse(url)
        if parsed_url.path.endswith('.pdf'):
            return True
        response = requests.head(url, allow_redirects=True, timeout=5)
        content_type = response.headers.get('Content-Type')
        if content_type and content_type.startswith('application/pdf'):
            return True
        mime_type, _ = mimetypes.guess_type(url)
        if mime_type and mime_type.startswith('application/pdf'):
            return True
        response = requests.get(url, stream=True, timeout=5)
        return response.raw.read(1024).startswith(b'%PDF-')
    except requests.exceptions.RequestException:
        return False

def is_youtube(url: str) -> bool:
    return "youtube.com" in url or "youtu.be" in url

def is_stock_symbol(query):
    url = f'https://www.alphavantage.co/query?function=SYMBOL_SEARCH&keywords={query}&apikey={settings.ALPHA_VANTAGE_API_KEY}'
    r=requests.get(url)
    data = r.json()
    print(data)
    if 'bestMatches' in data and len(data['bestMatches']) > 0:
        return True
    else:
        return False

def tokenize(text: str, tokenizer = "cl100k_base") -> int:
    """ Helper function to tokenize text and return token count """
    return len(tokenizer.encode(text, disallowed_special=()))

def extract_top_level_domain(url):
  """Extracts only the top-level domain (TLD) from a URL, handling various cases.

  Args:
    url: The URL to extract the TLD from.

  Returns:
    The top-level domain (TLD) as a string (without protocol or subdomains), 
    or None if the TLD cannot be determined or if None is passed in.
  """
  if url is None:
    return None  # Handle None input explicitly

  try:
    # Remove protocol (http://, https://)
    url = url.split("//")[-1]  
    # Remove trailing slash
    url = url.rstrip("/")
    # Split into parts and extract TLD using the previous logic
    url_parts = url.split(".")
    if len(url_parts) > 1 and url_parts[-1] in {"com", "org", "net", "edu", "gov", "mil"}:
      return url_parts[-2]  # Return TLD (e.g., sld.com, sld.org)
    elif len(url_parts) > 2 and url_parts[-3] in {"co", "ac"}:
      return ".".join(url_parts[-2:])  # Handle "sld.co.uk", etc.
    else:
      return url_parts[-1]  # Default to last part 
  except IndexError:
    return None 

def normalize_url(url):
    """Normalize a single URL"""
    url = url.lower()
    parsed_url = urllib.parse.urlparse(url)
    if parsed_url.port == 80 and parsed_url.scheme == 'http':
        parsed_url = parsed_url._replace(netloc=parsed_url.netloc.split(':')[0])
    url = urllib.parse.urlunparse(parsed_url)
    url = url.rstrip('/')
    url = urllib.parse.urldefrag(url)[0]
    url = urllib.parse.unquote(url)
    return url

def compare_urls(url1, url2):
    """Compare two URLs after normalizing them"""
    url1 = normalize_url(url1)
    url2 = normalize_url(url2)
    return url1 == url2

def format_message(content):
    if not content:
        return ''
    
    # Process ANSI color codes
    color_map = {
        '\x1b[1m': '<strong>',
        '\x1b[0m': '</strong>',
        '\x1b[93m': '<span class="text-warning">',  # Yellow
        '\x1b[92m': '<span class="text-success">',  # Green
        '\x1b[95m': '<span class="text-info">',     # Light Blue (for magenta)
        '\x1b[91m': '<span class="text-danger">',   # Red
        '\x1b[94m': '<span class="text-primary">',  # Blue
    }

    # Replace color codes with Bootstrap classes
    for code, html in color_map.items():
        content = content.replace(code, html)

    # Remove any remaining ANSI escape sequences
    ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
    content = ansi_escape.sub('', content)

    try:
        # Convert Markdown to HTML using markdown-it
        html_content = md.render(content)

        # Parse the HTML with BeautifulSoup
        soup = BeautifulSoup(html_content, 'html.parser')

        # Add Bootstrap classes to elements
        for tag in soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
            tag['class'] = tag.get('class', []) + ['mt-3', 'mb-2']
        
        for tag in soup.find_all('p'):
            tag['class'] = tag.get('class', []) + ['mb-2']
        
        for tag in soup.find_all('ul', 'ol'):
            tag['class'] = tag.get('class', []) + ['pl-4']
        
        for tag in soup.find_all('code'):
            tag['class'] = tag.get('class', []) + ['bg-light', 'p-1', 'rounded']

        # Convert back to string
        formatted_content = str(soup)

        # Ensure all spans are closed
        open_spans = formatted_content.count('<span')
        close_spans = formatted_content.count('</span>')
        if open_spans > close_spans:
            formatted_content += '</span>' * (open_spans - close_spans)

        return formatted_content
    except Exception as e:
        logger.error(f"Error formatting message: {str(e)}")
        return content  # Return original content if formatting fails

class DateProcessor:
    @staticmethod
    def process_relative_date(date_str: str) -> str:
        """
        Convert relative dates to YYYY-MM-DD format
        Supports:
        - NdaysAgo (e.g., 7daysAgo)
        - NmonthsAgo (e.g., 3monthsAgo)
        - today
        - yesterday
        - YYYY-MM-DD format
        """
        if date_str == 'today':
            return datetime.now().strftime('%Y-%m-%d')
        
        if date_str == 'yesterday':
            return (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
            
        # Check for NmonthsAgo format
        months_match = re.match(r'^(\d+)monthsAgo$', date_str)
        if months_match:
            months = int(months_match.group(1))
            return (datetime.now() - relativedelta(months=months)).strftime('%Y-%m-%d')
            
        # Check for NdaysAgo format
        days_match = re.match(r'^(\d+)daysAgo$', date_str)
        if days_match:
            days = int(days_match.group(1))
            return (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
            
        # Assume YYYY-MM-DD format
        try:
            datetime.strptime(date_str, '%Y-%m-%d')
            return date_str
        except ValueError:
            raise ValueError(
                "Invalid date format. Use either:\n"
                "- YYYY-MM-DD (e.g., 2024-03-15)\n"
                "- 'today' or 'yesterday'\n"
                "- 'NdaysAgo' where N is a positive number (e.g., 7daysAgo)\n"
                "- 'NmonthsAgo' where N is a positive number (e.g., 3monthsAgo)"
            )

def create_box(title: str, content: str) -> str:
    """Create a boxed debug message with wrapped content using Unicode box characters."""
    # Box drawing characters
    TOP_LEFT = "┌"
    TOP_RIGHT = "┐"
    BOTTOM_LEFT = "└"
    BOTTOM_RIGHT = "┘"
    HORIZONTAL = "─"
    VERTICAL = "│"
    
    # Wrap content to 80 chars
    wrapped_content = textwrap.fill(str(content), width=80)
    width = max(max(len(line) for line in wrapped_content.split('\n')), len(title)) + 4
    
    # Create box components
    top = f"{TOP_LEFT}{HORIZONTAL * (width-2)}{TOP_RIGHT}"
    title_line = f"{VERTICAL} {title.center(width-4)} {VERTICAL}"
    separator = f"{HORIZONTAL * width}"
    content_lines = [f"{VERTICAL} {line:<{width-4}} {VERTICAL}" for line in wrapped_content.split('\n')]
    bottom = f"{BOTTOM_LEFT}{HORIZONTAL * (width-2)}{BOTTOM_RIGHT}"
    
    return f"\n{top}\n{title_line}\n{separator}\n{chr(10).join(content_lines)}\n{bottom}\n"

================
File: apps/common/views.py
================
from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_GET
from asgiref.sync import async_to_sync

from .services.llm_service import LLMService

# Create your views here.

@require_GET
def get_llm_models(request):
    """Get available models for a provider."""
    provider = request.GET.get('provider')
    if not provider:
        return JsonResponse({'error': 'Provider parameter is required'}, status=400)
    
    try:
        # Initialize service and get models
        service = LLMService(user=request.user)
        models = async_to_sync(service.get_available_models)(provider_type=provider)
        
        if not models:
            return JsonResponse({'error': 'No models available for this provider'}, status=404)
            
        return JsonResponse(models)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

================
File: apps/crawl_website/static/crawl_website/js/crawl-htmx.js
================
/**
 * Minimal JavaScript functions for the crawl.html template
 * These functions are kept to a minimum to maximize HTMX usage
 */

// Function to toggle advanced options
function toggleAdvancedOptions() {
    const advancedOptions = document.getElementById('advanced-options');
    const button = document.getElementById('toggle-advanced-options');

    if (advancedOptions && button) {
        // Toggle the d-none class
        advancedOptions.classList.toggle('d-none');

        // Update button text
        if (advancedOptions.classList.contains('d-none')) {
            button.innerHTML = '<i class="fas fa-cog me-1"></i> Show Advanced Options';
        } else {
            button.innerHTML = '<i class="fas fa-times me-1"></i> Hide Advanced Options';
        }
    }
}

// No longer needed - we'll rely on HTMX OOB swaps and template logic

// Function to attach to an existing crawl
function attachToCrawl(taskId, url) {
    if (!taskId) return;

    // Show progress section
    document.getElementById('crawling-progress-section').style.display = 'block';

    // Update the crawling status title
    const statusTitle = document.getElementById('crawling-status-title');
    if (statusTitle) statusTitle.textContent = `Crawling in Progress: ${url}`;

    // Reset stats cards
    const pagesVisitedElement = document.getElementById('pages-visited-count');
    const linksFoundElement = document.getElementById('links-found-count');
    const currentUrlElement = document.getElementById('current-page-url');

    if (pagesVisitedElement) pagesVisitedElement.textContent = '0';
    if (linksFoundElement) linksFoundElement.textContent = '0';
    if (currentUrlElement) currentUrlElement.textContent = 'Connecting...';

    // Set up WebSocket connection
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsPath = `${wsScheme}://${window.location.host}/ws/crawl/${taskId}/`;

    // Set the WebSocket connection attribute
    const container = document.getElementById('crawl-container');
    container.setAttribute('ws-connect', wsPath);
    container.setAttribute('data-task-id', taskId);

    // Process the container to connect WebSocket
    htmx.process(container);

    // Show notification
    Swal.fire({
        title: 'Connected',
        text: 'Connected to crawl',
        icon: 'info',
        toast: true,
        position: 'top-end',
        showConfirmButton: false,
        timer: 3000,
        timerProgressBar: true
    });
}

// Initialize tooltips when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    tooltipTriggerList.forEach(function (tooltipTriggerEl) {
        new bootstrap.Tooltip(tooltipTriggerEl);
    });

    // Add WebSocket event listeners for debugging
    htmx.on('htmx:wsOpen', function(evt) {
        console.log('WebSocket connected:', evt);
    });

    htmx.on('htmx:wsClose', function(evt) {
        console.log('WebSocket closed:', evt);
    });

    htmx.on('htmx:wsError', function(evt) {
        console.error('WebSocket error:', evt);
    });
});

// Handle crawl completion event - only for notifications
htmx.on('htmx:wsMessage', function(evt) {
    try {
        // Try to parse as JSON
        const data = JSON.parse(evt.detail.message);

        // Only handle event messages for notifications
        if (data && data.type === 'event') {
            // Show appropriate notification based on event type
            if (data.event_name === 'crawl_complete') {
                console.log('Crawl completed:', data);

                // Show notification
                Swal.fire({
                    title: 'Crawl Complete',
                    text: data.message || 'Crawl completed successfully',
                    icon: 'success',
                    confirmButtonText: 'OK'
                });
            } else if (data.event_name === 'crawl_error') {
                console.log('Crawl error:', data);

                // Show notification
                Swal.fire({
                    title: 'Crawl Failed',
                    text: data.message || 'An error occurred during the crawl',
                    icon: 'error',
                    confirmButtonText: 'OK'
                });
            } else if (data.event_name === 'crawl_cancelled') {
                console.log('Crawl cancelled:', data);

                // Show notification
                Swal.fire({
                    title: 'Crawl Cancelled',
                    text: data.message || 'Crawl was cancelled',
                    icon: 'warning',
                    confirmButtonText: 'OK'
                });
            }
        }
    } catch (e) {
        // Not JSON, let HTMX handle it
        // HTMX will process HTML fragments with OOB swaps
    }
});

================
File: apps/crawl_website/templates/crawl_website/partials/_active_crawls.html
================
{% if tasks %}
    <div class="table-responsive">
        <table class="table align-items-center mb-0">
            <thead>
                <tr>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Task ID</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">URL</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                </tr>
            </thead>
            <tbody>
                {% for task in tasks %}
                <tr>
                    <td>
                        <p class="text-xs font-weight-bold mb-0">{{ task.id|truncatechars:10 }}</p>
                    </td>
                    <td>
                        <p class="text-xs text-secondary mb-0">{{ task.kwargs.website_url|default:"Unknown URL" }}</p>
                    </td>
                    <td>
                        {% if task.status == 'RUNNING' %}
                            <span class="badge badge-sm bg-gradient-info">Running</span>
                        {% elif task.status == 'SCHEDULED' %}
                            <span class="badge badge-sm bg-gradient-warning">Scheduled</span>
                        {% elif task.status == 'RESERVED' %}
                            <span class="badge badge-sm bg-gradient-secondary">Reserved</span>
                        {% else %}
                            <span class="badge badge-sm bg-gradient-primary">{{ task.status }}</span>
                        {% endif %}
                    </td>
                    <td>
                        <div class="btn-group" role="group">
                            <button class="btn btn-sm btn-success me-2"
                                    onclick="attachToCrawl('{{ task.id }}', '{{ task.kwargs.website_url|default:"Unknown URL" }}')">
                                <i class="fas fa-eye"></i> View
                            </button>
                            <button class="btn btn-sm btn-danger"
                                    hx-post="{% url 'crawl_website:cancel_crawl' task_id=task.id %}"
                                    hx-target="#active-crawls-container"
                                    hx-confirm="Are you sure you want to cancel this crawl?">
                                <i class="fas fa-stop-circle"></i> Cancel
                            </button>
                        </div>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
{% else %}
    <div class="alert alert-info">
        <i class="fas fa-info-circle me-2"></i>
        No active crawls at the moment.
    </div>
{% endif %}

================
File: apps/crawl_website/templates/crawl_website/partials/_crawl_results_section.html
================
{# Partial template for the crawl results section #}
<div class="card">
    <div class="card-header p-3">
        <div class="d-flex align-items-center justify-content-between">
            <div class="d-flex align-items-center">
                <i class="fas fa-check-circle text-success me-2"></i>
                <h6 class="mb-0">Crawl Results</h6>
            </div>
            <button class="btn btn-sm btn-outline-primary" 
                    hx-on:click="document.getElementById('crawl-results-section').style.display = 'none';">
                <i class="fas fa-times me-1"></i> Close Results
            </button>
        </div>
    </div>
    <div class="card-body p-3">
        <div id="crawl-results">
            {% include "crawl_website/partials/_crawl_results.html" %}
        </div>

        <div id="crawl-download-links" class="mt-3 d-flex gap-2" {% if file_url or csv_url %}style="display: flex;"{% else %}style="display: none;"{% endif %}>
            {% if file_url %}
                <a href="{{ file_url }}" class="btn btn-sm btn-info" target="_blank">View Raw Result</a>
                <a href="{{ file_url }}" class="btn btn-sm btn-primary" download>Download Result</a>
            {% endif %}
            {% if csv_url %}
                <a href="{{ csv_url }}" class="btn btn-sm btn-success" download="crawl_results.csv">Download CSV</a>
            {% endif %}
        </div>

        <div class="page-details" id="page-details-section" style="display: none;">
            <h6 class="mb-3">Page Details</h6>
            <div class="table-responsive">
                <table class="table align-items-center mb-0">
                    <thead>
                        <tr>
                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">URL</th>
                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Title</th>
                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                        </tr>
                    </thead>
                    <tbody id="page-details-table">
                        <!-- Page details will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

================
File: apps/crawl_website/templates/crawl_website/partials/_crawl_results.html
================
{# Updated via WS OOB swap on completion #}
{% if status == 'completed' and results %}
    <div class="alert alert-success">Crawl completed successfully!</div>

    {# Display based on output_format #}
    <div class="card">
        <div class="card-header">
            <h6 class="mb-0">Combined Content ({{ output_format|title }})</h6>
        </div>
        <div class="card-body" style="max-height: 400px; overflow-y: auto;">
            {% if output_format == 'html' %}
                <pre><code>{{ results|escape }}</code></pre> {# Display raw HTML escaped #}
            {% elif output_format == 'metadata' %}
                <pre><code>{{ results|safe }}</code></pre> {# Assuming results is preformatted JSON #}
            {% elif output_format == 'links' %}
                <pre>{% for item in results %}
{{ item.url }}
{% endfor %}</pre>
            {% else %}{# Handle text format by looping #}
                {% for item in results %}
                <div class="mb-5 border-bottom pb-4">
                    <h4>URL: <a href="{{ item.url }}" target="_blank">{{ item.url }}</a></h4>
                    <h5>Title: {{ item.title|default:"No title" }}</h5>

                    <!-- Tabs for different content types -->
                    <ul class="nav nav-tabs mb-3" id="content-tabs-{{ forloop.counter }}" role="tablist">
                        {% if item.text %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="text-tab-{{ forloop.counter }}" data-bs-toggle="tab" data-bs-target="#text-{{ forloop.counter }}" type="button" role="tab">Text Content</button>
                        </li>
                        {% endif %}

                        {% if item.metadata %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link {% if not item.text %}active{% endif %}" id="metadata-tab-{{ forloop.counter }}" data-bs-toggle="tab" data-bs-target="#metadata-{{ forloop.counter }}" type="button" role="tab">Metadata</button>
                        </li>
                        {% endif %}

                        {% if item.links %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link {% if not item.text and not item.metadata %}active{% endif %}" id="links-tab-{{ forloop.counter }}" data-bs-toggle="tab" data-bs-target="#links-{{ forloop.counter }}" type="button" role="tab">Links ({{ item.links|length }})</button>
                        </li>
                        {% endif %}

                        {% if item.screenshot %}
                        <li class="nav-item" role="presentation">
                            <button class="nav-link {% if not item.text and not item.metadata and not item.links %}active{% endif %}" id="screenshot-tab-{{ forloop.counter }}" data-bs-toggle="tab" data-bs-target="#screenshot-{{ forloop.counter }}" type="button" role="tab">Screenshot</button>
                        </li>
                        {% endif %}
                    </ul>

                    <!-- Tab content -->
                    <div class="tab-content" id="content-tabs-content-{{ forloop.counter }}">
                        {% if item.text %}
                        <div class="tab-pane fade show active" id="text-{{ forloop.counter }}" role="tabpanel">
                            <pre style="max-height: 400px; overflow-y: auto;">{{ item.text }}</pre>
                        </div>
                        {% endif %}

                        {% if item.metadata %}
                        <div class="tab-pane fade {% if not item.text %}show active{% endif %}" id="metadata-{{ forloop.counter }}" role="tabpanel">
                            <div class="table-responsive">
                                <table class="table table-sm table-striped">
                                    <thead>
                                        <tr>
                                            <th>Property</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for key, value in item.metadata.items %}
                                        <tr>
                                            <td><strong>{{ key }}</strong></td>
                                            <td>{{ value|default:"--" }}</td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        {% endif %}

                        {% if item.links %}
                        <div class="tab-pane fade {% if not item.text and not item.metadata %}show active{% endif %}" id="links-{{ forloop.counter }}" role="tabpanel">
                            <div class="table-responsive" style="max-height: 400px; overflow-y: auto;">
                                <table class="table table-sm table-striped">
                                    <thead>
                                        <tr>
                                            <th>#</th>
                                            <th>URL</th>
                                            <th>Text</th>
                                            <th>Title</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for link in item.links %}
                                        <tr>
                                            <td>{{ forloop.counter }}</td>
                                            <td><a href="{{ link.href }}" target="_blank">{{ link.href }}</a></td>
                                            <td>{{ link.text|truncatechars:50|default:"--" }}</td>
                                            <td>{{ link.title|default:"--" }}</td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        {% endif %}

                        {% if item.screenshot %}
                        <div class="tab-pane fade {% if not item.text and not item.metadata and not item.links %}show active{% endif %}" id="screenshot-{{ forloop.counter }}" role="tabpanel">
                            <div class="text-center">
                                <img src="data:image/png;base64,{{ item.screenshot }}" class="img-fluid border" alt="Screenshot of {{ item.url }}" />
                            </div>
                        </div>
                        {% endif %}
                    </div>
                </div>
                {% endfor %}
            {% endif %}
        </div>
    </div>

    {# Download links are now in _crawl_results_section.html to avoid duplication #}

    {# No JavaScript needed here - we'll use HTMX OOB swaps instead #}

{% elif status == 'failed' %}
    <div class="alert alert-danger">
        <strong>Crawl Failed:</strong> {{ error_message|default:"An unknown error occurred." }}
    </div>
    {# No JavaScript needed here - we'll use HTMX OOB swaps instead #}
{% elif status == 'cancelled' %}
    <div class="alert alert-warning">Crawl Cancelled.</div>
    {# No JavaScript needed here - we'll use HTMX OOB swaps instead #}
{% else %}
    <p>Results will appear here once the crawl is complete.</p>
{% endif %}

================
File: apps/crawl_website/templates/crawl_website/partials/_crawl_status_progress.html
================
{# Updated via WS OOB swap #}
<div id="crawl-status-message" class="mb-3">
    <p class="text-muted">{{ message|default:"Processing..." }}</p>
</div>
<div class="progress mb-3">
    <div id="crawl-progress-bar"
         class="progress-bar {% if status == 'failed' %}bg-danger{% elif status == 'completed' %}bg-success{% endif %}"
         role="progressbar"
         style="width: {{ progress|default:0 }}%"
         aria-valuenow="{{ progress|default:0 }}"
         aria-valuemin="0"
         aria-valuemax="100">
    </div>
    <span>{{ progress|default:0 }}%</span>
</div>
<div id="crawl-page-stats" class="mb-3">
    <small class="text-muted">Pages Visited: <span id="links-visited-count">{{ links_visited|default:0 }}</span></small><br/>
    <small class="text-muted" id="current-url-display">Current URL: <code>{{ current_url|default:'N/A' }}</code></small>
</div>

================
File: apps/crawl_website/templates/crawl_website/crawl.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% block title %} Website Crawler {% endblock %}

<!-- Specific Page CSS goes HERE  -->
{% block extrastyle %}
<style>
    /* Card styling */
    .info-card {
        border-radius: 10px;
        height: 100%;
        transition: transform 0.3s ease;
    }

    .info-card:hover {
        transform: translateY(-5px);
    }

    .info-icon {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 1rem;
    }

    /* Progress bar styling */
    .progress {
        height: 8px;
        overflow: visible;
    }

    .progress .progress-bar {
        position: relative;
        overflow: visible;
        border-radius: 8px;
    }

    .progress-percentage {
        position: absolute;
        right: 0;
        top: -25px;
    }

    /* Stats cards */
    .stat-card {
        border-radius: 10px;
        padding: 1.5rem;
        position: relative;
        overflow: hidden;
        min-height: 120px;
    }

    .stat-icon {
        position: absolute;
        right: 1rem;
        top: 50%;
        transform: translateY(-50%);
        opacity: 0.8;
    }

    /* Tip banner */
    .tip-banner {
        border-left: 4px solid var(--bs-warning);
        background-color: rgba(225, 192, 142, 0.1);
    }

    /* URL validation message */
    .url-validation {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        border-radius: 4px;
        display: inline-block;
        margin-top: 0.25rem;
    }

    /* Crawling in progress spinner */
    .crawling-spinner {
        display: inline-block;
        width: 1.5rem;
        height: 1.5rem;
        vertical-align: middle;
        border: 0.2em solid currentColor;
        border-right-color: transparent;
        border-radius: 50%;
        animation: spinner-border .75s linear infinite;
    }

    /* Page details section */
    .page-details {
        border-top: 1px solid rgba(0,0,0,0.1);
        padding-top: 1rem;
        margin-top: 1rem;
    }

    /* Dark mode adjustments */
    .dark-version .info-card {
        background-color: #1a2035;
    }

    .dark-version .tip-banner {
        background-color: rgba(225, 192, 142, 0.05);
    }
</style>
{% endblock extrastyle %}

{% block content %}
<div class="container-fluid py-4"
     id="crawl-container"
     hx-ext="ws">

    <!-- Header Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-md-8">
                            <h5 class="mb-0">Website Crawler</h5>
                            <p class="text-sm mb-0">Enter a URL to crawl and analyze website content</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Active Crawls Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header p-3 d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">Active Crawls</h6>
                    <button class="btn btn-sm btn-info"
                            hx-get="{% url 'crawl_website:list_active_crawls' %}"
                            hx-target="#active-crawls-container"
                            hx-trigger="click"
                            hx-indicator=".htmx-indicator">
                        <i class="fas fa-sync-alt"></i> Refresh
                        <span class="htmx-indicator spinner-border spinner-border-sm" style="display: none;"></span>
                    </button>
                </div>
                <div class="card-body p-3">
                    <div id="active-crawls-container"
                         hx-get="{% url 'crawl_website:list_active_crawls' %}"
                         hx-trigger="load">
                        <p class="text-muted">Loading active crawls...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Input Form Section -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body p-3">
                    <form id="crawl-form"
                          hx-post="{% url 'crawl_website:initiate_crawl' %}"
                          hx-target="#crawl-status-progress"
                          hx-swap="innerHTML"
                          hx-indicator="#processing-indicator"
                          hx-on::after-request="
                            const taskId = event.detail.xhr.getResponseHeader('X-Task-ID');
                            if (taskId) {
                                // Show progress section
                                document.getElementById('crawling-progress-section').style.display = 'block';

                                // Set up WebSocket connection
                                const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
                                const wsPath = `${wsScheme}://${window.location.host}/ws/crawl/${taskId}/`;
                                document.getElementById('crawl-container').setAttribute('ws-connect', wsPath);
                                htmx.process(document.getElementById('crawl-container'));

                                // Store task ID in a data attribute for later use
                                document.getElementById('crawl-container').setAttribute('data-task-id', taskId);
                            }
                          ">
                        {% csrf_token %}

                        <div class="row">
                            <div class="col-md-8">
                                <label for="url" class="form-label">Website URL to Crawl
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Specify the base URL where the crawl will begin. Ensure the URL is valid, includes the protocol (http:// or https://), and points to the desired starting page."></i>
                                </label>
                                <input type="url"
                                       class="form-control"
                                       id="url"
                                       name="url"
                                       placeholder="https://example.com"
                                       required
                                       hx-get="#"
                                       hx-trigger="keyup changed delay:500ms"
                                       hx-swap="none"
                                       _="on keyup
                                          if my.value.trim() !== '' and not my.value.match('^https?://.*\..*')
                                            set #url-validation.textContent to 'Please enter a valid URL (e.g., https://example.com)'
                                            remove .d-none from #url-validation
                                            remove .bg-success from #url-validation
                                            add .bg-danger .text-white to #url-validation
                                          else if my.value.trim() !== ''
                                            set #url-validation.textContent to 'Valid URL format'
                                            remove .d-none from #url-validation
                                            remove .bg-danger from #url-validation
                                            add .bg-success .text-white to #url-validation
                                          else
                                            add .d-none to #url-validation
                                          end">
                                <div id="url-validation" class="url-validation d-none"></div>
                            </div>
                            <div class="col-md-4">
                                <label for="max-depth" class="form-label">Crawl Depth
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Define the depth of the crawl: Level 1: Crawl only the starting page. Level 2: Crawl the starting page and all links found on it. Higher levels recursively follow links on each page, exponentially increasing the number of pages crawled."></i>
                                </label>
                                <select class="form-control" id="max-depth" name="max_depth">
                                    <option value="1">Level 1 (Homepage Only)</option>
                                    <option value="2" selected>Level 2 (Pages + Links)</option>
                                    <option value="3">Level 3 (Deep Crawl)</option>
                                    <option value="4">Level 4 (Very Deep)</option>
                                </select>
                            </div>
                        </div>

                        <div class="mt-3 mb-3">
                            <button type="button"
                                    class="btn btn-sm btn-outline-primary"
                                    id="toggle-advanced-options"
                                    onclick="toggleAdvancedOptions()">
                                <i class="fas fa-cog me-1"></i> Show Advanced Options
                            </button>
                        </div>

                        <!-- Advanced Options (Collapsible) -->
                        <div id="advanced-options" class="mt-4 d-none">
                            <div class="card bg-gray-100 border-0 shadow-none">
                                <div class="card-body">
                                    <h6 class="mb-3">Advanced Crawl Options</h6>

                                    <!-- Crawl Type Selection -->
                                    <div class="mb-3">
                                        <label class="form-label">Crawl Method
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Choose between standard link-following crawl or sitemap-based crawl."></i>
                                        </label>
                                        <div class="form-check">
                                            <input class="form-check-input"
                                                   type="radio"
                                                   name="crawl_type"
                                                   id="crawl_type_standard"
                                                   value="standard"
                                                   checked
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change
                                                      add .d-none to #sitemap-crawl-options
                                                      remove .d-none from #standard-crawl-options">
                                            <label class="form-check-label" for="crawl_type_standard">
                                                Standard Crawl (Follows links)
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="The crawler will parse the HTML of each page to extract and follow links (anchor tags). This method is suitable for websites without a sitemap or for broader exploration."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input"
                                                   type="radio"
                                                   name="crawl_type"
                                                   id="crawl_type_sitemap"
                                                   value="sitemap"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change
                                                      add .d-none to #standard-crawl-options
                                                      remove .d-none from #sitemap-crawl-options">
                                            <label class="form-check-label" for="crawl_type_sitemap">
                                                Sitemap-Based Crawl
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="The crawler will fetch and parse the website's sitemap.xml file (if available) to identify pages for crawling. This method is faster and more structured but relies on the sitemap's accuracy and completeness."></i>
                                            </label>
                                        </div>
                                    </div>

                                    <!-- Standard Crawl Options -->
                                    <div id="standard-crawl-options">
                                        <div class="mb-3">
                                            <label for="max-pages" class="form-label">Maximum Pages
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Set an upper limit on the number of pages to crawl. This prevents excessive crawling and resource usage. For example, a value of '7' will stop the crawl after processing 7 pages, regardless of the total number of pages available."></i>
                                            </label>
                                            <input type="number" class="form-control" id="max-pages" name="max_pages" value="100" min="1">
                                        </div>
                                        <div class="mb-3">
                                            <label for="include-patterns" class="form-label">Include Patterns (Optional)
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Use glob patterns to specify which URLs to include in the crawl. For example: 'blog/*' matches all URLs under the 'blog' path. 'docs/*' matches all URLs under the 'docs' path. Patterns are case-sensitive and should align with the website's URL structure."></i>
                                            </label>
                                            <input type="text" class="form-control" id="include-patterns" name="include_patterns" placeholder="e.g., blog/*, docs/*">
                                            <small class="form-text text-muted">Comma-separated glob patterns</small>
                                        </div>
                                        <div class="mb-3">
                                            <label for="exclude-patterns" class="form-label">Exclude Patterns (Optional)
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Use glob patterns to exclude specific URLs from the crawl. For example: 'admin/*' excludes all URLs under the 'admin' path. 'login/*' excludes all URLs under the 'login' path. Patterns are case-sensitive and should be used to avoid unnecessary or restricted pages."></i>
                                            </label>
                                            <input type="text" class="form-control" id="exclude-patterns" name="exclude_patterns" placeholder="e.g., admin/*, login/*">
                                            <small class="form-text text-muted">Comma-separated glob patterns</small>
                                        </div>
                                    </div>

                                    <!-- Sitemap Crawl Options -->
                                    <div id="sitemap-crawl-options" class="d-none">
                                        <div class="mb-3">
                                            <label for="max-sitemap-urls" class="form-label">Max Sitemap URLs to Process</label>
                                            <input type="number" class="form-control" id="max-sitemap-urls" name="max_sitemap_urls" value="50" min="1">
                                        </div>
                                        <div class="mb-3">
                                            <label for="max-sitemap-retriever-pages" class="form-label">Max Sitemap Discovery Pages</label>
                                            <input type="number" class="form-control" id="max-sitemap-retriever-pages" name="max_sitemap_retriever_pages" value="1000" min="1">
                                        </div>
                                        <div class="mb-3">
                                            <label for="sitemap-requests-per-second" class="form-label">Requests per Second</label>
                                            <input type="number" class="form-control" id="sitemap-requests-per-second" name="sitemap_requests_per_second" value="5.0" step="0.1" min="0.1">
                                        </div>
                                        <div class="mb-3">
                                            <label for="sitemap-timeout" class="form-label">Timeout (ms)</label>
                                            <input type="number" class="form-control" id="sitemap-timeout" name="sitemap_timeout" value="15000" min="1000">
                                        </div>
                                    </div>

                                    <hr class="horizontal dark my-4">

                                    <!-- Common Options -->
                                    <h6 class="mb-3">Content Options</h6>

                                    <div class="mb-3">
                                        <label class="form-label">Output Format
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Select the type of content you want to extract from each page. You can select multiple formats."></i>
                                        </label>
                                        <div class="form-check">
                                            <input class="form-check-input output-format-checkbox"
                                                   type="checkbox"
                                                   id="output-format-text"
                                                   name="output_format"
                                                   value="text"
                                                   checked
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change
                                                      if #output-format-full.checked
                                                        set #output-format-full.checked to false
                                                      end">
                                            <label class="form-check-label" for="output-format-text">Text Content
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Extracts only the visible text content from the page, excluding HTML tags and other non-visible elements."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input output-format-checkbox"
                                                   type="checkbox"
                                                   id="output-format-html"
                                                   name="output_format"
                                                   value="html"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change if #output-format-full.checked set #output-format-full.checked to false">
                                            <label class="form-check-label" for="output-format-html">HTML
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Extracts the full HTML source code of the page, including all tags, attributes, and structure."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input output-format-checkbox"
                                                   type="checkbox"
                                                   id="output-format-links"
                                                   name="output_format"
                                                   value="links"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change if #output-format-full.checked set #output-format-full.checked to false">
                                            <label class="form-check-label" for="output-format-links">Links
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Extracts all hyperlinks (anchor tags) from the page, including internal and external URLs."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input output-format-checkbox"
                                                   type="checkbox"
                                                   id="output-format-metadata"
                                                   name="output_format"
                                                   value="metadata"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change if #output-format-full.checked set #output-format-full.checked to false">
                                            <label class="form-check-label" for="output-format-metadata">Metadata
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Extracts metadata from the page, such as <title>, <meta> tags (e.g., description, keywords), and other structured data."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input output-format-checkbox"
                                                   type="checkbox"
                                                   id="output-format-screenshot"
                                                   name="output_format"
                                                   value="screenshot"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change if #output-format-full.checked set #output-format-full.checked to false">
                                            <label class="form-check-label" for="output-format-screenshot">Screenshot
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Captures a screenshot of the rendered page as it would appear in a browser."></i>
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input"
                                                   type="checkbox"
                                                   id="output-format-full"
                                                   name="output_format"
                                                   value="full"
                                                   hx-get="#"
                                                   hx-trigger="change"
                                                   hx-swap="none"
                                                   _="on change
                                                      if I.checked
                                                        set .output-format-checkbox.checked to false
                                                        set .output-format-checkbox.disabled to true
                                                      else
                                                        set .output-format-checkbox.disabled to false
                                                        set #output-format-text.checked to true
                                                      end">
                                            <label class="form-check-label" for="output-format-full">Full (All formats)
                                                <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                                   title="Extracts all available data, including text content, HTML, links, metadata, and screenshots. This is the most comprehensive option."></i>
                                            </label>
                                        </div>
                                    </div>

                                    <div class="mb-3">
                                        <label for="css-selector" class="form-label">CSS Selector (Optional)
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Specify a CSS selector to target specific elements on the page for scraping. For example: '.article-content' selects all elements with the class 'article-content'. '#main-content' selects the element with the ID 'main-content'. Leave blank to scrape the entire page. Use standard CSS selector syntax."></i>
                                        </label>
                                        <input type="text" class="form-control" id="css-selector" name="css-selector" placeholder="e.g., article.content">
                                    </div>

                                    <div class="mb-3">
                                        <label for="wait-for" class="form-label">Wait For Element (Optional)
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Specify a CSS selector for an element the crawler should wait for before starting to scrape. This is useful for handling dynamic content that loads asynchronously (e.g., JavaScript-rendered pages). For example: '#main-content' waits for the element with ID 'main-content' to load before proceeding."></i>
                                        </label>
                                        <input type="text" class="form-control" id="wait-for" name="wait-for" placeholder="e.g., #main-content">
                                    </div>

                                    <div class="mb-3 form-check">
                                        <input type="checkbox" class="form-check-input" id="save-file" name="save-file" checked>
                                        <label class="form-check-label" for="save-file">Save result to file
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Save the crawl results to a file for later reference or processing."></i>
                                        </label>
                                    </div>

                                    <div class="mb-3 form-check">
                                        <input type="checkbox" class="form-check-input" id="save-as-csv" name="save-as-csv" checked>
                                        <label class="form-check-label" for="save-as-csv">Save as CSV
                                            <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                               title="Exports the scraped data to a CSV file, which can be easily imported into tools like Excel, Google Sheets, or data analysis software."></i>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="text-end mt-3">
                            <button type="submit"
                                    class="btn bg-gradient-primary"
                                    hx-disable-elt="this"
                                    _="on htmx:beforeRequest
                                         if not document.querySelector('input[name=\'output_format\']:checked')
                                           halt the event
                                           call Swal.fire({title: 'Error', text: 'Please select at least one output format', icon: 'error'})
                                         end">
                                <span class="indicator-label">
                                    <i class="fas fa-spider me-2"></i>Start Crawling
                                </span>
                                <span class="indicator-progress" id="processing-indicator" style="display: none;">
                                    Please wait...
                                    <span class="spinner-border spinner-border-sm align-middle ms-2"></span>
                                </span>
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Cards Section -->
    <div class="row mb-4">
        <div class="col-md-4 mb-4 mb-md-0">
            <div class="card info-card bg-gradient-light shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex">
                        <div class="info-icon bg-gradient-primary text-white">
                            <i class="fas fa-info"></i>
                        </div>
                        <div>
                            <h6 class="text-dark mb-1">What is crawling?</h6>
                            <p class="mb-0 text-sm">Our tool visits web pages like a visitor would, collecting useful information.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4 mb-4 mb-md-0">
            <div class="card info-card bg-gradient-light shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex">
                        <div class="info-icon bg-gradient-info text-white">
                            <i class="fas fa-shield-alt"></i>
                        </div>
                        <div>
                            <h6 class="text-dark mb-1">Respectful Crawling</h6>
                            <p class="mb-0 text-sm">We follow robots.txt rules and don't overload servers.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card info-card bg-gradient-light shadow-sm">
                <div class="card-body p-3">
                    <div class="d-flex">
                        <div class="info-icon bg-gradient-success text-white">
                            <i class="fas fa-bolt"></i>
                        </div>
                        <div>
                            <h6 class="text-dark mb-1">Quick Results</h6>
                            <p class="mb-0 text-sm">Most crawls complete in under 2 minutes.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Crawling Progress Section -->
    <div class="row mb-4" id="crawling-progress-section" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header p-3">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <div class="crawling-spinner me-3" id="progress-spinner"></div>
                            <h6 class="mb-0" id="crawling-status-title">Crawling in Progress</h6>
                        </div>
                        <button id="cancel-crawl-btn" class="btn btn-sm btn-danger"
                                hx-target="#crawl-status-progress"
                                hx-swap="innerHTML"
                                hx-indicator=".htmx-indicator"
                                hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'
                                _="on click
                                   set taskId to document.getElementById('crawl-container').getAttribute('data-task-id')
                                   if taskId
                                     set my.attributes['hx-post'].value to '/crawl_website/cancel_crawl/' + taskId + '/'
                                     send htmx:trigger to me
                                   end">
                            <i class="fas fa-stop-circle me-1"></i> Stop Crawl
                            <span class="htmx-indicator spinner-border spinner-border-sm" style="display: none;"></span>
                        </button>
                    </div>
                </div>
                <div class="card-body p-3">
                    <div id="crawl-status-progress">
                        {% include "crawl_website/partials/_crawl_status_progress.html" %}
                    </div>

                    <div class="row mt-4">
                        <div class="col-md-4 mb-4 mb-md-0">
                            <div class="card stat-card bg-gradient-white shadow-sm">
                                <div class="stat-icon">
                                    <i class="fas fa-file-alt fa-2x text-primary opacity-6"></i>
                                </div>
                                <h6 class="text-sm mb-1">Pages Visited</h6>
                                <h3 class="font-weight-bold mb-0" id="pages-visited-count">0</h3>
                            </div>
                        </div>
                        <div class="col-md-4 mb-4 mb-md-0">
                            <div class="card stat-card bg-gradient-white shadow-sm">
                                <div class="stat-icon">
                                    <i class="fas fa-link fa-2x text-info opacity-6"></i>
                                </div>
                                <h6 class="text-sm mb-1">Links Found</h6>
                                <h3 class="font-weight-bold mb-0" id="links-found-count">0</h3>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card stat-card bg-gradient-white shadow-sm">
                                <div class="stat-icon">
                                    <i class="fas fa-globe fa-2x text-success opacity-6"></i>
                                </div>
                                <h6 class="text-sm mb-1">Current Page</h6>
                                <p class="text-sm mb-0 text-truncate" id="current-page-url">Waiting for crawl to start...</p>
                            </div>
                        </div>
                    </div>

                    <div class="tip-banner p-3 mt-4">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-lightbulb text-warning me-2"></i>
                            <p class="mb-0 text-sm">Tip: While crawling, you can minimize this window. We'll notify you when it's complete!</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Crawl Results Section -->
    <div class="row" id="crawl-results-section" style="display: none;">
        <div class="col-12">
            <!-- This will be replaced via OOB swap with the _crawl_results_section.html partial -->
            <div class="card">
                <div class="card-header p-3">
                    <div class="d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center">
                            <i class="fas fa-check-circle text-success me-2"></i>
                            <h6 class="mb-0">Crawl Results</h6>
                        </div>
                        <button class="btn btn-sm btn-outline-primary"
                                hx-on:click="document.getElementById('crawl-results-section').style.display = 'none';">
                            <i class="fas fa-times me-1"></i> Close Results
                        </button>
                    </div>
                </div>
                <div class="card-body p-3">
                    <div id="crawl-results">
                        <p>Results will appear here once the crawl is complete.</p>
                    </div>

                    <div id="crawl-download-links" class="mt-3 d-flex gap-2" style="display: none;">
                        <!-- Download links will be added here -->
                    </div>

                    <div class="page-details" id="page-details-section" style="display: none;">
                        <h6 class="mb-3">Page Details</h6>
                        <div class="table-responsive">
                            <table class="table align-items-center mb-0">
                                <thead>
                                    <tr>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">URL</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Title</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                                    </tr>
                                </thead>
                                <tbody id="page-details-table">
                                    <!-- Page details will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block extra_js %}
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/ws.js' %}"></script>
<script src="{% static 'crawl_website/js/crawl-htmx.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize tooltips
        var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
        var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl)
        })
    });
</script>
{% endblock extra_js %}

================
File: apps/crawl_website/templates/crawl_website/index.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% block title %} Crawl Website {% endblock %}

<!-- Specific Page CSS goes HERE  -->
{% block extrastyle %}
<style>
    /* Specific styles for this page - progress bar styling is now in custom-fixes.css */
    .list-group-item {
        padding: 0.5rem 1rem;
    }
    #visitors-chart-container {
        height: 300px;
        position: relative;
    }
    .timeline-block {
        margin-bottom: 1rem;
    }
    .timeline-step {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 0.75rem;
    }
    .timeline-content {
        flex: 1;
    }

    /* Styling for processing overlay */
    .processing-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }

    .processing-spinner i {
        font-size: 2rem;
    }
</style>
{% endblock extrastyle %}

{% block content %}

    <div class="container-fluid py-4"
         id="crawl-container"
         hx-ext="ws"
         {# ws-connect="/ws/crawl/{{ task_id }}/" -- Remove initial connection attribute #}
         >

        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header pb-0 p-3 d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Active Crawls</h6>
                        <button id="refresh-active-crawls" class="btn btn-sm btn-info">
                            <i class="fas fa-sync-alt"></i> Refresh
                        </button>
                    </div>
                    <div class="card-body p-3">
                        <div id="active-crawls-container">
                            <p class="text-muted">Loading active crawls...</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col-12 col-xl-4">
                <div class="card h-100">
                    <div class="card-header pb-0 p-3">
                        <h6 class="mb-0">Site to crawl</h6>
                    </div>
                    <div class="card-body p-3">
                        <form id="crawl-form"
                              hx-post="{% url 'crawl_website:initiate_crawl' %}"
                              hx-target="#crawl-status-message"
                              hx-swap="innerHTML"
                              hx-indicator="#processing-indicator">
                            {% csrf_token %}

                            <div class="mb-3">
                                <label for="url" class="form-label">URL to crawl
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Specify the base URL where the crawl will begin. Ensure the URL is valid, includes the protocol (http:// or https://), and points to the desired starting page."></i>
                                </label>
                                <input type="url" class="form-control" id="url" name="url" placeholder="https://example.com" required>
                            </div>

                            <!-- Crawl Type Selection -->
                            <div class="mb-3">
                                <label class="form-label">Crawl Method
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Choose between standard link-following crawl or sitemap-based crawl."></i>
                                </label>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="crawl_type" id="crawl_type_standard" value="standard" checked>
                                    <label class="form-check-label" for="crawl_type_standard">
                                        Standard Crawl (Follows links)
                                        <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                           title="The crawler will parse the HTML of each page to extract and follow links (anchor tags). This method is suitable for websites without a sitemap or for broader exploration."></i>
                                    </label>
                                </div>
                                <div class="form-check">
                                    <input class="form-check-input" type="radio" name="crawl_type" id="crawl_type_sitemap" value="sitemap">
                                    <label class="form-check-label" for="crawl_type_sitemap">
                                        Sitemap-Based Crawl
                                        <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                           title="The crawler will fetch and parse the website's sitemap.xml file (if available) to identify pages for crawling. This method is faster and more structured but relies on the sitemap's accuracy and completeness."></i>
                                    </label>
                                </div>
                            </div>

                            <!-- Standard Crawl Options -->
                            <div id="standard-crawl-options">
                            <div class="mb-3">
                                <label for="max-pages" class="form-label">Maximum Pages
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Set an upper limit on the number of pages to crawl. This prevents excessive crawling and resource usage. For example, a value of '7' will stop the crawl after processing 7 pages, regardless of the total number of pages available."></i>
                                </label>
                                    <input type="number" class="form-control" id="max-pages" name="max_pages" value="100" min="1">
                            </div>
                            <div class="mb-3">
                                <label for="max-depth" class="form-label">Maximum Depth
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Define the depth of the crawl: Level 1: Crawl only the starting page. Level 2: Crawl the starting page and all links found on it. Higher levels recursively follow links on each page, exponentially increasing the number of pages crawled."></i>
                                </label>
                                    <input type="number" class="form-control" id="max-depth" name="max_depth" value="3" min="0">
                                </div>
                                <div class="mb-3">
                                    <label for="include-patterns" class="form-label">Include Patterns (Optional)
                                        <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                           title="Use glob patterns to specify which URLs to include in the crawl. For example: 'blog/*' matches all URLs under the 'blog' path. 'docs/*' matches all URLs under the 'docs' path. Patterns are case-sensitive and should align with the website's URL structure."></i>
                                    </label>
                                    <input type="text" class="form-control" id="include-patterns" name="include_patterns" placeholder="e.g., blog/*, docs/*">
                                    <small class="form-text text-muted">Comma-separated glob patterns</small>
                                </div>
                                <div class="mb-3">
                                    <label for="exclude-patterns" class="form-label">Exclude Patterns (Optional)
                                        <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                           title="Use glob patterns to exclude specific URLs from the crawl. For example: 'admin/*' excludes all URLs under the 'admin' path. 'login/*' excludes all URLs under the 'login' path. Patterns are case-sensitive and should be used to avoid unnecessary or restricted pages."></i>
                                    </label>
                                    <input type="text" class="form-control" id="exclude-patterns" name="exclude_patterns" placeholder="e.g., admin/*, login/*">
                                    <small class="form-text text-muted">Comma-separated glob patterns</small>
                                </div>
                            </div>

                            <!-- Sitemap Crawl Options -->
                            <div id="sitemap-crawl-options" style="display: none;">
                                <div class="mb-3">
                                    <label for="max-sitemap-urls" class="form-label">Max Sitemap URLs to Process</label>
                                    <input type="number" class="form-control" id="max-sitemap-urls" name="max_sitemap_urls" value="50" min="1">
                                </div>
                                <div class="mb-3">
                                    <label for="max-sitemap-retriever-pages" class="form-label">Max Sitemap Discovery Pages</label>
                                    <input type="number" class="form-control" id="max-sitemap-retriever-pages" name="max_sitemap_retriever_pages" value="1000" min="1">
                                </div>
                                <div class="mb-3">
                                    <label for="sitemap-requests-per-second" class="form-label">Requests per Second</label>
                                    <input type="number" class="form-control" id="sitemap-requests-per-second" name="sitemap_requests_per_second" value="5.0" step="0.1" min="0.1">
                                </div>
                                <div class="mb-3">
                                    <label for="sitemap-timeout" class="form-label">Timeout (ms)</label>
                                    <input type="number" class="form-control" id="sitemap-timeout" name="sitemap_timeout" value="15000" min="1000">
                                </div>
                            </div>

                            <!-- Common Options -->
                            <div class="mb-3">
                                <label for="output-format" class="form-label">Output Format
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Select the type of content you want to extract from each page."></i>
                                </label>
                                <select class="form-control" id="output-format" name="output_format">
                                    <option value="text" selected>Text</option>
                                    <option value="html">HTML</option>
                                    <option value="metadata">Metadata</option>
                                </select>
                            </div>


                            <div class="mb-3">
                                <label for="css-selector" class="form-label">CSS Selector (Optional)
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Specify a CSS selector to target specific elements on the page for scraping. For example: '.article-content' selects all elements with the class 'article-content'. '#main-content' selects the element with the ID 'main-content'. Leave blank to scrape the entire page. Use standard CSS selector syntax."></i>
                                </label>
                                <input type="text" class="form-control" id="css-selector" name="css-selector" placeholder="e.g., article.content">
                            </div>
                            <div class="mb-3">
                                <label for="wait-for" class="form-label">Wait For Element (Optional)
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Specify a CSS selector for an element the crawler should wait for before starting to scrape. This is useful for handling dynamic content that loads asynchronously (e.g., JavaScript-rendered pages). For example: '#main-content' waits for the element with ID 'main-content' to load before proceeding."></i>
                                </label>
                                <input type="text" class="form-control" id="wait-for" name="wait-for" placeholder="e.g., #main-content">
                            </div>

                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="save-file" name="save-file" checked>
                                <label class="form-check-label" for="save-file">Save result to file
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Save the crawl results to a file for later reference or processing."></i>
                                </label>
                            </div>
                            <div class="mb-3 form-check">
                                <input type="checkbox" class="form-check-input" id="save-as-csv" name="save-as-csv" checked>
                                <label class="form-check-label" for="save-as-csv">Save as CSV
                                    <i class="fas fa-info-circle text-info ms-1" data-bs-toggle="tooltip" data-bs-placement="top"
                                       title="Exports the scraped data to a CSV file, which can be easily imported into tools like Excel, Google Sheets, or data analysis software."></i>
                                </label>
                            </div>

                            <button type="submit" class="btn btn-primary">
                                <span class="indicator-label">Initiate Crawl</span>
                                <span class="indicator-progress" id="processing-indicator" style="display: none;">
                                    Please wait...
                                    <span class="spinner-border spinner-border-sm align-middle ms-2"></span>
                                </span>
                            </button>
                        </form>

                        <div id="screenshot-container" class="mt-3">
                            <!-- Screenshot will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-12 col-xl-4">
                <div class="card h-100">
                    <div class="card-header pb-0 p-3">
                        <h6 class="mb-0">Crawl Progress</h6>
                    </div>
                    <div class="card-body p-3 position-relative">

                        <div id="crawl-status-progress">
                            {% include "crawl_website/partials/_crawl_status_progress.html" %}
                        </div>

                        <div class="text-center mt-3 mb-3" id="cancel-crawl-container" style="display: none;">
                            <button id="cancel-crawl-btn" class="btn btn-danger btn-sm">
                                <i class="fas fa-stop-circle me-1"></i> Stop Crawl
                            </button>
                        </div>

                        <div id="visitors-chart-container">
                            <canvas id="visitors-chart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-12 col-xl-4">
                <div class="card h-100">
                    <div class="card-header pb-0">
                        <h6 class="mb-0">Results</h6>
                    </div>
                    <div class="card-body p-3">

                        <div id="crawl-results">
                            <p>Results will appear here once the crawl is complete.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block extra_js %}
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="{% static 'assets/js/plugins/ws.js' %}"></script>

{# Include SweetAlert2 #}
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

{# No custom WebSocket handler needed - using HTMX's built-in WebSocket support #}

<script>
document.addEventListener('DOMContentLoaded', (event) => {
    console.log("DOM fully loaded and parsed");

    // Define elements once at the top
    const crawlContainer = document.getElementById('crawl-container');
    const crawlForm = document.getElementById('crawl-form');
    const activeCrawlsContainer = document.getElementById('active-crawls-container');
    const refreshActiveCrawlsBtn = document.getElementById('refresh-active-crawls');
    const cancelCrawlContainer = document.getElementById('cancel-crawl-container');
    const cancelCrawlBtn = document.getElementById('cancel-crawl-btn');

    // Current task ID for cancel functionality
    let currentTaskId = null;

    // --- Toggle options based on crawl type --- //
    const standardOptions = document.getElementById('standard-crawl-options');
    const sitemapOptions = document.getElementById('sitemap-crawl-options');
    const crawlTypeRadios = document.querySelectorAll('input[name="crawl_type"]');

    function toggleCrawlOptions() {
        const selectedType = document.querySelector('input[name="crawl_type"]:checked').value;
        if (selectedType === 'sitemap') {
            standardOptions.style.display = 'none';
            sitemapOptions.style.display = 'block';
        } else {
            standardOptions.style.display = 'block';
            sitemapOptions.style.display = 'none';
        }
    }
    if (crawlTypeRadios.length > 0 && standardOptions && sitemapOptions) {
        crawlTypeRadios.forEach(radio => {
            radio.addEventListener('change', toggleCrawlOptions);
        });
        toggleCrawlOptions(); // Initial call
    } else {
         console.warn("Could not find all elements needed for crawl type toggle functionality.");
    }


    // Simple chart for visualizing crawl progress
    let visitorsChart = null;
    let chartData = {
        labels: [],
        values: [],
        startTime: null,
        pagesProcessed: 0
    };

    function initChart() {
        const ctx = document.getElementById('visitors-chart');
        if (!ctx) return;

        visitorsChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: 'Pages Crawled',
                    data: [],
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    fill: false
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Pages Crawled'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)'
                        }
                    }
                }
            }
        });
    }

    // Initialize chart
    initChart();

    // --- Function to fetch active crawls ---
    function fetchActiveCrawls() {
        if (activeCrawlsContainer) {
            activeCrawlsContainer.innerHTML = '<p class="text-muted">Loading active crawls...</p>';

            fetch('{% url "crawl_website:list_active_crawls" %}')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        activeCrawlsContainer.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                        return;
                    }

                    if (!data.tasks || data.tasks.length === 0) {
                        activeCrawlsContainer.innerHTML = '<p class="text-muted">No active crawls found.</p>';
                        return;
                    }

                    // Create a table to display active crawls
                    let html = `
                        <div class="table-responsive">
                            <table class="table align-items-center mb-0">
                                <thead>
                                    <tr>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">URL</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                    `;

                    data.tasks.forEach(task => {
                        const url = task.kwargs.website_url || task.kwargs.url || 'Unknown URL';
                        html += `
                            <tr>
                                <td>
                                    <div class="d-flex px-2 py-1">
                                        <div class="d-flex flex-column justify-content-center">
                                            <h6 class="mb-0 text-sm">${url}</h6>
                                            <p class="text-xs text-secondary mb-0">Task ID: ${task.id}</p>
                                        </div>
                                    </div>
                                </td>
                                <td>
                                    <span class="badge bg-${task.status === 'RUNNING' ? 'info' : 'warning'}">${task.status}</span>
                                </td>
                                <td>
                                    <div class="d-flex gap-2">
                                        <button class="btn btn-sm btn-info connect-task-btn" data-task-id="${task.id}">
                                            <i class="fas fa-plug"></i> Connect
                                        </button>
                                        <button class="btn btn-sm btn-danger cancel-task-btn" data-task-id="${task.id}">
                                            <i class="fas fa-stop-circle"></i> Cancel
                                        </button>
                                    </div>
                                </td>
                            </tr>
                        `;
                    });

                    html += `
                                </tbody>
                            </table>
                        </div>
                    `;

                    activeCrawlsContainer.innerHTML = html;

                    // Add event listeners to cancel buttons
                    document.querySelectorAll('.cancel-task-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const taskId = this.getAttribute('data-task-id');
                            cancelCrawl(taskId);
                        });
                    });

                    // Add event listeners to connect buttons
                    document.querySelectorAll('.connect-task-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const taskId = this.getAttribute('data-task-id');
                            connectToCrawl(taskId);
                        });
                    });
                })
                .catch(error => {
                    console.error('Error fetching active crawls:', error);
                    activeCrawlsContainer.innerHTML = `<div class="alert alert-danger">Error fetching active crawls: ${error.message}</div>`;
                });
        }
    }

    // --- Function to connect to an existing crawl ---
    function connectToCrawl(taskId) {
        if (!taskId) return;

        // Store current task ID
        currentTaskId = taskId;

        // Reset chart data
        chartData.labels = [];
        chartData.values = [];
        chartData.startTime = Date.now();
        chartData.pagesProcessed = 0;

        if (visitorsChart) {
            visitorsChart.data.labels = [];
            visitorsChart.data.datasets[0].data = [];
            visitorsChart.update();
        }

        // Show cancel button
        if (cancelCrawlContainer) {
            cancelCrawlContainer.style.display = 'block';
        }

        // Set up WebSocket connection
        const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
        const wsPath = `${wsScheme}://${window.location.host}/ws/crawl/${taskId}/`;
        console.log(`Connecting to existing crawl: ${wsPath}`);

        // Set the WebSocket connection attribute
        crawlContainer.setAttribute('ws-connect', wsPath);

        // Process the container to connect WebSocket
        htmx.process(crawlContainer);

        // Show notification
        const Toast = Swal.mixin({
            toast: true,
            position: 'top-end',
            showConfirmButton: false,
            timer: 3000,
            timerProgressBar: true
        });
        Toast.fire({
            icon: 'info',
            title: 'Connected to crawl'
        });
    }

    // --- Function to cancel a crawl ---
    function cancelCrawl(taskId) {
        if (!taskId) return;

        // Confirm cancellation
        Swal.fire({
            title: 'Cancel Crawl?',
            text: 'Are you sure you want to cancel this crawl?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, cancel it!',
            cancelButtonText: 'No, keep it running'
        }).then((result) => {
            if (result.isConfirmed) {
                // Send request to cancel the crawl
                fetch(`{% url "crawl_website:cancel_crawl" task_id="TASK_ID" %}`.replace('TASK_ID', taskId), {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.text();
                })
                .then(html => {
                    // Show success message
                    Swal.fire('Cancelled!', 'The crawl has been cancelled.', 'success');

                    // Refresh active crawls list
                    fetchActiveCrawls();
                })
                .catch(error => {
                    console.error('Error cancelling crawl:', error);
                    Swal.fire('Error', `Failed to cancel crawl: ${error.message}`, 'error');
                });
            }
        });
    }

    // --- Event listener for refresh button ---
    if (refreshActiveCrawlsBtn) {
        refreshActiveCrawlsBtn.addEventListener('click', fetchActiveCrawls);
    }

    // --- Event listener for cancel button ---
    if (cancelCrawlBtn) {
        cancelCrawlBtn.addEventListener('click', function() {
            if (currentTaskId) {
                cancelCrawl(currentTaskId);
            }
        });
    }

    // Fetch active crawls on page load
    fetchActiveCrawls();

    // --- Listener for Form Submission (to get Task ID and init WS) ---
    if (crawlForm && crawlContainer) {
        crawlForm.addEventListener('htmx:afterRequest', function(event) {
            console.log('htmx:afterRequest event on crawl-form:', event.detail);
            if (event.detail.successful) {
                const taskId = event.detail.xhr.getResponseHeader('X-Task-ID');
                if (taskId) {
                    console.log("Received Task ID:", taskId);

                    // Store current task ID for cancel functionality
                    currentTaskId = taskId;

                    // Show cancel button
                    if (cancelCrawlContainer) {
                        cancelCrawlContainer.style.display = 'block';
                    }

                    // Reset chart data for new crawl
                    chartData.labels = [];
                    chartData.values = [];
                    chartData.startTime = Date.now();
                    chartData.pagesProcessed = 0;

                    if (visitorsChart) {
                        visitorsChart.data.labels = [];
                        visitorsChart.data.datasets[0].data = [];
                        visitorsChart.update();
                    }

                    // Refresh active crawls list
                    setTimeout(fetchActiveCrawls, 1000);

                    // Set up HTMX WebSocket connection
                    const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
                    const wsPath = `${wsScheme}://${window.location.host}/ws/crawl/${taskId}/`;
                    console.log(`Setting ws-connect attribute on #crawl-container to: ${wsPath}`);
                    crawlContainer.setAttribute('ws-connect', wsPath);

                    // IMPORTANT: Process the container to make HTMX connect the WebSocket
                    htmx.process(crawlContainer);

                    // Show a small notification that the crawl has started
                    const Toast = Swal.mixin({
                        toast: true,
                        position: 'top-end',
                        showConfirmButton: false,
                        timer: 3000,
                        timerProgressBar: true
                    });
                    Toast.fire({
                        icon: 'info',
                        title: 'Crawl started'
                    });
                } else {
                    console.error("X-Task-ID header not found in response.");
                    Swal.fire('Error', 'Could not get Task ID from server to initiate monitoring.', 'error');
                }
            } else {
                console.error("HTMX request failed:", event.detail);
                Swal.fire('Error', `Failed to start crawl: ${event.detail.xhr.statusText || 'Server Error'}`, 'error');
            }
        });
    } else {
        if (!crawlForm) console.error("Could not find crawl form (#crawl-form) to attach listener.");
        if (!crawlContainer) console.error("Could not find crawl container (#crawl-container) for WS processing.");
    }


    // --- Listener for HTMX WebSocket Messages (Attached to the container) ---
    if (crawlContainer) {
        console.log("Adding WebSocket message listener to crawl container");

        // Handle WebSocket messages
        crawlContainer.addEventListener('htmx:wsAfterMessage', function (evt) {
            console.log("htmx:wsAfterMessage received");
            try {
                const data = JSON.parse(evt.detail.message);

                // Handle heartbeat messages to keep connection alive
                if (data && data.type === 'heartbeat') {
                    console.log(`Received heartbeat #${data.count}`);
                    // Heartbeats don't need UI updates, just prevent HTMX from processing them
                    evt.stopImmediatePropagation();
                    return;
                }

                // Check if it's our specific event structure
                if (data && data.type === 'event') {
                    console.log(`Handling event: ${data.event_name}`);

                    // --- Stop HTMX from processing this JSON message ---
                    evt.stopImmediatePropagation();

                    let iconType = 'info';
                    let title = 'Task Update';

                    if (data.event_name === 'crawl_complete') {
                        iconType = 'success';
                        title = 'Crawl Complete!';
                        // Hide cancel button
                        if (cancelCrawlContainer) {
                            cancelCrawlContainer.style.display = 'none';
                        }
                        // Reset current task ID
                        currentTaskId = null;
                        // Refresh active crawls list
                        setTimeout(fetchActiveCrawls, 1000);
                    } else if (data.event_name === 'crawl_error') {
                        iconType = 'error';
                        title = 'Crawl Failed!';
                        // Hide cancel button
                        if (cancelCrawlContainer) {
                            cancelCrawlContainer.style.display = 'none';
                        }
                        // Reset current task ID
                        currentTaskId = null;
                        // Refresh active crawls list
                        setTimeout(fetchActiveCrawls, 1000);
                    } else if (data.event_name === 'crawl_cancelled') {
                        iconType = 'warning';
                        title = 'Crawl Cancelled';
                        // Hide cancel button
                        if (cancelCrawlContainer) {
                            cancelCrawlContainer.style.display = 'none';
                        }
                        // Reset current task ID
                        currentTaskId = null;
                        // Refresh active crawls list
                        setTimeout(fetchActiveCrawls, 1000);
                    }

                    Swal.fire({
                        title: title,
                        text: data.message,
                        icon: iconType,
                        confirmButtonText: 'Ok'
                    });
                }
            } catch (e) {
                // Parsing failed, likely an HTML fragment meant for HTMX OOB swap
                // Update chart if we have a progress update
                if (evt.detail.message.includes('crawl-progress-bar') &&
                    evt.detail.message.includes('Current URL:')) {

                    // Extract progress information
                    const progressMatch = evt.detail.message.match(/progress-bar.*?(\d+)%/);
                    const urlMatch = evt.detail.message.match(/Current URL: <code>(.*?)<\/code>/);
                    const visitedMatch = evt.detail.message.match(/Pages Visited: <span.*?>(\d+)<\/span>/);

                    if (visitedMatch && visitedMatch[1]) {
                        const pagesVisited = parseInt(visitedMatch[1]);

                        // Only update if we have a new page count
                        if (pagesVisited > chartData.pagesProcessed) {
                            chartData.pagesProcessed = pagesVisited;

                            // Update chart
                            if (visitorsChart) {
                                const elapsedSeconds = Math.floor((Date.now() - chartData.startTime) / 1000);
                                visitorsChart.data.labels.push(elapsedSeconds);
                                visitorsChart.data.datasets[0].data.push(pagesVisited);
                                visitorsChart.update();
                            }
                        }
                    }
                }
                // Let HTMX handle the HTML fragment
            }
        });

         // HTMX WebSocket connection event listeners
         crawlContainer.addEventListener('htmx:wsConnecting', function(evt) {
             console.log('HTMX WebSocket connecting...', evt.detail.elt.getAttribute('ws-connect'));
         });

         crawlContainer.addEventListener('htmx:wsOpen', function(evt) {
             console.log('HTMX WebSocket opened.');
             // Show a small notification that connection is established
             const Toast = Swal.mixin({
                 toast: true,
                 position: 'top-end',
                 showConfirmButton: false,
                 timer: 3000,
                 timerProgressBar: true
             });
             Toast.fire({
                 icon: 'success',
                 title: 'Connected to server'
             });
         });

         crawlContainer.addEventListener('htmx:wsClose', function(evt) {
             console.log('HTMX WebSocket closed. Code:', evt.detail.code);

             // Only show a warning if this wasn't a normal closure
             if (evt.detail.code !== 1000 && evt.detail.code !== 1001) {
                 // Attempt to reconnect automatically
                 setTimeout(function() {
                     console.log('Attempting to reconnect WebSocket...');
                     htmx.process(crawlContainer);
                 }, 5000); // Wait 5 seconds before reconnecting

                 Swal.fire({
                     title: 'Connection Lost',
                     text: 'The connection to the server was lost. The crawl may still be running in the background. Attempting to reconnect...',
                     icon: 'warning',
                     confirmButtonText: 'Ok'
                 });
             }
         });

         crawlContainer.addEventListener('htmx:wsError', function(evt) {
             console.error('HTMX WebSocket error!', evt);
             Swal.fire({
                 title: 'WebSocket Error',
                 text: 'Could not connect to the server for real-time updates. Please check the server status and your connection.',
                 icon: 'error'
             });
         });

    } else {
        console.error("Could not find crawl container (#crawl-container) element for WebSocket binding.");
    }

}); // End of DOMContentLoaded

    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl)
    })
</script>
{% endblock extra_js %}

================
File: apps/crawl_website/admin.py
================
from django.contrib import admin

# Register your models here.

================
File: apps/crawl_website/apps.py
================
from django.apps import AppConfig


class CrawlWebsiteConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.crawl_website'

================
File: apps/crawl_website/consumers.py
================
import json
import logging
from channels.generic.websocket import AsyncWebsocketConsumer
from django.template.loader import render_to_string

logger = logging.getLogger(__name__)

class CrawlConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.task_id = self.scope['url_route']['kwargs']['task_id']
        self.group_name = f"crawl_{self.task_id}"

        # Check if task_id is valid (optional, maybe check against a model or cache)
        if not self.task_id or self.task_id == 'initial': # Reject connection if task_id isn't set yet
            logger.warning(f"WebSocket connection rejected: Invalid task_id '{self.task_id}'.")
            await self.close()
            return

        #logger.info(f"WebSocket connecting for crawl task: {self.task_id}")
        # Join room group
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )

        await self.accept()
        #logger.info(f"WebSocket connected and added to group: {self.group_name}")

    async def disconnect(self, close_code):
        logger.info(f"WebSocket disconnecting from group: {self.group_name}")
        # Leave room group
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
        logger.info("WebSocket disconnected.")

    # Receive message from WebSocket (if needed for client->server communication)
    # async def receive(self, text_data):
    #     pass

    # Receive message from room group (sent by Celery task)
    async def crawl_update(self, event):
        """Handles messages sent from the Celery task via channel_layer.group_send."""
        data = event['data']
        update_type = data.get('update_type')
        #logger.debug(f"Received crawl_update for {self.group_name}, type: {update_type}")

        # Special handling for heartbeat messages
        if update_type == 'heartbeat':
            # For heartbeats, just send a minimal JSON message to keep the connection alive
            # No need to render templates or trigger UI updates
            await self.send(text_data=json.dumps({
                'type': 'heartbeat',
                'count': data.get('heartbeat_count', 0)
            }))
            #logger.debug(f"Sent heartbeat #{data.get('heartbeat_count', 0)} to {self.group_name}")
            return

        # Special handling for event messages (like crawl_progress)
        if update_type == 'event' and data.get('event_name') == 'crawl_progress':
            # For crawl_progress events, render HTML updates for the stats cards
            pages_visited = data.get('pages_visited', 0)
            links_found = data.get('links_found', 0)
            current_url = data.get('current_url', '')

            # Create HTML updates for the stats cards
            html = f"""
            <div id="pages-visited-count" hx-swap-oob="true">{pages_visited}</div>
            <div id="links-found-count" hx-swap-oob="true">{links_found}</div>
            <div id="current-page-url" hx-swap-oob="true">{current_url}</div>
            <span id="links-visited-count" hx-swap-oob="true">{pages_visited}</span>
            <div id="current-url-display" hx-swap-oob="true">Current URL: <code>{current_url}</code></div>
            """

            await self.send(text_data=html)
            #logger.debug(f"Sent HTML updates for crawl_progress to {self.group_name}")
            return
        elif update_type == 'event':
            # For other event types, forward the event data directly to the client
            event_data = json.dumps(data)
            await self.send(text_data=event_data)
            logger.debug(f"Forwarded event message to {self.group_name}: {data.get('event_name')}")
            return

        html = ""

        try:
            if update_type == 'progress':
                # Render the status/progress partial
                context = {
                    'status': data.get('status', 'in_progress'),
                    'message': data.get('message', 'Processing...'),
                    'progress': data.get('progress', 0),
                    'links_visited': data.get('links_visited', 0),
                    'current_url': data.get('current_url', 'N/A')
                }
                html = render_to_string('crawl_website/partials/_crawl_status_progress.html', context)
                # Target the outer div for replacement
                target_id = '#crawl-status-progress'
                # Wrap the HTML with OOB swap instruction targeting the specific container
                html = f'<div id="{target_id[1:]}" hx-swap-oob="true">{html}</div>'

            elif update_type == 'completion' or update_type == 'cancelled':
                # Render the results partial
                # Prepare the context with all necessary data
                context = {
                    'status': 'completed' if update_type == 'completion' else 'cancelled',
                    'results': data.get('results', []), # Pass the actual results data
                    'output_format': data.get('output_format', 'text'),
                    # Add file_url, csv_url if saving is implemented and passed from task
                    'file_url': data.get('file_url'),
                    'csv_url': data.get('csv_url'),
                    'message': data.get('message', 'Crawl completed successfully.')
                }

                # Log the results for debugging
                logger.debug(f"Results data for {self.task_id}: {context['results'][:100] if isinstance(context['results'], str) else len(context['results']) if isinstance(context['results'], list) else type(context['results'])}")
                results_html = render_to_string('crawl_website/partials/_crawl_results.html', context)
                # Target the results div for replacement
                target_id_results = '#crawl-results'
                # Also update progress to 100%
                progress_context = {'status': 'completed', 'progress': 100, 'message': 'Completed successfully.'}
                progress_html = render_to_string('crawl_website/partials/_crawl_status_progress.html', progress_context)

                # Update the crawling status title and hide spinner
                status_title = 'Crawl Completed' if update_type == 'completion' else 'Crawl Cancelled'

                # Wrap fragments with OOB swap instructions
                wrapped_results = f'<div id="{target_id_results[1:]}" hx-swap-oob="true">{results_html}</div>'
                wrapped_progress = f'<div id="crawl-status-progress" hx-swap-oob="true">{progress_html}</div>'
                wrapped_title = f'<h6 id="crawling-status-title" hx-swap-oob="true">{status_title}</h6>'
                wrapped_spinner = f'<div id="progress-spinner" class="crawling-spinner me-3" style="display: none;" hx-swap-oob="true"></div>'
                wrapped_results_section = f'<div id="crawl-results-section" style="display: block;" hx-swap-oob="true">{render_to_string("crawl_website/partials/_crawl_results_section.html", context)}</div>'

                # Combine all updates
                html = wrapped_results + wrapped_progress + wrapped_title + wrapped_spinner + wrapped_results_section

                # Additionally, send a structured message for JS listeners (e.g., dialogs, charts)
                event_data = {
                    'type': 'event',
                    'event_name': 'crawl_complete' if update_type == 'completion' else 'crawl_cancelled',
                    'message': progress_context['message'], # Use the completion message
                    'success': update_type == 'completion',
                    # Include URLs only if the task completed successfully
                    'file_url': data.get('file_url') if update_type == 'completion' else None,
                    'csv_url': data.get('csv_url') if update_type == 'completion' else None,
                    'task_id': self.task_id,  # Include the task ID
                    'results': data.get('results')  # Include the results data
                }
                await self.send(text_data=json.dumps(event_data))
                logger.debug(f"Sent JSON event ({update_type}) to {self.group_name}")

            elif update_type == 'failed':
                # Render the results partial with error state
                context = {
                    'status': 'failed',
                    'error_message': data.get('error_message', 'An unknown error occurred.')
                }
                results_html = render_to_string('crawl_website/partials/_crawl_results.html', context)
                # Target the results div for replacement
                target_id_results = '#crawl-results'
                # Also update progress to show failure
                progress_context = {'status': 'failed', 'progress': 0, 'message': context['error_message']}
                progress_html = render_to_string('crawl_website/partials/_crawl_status_progress.html', progress_context)

                # Update the crawling status title and hide spinner
                status_title = 'Crawl Failed'

                # Wrap fragments with OOB swap instructions
                wrapped_results = f'<div id="{target_id_results[1:]}" hx-swap-oob="true">{results_html}</div>'
                wrapped_progress = f'<div id="crawl-status-progress" hx-swap-oob="true">{progress_html}</div>'
                wrapped_title = f'<h6 id="crawling-status-title" hx-swap-oob="true">{status_title}</h6>'
                wrapped_spinner = f'<div id="progress-spinner" class="crawling-spinner me-3" style="display: none;" hx-swap-oob="true"></div>'
                wrapped_results_section = f'<div id="crawl-results-section" style="display: block;" hx-swap-oob="true">{render_to_string("crawl_website/partials/_crawl_results_section.html", context)}</div>'

                # Combine all updates
                html = wrapped_results + wrapped_progress + wrapped_title + wrapped_spinner + wrapped_results_section

                # Additionally, send a structured message for JS listeners
                error_event_data = {
                    'type': 'event',
                    'event_name': 'crawl_error', # Consistent event name
                    'message': context['error_message'], # Use the error message
                    'success': False
                }
                await self.send(text_data=json.dumps(error_event_data))
                logger.debug(f"Sent JSON event (crawl_error) to {self.group_name}")

            else:
                logger.warning(f"Received unknown crawl_update type: {update_type}")
                return

            # Send HTML fragment to WebSocket with OOB swap instruction
            await self.send(text_data=html)
            #logger.debug(f"Sent HTML update (OOB) to {self.group_name} for type {update_type}")

        except Exception as e:
            logger.error(f"Error processing crawl_update for {self.group_name}: {e}", exc_info=True)
            # Optionally send an error message back to the client
            await self.send(text_data=json.dumps({'error': 'Failed to process update.'}))

================
File: apps/crawl_website/export_utils.py
================
"""
Utility functions for exporting crawl results to different formats.
These functions are used by both the web_crawler and sitemap_crawler.
"""
import io
import csv
import json
import logging
from datetime import datetime
from django.core.files.base import ContentFile
from .utils import sanitize_url_for_filename

logger = logging.getLogger(__name__)

def generate_text_content(results):
    """
    Generate text content from crawl results.

    Args:
        results (list): List of result dictionaries from the crawler

    Returns:
        str: Formatted text content
    """
    content_parts = []

    for item in results:
        # Start with the URL
        item_content = [f"URL: {item.get('url', '')}"]

        # Add title if available
        if 'title' in item and item['title']:
            item_content.append(f"Title: {item['title']}")

        # Add text content if available
        if 'text' in item and item['text']:
            item_content.append(f"\nContent:\n{item['text']}")

        # Add HTML content indicator if available
        if 'html' in item and item['html']:
            item_content.append("\nHTML: Available (not shown in text output)")

        # Add metadata if available
        if 'metadata' in item and item['metadata']:
            metadata_count = len(item['metadata']) if isinstance(item['metadata'], dict) else 0
            metadata_str = f"\nMetadata ({metadata_count} tags):\n"
            if isinstance(item['metadata'], dict):
                # Sort metadata keys for consistent output
                for i, (key, value) in enumerate(sorted(item['metadata'].items())):
                    metadata_str += f"  {i+1}. {key}: {value}\n"
            else:
                metadata_str += str(item['metadata'])
            item_content.append(metadata_str)

        # Add links if available
        if 'links' in item and item['links']:
            # Remove duplicate links while preserving order
            unique_links = []
            seen_hrefs = set()

            if isinstance(item['links'], list):
                for link in item['links']:
                    if isinstance(link, dict) and 'href' in link:
                        href = link.get('href', '')
                        if href and href not in seen_hrefs:
                            seen_hrefs.add(href)
                            unique_links.append(link)
                    elif isinstance(link, str) and link not in seen_hrefs:
                        seen_hrefs.add(link)
                        unique_links.append(link)

            links_str = f"\nLinks ({len(unique_links)}):\n"

            if unique_links:
                for i, link in enumerate(unique_links):  # Show all unique links
                    if isinstance(link, dict):
                        link_href = link.get('href', '')
                        link_text = link.get('text', '').strip()
                        if link_text:
                            links_str += f"  {i+1}. {link_href} - {link_text}\n"
                        else:
                            links_str += f"  {i+1}. {link_href}\n"
                    else:
                        links_str += f"  {i+1}. {link}\n"
            else:
                links_str += str(item['links'])
            item_content.append(links_str)

        # Add screenshot indicator if available
        if 'screenshot' in item and item['screenshot']:
            item_content.append("\nScreenshot: Available (not shown in text output)")

        # Join all parts with newlines
        content_parts.append("\n".join(item_content))

    # Join all items with a separator
    return "\n\n" + "="*50 + "\n\n".join(content_parts)

def generate_csv_content(results):
    """
    Generate CSV content from crawl results.

    Args:
        results (list): List of result dictionaries from the crawler

    Returns:
        str: CSV content as a string
    """
    csv_buffer = io.StringIO()
    csv_writer = csv.writer(csv_buffer, dialect='excel', lineterminator='\n', quoting=csv.QUOTE_ALL)

    # Determine which columns to include based on the content in the results
    columns = ['URL', 'Title']
    has_text = any('text' in item for item in results)
    has_html = any('html' in item for item in results)
    has_metadata = any('metadata' in item for item in results)
    has_links = any('links' in item for item in results)
    has_screenshot = any('screenshot' in item for item in results)

    if has_text:
        columns.append('Text')
    if has_html:
        columns.append('HTML')
    if has_metadata:
        columns.append('Metadata')
    if has_links:
        columns.append('Links')
    if has_screenshot:
        columns.append('Screenshot')

    # Write the header row
    csv_writer.writerow(columns)

    # Write each result row
    for item in results:
        url_item = item.get('url', '')
        title_item = item.get('title', '')

        # Prepare the row data
        row_data = [url_item, title_item]

        # Add text content if available and requested
        if has_text:
            if 'text' in item and item['text']:
                # Truncate text to first 500 characters for CSV
                text = item['text'][:500] + '...' if len(item['text']) > 500 else item['text']
                # Replace newlines with spaces for CSV
                text = text.replace('\n', ' ').replace('\r', '')
                row_data.append(text)
            else:
                row_data.append('')

        # Add HTML content if available and requested
        if has_html:
            if 'html' in item and item['html']:
                # Just indicate HTML is available (too large for CSV)
                html_length = len(item['html'])
                row_data.append(f'HTML content available ({html_length} characters)')
            else:
                row_data.append('')

        # Add metadata if available and requested
        if has_metadata:
            if 'metadata' in item and item['metadata']:
                if isinstance(item['metadata'], dict):
                    # Format metadata with each tag on its own line
                    metadata_count = len(item['metadata'])
                    metadata_text = f"{metadata_count} metadata tags found:\n"

                    # Add each metadata tag on its own line
                    for i, (key, value) in enumerate(sorted(item['metadata'].items())):
                        if value:  # Only include non-empty values
                            # Clean the value to avoid CSV formatting issues
                            clean_value = str(value).replace('"', '').replace(',', ' ')
                            # Truncate very long values
                            if len(clean_value) > 100:
                                clean_value = clean_value[:100] + '...'
                            metadata_text += f"{i+1}. {key}: {clean_value}\n"

                    row_data.append(metadata_text)
                else:
                    row_data.append(str(item['metadata']))
            else:
                row_data.append('')

        # Add links if available and requested
        if has_links:
            if 'links' in item and item['links']:
                if isinstance(item['links'], list):
                    # Remove duplicate links while preserving order
                    unique_links = []
                    seen_hrefs = set()

                    for link in item['links']:
                        if isinstance(link, dict) and 'href' in link:
                            href = link.get('href', '')
                            if href and href not in seen_hrefs:
                                seen_hrefs.add(href)
                                unique_links.append(link)
                        elif isinstance(link, str) and link not in seen_hrefs:
                            seen_hrefs.add(link)
                            unique_links.append(link)

                    # Format all unique links for CSV output
                    links_count = len(unique_links)

                    # Create a properly formatted list of all links
                    # Use line breaks (\n) to separate links within the cell
                    links_text = f"{links_count} links found:\n"

                    for i, link in enumerate(unique_links):
                        if isinstance(link, dict) and 'href' in link:
                            # Format each link with its URL and text (if available)
                            link_href = link.get('href', '')
                            link_text = link.get('text', '').strip()

                            # Clean the link text to avoid CSV formatting issues
                            if link_text:
                                # Replace commas and quotes to avoid CSV parsing issues
                                clean_text = link_text.replace('"', '').replace(',', ' ')
                                # Truncate very long text
                                clean_text = clean_text[:50] + '...' if len(clean_text) > 50 else clean_text
                                links_text += f"{i+1}. {link_href} ({clean_text})\n"
                            else:
                                links_text += f"{i+1}. {link_href}\n"
                        elif isinstance(link, str):
                            links_text += f"{i+1}. {link}\n"

                    row_data.append(links_text)
                else:
                    row_data.append(str(item['links']))
            else:
                row_data.append('')

        # Add screenshot indicator if available and requested
        if has_screenshot:
            if 'screenshot' in item and item['screenshot']:
                row_data.append('Screenshot available')
            else:
                row_data.append('')

        # Write the row to the CSV
        csv_writer.writerow(row_data)

    # Get the CSV content
    return csv_buffer.getvalue()

def save_crawl_results(results, url, user_id, output_format, storage, save_as_csv=False):
    """
    Save crawl results to storage.

    Args:
        results (list): List of result dictionaries from the crawler
        url (str): The URL that was crawled
        user_id (int): The user ID
        output_format (str): The output format (text, html, json)
        storage: The storage backend to use
        save_as_csv (bool): Whether to also save as CSV

    Returns:
        tuple: (file_url, csv_url) URLs to the saved files
    """
    file_url = None
    csv_url = None

    try:
        # Determine filename suffix based on output format
        if output_format == 'json':
            file_suffix = 'json'
            # Save the list of result dictionaries directly
            content_to_save = json.dumps(results, indent=4)
        elif output_format == 'html':
            file_suffix = 'html'
            # Combine HTML content
            html_parts = []
            for item in results:
                # Get HTML content from 'html' key
                html_content = item.get('html', '')
                if html_content:
                    # Add URL as a header
                    url_header = f"<h2>URL: {item.get('url', '')}</h2>"
                    html_parts.append(f"{url_header}\n{html_content}")

            # Join all HTML parts with a separator
            content_to_save = '\n<hr>\n'.join(html_parts)
        else:  # Default to text
            file_suffix = 'txt'
            # Generate text content
            content_to_save = generate_text_content(results)

        sanitized_url = sanitize_url_for_filename(url)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')

        filename = f"{user_id}/crawled_websites/{sanitized_url}_{timestamp}.{file_suffix}"
        file_path = storage.save(filename, ContentFile(content_to_save.encode('utf-8')))
        file_url = storage.url(file_path)
        logger.info(f"Output file saved to: {file_path} (format: {file_suffix})")

        # Save as CSV if requested
        if save_as_csv and output_format != 'json':
            try:
                csv_filename = f"{user_id}/crawled_websites/{sanitized_url}_{timestamp}.csv"
                csv_content = generate_csv_content(results)
                csv_path = storage.save(csv_filename, ContentFile(csv_content.encode('utf-8')))
                csv_url = storage.url(csv_path)
                logger.info(f"CSV file saved to: {csv_path}")
            except Exception as csv_save_err:
                logger.error(f"Error saving CSV results: {csv_save_err}", exc_info=True)
    except Exception as primary_save_err:
        logger.error(f"Error saving primary output file: {primary_save_err}", exc_info=True)
        # File saving failed, but task might still be successful
        # file_url remains None

    return file_url, csv_url

================
File: apps/crawl_website/models.py
================
from django.db import models
from django.contrib.auth.models import User
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

class CrawlResult(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    website_url = models.URLField()
    links_visited = models.JSONField(default=dict)
    total_links = models.IntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)

    @classmethod
    def create_with_content(cls, user, website_url, content, links_visited=None, total_links=0):
        """Create a CrawlResult with metadata only."""
        try:
            # Create CrawlResult object with metadata only
            crawl_result = cls.objects.create(
                user=user,
                website_url=website_url,
                links_visited=links_visited or {},
                total_links=total_links
            )

            return crawl_result

        except Exception as e:
            logger.error(f"Error creating CrawlResult: {str(e)}", exc_info=True)
            raise

    def __str__(self):
        return f"Crawl of {self.website_url} by {self.user.username}"

    class Meta:
        ordering = ['-created_at']

================
File: apps/crawl_website/routing.py
================
from django.urls import re_path

from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/crawl/(?P<task_id>[\w-]+)/$', consumers.CrawlConsumer.as_asgi()),
]

================
File: apps/crawl_website/tasks.py
================
import json
import logging
import uuid
import csv
import io
from datetime import datetime
import time
import threading

from celery import shared_task
from celery.contrib.abortable import AbortableTask
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
from django.template.loader import render_to_string
from django.core.files.base import ContentFile
from pydantic import AnyHttpUrl

# Import the export utilities
from .export_utils import generate_text_content, generate_csv_content, save_crawl_results


# Import tools and utilities (adjust paths as necessary)
from apps.agents.tools.crawl_website_tool.crawl_website_tool import CrawlWebsiteTool
from apps.agents.tools.web_crawler_tool.sitemap_crawler import SitemapCrawlerTool, ContentOutputFormat
from apps.agents.tools.web_crawler_tool.web_crawler_tool import WebCrawlerTool, CrawlOutputFormat
from core.storage import SecureFileStorage
from .utils import sanitize_url_for_filename # Import from utils now

logger = logging.getLogger(__name__)

# Initialize storage (if tasks still need direct access)
crawl_storage = SecureFileStorage(private=True, collection='')

# --- Helper Function for Sending WS Updates ---

def send_crawl_update(task_id, update_type, data):
    """Sends an update message to the WebSocket group."""
    try:
        channel_layer = get_channel_layer()
        if not channel_layer:
            logger.warning(f"Cannot send WS update for {task_id}: Channel layer not configured.")
            return

        group_name = f"crawl_{task_id}"
        message = {
            'type': 'crawl_update', # Corresponds to the consumer method name
            'data': {
                'update_type': update_type,
                **data, # Merge the specific data payload
            }
        }
        # # Only log detailed info for non-heartbeat messages to avoid log noise
        # if update_type != 'heartbeat':
        #     logger.debug(f"Sending WS update to group {group_name}: Type={update_type}, DataKeys={list(data.keys())}")
        # else:
        #     # Simplified logging for heartbeats
        #     logger.debug(f"Sending heartbeat to group {group_name}: #{data.get('heartbeat_count', 0)}")

        # Use async_to_sync to call the async channel layer method from sync task
        async_to_sync(channel_layer.group_send)(group_name, message)
    except Exception as e:
        logger.error(f"Error sending WebSocket update for task {task_id}: {e}", exc_info=True)

# --- Celery Tasks ---

# Define a base task class if needed for common logic, otherwise use shared_task directly
# class CrawlBaseTask(AbortableTask):
#     pass # Add common abort/cleanup logic if needed

@shared_task(bind=True, time_limit=1800, soft_time_limit=1620)
def crawl_website_task(self, task_id, website_url, user_id, max_pages=100, max_depth=3,
                     include_patterns=None, exclude_patterns=None, output_format="text",
                     save_file=False, save_as_csv=False): # Default to False
    """Celery task for standard website crawl, sending progress via WebSockets."""
    logger.info(f"Starting standard crawl task {task_id} for {website_url}, user_id={user_id}")

    def progress_reporter(progress, total, message, **kwargs):
        """Callback function to send progress updates via WebSocket."""
        # Ensure progress is between 0 and 100
        percent_complete = min(100, max(0, int((progress / total) * 100) if total > 0 else 0))

        update_data = {
            'status': 'in_progress',
            'message': message,
            'progress': percent_complete,
            'current_step': progress,
            'total_steps': total,
            'current_url': kwargs.get('url', None), # Tool might pass current URL
            'links_visited': progress, # Assuming progress maps to links visited here
        }
        send_crawl_update(task_id, 'progress', update_data)

    try:
        # Send initial update
        progress_reporter(0, max_pages, "Starting crawl", url=website_url)

        # Initialize the tool - use WebCrawlerTool instead of CrawlWebsiteTool
        tool = WebCrawlerTool()

        # Parse output_format if it's a comma-separated string
        output_formats = output_format.split(',') if isinstance(output_format, str) and ',' in output_format else output_format

        # Prepare parameters for the WebCrawlerTool
        # Convert include_patterns and exclude_patterns to the format expected by WebCrawlerTool
        tool_include_patterns = include_patterns if include_patterns else None
        tool_exclude_patterns = exclude_patterns if exclude_patterns else None

        # Create a callback function to send progress updates
        def progress_callback(pages_visited, links_found, current_url):
            # Send a progress update via WebSocket
            send_crawl_update(task_id, 'event', {
                'type': 'event',
                'event_name': 'crawl_progress',
                'pages_visited': pages_visited,
                'links_found': links_found,
                'current_url': current_url
            })

        # Call the WebCrawlerTool with the appropriate parameters
        result_json = tool._run(
            start_url=website_url,
            max_pages=max_pages,
            max_depth=max_depth,
            output_format=output_formats,
            include_patterns=tool_include_patterns,
            exclude_patterns=tool_exclude_patterns,
            stay_within_domain=True,  # Default to staying within the same domain
            device="desktop",  # Default to desktop device
            delay_seconds=1.0,  # Default delay between requests
            batch_size=5,  # Default batch size
            max_retries=3,  # Default max retries
            timeout=60000,  # Default timeout in milliseconds
            stealth=True,  # Default to stealth mode
            progress_callback=progress_callback  # Pass the progress callback
        )

        result = json.loads(result_json)

        if result.get('status') == 'success':
            file_url = None
            csv_url = None
            if save_file:
                # Add file/CSV saving logic here using crawl_storage and sanitize_url_for_filename
                # (Copied and adapted from original view logic)
                # Use the common utility function to save the results
                file_url, csv_url = save_crawl_results(
                    results=result.get('results', []),
                    url=website_url,
                    user_id=user_id,
                    output_format=output_format,
                    storage=crawl_storage,
                    save_as_csv=save_as_csv
                )

                # Log the file URLs
                if file_url:
                    logger.info(f"Output file saved for task {task_id}: {file_url}")
                if csv_url:
                    logger.info(f"CSV file saved for task {task_id}: {csv_url}")

            final_data = {
                'status': 'completed',
                'message': 'Crawl completed successfully.',
                'results': result.get('results'),
                'output_format': output_format,
                'file_url': file_url, # Pass file URLs to consumer
                'csv_url': csv_url
            }
            send_crawl_update(task_id, 'completion', final_data)
            logger.info(f"Completed standard crawl task {task_id} for {website_url}")
        else:
            error_message = result.get('message', 'Unknown error occurred during crawl.')
            final_data = {'status': 'failed', 'message': error_message}
            send_crawl_update(task_id, 'error', final_data)
            logger.error(f"Failed standard crawl task {task_id} for {website_url}: {error_message}")

        return result_json

    except Exception as e:
        error_message = f"Unexpected error in crawl_website_task: {str(e)}"
        logger.error(f"{error_message} (Task ID: {task_id})", exc_info=True)
        final_data = {'status': 'failed', 'message': error_message}
        send_crawl_update(task_id, 'error', final_data)
        # Reraise to mark the task as failed in Celery
        raise


@shared_task(bind=True, time_limit=1200, soft_time_limit=1140) # Use limits from Sitemap tool
def sitemap_crawl_wrapper_task(self, task_id, user_id, url: str,
                               max_sitemap_urls_to_process: int = 50,
                               max_sitemap_retriever_pages: int = 1000,
                               requests_per_second: float = 5.0,
                               output_format: str = 'text', # Default to text string literal
                               timeout: int = 15000,
                               save_file: bool = False, # Add save flags
                               save_as_csv: bool = False):
    """Celery task wrapper for SitemapCrawlerTool, sending progress via WebSockets."""
    logger.info(f"Starting sitemap crawl task {task_id} for {url}, user_id={user_id}")

    # Heartbeat mechanism - runs in a separate thread
    heartbeat_active = True
    heartbeat_interval = 2  # Reduced to 2 seconds for more frequent heartbeats to maintain connection

    def websocket_heartbeat():
        """Send periodic heartbeats to keep WebSocket connection alive"""
        heartbeat_count = 0
        while heartbeat_active:
            try:
                heartbeat_count += 1
                heartbeat_data = {
                    'status': 'in_progress',
                    'message': f"Working... please wait",
                    'progress': -1,  # Special value indicating a heartbeat
                    'is_heartbeat': True,
                    'heartbeat_count': heartbeat_count
                }
                send_crawl_update(task_id, 'heartbeat', heartbeat_data)
                time.sleep(heartbeat_interval)
            except Exception as e:
                logger.warning(f"Heartbeat thread encountered error: {e}")
                # Don't crash the heartbeat thread, try again after interval
                time.sleep(heartbeat_interval)

    # Start heartbeat thread
    heartbeat_thread = threading.Thread(target=websocket_heartbeat, daemon=True)
    heartbeat_thread.start()

    # Flag to track if completion/error was already sent by callback
    final_update_sent = False

    def progress_reporter(progress, total, message, **kwargs):
        """Callback function passed to the tool to send WS updates."""
        nonlocal final_update_sent # Allow modification of outer scope flag
        percent_complete = min(100, max(0, int((progress / total) * 100) if total > 0 else 0))

        # Send progress update for the progress bar
        progress_data = {
            'status': 'in_progress',
            'message': message,
            'progress': percent_complete,
            'current_step': progress,
            'total_steps': total,
            'current_url': kwargs.get('url', None), # Sitemap tool provides current_url
            'links_visited': progress, # Approximation for sitemap processing
            'is_heartbeat': False  # Regular progress update
        }
        send_crawl_update(task_id, 'progress', progress_data)

        # Also send an event update for the stats cards
        event_data = {
            'update_type': 'event',
            'event_name': 'crawl_progress',
            'pages_visited': progress,
            'links_found': kwargs.get('links_count', 0),  # Use links_count if provided, otherwise 0
            'current_url': kwargs.get('url', 'Processing...')
        }
        send_crawl_update(task_id, 'event', event_data)

        # Check for final update

        # Also handle final result from callback if tool provides it here
        if progress == 100 and 'result' in kwargs:
            if final_update_sent:
                logger.warning(f"Final update already sent for task {task_id}, skipping callback completion.")
                return # Avoid sending duplicate completion messages

            final_result_data = kwargs['result']
            # Check if the result indicates success (adjust based on actual tool output structure)
            if final_result_data.get('success', False):
                file_url = None
                csv_url = None

                # --- File Saving Logic ---
                if save_file and final_result_data.get('results'):
                    # Use the common utility function to save the results
                    file_url, csv_url = save_crawl_results(
                        results=final_result_data.get('results', []),
                        url=url,
                        user_id=user_id,
                        output_format=output_format,
                        storage=crawl_storage,
                        save_as_csv=save_as_csv
                    )

                    # Log the file URLs
                    if file_url:
                        logger.info(f"Output file saved for task {task_id}: {file_url}")
                    if csv_url:
                        logger.info(f"CSV file saved for task {task_id}: {csv_url}")

                completion_data = {
                    'status': 'completed',
                    'message': final_result_data.get('message', 'Sitemap crawl completed successfully.'),
                    'results': final_result_data.get('results'), # Send processed results
                    'output_format': output_format,
                    'sitemap_source_url': final_result_data.get('sitemap_source_url'),
                    'total_sitemap_urls_found': final_result_data.get('total_sitemap_urls_found'),
                    'urls_processed': final_result_data.get('urls_processed'),
                    'file_url': file_url, # Pass URL if file was saved
                    'csv_url': csv_url   # Pass URL if CSV was saved
                }
                send_crawl_update(task_id, 'completion', completion_data)
                logger.info(f"Completed sitemap crawl task {task_id} via callback for {url}")
                final_update_sent = True # Mark as sent
            else:
                # Handle potential error reported within final result callback
                error_message = final_result_data.get('message', final_result_data.get('error', 'Sitemap crawl finished with errors.'))
                error_data = {'status': 'failed', 'message': error_message}
                send_crawl_update(task_id, 'error', error_data)
                logger.error(f"Failed sitemap crawl task {task_id} via callback for {url}: {error_message}")
                final_update_sent = True # Mark as sent


    try:
        tool = SitemapCrawlerTool()
        # Run the tool, passing the progress reporter callback
        result_json = tool._run(
            url=AnyHttpUrl(url),
            user_id=user_id,
            max_sitemap_urls_to_process=max_sitemap_urls_to_process,
            max_sitemap_retriever_pages=max_sitemap_retriever_pages,
            requests_per_second=requests_per_second,
            output_format=output_format,
            timeout=timeout,
            progress_callback=progress_reporter, # Pass the callback here
        )

        # Stop heartbeat thread
        heartbeat_active = False
        heartbeat_thread.join(timeout=2.0)  # Wait up to 2 seconds for clean shutdown

        # Note: The final success/error message might have already been sent by the callback.
        logger.debug(f"SitemapCrawlerTool._run call completed for task {task_id}. Final update handled by callback.")

        # Optional: Parse result_json and send update IF callback didn't handle completion/error
        # This is fallback logic in case the callback fails or the tool changes behavior.
        if not final_update_sent:
             try:
                 result = json.loads(result_json)
                 if result.get('success', False):
                     # Save files here as well? This might duplicate effort if callback handles it.
                     # For now, assume callback handles saving and file URLs.
                     logger.warning(f"Callback did not send final update for successful task {task_id}. Sending fallback completion.")
                     completion_data = {
                         'status': 'completed',
                         'message': result.get('message', 'Sitemap crawl completed (fallback).'),
                         'results': result.get('results'),
                         'output_format': output_format,
                         'sitemap_source_url': result.get('sitemap_source_url'),
                         'total_sitemap_urls_found': result.get('total_sitemap_urls_found'),
                         'urls_processed': result.get('urls_processed'),
                         'file_url': None, # Fallback doesn't have file URLs
                         'csv_url': None
                     }
                     send_crawl_update(task_id, 'completion', completion_data)
                 else:
                     logger.warning(f"Callback did not send final update for failed task {task_id}. Sending fallback error.")
                     error_message = result.get('message', 'Sitemap crawl failed (fallback).')
                     error_data = {'status': 'failed', 'message': error_message}
                     send_crawl_update(task_id, 'error', error_data)
             except json.JSONDecodeError:
                 logger.error(f"Fallback: Failed to parse tool result JSON for task {task_id}")
                 error_data = {'status': 'failed', 'message': 'Failed to parse tool results.'}
                 send_crawl_update(task_id, 'error', error_data)
             except Exception as fallback_err:
                 logger.error(f"Fallback: Error processing tool result for task {task_id}: {fallback_err}", exc_info=True)
                 error_data = {'status': 'failed', 'message': 'Internal error processing results.'}
                 send_crawl_update(task_id, 'error', error_data)

        return result_json # Return the original result from the tool

    except Exception as e:
        error_message = f"Unexpected error in sitemap_crawl_wrapper_task: {str(e)}"
        logger.error(f"{error_message} (Task ID: {task_id})", exc_info=True)
        final_data = {'status': 'failed', 'message': error_message}
        send_crawl_update(task_id, 'error', final_data)

        # Stop heartbeat thread
        heartbeat_active = False
        if heartbeat_thread.is_alive():
            heartbeat_thread.join(timeout=2.0)

        # Reraise to mark the task as failed in Celery
        raise

# Ensure tasks are discoverable by Celery
# Add an __init__.py file in the crawl_website app directory if it doesn't exist
# Make sure celery.py imports tasks using app.autodiscover_tasks()

================
File: apps/crawl_website/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/crawl_website/urls.py
================
from django.urls import path
from . import views

app_name = 'crawl_website'

urlpatterns = [
    path('', views.index, name='index'),
    path('crawl/', views.crawl, name='crawl'),
    path('initiate_crawl/', views.initiate_crawl, name='initiate_crawl'),
    path('get_crawl_progress/', views.get_crawl_progress, name='get_crawl_progress'),
    path('get_crawl_result/<str:task_id>/', views.get_crawl_result, name='get_crawl_result'),
    path('get_screenshot/', views.get_screenshot, name='get_screenshot'),
    path('cancel_crawl/<str:task_id>/', views.cancel_crawl, name='cancel_crawl'),
    path('active_crawls/', views.list_active_crawls, name='list_active_crawls'),
]

================
File: apps/crawl_website/utils.py
================
import re
from urllib.parse import urlparse

def sanitize_url_for_filename(url):
    """Convert URL to a safe filename component."""
    # Parse the URL to extract domain
    parsed = urlparse(url)
    domain = parsed.netloc
    
    # Remove www prefix if present
    if domain.startswith('www.'):
        domain = domain[4:]
        
    # Remove non-alphanumeric characters and replace with underscores
    domain = re.sub(r'[^a-zA-Z0-9]', '_', domain)
    
    # Limit length to prevent very long filenames
    if len(domain) > 50:
        domain = domain[:50]
        
    return domain

================
File: apps/crawl_website/views_updated.py
================
import json
import logging
import os
import uuid
from datetime import datetime
from urllib.parse import urlparse

from django.conf import settings
from django.contrib.auth.decorators import login_required
from django.core.exceptions import PermissionDenied
from django.http import JsonResponse, HttpResponse
from django.shortcuts import render, get_object_or_404, redirect
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_POST

from apps.crawl_website.models import CrawlResult
from apps.crawl_website.tasks import crawl_website_task
from apps.organizations.models import Organization
from apps.organizations.utils import get_user_organizations

logger = logging.getLogger(__name__)

@login_required
def index(request):
    """
    Display the crawl website interface.
    """
    # Get the user's organizations
    organizations = get_user_organizations(request.user)
    
    # Get the crawl results for the user
    crawl_results = CrawlResult.objects.filter(user=request.user).order_by('-created_at')
    
    # Prepare the context
    context = {
        'organizations': organizations,
        'crawl_results': crawl_results,
    }
    
    return render(request, 'crawl_website/index.html', context)

@login_required
def crawl_result_detail(request, result_id):
    """
    Display the details of a crawl result.
    """
    # Get the crawl result
    crawl_result = get_object_or_404(CrawlResult, id=result_id, user=request.user)
    
    # Prepare the context
    context = {
        'crawl_result': crawl_result,
    }
    
    return render(request, 'crawl_website/result_detail.html', context)

@login_required
def crawl_result_delete(request, result_id):
    """
    Delete a crawl result.
    """
    # Get the crawl result
    crawl_result = get_object_or_404(CrawlResult, id=result_id, user=request.user)
    
    # Delete the crawl result
    crawl_result.delete()
    
    # Redirect to the crawl website index
    return redirect('crawl_website:index')

@login_required
def crawl_website(request):
    """
    Crawl a website and save the results.
    """
    if request.method == 'POST':
        try:
            # Get the form data
            url = request.POST.get('url')
            max_pages = int(request.POST.get('max-pages', 10))
            max_depth = int(request.POST.get('max-depth', 2))
            include_patterns = request.POST.get('include-patterns')
            exclude_patterns = request.POST.get('exclude-patterns')
            save_file = 'save-file' in request.POST
            save_as_csv = 'save-as-csv' in request.POST
            
            # Get the output format
            output_format = []
            if 'output-text' in request.POST:
                output_format.append('text')
            if 'output-html' in request.POST:
                output_format.append('html')
            if 'output-metadata' in request.POST:
                output_format.append('metadata')
            if 'output-links' in request.POST:
                output_format.append('links')
            if 'output-screenshot' in request.POST:
                output_format.append('screenshot')
            
            # If no output format is selected, default to text
            if not output_format:
                output_format = ['text']
            
            # Convert output_format to comma-separated string
            output_format = ','.join(output_format)
            
            # Validate the URL
            if not url:
                return JsonResponse({'error': 'URL is required'}, status=400)
            
            # Create a task ID
            task_id = str(uuid.uuid4())
            
            # Create a crawl result
            crawl_result = CrawlResult.objects.create(
                user=request.user,
                url=url,
                task_id=task_id,
                status='pending',
                max_pages=max_pages,
                max_depth=max_depth,
                include_patterns=include_patterns,
                exclude_patterns=exclude_patterns,
                output_format=output_format,
            )
            
            # Start the crawl task
            crawl_website_task.delay(
                task_id=task_id,
                website_url=url,
                user_id=request.user.id,
                max_pages=max_pages,
                max_depth=max_depth,
                include_patterns=include_patterns,
                exclude_patterns=exclude_patterns,
                output_format=output_format,
                save_file=save_file,
                save_as_csv=save_as_csv
            )
            
            # Return the task ID
            return JsonResponse({'task_id': task_id})
        
        except Exception as e:
            logger.error(f"An error occurred: {e}", exc_info=True)
            return JsonResponse({'error': str(e)}, status=500)
    
    # If not a POST request, redirect to the index
    return redirect('crawl_website:index')

@login_required
def get_task_status(request, task_id):
    """
    Get the status of a crawl task.
    """
    try:
        # Get the crawl result
        crawl_result = get_object_or_404(CrawlResult, task_id=task_id, user=request.user)
        
        # Return the status
        return JsonResponse({
            'status': crawl_result.status,
            'progress': crawl_result.progress,
            'result_id': str(crawl_result.id) if crawl_result.status == 'completed' else None,
            'error': crawl_result.error,
        })
    
    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_active_tasks(request):
    """
    Get the active crawl tasks for the user.
    """
    try:
        # Get the active crawl results
        active_results = CrawlResult.objects.filter(
            user=request.user,
            status__in=['pending', 'running']
        ).order_by('-created_at')
        
        # Prepare the response
        tasks = []
        for result in active_results:
            tasks.append({
                'task_id': result.task_id,
                'url': result.url,
                'status': result.status,
                'progress': result.progress,
                'created_at': result.created_at.isoformat(),
            })
        
        # Return the tasks
        return JsonResponse({'tasks': tasks})
    
    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def cancel_task(request, task_id):
    """
    Cancel a crawl task.
    """
    try:
        # Get the crawl result
        crawl_result = get_object_or_404(CrawlResult, task_id=task_id, user=request.user)
        
        # Update the status
        crawl_result.status = 'cancelled'
        crawl_result.save()
        
        # Return success
        return JsonResponse({'success': True})
    
    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def download_result(request, result_id, format):
    """
    Download the crawl result in the specified format.
    """
    try:
        # Get the crawl result
        crawl_result = get_object_or_404(CrawlResult, id=result_id, user=request.user)
        
        # Check if the result has the requested format
        if format not in crawl_result.output_format.split(','):
            return HttpResponse(f"Format '{format}' not available for this result", status=400)
        
        # Get the result data
        result_data = crawl_result.get_result_data()
        
        # Prepare the response based on the format
        if format == 'text':
            response = HttpResponse(result_data.get('text', ''), content_type='text/plain')
            response['Content-Disposition'] = f'attachment; filename="{crawl_result.url_domain}_{result_id}.txt"'
        elif format == 'html':
            response = HttpResponse(result_data.get('html', ''), content_type='text/html')
            response['Content-Disposition'] = f'attachment; filename="{crawl_result.url_domain}_{result_id}.html"'
        elif format == 'metadata':
            response = JsonResponse(result_data.get('metadata', {}))
            response['Content-Disposition'] = f'attachment; filename="{crawl_result.url_domain}_{result_id}_metadata.json"'
        elif format == 'links':
            response = JsonResponse(result_data.get('links', []), safe=False)
            response['Content-Disposition'] = f'attachment; filename="{crawl_result.url_domain}_{result_id}_links.json"'
        else:
            return HttpResponse(f"Format '{format}' not supported for download", status=400)
        
        return response
    
    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return HttpResponse(str(e), status=500)

@csrf_exempt
@login_required
def get_screenshot(request):
    logger.debug("get_screenshot function called")
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            url = data.get('url')
            logger.debug(f"Received URL: {url}")

            if not url:
                return JsonResponse({'error': 'URL is required'}, status=400)

            # Import the screenshot tool
            from apps.agents.tools.screenshot_tool.screenshot_tool import screenshot_tool
            
            # Call the screenshot tool
            result = screenshot_tool.run(url=url)
            if 'error' in result:
                logger.error(f"Failed to get screenshot: {result['error']}")
                return JsonResponse({'error': result['error']}, status=500)

            logger.debug(f"Screenshot saved: {result['screenshot_url']}")
            return JsonResponse({'screenshot_url': result['screenshot_url']})
        except Exception as e:
            logger.error(f"An error occurred: {e}", exc_info=True)
            return JsonResponse({'error': str(e)}, status=500)

    return JsonResponse({'error': 'Invalid request method'}, status=405)

================
File: apps/crawl_website/views.py
================
import json
import logging
import os
import time
import re
import uuid
from django.shortcuts import render
from django.http import JsonResponse, HttpResponse
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from celery.result import AsyncResult
from celery.contrib.abortable import AbortableAsyncResult
from core.storage import SecureFileStorage
from urllib.parse import urlparse
from django.core.files.base import ContentFile
from .tasks import crawl_website_task, sitemap_crawl_wrapper_task
from celery import current_app
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

logger = logging.getLogger(__name__)

# Initialize the storage object
crawl_storage = SecureFileStorage(private=True, collection='')

@login_required
def index(request):
    logger.debug("Rendering index page for crawl_website")
    context = {
        'page_title': 'Crawl Website',
        'task_id': 'initial'
    }
    return render(request, 'crawl_website/index.html', context)

@login_required
def crawl(request):
    #logger.debug("Rendering alternative crawl page with HTMX UI")
    context = {
        'page_title': 'Website Crawler',
        'task_id': 'initial'
    }
    return render(request, 'crawl_website/crawl.html', context)

@csrf_exempt
@login_required
def initiate_crawl(request):
    if request.method == 'POST':
        task_id = None # Initialize task_id
        try:
            # Read data from request.POST (form submission) instead of request.body (JSON)
            url = request.POST.get('url')
            crawl_type = request.POST.get('crawl_type', 'standard')

            # Handle multiple output formats (checkboxes)
            output_formats = request.POST.getlist('output_format')
            if not output_formats:
                output_formats = ['text']  # Default to text if nothing selected

            # If 'full' is selected, include all formats
            if 'full' in output_formats:
                output_format = 'text,html,links,metadata,screenshot'
            else:
                # Join selected formats with commas
                output_format = ','.join(output_formats)

                # Always include text if not already included
                if 'text' not in output_formats and 'full' not in output_formats:
                    output_format = 'text,' + output_format

            save_file = 'save-file' in request.POST
            save_as_csv = 'save-as-csv' in request.POST

            if not url:
                return HttpResponse('<div class="alert alert-danger">URL is required</div>', status=400)

            task_id = uuid.uuid4().hex

            if crawl_type == 'sitemap':
                max_sitemap_urls = int(request.POST.get('max_sitemap_urls', 50))
                max_retriever_pages = int(request.POST.get('max_sitemap_retriever_pages', 1000))
                req_per_sec = float(request.POST.get('sitemap_requests_per_second', 5.0))
                timeout = int(request.POST.get('sitemap_timeout', 15000))

                sitemap_crawl_wrapper_task.delay(
                    task_id=task_id,
                    user_id=request.user.id,
                    url=url,
                    max_sitemap_urls_to_process=max_sitemap_urls,
                    max_sitemap_retriever_pages=max_retriever_pages,
                    requests_per_second=req_per_sec,
                    output_format=output_format,
                    timeout=timeout,
                    save_file=save_file,
                    save_as_csv=save_as_csv
                )

            else: # Default to standard crawl
                max_pages = int(request.POST.get('max_pages', 100))
                max_depth = int(request.POST.get('max_depth', 3))
                include_patterns_str = request.POST.get('include_patterns')
                exclude_patterns_str = request.POST.get('exclude_patterns')

                include_patterns = [p.strip() for p in include_patterns_str.split(',') if p.strip()] if include_patterns_str else None
                exclude_patterns = [p.strip() for p in exclude_patterns_str.split(',') if p.strip()] if exclude_patterns_str else None

                crawl_website_task.delay(
                    task_id=task_id,
                    website_url=url,
                    user_id=request.user.id,
                    max_pages=max_pages,
                    max_depth=max_depth,
                    include_patterns=include_patterns,
                    exclude_patterns=exclude_patterns,
                    output_format=output_format,
                    save_file=save_file,
                    save_as_csv=save_as_csv
                )
                logger.info(f"Launched standard crawl task {task_id} for {url}")

            # Return success response with task_id in header for JS
            response = HttpResponse(
                '<div id="crawl-status-message" hx-swap-oob="true"><div class="alert alert-info">Crawl initiated...</div></div>',
                status=200
            )
            response['X-Task-ID'] = task_id
            return response

        # Removed JSONDecodeError as we are not parsing JSON anymore
        except ValueError as e:
             logger.warning(f"Value error during crawl initiation for task_id={task_id}: {e}")
             return HttpResponse(f'<div class="alert alert-danger">Invalid parameter value: {e}</div>', status=400)
        except Exception as e:
            logger.error(f"Error initiating crawl task_id={task_id}: {e}", exc_info=True)
            return HttpResponse(f'<div class="alert alert-danger">Error initiating crawl: {e}</div>', status=500)

    return HttpResponse('<div class="alert alert-danger">Invalid request method</div>', status=405)

@csrf_exempt
@login_required
def cancel_crawl(request, task_id):
    """Cancel a running crawl task."""
    if request.method != 'POST':
        return HttpResponse('<div class="alert alert-danger">Invalid request method</div>', status=405)

    try:
        # Get the task
        result = AbortableAsyncResult(task_id)

        # Check if task exists and is not already done
        if not result.state or result.state in ['SUCCESS', 'FAILURE', 'REVOKED']:
            return HttpResponse(
                '<div class="alert alert-warning">Task is not running or does not exist</div>',
                status=404
            )

        # Revoke and terminate the task
        result.revoke(terminate=True)

        # Send a cancellation message via WebSocket
        channel_layer = get_channel_layer()
        if channel_layer:
            group_name = f"crawl_{task_id}"
            message = {
                'type': 'crawl_update',
                'data': {
                    'update_type': 'cancelled',
                    'status': 'cancelled',
                    'message': 'Crawl was cancelled by user.'
                }
            }
            async_to_sync(channel_layer.group_send)(group_name, message)

        return HttpResponse(
            '<div class="alert alert-success">Crawl task cancelled successfully</div>',
            status=200
        )
    except Exception as e:
        logger.error(f"Error cancelling crawl task {task_id}: {e}", exc_info=True)
        return HttpResponse(
            f'<div class="alert alert-danger">Error cancelling task: {str(e)}</div>',
            status=500
        )

@login_required
def list_active_crawls(request):
    """List active crawl tasks for the current user."""
    try:
        # Get all active tasks from Celery
        i = current_app.control.inspect()
        active_tasks = i.active() or {}
        scheduled_tasks = i.scheduled() or {}
        reserved_tasks = i.reserved() or {}

        # Combine all tasks
        all_tasks = []

        # Process active tasks
        for worker, tasks in active_tasks.items():
            for task in tasks:
                if task['name'] in ['apps.crawl_website.tasks.crawl_website_task', 'apps.crawl_website.tasks.sitemap_crawl_wrapper_task']:
                    # Extract task info
                    task_info = {
                        'id': task['id'],
                        'name': task['name'].split('.')[-1],
                        'status': 'RUNNING',
                        'worker': worker,
                        'started': task.get('time_start', 'Unknown'),
                        'args': task.get('args', []),
                        'kwargs': task.get('kwargs', {})
                    }

                    # Check if this task belongs to the current user
                    kwargs = task.get('kwargs', {})
                    if kwargs.get('user_id') == request.user.id:
                        all_tasks.append(task_info)

        # Process scheduled and reserved tasks similarly
        for worker, tasks in scheduled_tasks.items():
            for task in tasks:
                task_info = task['request']
                if task_info['name'] in ['apps.crawl_website.tasks.crawl_website_task', 'apps.crawl_website.tasks.sitemap_crawl_wrapper_task']:
                    if task_info.get('kwargs', {}).get('user_id') == request.user.id:
                        all_tasks.append({
                            'id': task_info['id'],
                            'name': task_info['name'].split('.')[-1],
                            'status': 'SCHEDULED',
                            'worker': worker,
                            'args': task_info.get('args', []),
                            'kwargs': task_info.get('kwargs', {})
                        })

        for worker, tasks in reserved_tasks.items():
            for task in tasks:
                if task['name'] in ['apps.crawl_website.tasks.crawl_website_task', 'apps.crawl_website.tasks.sitemap_crawl_wrapper_task']:
                    if task.get('kwargs', {}).get('user_id') == request.user.id:
                        all_tasks.append({
                            'id': task['id'],
                            'name': task['name'].split('.')[-1],
                            'status': 'RESERVED',
                            'worker': worker,
                            'args': task.get('args', []),
                            'kwargs': task.get('kwargs', {})
                        })

        # Render the template with the tasks
        return render(request, 'crawl_website/partials/_active_crawls.html', {'tasks': all_tasks})
    except Exception as e:
        logger.error(f"Error listing active crawls: {e}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def get_crawl_progress(request):
    """Get the progress of a crawl task."""
    task_id = request.GET.get('task_id')
    if not task_id:
        return JsonResponse({'error': 'Task ID is required'}, status=400)

    try:
        task = AsyncResult(task_id)

        if task.ready():
            if task.successful():
                # Parse the JSON string result
                result = json.loads(task.result)

                if result.get('status') == 'error':
                    return JsonResponse({
                        'status': 'failed',
                        'error': result.get('message', 'Unknown error occurred')
                    })

                return JsonResponse({
                    'status': 'completed',
                    'result': result,
                    'total_pages': result.get('total_pages', 0),
                    'file_url': result.get('file_url'),
                    'csv_url': result.get('csv_url'),
                    'crawled_urls': result.get('crawled_urls', [])
                })
            else:
                return JsonResponse({
                    'status': 'failed',
                    'error': str(task.result)
                })
        else:
            # Return current progress from task meta
            info = task.info or {}  # Handle None case
            return JsonResponse({
                'status': 'in_progress',
                'current': info.get('current', 0) if isinstance(info, dict) else 0,
                'total': info.get('total', 1) if isinstance(info, dict) else 1,
                'status_message': info.get('status', 'Processing...') if isinstance(info, dict) else str(info),
                'crawled_urls': info.get('crawled_urls', []) if isinstance(info, dict) else []
            })

    except Exception as e:
        logger.error(f"Error checking progress: {str(e)}", exc_info=True)
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@csrf_exempt
@login_required
def get_crawl_result(request, task_id):
    try:
        result = AsyncResult(task_id)
        if result.state == 'SUCCESS':
            # Parse the JSON string result
            task_result = json.loads(result.result)

            if task_result.get('status') == 'error':
                return JsonResponse({
                    'state': 'FAILURE',
                    'error': task_result.get('message', 'Unknown error occurred')
                })

            # The file should already be saved by the Celery task, just return the result
            file_url = task_result.get('file_url')
            csv_url = task_result.get('csv_url')

            return JsonResponse({
                'state': 'SUCCESS',
                'website_url': task_result.get('website_url'),
                'result': task_result,
                'total_pages': task_result.get('total_pages', 0),
                'file_url': file_url,
                'csv_url': csv_url
            })
        else:
            return JsonResponse({
                'state': result.state,
                'status': 'Task not completed yet'
            }, status=202)
    except Exception as e:
        logger.error(f"An error occurred: {e}", exc_info=True)
        return JsonResponse({'error': str(e)}, status=500)

@csrf_exempt
@login_required
def get_screenshot(request):
    logger.debug("get_screenshot function called")
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            url = data.get('url')
            logger.debug(f"Received URL: {url}")

            if not url:
                return JsonResponse({'error': 'URL is required'}, status=400)

            # Import the screenshot tool
            from apps.agents.tools.screenshot_tool.screenshot_tool import screenshot_tool

            # Call the screenshot tool
            result = screenshot_tool.run(url=url)
            if 'error' in result:
                logger.error(f"Failed to get screenshot: {result['error']}")
                return JsonResponse({'error': result['error']}, status=500)

            logger.debug(f"Screenshot saved: {result['screenshot_url']}")
            return JsonResponse({'screenshot_url': result['screenshot_url']})
        except Exception as e:
            logger.error(f"An error occurred: {e}", exc_info=True)
            return JsonResponse({'error': str(e)}, status=500)

    return JsonResponse({'error': 'Invalid request method'}, status=405)

================
File: apps/file_manager/templates/file_manager/file-manager.html
================
<!-- Add file header -->
<!--
  File Manager Template
  Purpose: Main interface for file management system
  Features: File browsing, upload, download, preview, and deletion
  Dependencies: Bootstrap, FontAwesome, SweetAlert
-->

{% extends "layouts/base.html" %}
{% load static file_extension info_value %}

{% block extrastyle %}
<style>
  ul li {
    list-style-type: none;
  }
  .dot-separator {
    height: 2px;
    width: 2px;
    background: #000;
    border-radius: 50%;
  }
  .actions span {
    cursor: pointer;
  }
  .modal {
    z-index: 99999 !important;
  }
  .folder-content a {
    text-decoration: none;
    color: inherit;
  }
  .folder-item.active > .folder-content {
    font-weight: bold;
  }
  .folder-item .fa-chevron-down {
    transition: transform 0.3s;
  }
  .folder-item.collapsed > .folder-content .fa-chevron-down {
    transform: rotate(-90deg);
  }
  /* Add these new styles */
  .file-manager__directory-tree {
    max-height: 300px; /* Default for mobile */
  }
  .file-manager__folder-item {
    margin-bottom: 5px;
  }
  .file-manager__folder-content {
    padding: 0.5rem;
    border-radius: 0.25rem;
    transition: background-color 0.3s;
  }
  .file-manager__folder-content:hover {
    background-color: #f8f9fa;
  }
  .folder-content a {
    max-width: 180px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-size: 0.9rem;
  }
  .folder-item .fa-chevron-down,
  .folder-item .fa-folder {
    font-size: 0.9rem;
  }
  .folder-contents {
    display: none;
  }
  .folder-item.active > .folder-contents {
    display: block;
  }
  @media (min-width: 768px) {
    .file-manager__directory-tree {
      max-height: 600px;
    }
  }
</style>
{% endblock extrastyle %}

{% block content %}

<div class="container-fluid py-4 px-5">
    <div class="row">
      <div class="col-lg-3 border py-2">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb">
            {% for breadcrumb in breadcrumbs %}
              {% if forloop.last %}
                <li class="breadcrumb-item active" aria-current="page">{{ breadcrumb.name }}</li>
              {% else %}
                <li class="breadcrumb-item"><a href="{{ breadcrumb.url }}">{{ breadcrumb.name }}</a></li>
              {% endif %}
            {% endfor %}
          </ol>
        </nav>
        <ul class="list-unstyled" id="directory-tree">
          {% include 'includes/subdirectories.html' with directory=directory %}
        </ul>
      </div>
      <div class="col-lg-9 border py-2">
        <div class="d-flex justify-content-start mb-3">
          <label for="fileInput">
            <i class="fas fa-upload text-primary fs-3"></i>
          </label>
          <form method="post" 
               action="{% url 'file_manager:upload' %}" 
               id="upload-file" 
               enctype="multipart/form-data"
               onsubmit="event.preventDefault(); submitForm()">
            {% csrf_token %}
            <input type="hidden" name="directory" value="{{ current_path }}">
            <input id="fileInput" 
                   class="d-none" 
                   type="file" 
                   name="file" 
                   onchange="submitForm()"
                   required>
          </form>
        </div>
        {% if contents %}
          {{contents|length|json_script:"contents-count"}}
          <div class="table-responsive">
            <table class="table">
              <thead>
                <tr>
                  <th scope="col">Name</th>
                  <th scope="col">Size</th>
                  <th scope="col">Type</th>
                  <th scope="col">Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for item in contents %}
                <tr>
                  <td>
                    {% if item.type == 'directory' %}
                      <i class="fas fa-folder text-warning me-2"></i>
                      <a href="{% url 'file_manager:browse' path=item.path %}">{{ item.name }}</a>
                    {% else %}
                      <i class="fas fa-file text-primary me-2"></i>
                      {{ item.name }}
                    {% endif %}
                  </td>
                  <td>
                    {% if item.type == 'file' %}
                      {{ item.size|filesizeformat }}
                    {% else %}
                      -
                    {% endif %}
                  </td>
                  <td>
                    {% if item.type == 'directory' %}
                      Directory
                    {% else %}
                      {{ item.extension|upper }}
                    {% endif %}
                  </td>
                  <td>
                    <div class="d-flex align-items-center actions">
                      {% if item.type == 'file' %}
                        <span 
                          data-bs-toggle="modal" 
                          data-bs-target="#info-{{forloop.counter}}"
                          role="button"
                          aria-label="View file information">
                          <i title="Info" class="fas fa-info-circle text-success"></i>
                        </span>
                        <div class="dot-separator mx-2"></div>
                        <span data-bs-toggle="modal" data-bs-target="#file-{{forloop.counter}}">
                          <i title="View" class="fas fa-eye text-primary"></i>
                        </span>
                      {% endif %}
                      <div class="dot-separator mx-2"></div>
                      <span>
                        {% if item.type == 'directory' %}
                            <a href="{% url 'file_manager:download' file_path=item.path|cut:'/'|add:'/'|urlencode %}">
                                <i title="Download" class="fas fa-download text-info"></i>
                            </a>
                        {% else %}
                            <a href="{% url 'file_manager:download' file_path=item.path|urlencode %}">
                                <i title="Download" class="fas fa-download text-info"></i>
                            </a>
                        {% endif %}
                      </span>
                      <div class="dot-separator mx-2"></div>
                      <span>
                        <i title="Delete" class="fas fa-trash text-danger" onclick="deleteItem('{{ item.path|urlencode|escapejs }}')"></i>
                      </span>
                    </div>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        {% else %}
          <p>No files or directories in this folder</p>
        {% endif %}
      </div>
    </div>
  </div>

  {% for item in contents %}
    {% if item.type == 'file' %}
      <!-- View Modal -->
      <div class="modal fade" id="file-{{forloop.counter}}" data-bs-backdrop="static" data-bs-keyboard="false"
        tabindex="-1" aria-labelledby="staticBackdropLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered modal-xl">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="staticBackdropLabel">{{ item.name }}</h1>
              <div class="ms-auto d-flex align-items-center gap-3">
                {% if item.type == 'directory' %}
                    <a href="{% url 'file_manager:download' file_path=item.path|cut:'/'|add:'/'|urlencode %}">
                        <i title="Download" class="fas fa-download text-success fs-4"></i>
                    </a>
                {% else %}
                    <a href="{% url 'file_manager:download' file_path=item.path|urlencode %}">
                        <i title="Download" class="fas fa-download text-success fs-4"></i>
                    </a>
                {% endif %}
                <div role="button" id="modal-close-btn-{{forloop.counter}}" data-bs-dismiss="modal" aria-label="Close">
                  <i class="fas fa-times fs-5"></i>
                </div>
              </div>
            </div>
            <div class="modal-body">
              {% if item.extension in "jpg,jpeg,png,gif" %}
                <img height="700px" class="w-100" src="{% url 'file_manager:preview' file_path=item.path %}" alt="{{ item.name }}">
              {% elif item.extension in "mp4,webm,ogg" %}
                <video class="w-100" height="700" controls>
                  <source src="{% url 'file_manager:preview' file_path=item.path %}" type="video/{{ item.extension }}">
                </video>
              {% elif item.extension in "txt,log,md,json,xml,yaml,yml,ini,conf" %}
                <div class="bg-dark text-light p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6 class="m-0">Text Preview (first 50 lines)</h6>
                        <a href="{% url 'file_manager:download' file_path=item.path %}" class="btn btn-primary btn-sm">
                            <i class="fas fa-download"></i> Download Full File
                        </a>
                    </div>
                    <iframe src="{% url 'file_manager:preview' file_path=item.path %}" 
                            width="100%" 
                            height="500px" 
                            style="border:none; background: white;"></iframe>
                </div>
              {% elif item.extension in "pdf" %}
                <div class="w-100">
                    <iframe src="{% url 'file_manager:preview' file_path=item.path %}" 
                            width="100%" 
                            height="700px"></iframe>
                </div>
              {% elif item.extension == "csv" %}
                <div class="bg-dark text-light p-3">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6 class="m-0">CSV Preview (first 10 rows)</h6>
                        <a href="{% url 'file_manager:download' file_path=item.path %}" class="btn btn-primary btn-sm">
                            <i class="fas fa-download"></i> Download Full CSV
                        </a>
                    </div>
                    <pre class="mt-3" style="max-height: 600px; overflow-y: auto;">{{ item.csv_text }}</pre>
                </div>
              {% else %}
                <p>Preview not available for this file type.</p>
              {% endif %}
            </div>
          </div>
        </div>
      </div>
    {% endif %}
    <!-- Delete Modal -->
    <div class="modal fade" id="delete-{{forloop.counter}}" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h1 class="modal-title fs-5" id="exampleModalLabel">Delete {% if item.type == 'directory' %}Directory{% else %}File{% endif %}</h1>
          </div>
          <div class="modal-body">
            Are you sure you want to delete {{item.name}}{% if item.type == 'directory' %} and all its contents{% endif %}?
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-danger" onclick="deleteItem('{{ item.path|urlencode|escapejs }}')">Delete</button>
          </div>
        </div>
      </div>
    </div>
    {% if item.type == 'file' %}
      <!-- Info Modal -->
      <div class="modal fade" id="info-{{forloop.counter}}" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="exampleModalLabel">File Info</h1>
              <div class="ms-auto">
                <div role="button" id="modal-close-btn-{{forloop.counter}}" data-bs-dismiss="modal" aria-label="Close">
                  <i class="fas fa-times fs-5"></i>
                </div>
              </div>
            </div>
            <div class="modal-body">
              <form action="{% url 'file_manager:save_info' file_path=item.path|urlencode %}" method="post">
                {% csrf_token %}
                <div class="form-group mb-2">
                  <label for="" class="form-label">File Info</label>
                  <input type="text" value="{{item.path|info_value}}" name="info" id="" class="form-control">
                </div>
                <div class="d-flex justify-content-end">
                  <button type="submit" class="btn btn-primary">Save</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    {% endif %}
  {% endfor %}

{% endblock content %}

{% block extra_js %}
<!-- Add SweetAlert JS -->
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>

<script>
  function submitForm() {
    const form = document.getElementById('upload-file');
    const fileInput = document.getElementById('fileInput');
    
    if (fileInput.files.length > 0) {
        console.log('Submitting form with file:', fileInput.files[0].name);
        // Add loading state
        Swal.fire({
            title: 'Uploading...',
            text: 'Please wait while your file is being uploaded',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });
        form.submit();
    } else {
        Swal.fire({
            title: 'Error',
            text: 'Please select a file to upload',
            icon: 'error',
            confirmButtonText: 'OK'
        });
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    const folderItems = document.querySelectorAll('.folder-item');
    folderItems.forEach((item) => {
      const folderContent = item.querySelector('.folder-content');
      folderContent.addEventListener('click', (e) => {
        if (e.target.tagName.toLowerCase() !== 'a') {
          e.preventDefault();
          e.stopPropagation();
          toggleFolder(item);
        }
      });
    });

    highlightCurrentFolder();
  });

  const toggleFolder = (folderItem) => {
    const folderContents = folderItem.querySelector('.folder-contents');
    folderItem.classList.toggle('collapsed');
    folderContents.style.display = folderItem.classList.contains('collapsed') ? 'none' : 'block';
  };

  const highlightCurrentFolder = () => {
    const currentPath = window.location.pathname.split('/').filter(Boolean);
    let currentElement = document.getElementById('directory-tree');

    currentPath.forEach((pathPart, index) => {
      if (index === 0) return; // Skip 'file-manager'
      
      const folderItem = currentElement.querySelector(`[data-path*="${pathPart}"]`);
      if (folderItem) {
        folderItem.classList.add('active');
        currentElement = folderItem.querySelector('.folder-contents');
      }
    });
  };

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27) {
      const contents = document.getElementById('contents-count').textContent;
      for (let i = 1; i <= contents; i++) {
        const closeButton = document.getElementById(`modal-close-btn-${i}`);
        if (closeButton) {
          closeButton.click();
        }
      }
    }
  });

  const deleteItem = async (path) => {
    try {
      const fileName = path.split('/').pop();
      const result = await Swal.fire({
        title: `Delete ${fileName}?`,
        text: "You won't be able to recover this file once deleted.",
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#3085d6',
        cancelButtonColor: '#d33',
        confirmButtonText: 'Yes, delete it!'
      });
      
      if (!result.isConfirmed) return;
      
      const response = await fetch(
        `{% url 'file_manager:delete' file_path='PLACEHOLDER' %}`.replace('PLACEHOLDER', path),
        {
          method: 'POST',
          headers: {
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRFToken': '{{ csrf_token }}'
          }
        }
      );
      
      if (!response.ok) throw new Error('Delete failed');
      
      await Swal.fire('Deleted!', `${fileName} has been deleted.`, 'success');
      window.location.reload();
    } catch (error) {
      console.error('Error:', error);
      Swal.fire({
        title: 'Error',
        text: 'Failed to delete file. Please try again.',
        icon: 'error'
      });
    }
  };

  // Delegate event listeners
  document.getElementById('directory-tree').addEventListener('click', (e) => {
    const folderContent = e.target.closest('.folder-content');
    if (folderContent && !e.target.closest('a')) {
      e.preventDefault();
      e.stopPropagation();
      toggleFolder(folderContent.closest('.folder-item'));
    }
  });
</script>
{% endblock extra_js %}

================
File: apps/file_manager/templatetags/file_extension.py
================
from django import template
from django.template.defaultfilters import stringfilter
import os
from urllib.parse import quote

register = template.Library()

@register.filter
@stringfilter
def file_extension(value):
    """Returns the file extension from a path."""
    return os.path.splitext(value)[1][1:].lower()

@register.filter
@stringfilter
def info_value(path):
    """Returns stored info for a file path."""
    from apps.file_manager.models import FileInfo
    try:
        file_info = FileInfo.objects.get(path=path)
        return file_info.info
    except FileInfo.DoesNotExist:
        return ''

@register.filter
def encoded_file_path(path):
    return path.replace('/', '%slash%')

@register.filter
def encoded_path(path):
    return path.replace('\\', '/')

================
File: apps/file_manager/templatetags/file_manager_extras.py
================
from django import template
import os

register = template.Library()

@register.filter
def basename(value):
    return os.path.basename(value)

================
File: apps/file_manager/templatetags/info_value.py
================
from django import template
from apps.file_manager.models import FileInfo

register = template.Library()

@register.filter
def info_value(path):
    file_info = FileInfo.objects.filter(path=path)
    if file_info.exists():
        return file_info.first().info
    else:
        return ""

================
File: apps/file_manager/admin.py
================
from django.contrib import admin

# Register your models here.

================
File: apps/file_manager/apps.py
================
from django.apps import AppConfig


class FileManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.file_manager'

================
File: apps/file_manager/models.py
================
from django.db import models

# Create your models here.


class FileInfo(models.Model):
    path = models.CharField(max_length=255, unique=True)
    info = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.path

================
File: apps/file_manager/storage.py
================
import os
from django.core.files.storage import default_storage
from core.storage import SecureFileStorage # Import SecureFileStorage
import logging
import io
import zipfile
import csv
from urllib.parse import unquote

logger = logging.getLogger(__name__)

class PathManager:
    """Handles file storage operations with proper error handling using SecureFileStorage"""
    
    def __init__(self, user_id=None):
        """Initialize with optional user_id for base directory and SecureFileStorage"""
        self.user_id = str(user_id) if user_id else None
        self.base_dir = f"{self.user_id}/" if self.user_id else ""
        # Initialize SecureFileStorage. We assume files here are private.
        # Collection is not set here, path construction happens in _get_full_path
        self.secure_storage = SecureFileStorage(private=True, collection='') 
        
    def _get_full_path(self, path):
        """Get full path including user base directory"""
        path = path.strip('/')
        # Ensure the path is relative to the user's base directory
        if self.user_id and not path.startswith(self.base_dir):
            return os.path.join(self.base_dir, path)
        # Handle case where user_id is None (e.g., admin access?) or path already includes base_dir
        return path
    
    def list_contents(self, prefix=''):
        """List contents of a directory using the underlying storage"""
        try:
            prefix = self._get_full_path(prefix)
            # Ensure prefix ends with / for directory listing
            if prefix and not prefix.endswith('/'):
                prefix = f"{prefix}/"
                
            # Use listdir from the underlying storage accessed via SecureFileStorage
            directories, files = self.secure_storage.storage.listdir(prefix)
            contents = []
            
            # Add directories
            for dir_name in sorted(directories):
                if not dir_name.startswith('.'): # Ignore hidden directories
                    full_path = os.path.join(prefix, dir_name) if prefix else dir_name
                    # Generate URL using secure_storage.url which handles private/public
                    dir_url = self.secure_storage.url(full_path + '/') # Append slash for consistency? Or handle in view?
                    contents.append({
                        'name': dir_name,
                        'path': full_path.replace(self.base_dir, '', 1), # Remove base_dir for display path
                        'type': 'directory',
                        'size': 0, # Directories don't have a size in this context
                        'url': dir_url # URL to browse the directory
                    })
            
            # Add files
            for file_name in sorted(files):
                if not file_name.startswith('.'): # Ignore hidden files
                    full_path = os.path.join(prefix, file_name) if prefix else file_name
                    try:
                        # Get size and URL using secure_storage methods
                        file_size = self.secure_storage.size(full_path)
                        file_url = self.secure_storage.url(full_path) 
                        contents.append({
                            'name': file_name,
                            'path': full_path.replace(self.base_dir, '', 1), # Remove base_dir for display path
                            'type': 'file',
                            'size': file_size,
                            'extension': os.path.splitext(file_name)[1][1:].lower(),
                            'url': file_url # URL for preview/download via secure view
                        })
                    except Exception as file_e:
                        logger.error(f"Error processing file {full_path}: {str(file_e)}")
                        # Optionally add file with error status
                        contents.append({
                             'name': file_name,
                             'path': full_path.replace(self.base_dir, '', 1),
                             'type': 'error',
                             'error': str(file_e)
                        })

            return contents
            
        except Exception as e:
            logger.error(f"Error listing contents for prefix '{prefix}': {str(e)}", exc_info=True)
            raise # Re-raise the exception to be handled by the view

    def delete(self, path):
        """Delete a file or directory using SecureFileStorage"""
        try:
            full_path = self._get_full_path(path)
            
            # Check if it's a file first using secure_storage.exists
            if self.secure_storage.exists(full_path):
                 # Attempt to determine if it's a directory by checking for trailing slash behavior 
                 # or by trying to list its contents. This part is tricky across backends.
                 # A common pattern is to try deleting as a file first.
                 try:
                     self.secure_storage.delete(full_path)
                     logger.info(f"Successfully deleted file: {full_path}")
                     return True
                 except Exception as file_delete_error:
                     # If deleting as a file fails, it might be a directory.
                     logger.warning(f"Could not delete {full_path} as file ({file_delete_error}), trying as directory.")
                     # Proceed to directory deletion logic
                     pass

            # If it wasn't deleted as a file or didn't exist as a file, try deleting as a directory
            # Need robust way to check if it's a directory. Listing is one option.
            # Use the underlying storage for listdir
            try:
                 dir_path_check = full_path.rstrip('/') + '/' # Ensure trailing slash for listing
                 dirs, files = self.secure_storage.storage.listdir(dir_path_check)
                 # If listdir succeeds without error and/or returns content, assume it's a directory
                 if dirs is not None or files is not None: 
                      logger.info(f"{full_path} appears to be a directory. Proceeding with directory deletion.")
                      return self._delete_directory_recursive(dir_path_check)
            except Exception as list_err:
                 # If listdir fails, it's likely not a directory or doesn't exist
                 logger.warning(f"Could not list contents of {dir_path_check} ({list_err}). Assuming not a directory or does not exist.")
                 pass

            logger.warning(f"Path not found or could not be deleted: {full_path}")
            return False
            
        except Exception as e:
            logger.error(f"Error deleting path {path}: {str(e)}", exc_info=True)
            raise

    def _delete_directory_recursive(self, dir_path):
        """Recursively delete a directory using SecureFileStorage"""
        try:
            # Use underlying storage's listdir via secure_storage
            dirs, files = self.secure_storage.storage.listdir(dir_path)
            
            # Delete files in the current directory
            for file_name in files:
                file_path = os.path.join(dir_path, file_name)
                try:
                    self.secure_storage.delete(file_path)
                    logger.debug(f"Deleted file: {file_path}")
                except Exception as e:
                    logger.error(f"Error deleting file {file_path}: {str(e)}")
                    # Continue deleting other files/dirs even if one fails? Or raise?
                    raise

            # Recursively delete subdirectories
            for dir_name in dirs:
                subdir_path = os.path.join(dir_path, dir_name) + '/' # Ensure trailing slash
                self._delete_directory_recursive(subdir_path)
            
            # Finally, delete the now-empty directory itself
            # Some storage backends might automatically remove empty "folders", 
            # others might require an explicit delete. The `delete` method should handle this.
            # We attempt to delete the directory path itself. If it's just a prefix (like S3),
            # this might do nothing, which is fine. If it's an actual directory object, it should be deleted.
            try:
                # Attempt to delete the directory marker/object itself
                self.secure_storage.delete(dir_path.rstrip('/')) # Delete without trailing slash
                logger.info(f"Successfully deleted directory: {dir_path}")
            except Exception as e:
                 # If the backend doesn't support explicit directory deletion or it was already removed
                 logger.warning(f"Could not explicitly delete directory path {dir_path}: {str(e)}. May already be removed.")

            return True
        except Exception as e:
            # If listdir fails (e.g., directory doesn't exist anymore)
            if "NoSuchKey" in str(e) or "does not exist" in str(e): # Example error checks
                 logger.warning(f"Directory {dir_path} likely already deleted or does not exist: {str(e)}")
                 return True # Consider it successful if it's already gone
            logger.error(f"Error deleting directory contents {dir_path}: {str(e)}", exc_info=True)
            raise # Re-raise the exception

    def save_file(self, file_obj, path):
        """Save an uploaded file using SecureFileStorage"""
        try:
            full_path = self._get_full_path(path)
            logger.debug(f"Saving file to storage path via SecureStorage: {full_path}")
            
            # Use SecureFileStorage's _save method
            saved_path = self.secure_storage._save(full_path, file_obj)
            logger.info(f"File saved successfully via SecureStorage: {saved_path}")
            
            # Verify storage using SecureFileStorage's exists method
            if self.secure_storage.exists(saved_path):
                logger.debug(f"SecureStorage verification passed: {saved_path}")
            else:
                # This case should ideally not happen if _save succeeded without error
                logger.error(f"SecureStorage verification failed after save: {saved_path}")
            
            # Return the path relative to the user's base directory
            return saved_path.replace(self.base_dir, '', 1) if self.base_dir else saved_path
            
        except Exception as e:
            logger.error(f"Error saving file {path} via SecureStorage: {str(e)}", exc_info=True)
            raise

    def download_file(self, path):
        """Get file contents for download using SecureFileStorage"""
        try:
            # Normalize the path and handle URL encoding
            path = unquote(path).strip('/')
            full_path = self._get_full_path(path)
            
            #logger.debug(f"Attempting to download file via SecureStorage: {full_path}")
            
            # Check existence using SecureFileStorage
            if not self.secure_storage.exists(full_path):
                logger.error(f"File not found via SecureStorage: {full_path}")
                return None
            
            try:
                # Open using SecureFileStorage's _open method
                with self.secure_storage._open(full_path, 'rb') as f:
                    return f.read()
            except Exception as e:
                logger.error(f"Error reading file {full_path} via SecureStorage: {str(e)}")
                return None # Or re-raise depending on desired view behavior
            
        except Exception as e:
            logger.error(f"Error in download_file for path {path} using SecureStorage: {str(e)}", exc_info=True)
            return None # Or re-raise

    def create_directory_zip(self, path):
        """Create zip file from directory contents using SecureFileStorage"""
        try:
            path = path.strip('/')
            full_path = self._get_full_path(path)
            logger.debug(f"Creating zip for directory via SecureStorage: {full_path}")
            
            zip_buffer = io.BytesIO()
            
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                # List files using the underlying storage via SecureFileStorage
                # Need to handle potential errors if directory doesn't exist
                try:
                    dirs, files = self.secure_storage.storage.listdir(full_path.rstrip('/') + '/')
                except Exception as list_e:
                     logger.error(f"Cannot list directory {full_path} to create zip: {list_e}")
                     return None # Cannot create zip if directory cannot be listed

                # Add files from current directory
                for file_name in files:
                    file_path = os.path.join(full_path, file_name)
                    logger.debug(f"Adding file to zip: {file_path}")
                    
                    try:
                        # Open file using SecureFileStorage's _open
                        with self.secure_storage._open(file_path, 'rb') as f:
                            zip_file.writestr(file_name, f.read())
                    except Exception as e:
                        logger.error(f"Error adding file {file_path} to zip: {str(e)}")
                        # Optionally skip this file and continue? Or fail the zip creation?
                
                # Recursively add files from subdirectories
                for dir_name in dirs:
                    dir_path = os.path.join(full_path, dir_name)
                    # Pass the relative path within the zip file correctly
                    self._add_directory_to_zip(zip_file, dir_path, dir_name) 
            
            zip_data = zip_buffer.getvalue()
            if not zip_data:
                logger.warning(f"No files found in directory: {full_path}, zip is empty.")
                # Decide whether to return None or an empty zip buffer
                # Returning None seems reasonable if the directory was truly empty or only contained errors
                return None 
            
            return zip_data
            
        except Exception as e:
            logger.error(f"Error creating zip for directory {path}: {str(e)}", exc_info=True)
            return None # Return None on error

    def _add_directory_to_zip(self, zip_file, dir_path, rel_path):
        """Recursively add directory contents to zip file using SecureFileStorage"""
        try:
            # Ensure dir_path has trailing slash for listdir
            dir_path_list = dir_path.rstrip('/') + '/'
            # Use underlying storage's listdir via SecureFileStorage
            dirs, files = self.secure_storage.storage.listdir(dir_path_list)
            
            # Add files in this directory
            for file_name in files:
                file_path = os.path.join(dir_path, file_name) # Use original dir_path for joining
                zip_path = os.path.join(rel_path, file_name) # Path inside the zip file
                logger.debug(f"Adding file to zip: {file_path} as {zip_path}")
                
                try:
                    # Open file using SecureFileStorage's _open
                    with self.secure_storage._open(file_path, 'rb') as f:
                        zip_file.writestr(zip_path, f.read())
                except Exception as e:
                    logger.error(f"Error adding file {file_path} to zip: {str(e)}")
                    # Continue with next file?
            
            # Recursively process subdirectories
            for subdir in dirs:
                new_dir_path = os.path.join(dir_path, subdir)
                new_rel_path = os.path.join(rel_path, subdir)
                self._add_directory_to_zip(zip_file, new_dir_path, new_rel_path)
            
        except Exception as e:
            # Log error if listing subdirectory fails, but potentially continue building zip
            logger.error(f"Error adding directory {dir_path} contents to zip: {str(e)}")
            # Decide if this error should stop the whole zip creation process

    def convert_csv_to_text(self, path, max_chars=1000):
        """Convert CSV file content to text with character limit using SecureFileStorage"""
        try:
            full_path = self._get_full_path(path)
            # Open using SecureFileStorage's _open method
            # Need to handle text mode ('rt') - SecureFileStorage._open might return bytes
            with self.secure_storage._open(full_path, 'rb') as file_bytes: # Open as bytes first
                 # Decode bytes to text, handling potential encoding issues
                 try:
                     file_content = file_bytes.read().decode('utf-8')
                 except UnicodeDecodeError:
                     logger.warning(f"UTF-8 decoding failed for {full_path}, trying latin-1")
                     # Reset stream position if necessary (BytesIO allows re-reading)
                     file_bytes.seek(0) 
                     file_content = file_bytes.read().decode('latin-1', errors='replace')

                 # Use io.StringIO to treat the decoded string as a file for csv.reader
                 file_text_io = io.StringIO(file_content)
                 reader = csv.reader(file_text_io)
                 
                 content = []
                 current_chars = 0
                 for row in reader:
                      row_text = ','.join(row)
                      if current_chars + len(row_text) + 1 > max_chars: # +1 for newline
                           remaining_chars = max_chars - current_chars
                           if remaining_chars > 3: # Need space for "..."
                                content.append(row_text[:remaining_chars-3] + "...")
                           break # Stop reading rows
                      content.append(row_text)
                      current_chars += len(row_text) + 1
                 
                 final_text = '\n'.join(content)
                 if current_chars >= max_chars: # Check if truncation happened within the last row or exactly at limit
                     # Add truncation indicator if not already added
                     if not final_text.endswith("..."):
                          final_text += "\n... (Preview truncated)" 
                 
                 return final_text

        except Exception as e:
            logger.error(f"Error converting CSV {path} to text: {str(e)}", exc_info=True)
            return f"Error loading CSV content: {str(e)}"

    # Removed obsolete delete_directory method
    # def delete_directory(self, path): ...

================
File: apps/file_manager/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/file_manager/urls.py
================
from django.urls import path
from . import views

app_name = 'file_manager'

urlpatterns = [
    path('', views.file_manager, name='index'),  # Root view
    path('api/upload/', views.upload_file, name='upload'),  # Change upload URL
    path('download/<path:file_path>', views.download_file, name='download'),
    path('delete/<path:file_path>', views.delete_file, name='delete'),
    path('preview/<path:file_path>', views.file_preview, name='preview'),
    path('save-info/<path:file_path>/', views.save_info, name='save_info'),
    path('<path:path>/', views.file_manager, name='browse'),  # Keep this last
]

================
File: apps/file_manager/views.py
================
import os
import csv
from django.shortcuts import render, redirect
from django.http import HttpResponse, Http404, JsonResponse
from django.core.files.base import ContentFile
from django.contrib.auth.decorators import login_required
from django.urls import reverse
from urllib.parse import unquote
from .models import FileInfo
import logging
import tempfile
import zipfile
import io
from django.conf import settings
import json
from .storage import PathManager
from django.views.decorators.csrf import csrf_exempt
import mimetypes

logger = logging.getLogger(__name__)

@login_required(login_url='/accounts/login/basic-login/')
def save_info(request, file_path):
    """Save file information."""
    path = unquote(file_path)
    if request.method == 'POST':
        FileInfo.objects.update_or_create(
            path=path,
            defaults={'info': request.POST.get('info')}
        )
    return redirect(request.META.get('HTTP_REFERER'))

@login_required
def file_manager(request, path=''):
    """Render file manager view with directory contents"""
    logger.debug("FILE_MANAGER VIEW ENTERED")
    try:
        path = path.strip('/')
        path_manager = PathManager(user_id=request.user.id)
        
        context = {
            'current_path': path,
            'contents': path_manager.list_contents(path),
            'breadcrumbs': get_breadcrumbs(path),
            'user_id': request.user.id
        }
        
        return render(request, 'file_manager/file-manager.html', context)
    except Exception as e:
        logger.error(f"Error in file manager view: {str(e)}", exc_info=True)
        return render(request, 'file_manager/file-manager.html', {
            'error': str(e),
            'current_path': path,
            'contents': [],
            'breadcrumbs': get_breadcrumbs(path),
            'user_id': request.user.id
        })

@csrf_exempt
@login_required
def delete_file(request, file_path):
    """Delete file or directory using PathManager"""
    logger.debug("DELETE_FILE VIEW ENTERED - PATH: %s", file_path)
    try:
        path = unquote(file_path).rstrip('/')
        logger.debug(f"Deleting: {path}")
        path_manager = PathManager(user_id=request.user.id)
        
        # Let PathManager handle directory/file detection
        success = path_manager.delete(path)
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            if success:
                return JsonResponse({'status': 'success'})
            return JsonResponse({'status': 'error', 'message': 'Path not found or could not be deleted'}, status=404)
            
        referer = request.META.get('HTTP_REFERER', reverse('file_manager:index'))
        return redirect(referer)
        
    except Exception as e:
        logger.error(f"Error deleting {path}: {str(e)}", exc_info=True)
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)
        raise

@login_required
def download_file(request, file_path):
    """Download file or directory as zip using PathManager"""
    try:
        # Log the raw file_path before any processing
        logger.debug(f"Raw download file_path: {file_path}")
        
        # Normalize and decode the path
        path = unquote(file_path).rstrip('/')
        logger.debug(f"Processed path after unquote: {path}")
        
        path_manager = PathManager(user_id=request.user.id)
        logger.debug(f"User ID: {request.user.id}")
        
        # Check if this is a directory by looking at the original file_path
        is_directory = file_path.endswith('/')
        logger.debug(f"Is directory request: {is_directory}")
        
        if is_directory:
            logger.debug(f"Creating zip for directory: {path}")
            zip_data = path_manager.create_directory_zip(path)
            if not zip_data:
                logger.error(f"No files found or error creating zip for directory: {path}")
                raise Http404("No files found in directory or error creating zip.")
                
            # Sanitize filename for Content-Disposition
            zip_filename = os.path.basename(path) if path else f"user_{request.user.id}_files"
            safe_zip_filename = zip_filename.replace('"', '\\"') + '.zip'
            
            response = HttpResponse(zip_data, content_type='application/zip')
            response['Content-Disposition'] = f'attachment; filename="{safe_zip_filename}"'
            return response
        else:
            file_data = path_manager.download_file(path)
            if file_data is None:
                logger.error(f"File not found or error reading file via PathManager: {path}")
                raise Http404("File not found or could not be read")
                
            filename = os.path.basename(path)
            safe_filename = filename.replace('"', '\\"')
            
            # Determine content type (optional but recommended)
            content_type, encoding = mimetypes.guess_type(filename)
            if content_type is None:
                content_type = 'application/octet-stream' # Default binary type

            response = HttpResponse(file_data, content_type=content_type)
            response['Content-Disposition'] = f'attachment; filename="{safe_filename}"'
            return response
            
    except Http404 as e:
        logger.warning(f"Download failed (404): {str(e)} for path {file_path}")
        raise # Re-raise Http404 to let Django handle it
    except Exception as e:
        logger.error(f"Error downloading file/directory {file_path}: {str(e)}", exc_info=True)
        # Generic error, return 500 or raise Http404? Http404 might be safer.
        raise Http404(f"Error downloading file: {str(e)}") 

@login_required
def upload_file(request):
    """Handle file upload using PathManager"""
    try:
        logger.debug(f"Upload request received. Method: {request.method}")
        
        if request.method == 'POST':
            logger.debug(f"POST data: {request.POST}")
            logger.debug(f"FILES: {request.FILES}")
            
            file_obj = request.FILES.get('file')
            if not file_obj:
                logger.error("No file found in upload request")
                # Consider returning an error message via messages framework
                return redirect(request.META.get('HTTP_REFERER', reverse('file_manager:index')))
            
            directory = unquote(request.POST.get('directory', '')).strip('/')
            logger.debug(f"Raw directory from POST: '{request.POST.get('directory', '')}'")
            logger.debug(f"Processed directory: '{directory}'")
            
            if file_obj:
                logger.debug(f"Processing file upload: {file_obj.name}")
                path_manager = PathManager(user_id=request.user.id)
                relative_path = os.path.join(directory, file_obj.name)
                logger.debug(f"Attempting to save to relative path: '{relative_path}'")
                
                saved_relative_path = path_manager.save_file(file_obj, relative_path)
                logger.info(f"File uploaded successfully. Relative path: {saved_relative_path}")
            
            if directory:
                return redirect('file_manager:browse', path=directory)
            return redirect('file_manager:index')
            
    except Exception as e:
        logger.error(f"Error uploading file: {str(e)}", exc_info=True)
        # On error, redirect back to previous page with an error message
        # messages.error(request, f"File upload failed: {str(e)}")
        return redirect(request.META.get('HTTP_REFERER', reverse('file_manager:index')))

def get_breadcrumbs(path):
    """Generate breadcrumbs for a given path."""
    # Start with Home as the root
    breadcrumbs = [{'name': 'Home', 'path': '', 'url': reverse('file_manager:index')}]
    
    if not path:
        return breadcrumbs
    
    # Process each part of the path
    parts = path.strip('/').split('/')
    current_path = ''
    for part in parts:
        current_path = os.path.join(current_path, part)
        breadcrumbs.append({
            'name': part,
            'path': current_path,
            'url': reverse('file_manager:browse', kwargs={'path': current_path})
        })
    
    return breadcrumbs

@login_required
def file_preview(request, file_path):
    """Serve file preview through Django using PathManager"""
    try:
        path = unquote(file_path).rstrip('/')
        path_manager = PathManager(user_id=request.user.id)
        
        # Get file extension
        ext = os.path.splitext(path)[1][1:].lower()
        
        # Handle text-based files using PathManager.convert_csv_to_text (or a new generic method)
        text_extensions = {'txt', 'log', 'md', 'json', 'xml', 'yaml', 'yml', 'ini', 'conf', 'csv'}
        
        if ext in text_extensions:
             if ext == 'csv':
                 # Use the dedicated method in PathManager for CSV preview
                 preview_content = path_manager.convert_csv_to_text(path, max_chars=2000) # Increase limit slightly?
                 # Wrap in pre tags for consistent display
                 html_content = f'<pre class="text-light bg-dark p-3">{preview_content}</pre>'
                 return HttpResponse(html_content, content_type='text/html')
             else:
                 # For other text files, download and truncate
                 file_data = path_manager.download_file(path)
                 if file_data is None:
                     raise Http404("File not found or cannot be read")
                 
                 # Decode, handling potential errors
                 try:
                     content = file_data.decode('utf-8')
                 except UnicodeDecodeError:
                     logger.warning(f"UTF-8 decoding failed for preview {path}, trying latin-1")
                     content = file_data.decode('latin-1', errors='ignore')
                 
                 # Truncate (e.g., 100 lines or 2000 characters)
                 lines = content.split('\n')[:100]
                 truncated = '\n'.join(lines)
                 if len(truncated) > 2000:
                     truncated = truncated[:2000] + '\n... (Preview truncated)'
                 
                 return HttpResponse(f'<pre class="text-light bg-dark p-3">{truncated}</pre>', 
                                   content_type='text/html')

        # Handle image previews (inline display)
        image_extensions = {'png', 'jpg', 'jpeg', 'gif', 'bmp', 'webp', 'svg'}
        if ext in image_extensions:
             file_data = path_manager.download_file(path)
             if file_data is None:
                 raise Http404("Image file not found or cannot be read")
             
             content_type, _ = mimetypes.guess_type(path)
             if content_type is None:
                  content_type = 'application/octet-stream' # Fallback
             
             # Return image directly for inline display
             response = HttpResponse(file_data, content_type=content_type)
             # 'inline' suggests browser should display if possible
             response['Content-Disposition'] = f'inline; filename="{os.path.basename(path)}"' 
             return response

        # Default: Attempt download for other types (or show 'preview not available')
        # For security, maybe only allow preview for specific safe types?
        # Let's return a 'preview not available' message for unsupported types.
        logger.warning(f"Preview not supported for file type: {ext} (path: {path})")
        return HttpResponse(f"<div class=\"alert alert-warning\">Preview is not available for this file type (.{ext}). <a href=\"{reverse('file_manager:download', kwargs={'file_path': file_path})}\" class=\"alert-link\">Download file</a> instead.</div>",
                           content_type='text/html', status=200) # Return 200 OK but with message

    except Http404 as e:
         logger.warning(f"File preview failed (404): {str(e)} for path {file_path}")
         raise # Let Django handle 404
    except Exception as e:
        logger.error(f"Error previewing file {file_path}: {str(e)}", exc_info=True)
        # Return generic error message, maybe link to download
        return HttpResponse(f"<div class=\"alert alert-danger\">Error accessing file preview: {str(e)}. You can try to <a href=\"{reverse('file_manager:download', kwargs={'file_path': file_path})}\" class=\"alert-link\">download the file</a>.</div>",
                           content_type='text/html', status=500)

================
File: apps/image_optimizer/static/image_optimizer/js/services/websocket.js
================
class ImageOptimizationWebSocket {
    constructor(optimizationId) {
        this.optimizationId = optimizationId;
        this.socket = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
        this.reconnectDelay = 1000;
        this.handlers = new Map();
        this.lastPongTime = Date.now();
    }

    connect() {
        if (this.socket?.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }

        if (this.socket) {
            this.socket.close();
        }

        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}/ws/image-optimizer/${this.optimizationId}/`;

        try {
            this.socket = new WebSocket(wsUrl);
            this.setupEventHandlers();
            this.startPingInterval();
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            this.handleReconnect();
        }
    }

    setupEventHandlers() {
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.emit('connectionStatus', 'connected');
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'pong') {
                    this.lastPongTime = Date.now();
                    return;
                }
                this.handleMessage(data);
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };

        this.socket.onclose = (event) => {
            this.isConnected = false;
            this.stopPingInterval();
            this.emit('connectionStatus', 'disconnected');
            
            if (event.code !== 1000 && event.code !== 1001) {
                this.handleReconnect();
            }
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.emit('connectionStatus', 'error');
        };
    }

    handleReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);
            const jitter = Math.random() * 1000;
            setTimeout(() => this.connect(), delay + jitter);
        } else {
            this.emit('error', { message: 'Max reconnection attempts reached' });
        }
    }

    handleMessage(data) {
        switch (data.type) {
            case 'optimization_update':
                this.emit('optimizationUpdate', data);
                break;
            case 'job_update':
                this.emit('jobUpdate', data);
                break;
            case 'error':
                this.emit('error', data);
                break;
            default:
                console.log('Unknown message type:', data.type);
        }
    }

    send(data) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
        } else {
            console.warn('WebSocket not connected, message not sent:', data);
        }
    }

    on(event, handler) {
        if (!this.handlers.has(event)) {
            this.handlers.set(event, new Set());
        }
        this.handlers.get(event).add(handler);
    }

    emit(event, data) {
        const handlers = this.handlers.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }

    disconnect() {
        this.stopPingInterval();
        if (this.socket) {
            this.socket.close();
        }
    }

    startPingInterval() {
        this.stopPingInterval();
        this.pingInterval = setInterval(() => {
            if (this.socket?.readyState === WebSocket.OPEN) {
                if (Date.now() - this.lastPongTime > 45000) {
                    this.socket.close();
                    this.connect();
                    return;
                }
                this.send({ type: 'ping' });
            }
        }, 15000);
    }

    stopPingInterval() {
        if (this.pingInterval) {
            clearInterval(this.pingInterval);
            this.pingInterval = null;
        }
    }
}

export { ImageOptimizationWebSocket };

================
File: apps/image_optimizer/static/image_optimizer/js/optimize_app.js
================
import { ImageOptimizationWebSocket } from './services/websocket.js';

class OptimizeApp {
    constructor() {
        this.sockets = {};
        this.completedOptimizations = new Set();
        this.isCompleted = false;
        this.setupUI();
        this.setupDropzone();
        this.setupEventListeners();
    }

    setupUI() {
        this.elements = {
            previewGrid: document.getElementById('previewGrid'),
            previewContainer: document.getElementById('previewContainer'),
            prevButton: document.getElementById('prevImage'),
            nextButton: document.getElementById('nextImage'),
            paginationText: document.getElementById('paginationText'),
            optimizeBtn: document.getElementById('optimizeBtn'),
            qualitySlider: document.getElementById('qualitySlider'),
            maxWidth: document.getElementById('maxWidth'),
            maxHeight: document.getElementById('maxHeight')
        };
        this.currentPreviewIndex = 0;
        this.totalFiles = 0;
        this.currentJobId = null;
    }

    setupDropzone() {
        console.log('Setting up Dropzone...');
        const form = document.getElementById('imageDropzone');
        const uploadUrl = form.getAttribute('action');
        console.log('Upload URL:', uploadUrl);
        
        this.dropzone = new Dropzone("#imageDropzone", {
            url: uploadUrl,
            paramName: "file",
            maxFilesize: 50,
            acceptedFiles: "image/*",
            addRemoveLinks: true,
            createImageThumbnails: true,
            autoProcessQueue: false,
            parallelUploads: 4,
            uploadMultiple: false,
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            init: function() {
                // Store dropzone instance for later use
                const dropzone = this;
                
                // Handle the queue completion
                this.on("queuecomplete", function() {
                    console.log("All files have been uploaded.");
                });
                
                // Handle when a file is added to the queue
                this.on("addedfile", function(file) {
                    console.log("File added to queue:", file.name);
                });
                
                // Handle when the upload starts
                this.on("sending", function(file, xhr, formData) {
                    console.log("Starting upload for:", file.name);
                });
            }
        });

        this.dropzone.on("addedfile", (file) => {
            console.log('File added:', file.name);
            if (this.totalFiles === 0) {
                this.elements.previewContainer.classList.remove('d-none');
            }
            
            const previewId = `preview-${file.upload.uuid}`;
            const previewHtml = `
                <div id="${previewId}" class="preview-grid ${this.totalFiles === 0 ? 'active' : ''}">
                    <div class="preview-item">
                        <h6>${file.name}</h6>
                        <div class="image-comparison">
                            <div class="image-box">
                                <h6>Original</h6>
                                <img src="${URL.createObjectURL(file)}" alt="Original ${file.name}">
                                <p>${this.formatBytes(file.size)}</p>
                            </div>
                            <div class="image-box">
                                <h6>Optimized</h6>
                                <img src="${window.PLACEHOLDER_IMAGE_URL}" 
                                     alt="Optimized ${file.name}" 
                                     class="optimized-preview"
                                     style="opacity: 0.2;">
                                <p class="optimized-size">Pending</p>
                            </div>
                        </div>
                        <div class="status pending">Pending Optimization</div>
                    </div>
                </div>
            `;
            this.elements.previewGrid.insertAdjacentHTML('beforeend', previewHtml);
            this.totalFiles++;
            this.updatePreviewNavigation();
        });

        this.dropzone.on("sending", (file, xhr, formData) => {
            console.log('Sending file:', file.name);
            const quality = Math.round(this.elements.qualitySlider.noUiSlider.get());
            const maxWidth = this.elements.maxWidth.value || '';
            const maxHeight = this.elements.maxHeight.value || '';
            
            formData.append("quality", quality);
            formData.append("max_width", maxWidth);
            formData.append("max_height", maxHeight);
            if (this.currentJobId) {
                formData.append("job_id", this.currentJobId);
            }
            
            console.log('Form data:', {
                quality: quality,
                max_width: maxWidth,
                max_height: maxHeight,
                job_id: this.currentJobId
            });
            
            const previewItem = document.getElementById(`preview-${file.upload.uuid}`);
            previewItem.querySelector('.status').textContent = 'Processing...';
        });

        this.dropzone.on("success", (file, response) => {
            console.log('Upload success:', file.name, response);
            if (response.success) {
                if (!this.currentJobId && response.job_id) {
                    this.currentJobId = response.job_id;
                }

                const previewItem = document.getElementById(`preview-${file.upload.uuid}`);
                previewItem.setAttribute('data-optimization-id', response.optimization_id);
                this.connectWebSocket(response.optimization_id);
            }
        });

        this.dropzone.on("error", (file, errorMessage, xhr) => {
            console.error('Upload error:', {
                file: file.name,
                error: errorMessage,
                xhr: xhr ? xhr.status : 'No XHR'
            });
            
            const previewItem = document.getElementById(`preview-${file.upload.uuid}`);
            const status = previewItem.querySelector('.status');
            status.textContent = 'Failed';
            status.classList.remove('pending');
            status.classList.add('failed');
            
            const optimizedSize = previewItem.querySelector('.optimized-size');
            optimizedSize.textContent = 'Error';
            
            let message = errorMessage;
            if (typeof errorMessage === 'object' && errorMessage.message) {
                message = errorMessage.message;
            }
            
            Swal.fire({
                icon: 'error',
                title: 'Optimization Failed',
                text: message,
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000
            });
        });

        this.dropzone.on("queuecomplete", () => {
            console.log('Queue complete');
        });
    }

    setupEventListeners() {
        this.elements.prevButton.addEventListener('click', () => this.navigatePreview('prev'));
        this.elements.nextButton.addEventListener('click', () => this.navigatePreview('next'));
        
        // Add optimize button handler
        this.elements.optimizeBtn.addEventListener('click', () => {
            console.log('Optimize button clicked');  // Debug log
            const queuedFiles = this.dropzone.getQueuedFiles();
            console.log('Queued files:', queuedFiles.length);
            
            if (queuedFiles.length > 0) {
                this.totalFiles = queuedFiles.length;
                this.currentJobId = null;
                
                Swal.fire({
                    title: 'Optimizing Images',
                    html: `
                        <div class="text-center">
                            <p class="mb-2">Processing image 1 of ${this.totalFiles}</p>
                            <div class="progress">
                                <div class="progress-bar bg-gradient-primary" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                            </div>
                        </div>
                    `,
                    allowOutsideClick: false,
                    showConfirmButton: false
                });
                
                console.log('Processing queue...');
                this.dropzone.processQueue();
            } else {
                Swal.fire({
                    icon: 'warning',
                    title: 'No Files',
                    text: 'Please add some files to optimize first.'
                });
            }
        });
    }

    connectWebSocket(optimizationId) {
        if (this.sockets[optimizationId]) {
            console.log('WebSocket already exists for:', optimizationId);
            return;
        }

        const socket = new ImageOptimizationWebSocket(optimizationId);

        socket.on('connectionStatus', (status) => {
            console.log('WebSocket status:', status);
            this.updateConnectionUI(status, optimizationId);
        });

        socket.on('optimizationUpdate', (data) => {
            this.handleOptimizationUpdate(data);
        });

        socket.on('jobUpdate', (data) => {
            this.handleJobUpdate(data);
        });

        socket.on('error', (error) => {
            console.error('WebSocket error:', error);
            Swal.fire({
                icon: 'error',
                title: 'Connection Error',
                text: error.message,
                toast: true,
                position: 'top-end',
                showConfirmButton: false,
                timer: 3000
            });
        });

        socket.connect();
        this.sockets[optimizationId] = socket;
    }

    updateConnectionUI(status, optimizationId) {
        const previewItem = document.querySelector(`[data-optimization-id="${optimizationId}"]`);
        if (!previewItem) return;

        const statusElement = previewItem.querySelector('.status');
        switch (status) {
            case 'connected':
                statusElement.textContent = 'Connected';
                break;
            case 'disconnected':
                statusElement.textContent = 'Disconnected';
                break;
            case 'connecting':
                statusElement.textContent = 'Connecting...';
                break;
            case 'error':
                statusElement.textContent = 'Connection Error';
                break;
        }
    }

    handleOptimizationUpdate(data) {
        const previewItem = document.querySelector(`[data-optimization-id="${data.optimization_id}"]`);
        if (!previewItem) return;

        const statusElement = previewItem.querySelector('.status');
        const optimizedPreview = previewItem.querySelector('.optimized-preview');
        const optimizedSize = previewItem.querySelector('.optimized-size');

        switch (data.status) {
            case 'processing':
                statusElement.textContent = 'Processing...';
                statusElement.className = 'status pending';
                break;
            case 'completed':
                statusElement.textContent = 'Optimization Complete';
                statusElement.className = 'status completed';
                
                // Force image reload by adding timestamp and use absolute URL
                const imageUrl = new URL(data.download_url, window.location.origin);
                imageUrl.searchParams.set('t', Date.now());
                
                // Create a new image object to ensure it loads
                const img = new Image();
                img.onload = () => {
                    optimizedPreview.src = img.src;
                    optimizedPreview.style.opacity = '1';
                };
                img.src = imageUrl.toString();
                
                optimizedSize.textContent = this.formatBytes(data.optimized_size);
                
                // Add to DataTable with proper data
                this.addOptimizationToTable({
                    file_name: data.file_name,
                    original_size: data.original_size,
                    optimized_size: data.optimized_size,
                    reduction: data.reduction,
                    download_url: data.download_url
                });

                // Track completed optimizations
                this.completedOptimizations.add(data.optimization_id);
                
                break;
            case 'failed':
                statusElement.textContent = 'Optimization Failed';
                statusElement.className = 'status failed';
                optimizedSize.textContent = 'Failed';
                
                // Also track failed ones as completed
                this.completedOptimizations.add(data.optimization_id);
                
                Swal.fire({
                    icon: 'error',
                    title: 'Optimization Failed',
                    text: data.error || 'An error occurred during optimization',
                    toast: true,
                    position: 'top-end',
                    showConfirmButton: false,
                    timer: 3000
                });
                break;
        }

        // Check if all optimizations are complete
        if (this.completedOptimizations.size === this.totalFiles) {
            this.handleAllOptimizationsComplete();
        }
    }

    handleJobUpdate(data) {
        if (!this.currentJobId || data.job_id !== this.currentJobId) return;

        const progress = (data.completed_count / this.totalFiles) * 100;
        const swalContent = document.querySelector('.swal2-html-container');
        
        if (swalContent) {
            swalContent.innerHTML = `
                <div class="text-center">
                    <p class="mb-2">Processing image ${data.completed_count} of ${this.totalFiles}</p>
                    <div class="progress">
                        <div class="progress-bar bg-gradient-primary" role="progressbar" 
                             style="width: ${progress}%" 
                             aria-valuenow="${progress}" 
                             aria-valuemin="0" 
                             aria-valuemax="100">
                        </div>
                    </div>
                </div>
            `;
        }

        // If job is complete and we've received all optimization updates
        if (data.status === 'completed' && data.completed_count === this.totalFiles) {
            // Check if we've received all individual optimization updates
            if (this.completedOptimizations.size === this.totalFiles) {
                this.handleAllOptimizationsComplete();
            } else {
                // Set a timeout to force completion if we don't receive all updates
                setTimeout(() => {
                    if (!this.isCompleted) {
                        this.handleAllOptimizationsComplete();
                    }
                }, 2000); // Wait 2 seconds for any remaining updates
            }
        }
    }

    handleAllOptimizationsComplete() {
        if (this.isCompleted) return; // Prevent multiple completions
        this.isCompleted = true;

        // Clean up WebSocket connections
        Object.values(this.sockets).forEach(socket => socket.disconnect());
        this.sockets = {};
        this.currentJobId = null;
        this.completedOptimizations.clear();

        Swal.fire({
            icon: 'success',
            title: 'Optimization Complete',
            text: `Successfully processed ${this.totalFiles} images`,
            timer: 3000,
            showConfirmButton: false
        });
    }

    navigatePreview(direction) {
        const previews = document.querySelectorAll('.preview-grid');
        previews[this.currentPreviewIndex].classList.remove('active');
        
        if (direction === 'next') {
            this.currentPreviewIndex = (this.currentPreviewIndex + 1) % this.totalFiles;
        } else {
            this.currentPreviewIndex = (this.currentPreviewIndex - 1 + this.totalFiles) % this.totalFiles;
        }
        
        previews[this.currentPreviewIndex].classList.add('active');
        this.updatePreviewNavigation();
    }

    updatePreviewNavigation() {
        this.elements.prevButton.disabled = this.totalFiles <= 1;
        this.elements.nextButton.disabled = this.totalFiles <= 1;
        this.elements.paginationText.textContent = `Image ${this.currentPreviewIndex + 1} of ${this.totalFiles}`;
    }

    closeSocket(optimizationId) {
        if (this.sockets[optimizationId]) {
            this.sockets[optimizationId].disconnect();
            delete this.sockets[optimizationId];
        }
    }

    formatBytes(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    addOptimizationToTable(optimization) {
        // Create a new row with proper formatting
        const newRow = [
            `<div class="d-flex px-2 py-1">
                <div class="d-flex flex-column justify-content-center">
                    <span class="text-xs font-weight-bold">${optimization.file_name}</span>
                </div>
            </div>`,
            `<span class="text-xs font-weight-bold">${this.formatBytes(optimization.original_size)}</span>`,
            `<span class="text-xs font-weight-bold">${this.formatBytes(optimization.optimized_size)}</span>`,
            `<span class="text-xs font-weight-bold">${optimization.reduction}%</span>`,
            `<span class="badge badge-sm bg-gradient-success">Completed</span>`,
            `<a href="${optimization.download_url}" class="text-secondary font-weight-bold text-xs" download>
                <i class="fa fa-download"></i> Download
            </a>`
        ];
        
        // Insert at the beginning of the table
        this.dataTable.insert({data: [newRow], index: 0});
        
        // Force refresh to ensure proper rendering
        this.dataTable.refresh();
    }
}

export { OptimizeApp };

================
File: apps/image_optimizer/templates/image_optimizer/dashboard.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Image Optimization Dashboard {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <!-- Statistics Cards -->
    <div class="row">
        <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Optimizations</p>
                                <h5 class="font-weight-bolder mb-0">
                                    {{ total_optimizations }}
                                </h5>
                            </div>
                        </div>
                        <div class="col-4 text-end">
                            <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                                <i class="ni ni-image text-lg opacity-10" aria-hidden="true"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Average Reduction</p>
                                <h5 class="font-weight-bolder mb-0">
                                    {{ avg_reduction }}%
                                </h5>
                            </div>
                        </div>
                        <div class="col-4 text-end">
                            <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md">
                                <i class="ni ni-chart-bar-32 text-lg opacity-10" aria-hidden="true"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Space Saved</p>
                                <h5 class="font-weight-bolder mb-0">
                                    {{ total_saved_mb }} MB
                                </h5>
                            </div>
                        </div>
                        <div class="col-4 text-end">
                            <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md">
                                <i class="ni ni-folder-17 text-lg opacity-10" aria-hidden="true"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-xl-3 col-sm-6">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Daily Limit</p>
                                <h5 class="font-weight-bolder mb-0">
                                    {% if request.user.is_staff %}
                                        Unlimited
                                    {% else %}
                                        100 images
                                    {% endif %}
                                </h5>
                            </div>
                        </div>
                        <div class="col-4 text-end">
                            <div class="icon icon-shape bg-gradient-info shadow text-center border-radius-md">
                                <i class="ni ni-time-alarm text-lg opacity-10" aria-hidden="true"></i>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Quick Actions -->
    <div class="row mt-4">
        <div class="col-lg-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Quick Actions</h6>
                </div>
                <div class="card-body p-3">
                    <div class="row">
                        <div class="col-xl-3 col-md-6 mb-xl-0 mb-4">
                            <div class="card card-blog card-plain">
                                <div class="position-relative">
                                    <a href="{% url 'image_optimizer:optimize' %}" class="d-block">
                                        <div class="icon icon-lg icon-shape bg-gradient-primary shadow-primary text-center border-radius-xl mt-n4 position-absolute">
                                            <i class="ni ni-cloud-upload-96"></i>
                                        </div>
                                        <div class="p-3 pt-6 text-center">
                                            <h5>Optimize Images</h5>
                                            <p class="text-sm">Upload and optimize new images</p>
                                        </div>
                                    </a>
                                </div>
                            </div>
                        </div>
                        
                        <div class="col-xl-3 col-md-6 mb-xl-0 mb-4">
                            <div class="card card-blog card-plain">
                                <div class="position-relative">
                                    <a href="{% url 'image_optimizer:history' %}" class="d-block">
                                        <div class="icon icon-lg icon-shape bg-gradient-info shadow-info text-center border-radius-xl mt-n4 position-absolute">
                                            <i class="ni ni-archive-2"></i>
                                        </div>
                                        <div class="p-3 pt-6 text-center">
                                            <h5>View History</h5>
                                            <p class="text-sm">Access your optimization history</p>
                                        </div>
                                    </a>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Recent Optimizations -->
    <div class="row mt-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Recent Optimizations</h6>
                </div>
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <table class="table align-items-center mb-0" id="recent-optimizations">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">File</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Original Size</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Optimized Size</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Reduction</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Date</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for optimization in recent_optimizations %}
                                <tr>
                                    <td>
                                        <div class="d-flex px-2 py-1">
                                            <div>
                                                <img src="{{ optimization.optimized_file.url }}" class="avatar avatar-sm me-3">
                                            </div>
                                            <div class="d-flex flex-column justify-content-center">
                                                <h6 class="mb-0 text-sm">{{ optimization.original_file.name|truncatechars:30 }}</h6>
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ optimization.original_size|filesizeformat }}</p>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ optimization.optimized_size|filesizeformat }}</p>
                                    </td>
                                    <td>
                                        <span class="badge badge-sm bg-gradient-success">{{ optimization.compression_ratio|floatformat:1 }}%</span>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ optimization.created_at|date:"M d, Y" }}</p>
                                    </td>
                                    <td>
                                        <a href="{{ optimization.optimized_file.url }}" class="btn btn-link text-secondary mb-0">
                                            <i class="fa fa-download text-xs"></i> Download
                                        </a>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<script>
    const dataTableSearch = new simpleDatatables.DataTable("#recent-optimizations", {
        searchable: true,
        fixedHeight: true,
        perPage: 10
    });
</script>
{% endblock extra_js %}

================
File: apps/image_optimizer/templates/image_optimizer/history.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Optimization History {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Optimization History</h6>
                </div>
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <table class="table align-items-center mb-0" id="history-table">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">File</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Original Size</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Optimized Size</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Reduction</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Date</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for opt in optimizations %}
                                <tr>
                                    <td>
                                        <div class="d-flex px-2 py-1">
                                            <div>
                                                {% if opt.original_file %}
                                                <img src="{{ opt.original_file.url }}" class="avatar avatar-sm me-3">
                                                {% endif %}
                                            </div>
                                            <div class="d-flex flex-column justify-content-center">
                                                <h6 class="mb-0 text-sm">{{ opt.original_file.name|default:"N/A" }}</h6>
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ opt.original_size|filesizeformat }}</p>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">
                                            {% if opt.status == 'completed' %}
                                                {{ opt.optimized_size|filesizeformat }}
                                            {% else %}
                                                -
                                            {% endif %}
                                        </p>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">
                                            {% if opt.status == 'completed' %}
                                                {{ opt.compression_ratio|floatformat:1 }}%
                                            {% else %}
                                                -
                                            {% endif %}
                                        </p>
                                    </td>
                                    <td>
                                        <span class="badge badge-sm bg-gradient-{{ opt.status|yesno:'success,warning,danger' }}">
                                            {{ opt.status|title }}
                                        </span>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ opt.created_at|date:"M d, Y H:i" }}</p>
                                    </td>
                                    <td>
                                        {% if opt.status == 'completed' and opt.optimized_file %}
                                        <a href="{{ opt.optimized_file.url }}" class="btn btn-link text-secondary mb-0" download>
                                            <i class="fa fa-download text-xs"></i> Download
                                        </a>
                                        {% endif %}
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="7" class="text-center py-4">
                                        <p class="text-sm mb-0">No optimizations found</p>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<script>
    const dataTableSearch = new simpleDatatables.DataTable("#history-table", {
        searchable: true,
        fixedHeight: true,
        perPage: 25,
        pageLength: [25, 50, 100, 200]
    });
</script>
{% endblock extra_js %}

================
File: apps/image_optimizer/templates/image_optimizer/optimize.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Image Optimization {% endblock %}

{% block extrastyle %}
<!-- Dropzone CSS -->
<link rel="stylesheet" href="https://unpkg.com/dropzone@5/dist/min/dropzone.min.css">
<!-- noUiSlider CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css">
<!-- PhotoSwipe CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.css">
<style>
    .dropzone {
        border: 2px dashed #cb0c9f;
        border-radius: 1rem;
        background: white;
        min-height: 300px;
        transition: all 0.3s ease;
    }
    .dropzone:hover {
        border-color: #5e72e4;
        background: #f8f9fa;
    }
    .dropzone .dz-message {
        margin: 6em 0;
    }
    .dropzone .dz-message h3 {
        color: #344767;
        font-weight: 600;
        margin-bottom: 1rem;
    }
    .optimization-controls {
        background: white;
        border-radius: 1rem;
        padding: 1.5rem;
        height: 100%;
    }
    .preview-container {
        position: relative;
        margin-top: 2rem;
        padding: 0 3rem;
    }
    .preview-grid {
        display: none;  /* Hide all previews by default */
    }
    .preview-grid.active {
        display: block;  /* Show only active preview */
    }
    .preview-item {
        background: white;
        border-radius: 0.75rem;
        padding: 2rem;
        box-shadow: 0 2px 12px 0 rgba(0,0,0,0.1);
        width: 100%;
    }
    .preview-navigation {
        position: absolute;
        top: 50%;
        width: 100%;
        left: 0;
        transform: translateY(-50%);
        display: flex;
        justify-content: space-between;
        pointer-events: none;
        padding: 0 1rem;
    }
    .preview-nav-button {
        background: white;
        border: none;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 12px rgba(0,0,0,0.1);
        cursor: pointer;
        pointer-events: auto;
        color: #344767;
        transition: all 0.2s ease;
    }
    .preview-nav-button:hover {
        background: #f8f9fa;
        transform: scale(1.1);
    }
    .preview-nav-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: scale(1);
    }
    .preview-pagination {
        text-align: center;
        margin-top: 1rem;
    }
    .preview-pagination span {
        color: #67748e;
        font-size: 0.875rem;
        font-weight: 500;
    }
    .preview-item .image-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 2rem;
        margin: 2rem 0;
    }
    .preview-item img {
        width: 100%;
        height: 500px;
        object-fit: contain;
        border-radius: 0.75rem;
        border: 1px solid #e9ecef;
        background: #f8f9fa;
        padding: 1rem;
    }
    .preview-item .status {
        text-align: center;
        margin-top: 1rem;
        font-weight: 500;
        padding: 0.5rem;
        border-radius: 0.5rem;
    }
    .preview-item .status.pending {
        color: #cb0c9f;
        background: rgba(203, 12, 159, 0.1);
    }
    .preview-item .status.completed {
        color: #82d616;
        background: rgba(130, 214, 22, 0.1);
    }
    .preview-item .status.failed {
        color: #ea0606;
        background: rgba(234, 6, 6, 0.1);
    }
    .preview-item .image-box p {
        margin-top: 1rem;
        color: #67748e;
        font-size: 0.875rem;
        font-weight: 500;
    }
    .dimension-inputs {
        display: flex;
        align-items: center;
        gap: 1rem;
        background: #f8f9fa;
        border-radius: 0.5rem;
        padding: 1.5rem;
    }
    .dimension-inputs .form-control {
        max-width: 120px;
        text-align: center;
        border: 1px solid #d2d6da;
        transition: all 0.3s ease;
    }
    .dimension-inputs .form-control:focus {
        border-color: #5e72e4;
    }
    .dimension-helper {
        margin-top: 0.75rem;
        color: #67748e;
        font-size: 0.875rem;
        text-align: center;
    }
    .quality-value {
        margin-top: 0.5rem;
        text-align: center;
        font-weight: 400;
        color: #344767;
        font-size: 0.875rem;
    }
    .settings-header {
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e9ecef;
    }
    .settings-header h6 {
        color: #344767;
        font-weight: 600;
        margin: 0;
    }
    .slider-helper {
        margin-top: 0.5rem;
        color: #67748e;
        font-size: 0.75rem;
        text-align: center;
    }
</style>
{% endblock extrastyle %}

{% block content %}
<div class="container-fluid py-4">
    <!-- Main Upload Area -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Upload Images</h6>
                </div>
                <div class="card-body">
                    <form action="{% url 'image_optimizer:handle_upload' %}" class="dropzone" id="imageDropzone">
                        {% csrf_token %}
                        <div class="dz-message">
                            <h3>Drop files here or click to upload</h3>
                            <p class="text-sm text-secondary">
                                Supported formats: JPEG, PNG, WebP, GIF
                            </p>
                        </div>
                    </form>

                    <!-- Preview Container -->
                    <div class="preview-container d-none" id="previewContainer">
                        <div class="preview-navigation">
                            <button class="preview-nav-button" id="prevImage" disabled>
                                <i class="fas fa-chevron-left"></i>
                            </button>
                            <button class="preview-nav-button" id="nextImage" disabled>
                                <i class="fas fa-chevron-right"></i>
                            </button>
                        </div>
                        <div id="previewGrid"></div>
                        <div class="preview-pagination">
                            <span id="paginationText">Image 0 of 0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Panel -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Optimization Settings</h6>
                </div>
                <div class="card-body">
                    <div class="optimization-controls">
                        <div class="row">
                            <div class="col-md-4">
                                <!-- Quality Slider -->
                                <div class="slider-container">
                                    <label>Quality</label>
                                    <div id="qualitySlider"></div>
                                    <div class="quality-value">80%</div>
                                    <div class="slider-helper">Higher quality means larger file size</div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <!-- Dimension Controls -->
                                <div class="form-group">
                                    <label class="form-control-label mb-3">Maximum Dimensions</label>
                                    <div class="dimension-inputs">
                                        <input type="number" id="maxWidth" class="form-control" placeholder="Width">
                                        <span class="text-lg fw-bold">×</span>
                                        <input type="number" id="maxHeight" class="form-control" placeholder="Height">
                                    </div>
                                    <span class="dimension-helper">Leave empty to maintain aspect ratio</span>
                                </div>
                            </div>
                            <div class="col-md-4 d-flex align-items-center justify-content-center">
                                <!-- Optimize Button -->
                                <button type="button" id="optimizeBtn" class="btn bg-gradient-primary btn-lg">
                                    Optimize Images
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Recent Optimizations -->
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <!-- Card header -->
                <div class="card-header pb-0">
                    <h5 class="mb-0">Recent Optimizations</h5>
                    <p class="text-sm mb-0">
                        View your optimized images.
                    </p>
                </div>
                <div class="table-responsive">
                    <table class="table table-flush" id="optimizationsTable">
                        <thead class="thead-light">
                            <tr>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">File</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Original Size</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Optimized Size</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Reduction</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Rows will be populated via JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<!-- jQuery -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
<!-- Dropzone JS -->
<script src="https://unpkg.com/dropzone@5/dist/min/dropzone.min.js"></script>
<!-- noUiSlider JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js"></script>
<!-- PhotoSwipe JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.js"></script>
<!-- SweetAlert2 -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<!-- Simple-DataTables -->
<script src="https://cdn.jsdelivr.net/npm/simple-datatables@latest"></script>

<script>
// Add global variable for placeholder image URL
window.PLACEHOLDER_IMAGE_URL = "{% static 'assets/neuralami/logos/NeuralamiLogo480x480SD.png' %}";

// Initialize quality slider with default configuration
const qualitySlider = document.getElementById('qualitySlider');
noUiSlider.create(qualitySlider, {
    start: 80,
    connect: 'lower',
    range: {
        'min': 0,
        'max': 100
    }
});

// Update quality value display
const qualityValue = document.querySelector('.quality-value');
qualitySlider.noUiSlider.on('update', function (values) {
    qualityValue.textContent = Math.round(values[0]) + '%';
});

// Prevent Dropzone from auto-discovering
Dropzone.autoDiscover = false;
</script>

<!-- Import our app -->
<script type="module">
    import { OptimizeApp } from "{% static 'image_optimizer/js/optimize_app.js' %}";
    
    // Initialize app and store globally (needed for DataTable access)
    window.optimizeApp = new OptimizeApp();
    
    // Initialize DataTable with exact same options as manage_tools.html
    window.optimizeApp.dataTable = new simpleDatatables.DataTable("#optimizationsTable", {
        searchable: true,
        fixedHeight: true,
        perPage: 25
    });
</script>

<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
{% endblock extra_js %}

================
File: apps/image_optimizer/admin.py
================
from django.contrib import admin
from .models import OptimizedImage

@admin.register(OptimizedImage)
class OptimizedImageAdmin(admin.ModelAdmin):
    list_display = ('original_file', 'user', 'original_size', 'optimized_size', 'compression_ratio', 'status', 'created_at')
    list_filter = ('status', 'created_at', 'user')
    search_fields = ('original_file', 'user__username')
    readonly_fields = ('compression_ratio', 'created_at')
    ordering = ('-created_at',)
    
    def get_readonly_fields(self, request, obj=None):
        if obj:  # editing an existing object
            return self.readonly_fields + ('original_size', 'optimized_size', 'original_file', 'optimized_file')
        return self.readonly_fields

================
File: apps/image_optimizer/apps.py
================
from django.apps import AppConfig


class ImageOptimizerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.image_optimizer'
    verbose_name = 'Image Optimizer'

    def ready(self):
        try:
            import apps.image_optimizer.signals
        except ImportError:
            pass

================
File: apps/image_optimizer/consumers.py
================
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
from channels.db import database_sync_to_async
from .models import OptimizedImage, OptimizationJob
import json
import logging

logger = logging.getLogger(__name__)

# Create a custom consumer that combines AsyncJsonWebsocketConsumer and OrganizationAwareConsumer
class OrganizationAwareJsonConsumer(OrganizationAwareConsumer):
    """
    Combines OrganizationAwareConsumer with AsyncJsonWebsocketConsumer functionality.
    """
    async def send_json(self, content, close=False):
        """Send JSON data to the client"""
        await self.send(text_data=json.dumps(content), close=close)
        
    async def receive_json(self, content):
        """
        Override to handle JSON messages. To be implemented by subclasses.
        """
        pass
        
    async def receive(self, text_data, **kwargs):
        """Parse the JSON content and call receive_json"""
        try:
            data = json.loads(text_data)
            await self.receive_json(data)
        except json.JSONDecodeError:
            logger.error("Invalid JSON received")
            await self.send_json({"error": "Invalid JSON"})

class OptimizationConsumer(OrganizationAwareJsonConsumer):
    async def connect(self):
        """Handle connection with organization context"""
        # Set organization context first
        await super().connect()
        
        # Get optimization_id from URL route
        self.optimization_id = self.scope['url_route']['kwargs']['optimization_id']
        self.job_group_name = None

        # Accept the connection
        await self.accept()

        # Add to optimization-specific group
        await self.channel_layer.group_add(
            f"optimization_{self.optimization_id}",
            self.channel_name
        )

        # Get job ID and add to job group if part of a job
        job_id = await self.get_job_id()
        if job_id:
            self.job_group_name = f"optimization_job_{job_id}"
            await self.channel_layer.group_add(
                self.job_group_name,
                self.channel_name
            )

    async def disconnect(self, close_code):
        """Handle disconnection"""
        # Remove from optimization group
        await self.channel_layer.group_discard(
            f"optimization_{self.optimization_id}",
            self.channel_name
        )

        # Remove from job group if part of a job
        if self.job_group_name:
            await self.channel_layer.group_discard(
                self.job_group_name,
                self.channel_name
            )
            
        # Clear organization context
        await super().disconnect(close_code)

    @database_sync_to_async
    def get_job_id(self):
        """Get job ID for the optimization"""
        try:
            optimization = OptimizedImage.objects.get(id=self.optimization_id)
            return optimization.job_id if optimization.job else None
        except OptimizedImage.DoesNotExist:
            return None

    async def optimization_update(self, event):
        """Handle optimization updates"""
        # Add message type to data
        data = event['data']
        data['type'] = 'optimization_update'
        # Send message to WebSocket
        await self.send_json(data)

    async def job_update(self, event):
        """Handle job updates"""
        # Add message type to data
        data = event['data']
        data['type'] = 'job_update'
        # Send message to WebSocket
        await self.send_json(data)

================
File: apps/image_optimizer/models.py
================
from django.db import models
from django.conf import settings
from core.storage import SecureFileStorage
from apps.organizations.models.mixins import OrganizationModelMixin

# Create storage for original and optimized images
original_images_storage = SecureFileStorage(
    private=True,
    collection='image_optimizer/original_images'
)

optimized_images_storage = SecureFileStorage(
    private=True,
    collection='image_optimizer/optimized_images'
)

def user_original_path(instance, filename):
    # Return only the filename since the collection is handled by SecureFileStorage
    return filename

def user_optimized_path(instance, filename):
    # Return only the filename since the collection is handled by SecureFileStorage
    return filename

class OptimizationJob(OrganizationModelMixin, models.Model):
    """
    Represents a batch job for optimizing multiple images.
    Uses OrganizationModelMixin with a nullable organization field for migration purposes.
    """
    # Override the organization field to make it nullable
    organization = models.ForeignKey(
        'organizations.Organization',
        on_delete=models.CASCADE,
        related_name="%(class)ss",
        null=True,
        blank=True
    )
    
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    settings_used = models.JSONField(help_text='Optimization settings used for all images')
    total_files = models.IntegerField(default=0)
    processed_files = models.IntegerField(default=0)
    total_original_size = models.BigIntegerField(default=0, help_text='Total size in bytes')
    total_optimized_size = models.BigIntegerField(default=0, help_text='Total size in bytes')

    class Meta:
        ordering = ['-created_at']

    def __str__(self):
        return f"Job {self.id} - {self.status} ({self.processed_files}/{self.total_files})"

    @property
    def progress_percentage(self):
        if self.total_files == 0:
            return 0
        return (self.processed_files / self.total_files) * 100

    @property
    def total_reduction_percentage(self):
        if self.total_original_size == 0:
            return 0
        return ((self.total_original_size - self.total_optimized_size) / self.total_original_size) * 100

class OptimizedImage(OrganizationModelMixin, models.Model):
    """
    Represents an individual image that has been optimized.
    Uses OrganizationModelMixin with a nullable organization field for migration purposes.
    """
    # Override the organization field to make it nullable
    organization = models.ForeignKey(
        'organizations.Organization',
        on_delete=models.CASCADE,
        related_name="%(class)ss",
        null=True,
        blank=True
    )
    
    STATUS_CHOICES = (
        ('pending', 'Pending'),
        ('processing', 'Processing'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
    )

    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    job = models.ForeignKey(OptimizationJob, on_delete=models.CASCADE, related_name='images', null=True, blank=True)
    original_file = models.FileField(upload_to=user_original_path, storage=original_images_storage)
    optimized_file = models.FileField(upload_to=user_optimized_path, storage=optimized_images_storage)
    original_size = models.IntegerField(help_text='Size in bytes')
    optimized_size = models.IntegerField(help_text='Size in bytes')
    compression_ratio = models.FloatField(help_text='Compression ratio in percentage')
    settings_used = models.JSONField(help_text='Optimization settings used')
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')

    class Meta:
        ordering = ['-created_at']
        verbose_name = 'Optimized Image'
        verbose_name_plural = 'Optimized Images'

    def __str__(self):
        return f"{self.original_file.name} - {self.compression_ratio}% compression"

    @property
    def size_reduction(self):
        """Returns size reduction in percentage"""
        return ((self.original_size - self.optimized_size) / self.original_size) * 100

================
File: apps/image_optimizer/routing.py
================
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/image-optimizer/(?P<optimization_id>\d+)/$', consumers.OptimizationConsumer.as_asgi()),
]

================
File: apps/image_optimizer/tasks.py
================
from celery import shared_task
from django.core.files.storage import default_storage
from django.core.files.uploadedfile import InMemoryUploadedFile
from rest_framework.test import APIRequestFactory
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.db import models
from apps.api.views import ImageOptimizeView
from .models import OptimizedImage, OptimizationJob
import io
import os
import logging
from django.utils.datastructures import MultiValueDict
from apps.organizations.utils import OrganizationContext
from contextlib import nullcontext

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

@shared_task
def optimize_image(optimization_id, organization_id=None):
    """
    Celery task to optimize a single image
    """
    optimization = None
    try:
        # Set organization context if provided
        from apps.organizations.utils import OrganizationContext
        from contextlib import nullcontext
        # Import OptimizedImage model at the function level to avoid circular imports
        from apps.image_optimizer.models import OptimizedImage
        
        # If organization_id is not provided, try to get it from the optimization object first
        if not organization_id:
            try:
                # Use unfiltered_objects to avoid organization filtering when fetching initial object
                optimization_obj = OptimizedImage.unfiltered_objects.get(id=optimization_id)
                organization_id = optimization_obj.organization_id
            except OptimizedImage.DoesNotExist:
                logger.error(f"OptimizedImage {optimization_id} not found when trying to get organization ID")
                return {'success': False, 'error': f'OptimizedImage {optimization_id} not found'}
            except Exception as e:
                logger.warning(f"Could not determine organization for optimization {optimization_id}: {str(e)}")
        
        # Verify that the OptimizedImage object exists before entering context manager
        try:
            # Check if optimization exists using unfiltered manager (no organization context yet)
            optimization_exists = OptimizedImage.unfiltered_objects.filter(id=optimization_id).exists()
            if not optimization_exists:
                logger.error(f"OptimizedImage {optimization_id} not found before entering organization context")
                return {'success': False, 'error': f'OptimizedImage {optimization_id} not found'}
        except Exception as e:
            logger.error(f"Error checking if optimization {optimization_id} exists: {str(e)}")
            return {'success': False, 'error': f'Error checking optimization existence: {str(e)}'}
        
        # Use organization context manager if we have an organization ID
        context_manager = OrganizationContext.organization_context(organization_id) if organization_id else nullcontext()
        
        with context_manager:
            try:
                logger.info(f"Starting optimization task for ID: {optimization_id}")
                # Use objects manager which is now organization-aware through the mixin
                optimization = OptimizedImage.objects.select_related('job').get(id=optimization_id)
                job = optimization.job
                logger.info(f"Found optimization record: {optimization.original_file.name}")
            except OptimizedImage.DoesNotExist:
                logger.error(f"OptimizedImage {optimization_id} not found after setting organization context (organization_id: {organization_id})")
                return {'success': False, 'error': f'OptimizedImage {optimization_id} not found in organization context'}

        # Send initial status update
        send_optimization_update(optimization_id, {
            'status': 'processing',
            'message': 'Starting optimization...'
        })
        
        # Read the original file
        with default_storage.open(optimization.original_file.name, 'rb') as f:
            file_content = f.read()
        logger.info(f"Read original file, size: {len(file_content)} bytes")
        
        # Create a new file object
        file_obj = InMemoryUploadedFile(
            io.BytesIO(file_content),
            'image',
            os.path.basename(optimization.original_file.name),
            'image/jpeg',  # Default to JPEG, ImageOptimizeView will handle actual type
            len(file_content),
            None
        )
        
        # Process the image directly with ImageOptimizeView
        optimizer = ImageOptimizeView()
        
        # Create data dict that matches what the serializer expects
        data = {
            'image': file_obj,
            'quality': optimization.settings_used['quality'],
        }
        
        # Only add dimensions if they have actual values
        if optimization.settings_used.get('max_width'):
            data['max_width'] = int(optimization.settings_used['max_width'])
        if optimization.settings_used.get('max_height'):
            data['max_height'] = int(optimization.settings_used['max_height'])
        
        # Use the serializer directly
        serializer = optimizer.serializer_class(data=data)
        if not serializer.is_valid():
            raise Exception(f"Invalid data: {serializer.errors}")
            
        # Process with validated data
        response = optimizer.process_image(
            serializer.validated_data['image'],
            serializer.validated_data['quality'],
            serializer.validated_data.get('max_width'),
            serializer.validated_data.get('max_height')
        )
        
        if response.status_code == 200:
            # Let the model handle the file path
            optimized_filename = f"{os.path.splitext(os.path.basename(optimization.original_file.name))[0]}.webp"
            
            # Save directly through the model's FileField
            with io.BytesIO(response.content) as f:
                optimization.optimized_file.save(optimized_filename, f, save=False)
            
            # Calculate reduction
            optimized_size = len(response.content)
            reduction = ((optimization.original_size - optimized_size) / optimization.original_size) * 100
            
            # Update optimization record
            optimization.optimized_size = optimized_size
            optimization.compression_ratio = reduction
            optimization.status = 'completed'
            optimization.save()

            # Update job statistics
            if job:
                job.processed_files = OptimizedImage.objects.filter(
                    job=job, status='completed'
                ).count()
                job.total_optimized_size = OptimizedImage.objects.filter(
                    job=job, status='completed'
                ).aggregate(total=models.Sum('optimized_size'))['total'] or 0
                
                if job.processed_files == job.total_files:
                    job.status = 'completed'
                job.save()
                # Send job update with accurate completion status
                job_data = {
                    'status': job.status,
                    'job_id': job.id,
                    'processed_files': job.processed_files,
                    'total_files': job.total_files,
                    'completed_count': job.processed_files,
                    'progress_percentage': (job.processed_files / job.total_files * 100) if job.total_files > 0 else 0
                }
                send_job_update(job.id, job_data)
                logger.info(f"Sent job update: {job_data}")

            # Send completion update for individual optimization
            result = {
                'success': True,
                'status': 'completed',
                'optimization_id': optimization.id,
                'job_id': job.id if job else None,
                'file_name': os.path.basename(optimization.original_file.name),
                'original_size': optimization.original_size,
                'optimized_size': optimized_size,
                'reduction': round(reduction, 2),
                'download_url': optimization.optimized_file.url,
                'message': 'Optimization completed successfully'
            }
            
            # Send optimization update first
            send_optimization_update(optimization_id, result)
            logger.info(f"Sent completion update: {result}")
            
            # If this is the last file in the job, send final job update
            if job and job.status == 'completed':
                final_job_data = {
                    'status': 'completed',
                    'job_id': job.id,
                    'processed_files': job.total_files,
                    'total_files': job.total_files,
                    'completed_count': job.total_files,
                    'progress_percentage': 100.0,
                    'total_reduction': ((job.total_original_size - job.total_optimized_size) / job.total_original_size * 100) if job.total_original_size > 0 else 0
                }
                send_job_update(job.id, final_job_data)
                logger.info(f"Sent final job completion update: {final_job_data}")
            
            return result
        else:
            error_msg = response.data.get('message', 'Optimization failed')
            logger.error(f"Optimization failed: {error_msg}")
            raise Exception(error_msg)
            
    except Exception as e:
        logger.error(f"Error in optimize_image task: {str(e)}", exc_info=True)
        error_data = {
            'success': False,
            'status': 'failed',
            'message': str(e)
        }
        
        if optimization:
            optimization.status = 'failed'
            optimization.save()
            logger.info("Updated optimization status to failed")
            
            if job:
                job.processed_files = OptimizedImage.objects.filter(
                    job=job, status__in=['completed', 'failed']
                ).count()
                if job.processed_files == job.total_files:
                    job.status = 'failed'
                job.save()
                logger.info("Updated job status to failed")

                # Send job update
                job_update_data = {
                    'status': job.status,
                    'processed_files': job.processed_files,
                    'total_files': job.total_files,
                    'progress_percentage': job.progress_percentage
                }
                send_job_update(job.id, job_update_data)
                logger.info(f"Sent job update for failure: {job_update_data}")

        send_optimization_update(optimization_id, error_data)
        logger.info(f"Sent error update: {error_data}")
        return error_data

def send_optimization_update(optimization_id, data):
    """Send update to optimization-specific WebSocket group"""
    try:
        async_to_sync(channel_layer.group_send)(
            f"optimization_{optimization_id}",
            {
                'type': 'optimization_update',
                'data': data
            }
        )
    except Exception as e:
        logger.error(f"Error sending optimization update: {str(e)}", exc_info=True)

def send_job_update(job_id, data):
    """Send update to job-specific WebSocket group"""
    try:
        async_to_sync(channel_layer.group_send)(
            f"optimization_job_{job_id}",
            {
                'type': 'job_update',
                'data': data
            }
        )
    except Exception as e:
        logger.error(f"Error sending job update: {str(e)}", exc_info=True)

================
File: apps/image_optimizer/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/image_optimizer/urls.py
================
from django.urls import path
from . import views

app_name = 'image_optimizer'

urlpatterns = [
    path('', views.dashboard, name='dashboard'),
    path('optimize/', views.optimize, name='optimize'),
    path('upload/', views.handle_upload, name='handle_upload'),
    path('history/', views.optimization_history, name='history'),
]

================
File: apps/image_optimizer/views.py
================
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.core.files.storage import default_storage
from django.conf import settings

from .models import OptimizedImage, OptimizationJob
from apps.api.views import ImageOptimizeView

import os
import json
from PIL import Image
import io
import logging

logger = logging.getLogger(__name__)

@login_required
def dashboard(request):
    """Dashboard view showing optimization statistics and recent optimizations"""
    recent_optimizations = OptimizedImage.objects.filter(user=request.user).order_by('-created_at')[:10]
    
    # Calculate overall statistics
    total_optimizations = OptimizedImage.objects.filter(user=request.user).count()
    total_saved = OptimizedImage.objects.filter(
        user=request.user, 
        status='completed'
    ).values_list('original_size', 'optimized_size')
    
    total_original = sum(orig for orig, _ in total_saved)
    total_optimized = sum(opt for _, opt in total_saved)
    avg_reduction = ((total_original - total_optimized) / total_original * 100) if total_original > 0 else 0
    
    context = {
        'recent_optimizations': recent_optimizations,
        'total_optimizations': total_optimizations,
        'avg_reduction': round(avg_reduction, 2),
        'total_saved_mb': round((total_original - total_optimized) / (1024 * 1024), 2)
    }
    
    return render(request, 'image_optimizer/dashboard.html', context)

@login_required
def optimize(request):
    """Main optimization interface"""
    return render(request, 'image_optimizer/optimize.html')

@login_required
@require_http_methods(["POST"])
def handle_upload(request):
    """Handle image upload and optimization"""
    try:
        logger.info(f"Received upload request from user: {request.user.username}")
        logger.info(f"Files in request: {request.FILES}")
        logger.info(f"POST data: {request.POST}")
        
        if 'file' not in request.FILES:
            logger.error("No file found in request")
            return JsonResponse({'success': False, 'message': 'No file was uploaded'}, status=400)

        uploaded_file = request.FILES['file']
        logger.info(f"Processing file: {uploaded_file.name} ({uploaded_file.size} bytes)")
        
        quality = int(request.POST.get('quality', 80))
        max_width = request.POST.get('max_width')
        max_height = request.POST.get('max_height')
        job_id = request.POST.get('job_id')
        
        logger.info(f"Parameters: quality={quality}, max_width={max_width}, max_height={max_height}, job_id={job_id}")

        # Convert empty strings to None
        max_width = int(max_width) if max_width else None
        max_height = int(max_height) if max_height else None

        # Get or create optimization job
        if job_id:
            logger.info(f"Using existing job: {job_id}")
            job = OptimizationJob.objects.get(id=job_id)
        else:
            logger.info("Creating new optimization job")
            job = OptimizationJob.objects.create(
                user=request.user,
                settings_used={
                    'quality': quality,
                    'max_width': max_width if max_width is not None else '',
                    'max_height': max_height if max_height is not None else ''
                },
                status='processing'
            )
            logger.info(f"Created new job: {job.id}")

        # Save original file
        original_size = uploaded_file.size
        logger.info(f"Saved original file: {uploaded_file.name} ({original_size} bytes)")

        # Update job statistics
        job.total_files += 1
        job.total_original_size += original_size
        job.save()
        logger.info(f"Updated job statistics: total_files={job.total_files}, total_size={job.total_original_size}")

        # Create optimization record
        optimization = OptimizedImage.objects.create(
            user=request.user,
            job=job,
            original_file=uploaded_file,
            original_size=original_size,
            optimized_size=original_size,  # Initial value, will be updated
            compression_ratio=0.0,  # Initial value, will be updated
            settings_used={
                'quality': quality,
                'max_width': max_width if max_width is not None else '',
                'max_height': max_height if max_height is not None else ''
            },
            status='processing'
        )
        logger.info(f"Created optimization record: {optimization.id}")

        # Start Celery task
        from .tasks import optimize_image
        task = optimize_image.delay(optimization.id)
        logger.info(f"Started optimization task: {task.id}")

        # Return initial response
        response_data = {
            'success': True,
            'message': 'File uploaded and queued for optimization',
            'optimization_id': optimization.id,
            'job_id': job.id,
            'task_id': task.id,
            'file_name': uploaded_file.name,
            'original_size': original_size,
            'status': 'processing'
        }
        logger.info(f"Sending response: {response_data}")
        return JsonResponse(response_data)

    except Exception as e:
        logger.error(f"Error processing image: {str(e)}", exc_info=True)
        return JsonResponse({
            'success': False,
            'message': f'Error processing image: {str(e)}'
        }, status=500)

@login_required
def optimization_history(request):
    """View for displaying optimization history"""
    optimizations = OptimizedImage.objects.filter(user=request.user)
    return render(request, 'image_optimizer/history.html', {'optimizations': optimizations})

================
File: apps/organizations/models/__init__.py
================
from .base import Organization, OrganizationMembership, Role, Permission
from .mixins import OrganizationModelMixin, OrganizationModelManager

__all__ = [
    'Organization',
    'OrganizationMembership',
    'Role',
    'Permission',
    'OrganizationModelMixin',
    'OrganizationModelManager',
]

================
File: apps/organizations/models/base.py
================
from django.db import models
from django.conf import settings
from django.utils import timezone
import uuid
from core.storage import SecureFileStorage

# Create a storage instance for organization logos
organization_logo_storage = SecureFileStorage(
    private=True,
    collection='organization_logos'
)

class Organization(models.Model):
    """
    A top-level entity that contains users, clients, and resources.
    Acts as the foundation for multi-tenancy in the application.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    owner = models.ForeignKey(
        settings.AUTH_USER_MODEL, 
        on_delete=models.CASCADE,
        related_name='owned_organizations'
    )
    is_active = models.BooleanField(default=True)
    settings = models.JSONField(default=dict, blank=True)
    billing_email = models.EmailField(blank=True, null=True)
    billing_details = models.JSONField(default=dict, blank=True)
    max_clients = models.PositiveIntegerField(default=5)  # Default until subscription plans are implemented
    logo = models.ImageField(
        upload_to='', 
        storage=organization_logo_storage,
        blank=True, 
        null=True
    )
    
    def __str__(self):
        return self.name
        
    class Meta:
        ordering = ['name']
        verbose_name = 'Organization'
        verbose_name_plural = 'Organizations'


class Permission(models.Model):
    """
    Represents a single permission that can be assigned to a role.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    codename = models.CharField(max_length=100, unique=True)
    name = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    category = models.CharField(max_length=100, help_text="For grouping related permissions")
    
    def __str__(self):
        return f"{self.name} ({self.codename})"
    
    class Meta:
        ordering = ['category', 'codename']
        verbose_name = 'Permission'
        verbose_name_plural = 'Permissions'


class Role(models.Model):
    """
    Defines a set of permissions that can be assigned to organization members.
    Can be system-wide or specific to an organization.
    """
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=100)
    organization = models.ForeignKey(
        Organization,
        on_delete=models.CASCADE,
        related_name='roles',
        null=True,
        blank=True,
        help_text="If null, this is a system-wide role"
    )
    is_system_role = models.BooleanField(default=False)
    permissions = models.ManyToManyField(
        Permission,
        related_name='roles'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    description = models.TextField(blank=True)
    
    def __str__(self):
        if self.organization:
            return f"{self.name} ({self.organization.name})"
        return f"{self.name} (System)"
    
    class Meta:
        unique_together = ('name', 'organization')
        ordering = ['organization', 'name']
        verbose_name = 'Role'
        verbose_name_plural = 'Roles'


class OrganizationMembership(models.Model):
    """
    Represents the relationship between a user and an organization,
    including their role and invitation status.
    """
    MEMBERSHIP_STATUS_CHOICES = (
        ('invited', 'Invited'),
        ('active', 'Active'),
        ('suspended', 'Suspended'),
    )
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    organization = models.ForeignKey(
        Organization, 
        on_delete=models.CASCADE,
        related_name='memberships'
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='organization_memberships'
    )
    role = models.ForeignKey(
        Role,
        on_delete=models.PROTECT,
        related_name='memberships'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    invited_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='sent_invitations'
    )
    status = models.CharField(
        max_length=20,
        choices=MEMBERSHIP_STATUS_CHOICES,
        default='invited'
    )
    invitation_sent_at = models.DateTimeField(null=True, blank=True)
    invitation_accepted_at = models.DateTimeField(null=True, blank=True)
    custom_permissions = models.JSONField(default=dict, blank=True)
    
    def __str__(self):
        return f"{self.user} in {self.organization} as {self.role}"
    
    class Meta:
        unique_together = ('organization', 'user')
        ordering = ['organization', 'user']
        verbose_name = 'Organization Membership'
        verbose_name_plural = 'Organization Memberships'

================
File: apps/organizations/models/mixins.py
================
import logging
from django.db import models
from django.db.models.query import QuerySet
import uuid

logger = logging.getLogger(__name__)

class OrganizationModelManager(models.Manager):
    """
    A model manager that automatically filters querysets based on the user's active organization.
    This ensures organization isolation at the query level without relying on view-level filtering.
    """
    def get_queryset(self):
        from ..utils import get_current_user, get_user_active_organization, get_current_organization
        
        queryset = super().get_queryset()
        user = get_current_user()
        
        # Superusers can see all records when needed
        if user and user.is_superuser:
            return queryset
            
        # Try to get from context directly first (most reliable)
        org = get_current_organization()
        if org:
            #logger.debug(f"Filtering queryset by organization from context: {org.id}")
            return queryset.filter(organization_id=org.id)
            
        # Regular users only see records from their organization
        if user and user.is_authenticated:
            org_id = get_user_active_organization(user)
            if org_id:
                # Handle UUID string vs object conversion
                if isinstance(org_id, str):
                    try:
                        org_id = uuid.UUID(org_id)
                    except (ValueError, AttributeError):
                        pass
                    
                #logger.debug(f"Filtering queryset by organization: {org_id} (type: {type(org_id).__name__})")
                return queryset.filter(organization_id=org_id)
                
        # No organization context = no access (empty queryset)
        logger.debug("No organization context found, returning empty queryset")
        return queryset.none()


class OrganizationUnfilteredManager(models.Manager):
    """
    A model manager that does not filter by organization.
    This should be used only in administrative contexts or internal code where
    accessing records across organizations is explicitly needed.
    """
    pass


class OrganizationModelMixin(models.Model):
    """
    Abstract model mixin that enforces organization-based access control.
    Models that inherit this will automatically be scoped to an organization.
    """
    organization = models.ForeignKey(
        'organizations.Organization',
        on_delete=models.CASCADE,
        related_name="%(class)ss"
    )
    
    # Organization-filtered manager - THIS IS NOW THE DEFAULT
    objects = OrganizationModelManager()
    
    # Unfiltered manager - use this explicitly only when needed
    unfiltered_objects = OrganizationUnfilteredManager()
    
    class Meta:
        abstract = True
    
    def save(self, *args, **kwargs):
        # Ensure new objects get assigned to the current user's organization
        if not self.pk and not self.organization_id:
            from ..utils import get_current_user, get_current_organization
            user = get_current_user()
            
            if user and user.is_authenticated:
                # Try to get the organization from thread local storage first
                organization = get_current_organization()
                
                if organization:
                    self.organization = organization
                    #logger.debug(f"Automatically set organization to {organization.name} for {self.__class__.__name__}")
                else:
                    # Fall back to querying the database for the user's active membership
                    try:
                        membership = user.organization_memberships.filter(status='active').first()
                        if membership:
                            self.organization = membership.organization
                            #logger.debug(f"Automatically set organization to {membership.organization.name} for {self.__class__.__name__}")
                    except Exception as e:
                        logger.error(f"Error setting organization automatically: {e}")
        
        super().save(*args, **kwargs)

    @classmethod
    def get_for_organization(cls, organization_id, **kwargs):
        """
        Helper method to get objects for a specific organization.
        
        Args:
            organization_id: The organization ID to filter by
            **kwargs: Additional filter parameters
            
        Returns:
            QuerySet: Filtered queryset
        """
        return cls.unfiltered_objects.filter(organization_id=organization_id, **kwargs)

================
File: apps/organizations/templates/organizations/components/organization_switcher.html
================
<!-- Organization Switcher Component -->
<div class="dropdown">
  <a href="#" class="nav-link d-flex align-items-center gap-2" id="orgSwitcherDropdown" data-bs-toggle="dropdown" aria-expanded="false">
    {% if current_organization.logo %}
      <img src="{{ current_organization.logo.url }}" alt="{{ current_organization.name }}" class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center d-flex align-items-center justify-content-center" width="24" height="24">
    {% else %}
      <span class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center d-flex align-items-center justify-content-center text-primary text-sm opacity-10" style="width: 24px; height: 24px;">
        {{ current_organization.name|slice:":1" }}
      </span>
    {% endif %}
    <span class="nav-link-text ms-1 text-truncate" style="max-width: 150px;">{{ current_organization.name }}</span>
    <i class="fas fa-caret-down ms-1"></i>
  </a>
  
  <ul class="dropdown-menu bg-white" aria-labelledby="orgSwitcherDropdown">
    <li class="dropdown-header">Your Organizations</li>
    
    {% for membership in memberships %}
      <li>
        <form method="post" action="{% url 'organizations:switch_organization' %}" class="m-0">
          {% csrf_token %}
          <input type="hidden" name="organization_id" value="{{ membership.organization.id }}">
          <input type="hidden" name="redirect_url" value="{{ request.path }}">
          
          <button type="submit" class="dropdown-item d-flex align-items-center gap-2 {% if membership.organization.id == current_organization.id %}active{% endif %}">
            {% if membership.organization.logo %}
              <img src="{{ membership.organization.logo.url }}" alt="{{ membership.organization.name }}" class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center d-flex align-items-center justify-content-center" width="24" height="24">
            {% else %}
              <span class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center d-flex align-items-center justify-content-center text-primary text-sm opacity-10" style="width: 24px; height: 24px;">
                {{ membership.organization.name|slice:":1" }}
              </span>
            {% endif %}
            <div class="d-flex flex-column">
              <span>{{ membership.organization.name }}</span>
              <small class="text-muted">{{ membership.role.name }}</small>
            </div>
            {% if membership.organization.id == current_organization.id %}
              <i class="fas fa-check ms-auto"></i>
            {% endif %}
          </button>
        </form>
      </li>
    {% endfor %}
    
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="{% url 'organizations:settings' %}">Organization Settings</a></li>
  </ul>
</div>

<style>
  .org-switcher .btn {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    color: #212529;
    font-weight: 500;
    padding: 0.375rem 0.75rem;
    max-width: 200px;
  }
  
  .org-switcher .org-name {
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  
  .org-switcher .dropdown-item.active {
    background-color: #f8f9fa;
    color: #212529;
  }
</style>

================
File: apps/organizations/templates/organizations/edit_organization.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Edit Organization {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <h6>Edit Organization</h6>
            <a href="{% url 'organizations:settings_specific' org_id=organization.id %}" class="btn btn-sm btn-outline-secondary">
              <i class="fas fa-arrow-left me-2"></i>Back to Settings
            </a>
          </div>
        </div>
        <div class="card-body">
          {% if messages %}
            {% for message in messages %}
              <div class="alert alert-{{ message.tags }}">
                {{ message }}
              </div>
            {% endfor %}
          {% endif %}
            
          <form method="post" enctype="multipart/form-data">
            {% csrf_token %}

            <!-- Organization Logo Preview -->
            <div class="row mb-4">
              <div class="col-md-4 offset-md-4 text-center">
                <label class="form-label">Organization Logo</label>
                <div class="position-relative">
                  <div class="org-logo mx-auto" id="logoPreview">
                    {% if organization.logo %}
                      <img src="{{ organization.logo.url }}" alt="{{ organization.name }}" id="orgLogoImg">
                    {% else %}
                      <span>{{ organization.name|slice:":1" }}</span>
                    {% endif %}
                  </div>
                  <div class="mt-2">{{ form.logo }}</div>
                  {% if form.logo.errors %}
                    <div class="text-danger">{{ form.logo.errors }}</div>
                  {% endif %}
                </div>
              </div>
            </div>

            <!-- Organization Details -->
            <div class="row">
              <div class="col-md-6">
                <div class="form-group">
                  <label class="form-control-label">{{ form.name.label }}</label>
                  {{ form.name }}
                  {% if form.name.errors %}
                    <div class="text-danger">{{ form.name.errors }}</div>
                  {% endif %}
                </div>
              </div>
              <div class="col-md-6">
                <div class="form-group">
                  <label class="form-control-label">{{ form.billing_email.label }}</label>
                  {{ form.billing_email }}
                  {% if form.billing_email.errors %}
                    <div class="text-danger">{{ form.billing_email.errors }}</div>
                  {% endif %}
                </div>
              </div>
            </div>

            <div class="form-group mt-3">
              <label class="form-control-label">{{ form.description.label }}</label>
              {{ form.description }}
              {% if form.description.errors %}
                <div class="text-danger">{{ form.description.errors }}</div>
              {% endif %}
            </div>

            <div class="form-group mt-4">
              <button type="submit" class="btn btn-primary">Save Changes</button>
              <a href="{% url 'organizations:settings_specific' org_id=organization.id %}" class="btn btn-outline-secondary ms-2">Cancel</a>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Logo preview functionality
    const logoInput = document.querySelector('input[type="file"]');
    const logoPreview = document.getElementById('logoPreview');
    
    logoInput.addEventListener('change', function() {
      const file = this.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          // Create or update image element
          let img = logoPreview.querySelector('img');
          if (!img) {
            img = document.createElement('img');
            img.id = 'orgLogoImg';
            logoPreview.innerHTML = '';
            logoPreview.appendChild(img);
          }
          img.src = e.target.result;
          img.alt = 'Organization Logo Preview';
        };
        reader.readAsDataURL(file);
      }
    });
  });
</script>
{% endblock extra_js %}

{% block stylesheets %}
<style>
  .org-logo {
    width: 150px;
    height: 150px;
    object-fit: cover;
    border-radius: 50%;
    background-color: #e9ecef;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3rem;
    color: #6c757d;
    margin: 0 auto;
    border: 2px dashed #dee2e6;
  }
  .org-logo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }
</style>
{% endblock stylesheets %}

================
File: apps/organizations/templates/organizations/settings.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Organization Settings {% endblock %}

{% block stylesheets %}
<style>
  .org-header {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
  }
  .org-logo {
    width: 100px;
    height: 100px;
    object-fit: cover;
    border-radius: 50%;
    background-color: #e9ecef;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2rem;
    color: #6c757d;
  }
  .org-logo img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }
  .member-card {
    border-radius: 8px;
    margin-bottom: 10px;
    transition: all 0.2s;
  }
  .member-card:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }
</style>
{% endblock stylesheets %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <h6>Organization Settings</h6>
            {% if is_owner or is_admin %}
            <a href="{% url 'organizations:edit' org_id=organization.id %}" class="btn btn-sm btn-primary">Edit Organization</a>
            {% endif %}
          </div>
        </div>
        <div class="card-body">
          <div class="row org-header">
            <div class="col-md-2 text-center">
              <div class="org-logo mx-auto">
                {% if organization.logo %}
                <img src="{{ organization.logo.url }}" alt="{{ organization.name }}">
                {% else %}
                {{ organization.name|slice:":1" }}
                {% endif %}
              </div>
            </div>
            <div class="col-md-10">
              <h3>{{ organization.name }}</h3>
              <p class="text-muted">{{ organization.description|default:"No description provided." }}</p>
              <div class="row">
                <div class="col-md-6">
                  <p><strong>Owner:</strong> {{ organization.owner.get_full_name|default:organization.owner.username }}</p>
                  <p><strong>Created:</strong> {{ organization.created_at|date:"F j, Y" }}</p>
                </div>
                <div class="col-md-6">
                  <p><strong>Status:</strong> 
                    {% if organization.is_active %}
                    <span class="badge bg-success">Active</span>
                    {% else %}
                    <span class="badge bg-danger">Inactive</span>
                    {% endif %}
                    
                    {% if is_owner or is_admin %}
                    <form method="post" action="{% url 'organizations:toggle_status' org_id=organization.id %}" style="display: inline-block; margin-left: 10px;">
                      {% csrf_token %}
                      <button type="submit" class="btn btn-sm {% if organization.is_active %}btn-outline-danger{% else %}btn-outline-success{% endif %}" 
                              onclick="return confirm('Are you sure you want to {% if organization.is_active %}deactivate{% else %}activate{% endif %} this organization?');">
                        {% if organization.is_active %}Deactivate{% else %}Activate{% endif %}
                      </button>
                    </form>
                    {% endif %}
                  </p>
                  <p><strong>Your Role:</strong> {{ active_membership.role.name }}</p>
                </div>
              </div>
            </div>
          </div>
          
          {% if is_owner or is_admin %}
          <div class="row mb-4">
            <div class="col-12">
              <div class="card">
                <div class="card-header pb-0">
                  <h6>Organization Status Information</h6>
                </div>
                <div class="card-body">
                  <p>Organization status controls what users can do with this organization:</p>
                  <div class="table-responsive">
                    <table class="table align-items-center mb-0">
                      <thead>
                        <tr>
                          <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                          <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Description</th>
                          <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Impact</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <td>
                            <span class="badge bg-success">Active</span>
                          </td>
                          <td>Organization is fully operational</td>
                          <td>Members can access all resources and create new content</td>
                        </tr>
                        <tr>
                          <td>
                            <span class="badge bg-danger">Inactive</span>
                          </td>
                          <td>Organization is temporarily disabled</td>
                          <td>Members can still log in, but cannot create new content or modify existing resources</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
          </div>
          {% endif %}
          
          <div class="row">
            <div class="col-12">
              <div class="d-flex justify-content-between align-items-center mb-3">
                <h5>Organization Members</h5>
                <a href="{% url 'organizations:members' %}" class="btn btn-sm btn-info">Manage Members</a>
              </div>
              
              <div class="table-responsive">
                <table class="table align-items-center mb-0">
                  <thead>
                    <tr>
                      <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Member</th>
                      <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Role</th>
                      <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                      <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Joined</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for member in members %}
                    <tr>
                      <td>
                        <div class="d-flex px-2 py-1">
                          <div>
                            {% if member.user.profile.avatar %}
                            <img src="{{ member.user.profile.avatar.url }}" class="avatar avatar-sm me-3" alt="{{ member.user.username }}">
                            {% else %}
                            <div class="avatar avatar-sm me-3 bg-gradient-secondary">{{ member.user.username|slice:":1" }}</div>
                            {% endif %}
                          </div>
                          <div class="d-flex flex-column justify-content-center">
                            <h6 class="mb-0 text-sm">{{ member.user.get_full_name|default:member.user.username }}</h6>
                            <p class="text-xs text-secondary mb-0">{{ member.user.email }}</p>
                          </div>
                        </div>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ member.role.name }}</p>
                      </td>
                      <td>
                        {% if member.status == 'active' %}
                        <span class="badge badge-sm bg-gradient-success">Active</span>
                        {% elif member.status == 'invited' %}
                        <span class="badge badge-sm bg-gradient-warning">Invited</span>
                        {% else %}
                        <span class="badge badge-sm bg-gradient-danger">Suspended</span>
                        {% endif %}
                      </td>
                      <td>
                        <span class="text-secondary text-xs font-weight-bold">{{ member.created_at|date:"M d, Y" }}</span>
                      </td>
                    </tr>
                    {% empty %}
                    <tr>
                      <td colspan="4" class="text-center py-3">No members found.</td>
                    </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
              
              {% if members.has_other_pages %}
              <div class="pagination-container mt-3">
                <nav aria-label="Page navigation">
                  <ul class="pagination justify-content-center">
                    {% if members.has_previous %}
                    <li class="page-item">
                      <a class="page-link" href="?page={{ members.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true">&laquo;</span>
                      </a>
                    </li>
                    {% else %}
                    <li class="page-item disabled">
                      <a class="page-link" href="#" aria-label="Previous">
                        <span aria-hidden="true">&laquo;</span>
                      </a>
                    </li>
                    {% endif %}
                    
                    {% for i in members.paginator.page_range %}
                    {% if members.number == i %}
                    <li class="page-item active"><a class="page-link" href="#">{{ i }}</a></li>
                    {% else %}
                    <li class="page-item"><a class="page-link" href="?page={{ i }}">{{ i }}</a></li>
                    {% endif %}
                    {% endfor %}
                    
                    {% if members.has_next %}
                    <li class="page-item">
                      <a class="page-link" href="?page={{ members.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true">&raquo;</span>
                      </a>
                    </li>
                    {% else %}
                    <li class="page-item disabled">
                      <a class="page-link" href="#" aria-label="Next">
                        <span aria-hidden="true">&raquo;</span>
                      </a>
                    </li>
                    {% endif %}
                  </ul>
                </nav>
              </div>
              {% endif %}
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block javascripts %}
<script>
  // Any JavaScript for the organization settings page
</script>
{% endblock javascripts %}

================
File: apps/organizations/templatetags/__init__.py
================
# Template tags package for the organizations app

================
File: apps/organizations/templatetags/organization_tags.py
================
from django import template
from django.utils.safestring import mark_safe
from apps.organizations.utils import get_current_organization

register = template.Library()

@register.simple_tag
def organization_context_indicator(resource_type="resource"):
    """
    Displays an organization context indicator for forms that create new resources.
    
    Args:
        resource_type (str): The type of resource being created (e.g., "client", "project")
        
    Returns:
        HTML markup for the organization context indicator
    """
    organization = get_current_organization()
    if not organization:
        return ""
    
    html = """
    <div class="alert alert-info d-flex align-items-center organization-context-alert">
        <i class="fas fa-building me-2"></i>
        <div>
            Creating new {resource_type} in <strong>{org_name}</strong>
        </div>
    </div>
    """.format(
        resource_type=resource_type,
        org_name=organization.name
    )
    
    return mark_safe(html)

@register.simple_tag
def organization_name():
    """
    Returns the name of the current organization or placeholder text if none.
    """
    organization = get_current_organization()
    if organization:
        return organization.name
    return "No Organization"

================
File: apps/organizations/tests/__init__.py
================
# Organization tests package

================
File: apps/organizations/tests/test_organization_context.py
================
from django.test import TestCase, RequestFactory
from django.contrib.auth import get_user_model
import uuid

from apps.organizations.models import Organization, OrganizationMembership, Role, Permission
from apps.organizations.utils import OrganizationContext, get_current_organization, set_current_organization

User = get_user_model()

class OrganizationContextTests(TestCase):
    """Tests for organization context propagation."""
    
    def setUp(self):
        """Set up test data."""
        # Create users
        self.user1 = User.objects.create_user(username='user1', email='user1@example.com', password='password')
        self.user2 = User.objects.create_user(username='user2', email='user2@example.com', password='password')
        
        # Create organizations with owners
        self.org1 = Organization.objects.create(name='Org 1', owner=self.user1)
        self.org2 = Organization.objects.create(name='Org 2', owner=self.user2)
        
        # Create a system role for testing
        self.member_role = Role.objects.create(
            name='Member',
            is_system_role=True,
            description='Basic access to view and work with assigned clients'
        )
        
        # Create memberships
        OrganizationMembership.objects.create(
            user=self.user1,
            organization=self.org1,
            status='active',
            role=self.member_role
        )
        OrganizationMembership.objects.create(
            user=self.user2,
            organization=self.org2,
            status='active',
            role=self.member_role
        )
        
        # Create request factory for tests
        self.factory = RequestFactory()
    
    def test_organization_context_get_set(self):
        """Test basic get/set of organization context."""
        # Set organization context
        set_current_organization(self.org1)
        
        # Check it was set correctly
        current_org = get_current_organization()
        self.assertEqual(current_org, self.org1)
        
        # Change to a different organization
        set_current_organization(self.org2)
        
        # Check it changed
        current_org = get_current_organization()
        self.assertEqual(current_org, self.org2)
    
    def test_organization_context_manager(self):
        """Test organization context manager."""
        # Set initial context
        set_current_organization(self.org1)
        self.assertEqual(get_current_organization(), self.org1)
        
        # Use context manager to temporarily change
        with OrganizationContext.organization_context(self.org2.id):
            self.assertEqual(get_current_organization(), self.org2)
            
            # Nested context
            with OrganizationContext.organization_context(self.org1.id):
                self.assertEqual(get_current_organization(), self.org1)
            
            # Back to second context
            self.assertEqual(get_current_organization(), self.org2)
        
        # Back to original
        self.assertEqual(get_current_organization(), self.org1)
    
    def test_organization_context_unified_api(self):
        """Test the unified organization context API."""
        # Clear context to start fresh
        OrganizationContext.clear_current()
        self.assertIsNone(OrganizationContext.get_current())
        
        # Set context using API
        OrganizationContext.set_current(self.org1)
        self.assertEqual(OrganizationContext.get_current(), self.org1)
        
        # Test with organization ID instead of object
        OrganizationContext.set_current(self.org2.id)
        self.assertEqual(OrganizationContext.get_current().id, self.org2.id)
        
        # Test with mocked request
        request = self.factory.get('/')
        request.organization = self.org1
        self.assertEqual(OrganizationContext.get_current(request), self.org1)
        
        # Clear context
        OrganizationContext.clear_current()
        self.assertIsNone(OrganizationContext.get_current())

================
File: apps/organizations/admin.py
================
from django.contrib import admin
from .models import Organization, OrganizationMembership, Role, Permission

@admin.register(Organization)
class OrganizationAdmin(admin.ModelAdmin):
    list_display = ('name', 'owner', 'is_active', 'created_at')
    list_filter = ('is_active',)
    search_fields = ('name', 'description', 'owner__username')
    date_hierarchy = 'created_at'
    readonly_fields = ('created_at', 'updated_at')

@admin.register(Role)
class RoleAdmin(admin.ModelAdmin):
    list_display = ('name', 'organization', 'is_system_role', 'created_at')
    list_filter = ('is_system_role', 'organization')
    search_fields = ('name', 'description')
    filter_horizontal = ('permissions',)
    readonly_fields = ('created_at', 'updated_at')

@admin.register(Permission)
class PermissionAdmin(admin.ModelAdmin):
    list_display = ('codename', 'name', 'category')
    list_filter = ('category',)
    search_fields = ('codename', 'name', 'description')

@admin.register(OrganizationMembership)
class OrganizationMembershipAdmin(admin.ModelAdmin):
    list_display = ('user', 'organization', 'role', 'status', 'created_at')
    list_filter = ('status', 'organization', 'role')
    search_fields = ('user__username', 'user__email', 'organization__name')
    readonly_fields = ('created_at', 'updated_at', 'invitation_sent_at', 'invitation_accepted_at')

================
File: apps/organizations/apps.py
================
from django.apps import AppConfig
import logging

logger = logging.getLogger(__name__)

class OrganizationsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.organizations'
    
    def ready(self):
        """
        Apply organization security enhancements when the app is ready.
        This includes patching Django's shortcuts with our secure versions.
        """
        #logger.info("Initializing organization security features")
        
        # Patch Django's shortcuts with secure versions
        from .shortcuts import patch_django_shortcuts
        patch_django_shortcuts()
        
        #logger.info("Organization security features initialized")

================
File: apps/organizations/forms.py
================
from django import forms
from .models.base import Organization

class OrganizationForm(forms.ModelForm):
    """
    Form for creating and editing organizations.
    """
    class Meta:
        model = Organization
        fields = ['name', 'description', 'logo', 'billing_email']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Organization Name'
            }),
            'description': forms.Textarea(attrs={
                'class': 'form-control',
                'placeholder': 'Description of your organization',
                'rows': 4
            }),
            'logo': forms.FileInput(attrs={
                'class': 'form-control',
                'accept': 'image/*'
            }),
            'billing_email': forms.EmailInput(attrs={
                'class': 'form-control',
                'placeholder': 'billing@example.com'
            }),
        }

    def clean_name(self):
        """Validate that the organization name is unique."""
        name = self.cleaned_data.get('name')
        instance = getattr(self, 'instance', None)
        
        # If editing an existing organization
        if instance and instance.pk:
            # If the name hasn't been changed, it's valid
            if instance.name == name:
                return name
                
            # If name changed, check it doesn't conflict with other organizations
            if Organization.objects.filter(name=name).exclude(pk=instance.pk).exists():
                raise forms.ValidationError("An organization with this name already exists.")
        # If creating a new organization, check name doesn't exist
        elif name and Organization.objects.filter(name=name).exists():
            raise forms.ValidationError("An organization with this name already exists.")
        
        return name

================
File: apps/organizations/middleware.py
================
import logging
from django.core.exceptions import PermissionDenied
from django.shortcuts import redirect
from django.contrib import messages
from django.urls import resolve, reverse
from .utils import set_current_user, set_current_organization, clear_organization_context, get_current_organization
from .models.base import Organization

logger = logging.getLogger(__name__)

class OrganizationMiddleware:
    """
    Middleware that stores the current user and their active organization
    in context variables for access throughout the request lifecycle.
    
    Using ContextVars instead of thread-local storage enables this middleware
    to work properly in both synchronous and asynchronous contexts.
    """
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Clear organization context at the start of each request
        clear_organization_context()
        
        if request.user.is_authenticated:
            # Set the current user
            set_current_user(request.user)
            
            # Try to get the active organization from session
            active_org_id = request.session.get('active_organization_id')
            
            if active_org_id:
                # Verify user membership in this organization
                try:
                    membership = request.user.organization_memberships.filter(
                        organization_id=active_org_id, 
                        status='active'
                    ).select_related('organization').first()
                    
                    if membership:
                        set_current_organization(membership.organization)
                except Exception as e:
                    logger.error(f"Error setting organization context from session: {e}")
            
            # If no organization set from session, fall back to first active membership
            if not get_current_organization():
                try:
                    membership = request.user.organization_memberships.filter(
                        status='active'
                    ).select_related('organization').first()
                    
                    if membership:
                        set_current_organization(membership.organization)
                        
                        # Store in session for future requests
                        request.session['active_organization_id'] = str(membership.organization.id)
                        request.session['active_organization_name'] = membership.organization.name
                except Exception as e:
                    logger.error(f"Error setting organization context: {e}")
            
            # Log the final organization context before assigning to request
            final_org = get_current_organization()
            request.organization = final_org # Assign to request
            
            # Check if organization is inactive and restrict certain operations
            current_org = get_current_organization()
            if current_org and not current_org.is_active and request.method == 'POST':
                # Get the current view name
                resolver_match = resolve(request.path)
                view_name = resolver_match.view_name if resolver_match else ''
                
                # List of allowed POST views for inactive organizations
                allowed_views = [  
                    'organizations:toggle_status',
                    'organizations:switch_organization',
                    'logout', 
                    'password_change'
                ]
                
                # If the view is not in allowed views, restrict it
                if view_name not in allowed_views and not request.user.is_superuser:
                    messages.error(
                        request, 
                        f"This organization is currently inactive. Contact the organization owner or an administrator."
                    )
                    # Determine redirect URL based on the current path
                    if 'organizations/settings' in request.path:
                        return redirect('organizations:settings')
                    else:
                        return redirect('dashboard')
        
        # Process the request
        response = self.get_response(request)
        
        # Clean up at the end of the request
        clear_organization_context()
        
        return response

# For ASGI applications, an async middleware version is also needed
class OrganizationMiddlewareAsync:
    """
    Async version of the OrganizationMiddleware for ASGI applications.
    This is used when the application is running in an async context.
    """
    def __init__(self, inner):
        self.inner = inner
        
    async def __call__(self, scope, receive, send):
        # Process only if this is a http or websocket scope
        if scope["type"] not in ["http", "websocket"]:
            return await self.inner(scope, receive, send)
            
        # Clear organization context at the start
        clear_organization_context()
        
        # Check if user is authenticated
        if "user" in scope and scope["user"].is_authenticated:
            user = scope["user"]
            # Set the current user
            set_current_user(user)
            
            # Try to get the active organization for this user
            try:
                # First try to get from session 
                session = scope.get("session", {})
                active_org_id = session.get('active_organization_id')
                
                if active_org_id:
                    membership = await self._get_membership_by_org_id(user, active_org_id)
                    if membership:
                        set_current_organization(membership.organization)
            except Exception as e:
                logger.error(f"Error setting organization context for {scope['type']}: {e}")
            
        # Call the inner application, maintaining the organization context
        try:
            return await self.inner(scope, receive, send)
        finally:
            # Clean up organization context when done
            clear_organization_context()

    async def _get_membership_by_org_id(self, user, org_id):
        """Helper method to get membership asynchronously - actual implementation would use database_sync_to_async"""
        from django.db.models.query import QuerySet
        from asgiref.sync import sync_to_async
        
        get_membership = sync_to_async(lambda: user.organization_memberships.filter(
            organization_id=org_id, 
            status='active'
        ).select_related('organization').first())
        
        return await get_membership()
        
    async def _get_first_active_membership(self, user):
        """Helper method to get first active membership asynchronously"""
        from asgiref.sync import sync_to_async
        
        get_membership = sync_to_async(lambda: user.organization_memberships.filter(
            status='active'
        ).select_related('organization').first())
        
        return await get_membership()


class OrganizationSecurityMiddleware:
    """
    Middleware that automatically intercepts responses and checks if
    there's any unauthorized cross-organization access.
    
    This acts as a safety net to prevent data leakage between organizations
    even if developers forget to add explicit checks.
    """
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # Process request normally
        response = self.get_response(request)
        
        # Skip for anonymous users, superusers, or non-HTML responses
        if not request.user.is_authenticated or request.user.is_superuser:
            return response
            
        # Skip admin, static, media, and API requests
        skip_paths = ['/admin/', '/static/', '/media/', '/api/']
        if any(request.path.startswith(path) for path in skip_paths):
            return response
            
        # Only process TemplateResponse objects that have context_data
        if hasattr(response, 'context_data') and response.context_data:
            try:
                self._validate_context_objects(request, response.context_data)
            except PermissionDenied as e:
                logger.warning(
                    f"Organization security violation detected: {str(e)}. "
                    f"User: {request.user.username}, Path: {request.path}, "
                    f"Organization: {getattr(get_current_organization(), 'name', 'None')}"
                )
                # Re-raise the exception to be handled by Django's exception middleware
                raise
            
        return response
        
    def _validate_context_objects(self, request, context):
        """Validate all objects in the template context for organization isolation."""
        from django.db.models import Model
        from django.db.models.query import QuerySet
        
        current_org = get_current_organization()
        if not current_org:
            return
            
        # Check all context items that might be model instances or querysets
        for key, value in context.items():
            # Skip non-data items
            if key.startswith('_') or callable(value) or isinstance(value, (str, int, bool, float)):
                continue
                
            # Check single model instances
            if isinstance(value, Model) and hasattr(value, 'organization_id'):
                if value.organization_id and str(value.organization_id) != str(current_org.id):
                    raise PermissionDenied(
                        f"Unauthorized access to {value.__class__.__name__} ({key}) "
                        f"from organization {value.organization_id} (user's organization: {current_org.id})"
                    )
                    
            # Check querysets
            elif isinstance(value, QuerySet) and hasattr(value.model, 'organization'):
                # We'll just check the first few items as a sample - checking all could be expensive
                for item in value[:10]:
                    if hasattr(item, 'organization_id'):
                        if item.organization_id and str(item.organization_id) != str(current_org.id):
                            raise PermissionDenied(
                                f"Unauthorized access to {item.__class__.__name__} in {key} "
                                f"from organization {item.organization_id} (user's organization: {current_org.id})"
                            )
            
            # Check lists and other iterables
            elif hasattr(value, '__iter__') and not isinstance(value, (str, bytes, dict)):
                for item in value:
                    if isinstance(item, Model) and hasattr(item, 'organization_id'):
                        if item.organization_id and str(item.organization_id) != str(current_org.id):
                            raise PermissionDenied(
                                f"Unauthorized access to {item.__class__.__name__} in {key} list "
                                f"from organization {item.organization_id} (user's organization: {current_org.id})"
                            ) 


# Async version of the security middleware
class OrganizationSecurityMiddlewareAsync:
    """
    Async version of the OrganizationSecurityMiddleware for ASGI applications.
    """
    def __init__(self, inner):
        self.inner = inner
        
    async def __call__(self, scope, receive, send):
        # Skip non-http scopes
        if scope["type"] != "http":
            return await self.inner(scope, receive, send)
            
        # Skip for anonymous users, superusers
        if not scope["user"].is_authenticated or scope["user"].is_superuser:
            return await self.inner(scope, receive, send)
            
        # Skip admin, static, media, and API requests
        skip_paths = ['/admin/', '/static/', '/media/', '/api/']
        if any(scope["path"].startswith(path) for path in skip_paths):
            return await self.inner(scope, receive, send)

        # We can't inspect/validate template context in ASGI middleware
        # This would need to be done in an actual view or template processor
        # The security check must happen in sync context

        return await self.inner(scope, receive, send)

================
File: apps/organizations/shortcuts.py
================
import logging
from django.shortcuts import get_object_or_404 as django_get_object_or_404
from django.core.exceptions import PermissionDenied
from .utils import get_current_organization, get_current_user

logger = logging.getLogger(__name__)

def get_object_or_404(*args, **kwargs):
    """
    Drop-in secure replacement for Django's get_object_or_404 that enforces
    organization-based access control automatically.
    
    Works with both synchronous and asynchronous code via ContextVars.
    
    Args:
        Same arguments as Django's get_object_or_404
        
    Returns:
        The requested object if it exists and belongs to the current organization
        
    Raises:
        Http404: If the object doesn't exist
        PermissionDenied: If the object belongs to a different organization
    """
    # Get the object using Django's function
    obj = django_get_object_or_404(*args, **kwargs)
    
    # Skip security check for superusers
    user = get_current_user()
    if user and user.is_superuser:
        return obj
    
    # If the object has an organization field, verify access
    if hasattr(obj, 'organization_id'):
        current_org = get_current_organization()
        if (current_org and obj.organization_id and 
            str(obj.organization_id) != str(current_org.id)):
                
            logger.warning(
                f"Organization security violation detected in get_object_or_404. "
                f"User: {getattr(user, 'username', 'None')}, "
                f"Object: {obj.__class__.__name__} (ID: {obj.pk}), "
                f"Object organization: {obj.organization_id}, "
                f"User organization: {current_org.id}"
            )
            
            raise PermissionDenied(
                f"You don't have access to this {obj.__class__.__name__}"
            )
    
    return obj

# Async version of the same function
async def aget_object_or_404(*args, **kwargs):
    """
    Async version of get_object_or_404 that enforces organization-based access control.
    This works with async views and contexts.
    
    Args:
        Same arguments as Django's get_object_or_404
        
    Returns:
        The requested object if it exists and belongs to the current organization
        
    Raises:
        Http404: If the object doesn't exist
        PermissionDenied: If the object belongs to a different organization
    """
    # In fully async implementations, this would use a Django async ORM method
    # For now, we're just wrapping the synchronous method
    
    from asgiref.sync import sync_to_async
    
    # Run the synchronous version in a thread
    obj = await sync_to_async(get_object_or_404)(*args, **kwargs)
    return obj

def patch_django_shortcuts():
    """
    Patches Django's shortcuts module to replace get_object_or_404 with our secure version.
    This should be called in AppConfig.ready() to apply globally.
    """
    import django.shortcuts
    django.shortcuts.get_object_or_404 = get_object_or_404
    
    # In Django 4.1+, patch the async version as well
    try:
        if hasattr(django.shortcuts, 'aget_object_or_404'):
            django.shortcuts.aget_object_or_404 = aget_object_or_404
            #logger.info("Django shortcuts patched with secure sync and async get_object_or_404")
        else:
            #logger.info("Django shortcuts patched with secure get_object_or_404 (async version not available)")
            pass
    except Exception as e:
        logger.warning(f"Error patching async shortcuts: {e}")
        logger.info("Django shortcuts patched with secure get_object_or_404 only")

================
File: apps/organizations/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/organizations/urls.py
================
from django.urls import path
from . import views

app_name = 'organizations'

urlpatterns = [
    path('settings/', views.organization_settings, name='settings'),
    path('settings/<uuid:org_id>/', views.organization_settings, name='settings_specific'),
    path('edit/<uuid:org_id>/', views.edit_organization, name='edit'),
    path('members/', views.organization_members, name='members'),
    path('switch/', views.switch_organization, name='switch_organization'),
    path('switcher/', views.organization_switcher, name='switcher'),
    path('toggle-status/<uuid:org_id>/', views.toggle_organization_status, name='toggle_status'),
]

================
File: apps/organizations/utils.py
================
import threading
import logging
from contextlib import contextmanager
import contextvars  # Add contextvars import

logger = logging.getLogger(__name__)

# Context variables for organization context (replaces thread local storage)
_user_var = contextvars.ContextVar('user', default=None)
_organization_var = contextvars.ContextVar('organization', default=None)

# Keep thread local storage for backward compatibility during transition
_thread_locals = threading.local()

def get_current_user():
    """
    Get the current user from context variable or thread local storage.
    
    Returns:
        User or None: The current user or None if not set
    """
    # Try contextvars first
    user = _user_var.get()
    if user is not None:
        return user
    
    # Fall back to thread local for backward compatibility
    return getattr(_thread_locals, 'user', None)

def set_current_user(user):
    """
    Set the current user in context variable and thread local storage.
    
    Args:
        user (User): The user to set as current
    """
    # Set in contextvars
    _user_var.set(user)
    
    # Also set in thread local for backward compatibility
    _thread_locals.user = user

def get_current_organization():
    """
    Get the current organization from context variable or thread local storage.
    
    Returns:
        Organization or None: The current organization or None if not set
    """
    # Try contextvars first
    org = _organization_var.get()
    if org is not None:
        return org
    
    # Fall back to thread local for backward compatibility
    return getattr(_thread_locals, 'organization', None)

def set_current_organization(organization):
    """
    Set the current organization in context variable and thread local storage.
    
    Args:
        organization (Organization): The organization to set as current
    """
    # Set in contextvars
    _organization_var.set(organization)
    
    # Also set in thread local for backward compatibility
    _thread_locals.organization = organization

def get_user_active_organization(user=None):
    """
    Get active organization ID for the user.
    First checks context variable, then falls back to database query.
    
    Args:
        user (User, optional): The user to get the organization for. 
                              If None, uses current user from context variable.
    
    Returns:
        UUID or None: The organization ID or None if not found
    """
    if not user:
        user = get_current_user()
    
    if not user or not user.is_authenticated:
        return None
        
    # Get from context variable if available
    org = get_current_organization()
    if org:
        return org.id
        
    # Otherwise query the database
    try:
        membership = user.organization_memberships.filter(status='active').first()
        return membership.organization.id if membership else None
    except Exception as e:
        logger.error(f"Error getting user's active organization: {e}")
        return None

def clear_organization_context():
    """
    Clear the organization context from context variables and thread local storage.
    Call this at the end of a request or when the context is no longer needed.
    """
    # Clear contextvars
    _user_var.set(None)
    _organization_var.set(None)
    
    # Also clear thread local for backward compatibility
    if hasattr(_thread_locals, 'user'):
        delattr(_thread_locals, 'user')
    
    if hasattr(_thread_locals, 'organization'):
        delattr(_thread_locals, 'organization')

class OrganizationContext:
    """
    Class for managing organization context.
    Provides methods for getting, setting, and temporarily switching the current organization.
    Works with both synchronous and asynchronous code using ContextVars.
    """
    
    @classmethod
    def get_current(cls, request=None):
        """
        Get organization from multiple possible sources.
        
        Args:
            request (HttpRequest, optional): The current request, if available
            
        Returns:
            Organization or None: The current organization or None if not found
        """
        # Try request first (highest priority)
        if request and hasattr(request, 'organization'):
            return request.organization
               
        # Try context variable storage
        org = get_current_organization()
        if org:
            return org
               
        # Get from current user's membership
        user = get_current_user()
        if user and user.is_authenticated:
            # Get organization ID
            org_id = get_user_active_organization(user)
            if org_id:
                # Convert ID to organization object if needed
                if not isinstance(org_id, (str, int)):
                    return org_id  # Already an organization object
                    
                # Import here to avoid circular imports
                from apps.organizations.models import Organization
                try:
                    return Organization.objects.get(id=org_id)
                except Exception as e:
                    logger.error(f"Error getting organization object: {e}")
                    
        return None
       
    @classmethod
    def set_current(cls, organization, request=None):
        """
        Set organization in all relevant storage mechanisms.
        
        Args:
            organization (Organization): The organization to set as current
            request (HttpRequest, optional): The current request, if available
        """
        # Set in context variable storage
        set_current_organization(organization)
           
        # Set in request if provided
        if request:
            request.organization = organization
       
    @classmethod
    @contextmanager
    def organization_context(cls, organization_id):
        """
        Context manager for temporarily setting organization context.
        Works in both sync and async code thanks to ContextVars.
        
        Args:
            organization_id: The ID of the organization to set as current
            
        Yields:
            Organization: The organization object
        """
        if organization_id is None:
            # Handle null organization_id gracefully
            logger.warning("organization_context called with None organization_id")
            yield None
            return
            
        # Save tokens for restoring context later
        user_token = _user_var.set(_user_var.get())
        org_token = _organization_var.set(_organization_var.get())
        
        try:
            # Import here to avoid circular imports
            from apps.organizations.models import Organization
            
            # Get the organization object
            try:
                organization = Organization.objects.get(id=organization_id)
                # Set as current
                cls.set_current(organization)
                logger.debug(f"Organization context set to: {organization.name} ({organization.id})")
                yield organization
            except Organization.DoesNotExist:
                logger.error(f"Organization with ID {organization_id} not found")
                cls.set_current(None)
                yield None
            except Exception as e:
                logger.error(f"Error in organization_context: {str(e)}", exc_info=True)
                cls.set_current(None)
                yield None
        except Exception as e:
            # Catch all exceptions to ensure context is always restored
            logger.error(f"Unexpected error in organization_context: {str(e)}", exc_info=True)
            cls.set_current(None)
            yield None
        finally:
            # Restore previous context
            try:
                _user_var.reset(user_token)
                _organization_var.reset(org_token)
                logger.debug("Organization context reset to previous value")
            except Exception as e:
                # Make sure we don't break even if resetting fails
                logger.error(f"Error resetting organization context: {str(e)}", exc_info=True)
                # Clear context as a fallback
                clear_organization_context()

================
File: apps/organizations/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.paginator import Paginator
from django.http import JsonResponse, HttpResponseForbidden, HttpResponseRedirect
from django.urls import reverse
from django.views.decorators.http import require_POST
from django.utils.decorators import method_decorator
from django.views.generic import ListView, DetailView, UpdateView, CreateView, DeleteView
from .models.base import Organization, OrganizationMembership, Role, Permission
from .forms import OrganizationForm
from .utils import set_current_organization, get_current_organization
import logging

logger = logging.getLogger(__name__)

@login_required
def organization_settings(request, org_id=None):
    """
    View for organization settings page.
    If org_id is not provided, uses the user's current organization.
    """
    # Get the organization, either by ID or current context
    if org_id:
        organization = get_object_or_404(Organization, pk=org_id)
        # Check if user is a member of this organization
        if not request.user.organization_memberships.filter(organization=organization, status='active').exists():
            messages.error(request, "You don't have access to this organization.")
            return redirect('dashboard')
    else:
        organization = get_current_organization()
        if not organization:
            messages.error(request, "You need to be part of an organization to access settings.")
            return redirect('dashboard')
    
    # Get user's membership to check permissions
    try:
        user_membership = OrganizationMembership.objects.get(user=request.user, organization=organization, status='active')
        is_owner = organization.owner == request.user
        is_admin = user_membership.role.permissions.filter(codename='manage_organization').exists()
    except OrganizationMembership.DoesNotExist:
        is_owner = False
        is_admin = False
    
    members = OrganizationMembership.objects.filter(organization=organization).select_related('user', 'role')
    
    return render(request, 'organizations/settings.html', {
        'organization': organization,
        'members': members,
        'is_owner': is_owner,
        'is_admin': is_admin,
        'active_membership': user_membership,
    })

@login_required
@require_POST
def toggle_organization_status(request, org_id):
    """
    Toggle the active status of an organization.
    Only organization owners and admins can change organization status.
    """
    organization = get_object_or_404(Organization, pk=org_id)
    
    # Check if user has permission to modify organization status
    try:
        membership = OrganizationMembership.objects.get(
            user=request.user, 
            organization=organization, 
            status='active'
        )
        is_owner = organization.owner == request.user
        is_admin = membership.role.permissions.filter(codename='manage_organization').exists()
        
        if not (is_owner or is_admin):
            messages.error(request, "You don't have permission to change organization status.")
            return redirect('organizations:settings_specific', org_id=org_id)
            
    except OrganizationMembership.DoesNotExist:
        messages.error(request, "You are not a member of this organization.")
        return redirect('dashboard')
    
    # Toggle the status
    organization.is_active = not organization.is_active
    organization.save()
    
    # Log the action
    action = "activated" if organization.is_active else "deactivated"
    logger.info(
        f"Organization {organization.name} {action} by {request.user.username}"
    )
    
    # Show appropriate message
    status_message = "activated" if organization.is_active else "deactivated"
    messages.success(request, f"Organization has been {status_message} successfully.")
    
    return redirect('organizations:settings_specific', org_id=org_id)

@login_required
@require_POST
def switch_organization(request):
    """
    View to switch the user's active organization.
    """
    org_id = request.POST.get('organization_id')
    redirect_url = request.POST.get('redirect_url', 'dashboard')
    
    if not org_id:
        messages.error(request, "No organization specified.")
        return HttpResponseRedirect(redirect_url)
    
    # Check if the user is a member of this organization
    try:
        membership = request.user.organization_memberships.get(
            organization_id=org_id,
            status='active'
        )
        
        # Set this as the user's active organization in session
        request.session['active_organization_id'] = str(membership.organization.id)
        request.session['active_organization_name'] = membership.organization.name
        
        # Update thread-local storage for current request
        set_current_organization(membership.organization)
        
        messages.success(request, f"Now viewing {membership.organization.name}")
        logger.info(f"User {request.user.username} switched to organization {membership.organization.name}")
        
    except OrganizationMembership.DoesNotExist:
        messages.error(request, "You are not a member of this organization.")
        logger.warning(f"User {request.user.username} attempted to switch to unauthorized organization {org_id}")
    
    return HttpResponseRedirect(redirect_url)

@login_required
def organization_switcher(request):
    """
    View to render the organization switcher component.
    """
    user_memberships = request.user.organization_memberships.filter(
        status='active'
    ).select_related('organization', 'role')
    
    current_org = get_current_organization()
    
    return render(request, 'organizations/components/organization_switcher.html', {
        'memberships': user_memberships,
        'current_organization': current_org,
    })

@login_required
def organization_members(request):
    """
    View for organization members management page.
    Lists members and allows admins to manage them.
    """
    # Get the user's active organization memberships
    user_memberships = request.user.organization_memberships.filter(status='active')
    
    if not user_memberships.exists():
        messages.warning(request, "You don't belong to any organization. Please contact an administrator.")
        return redirect('home')
    
    # For now, use the first active organization
    active_membership = user_memberships.first()
    organization = active_membership.organization
    
    # Check if user is owner or admin
    is_owner = organization.owner == request.user
    is_admin = active_membership.role.permissions.filter(codename='manage_members').exists()
    
    if not is_owner and not is_admin:
        messages.error(request, "You don't have permission to manage organization members.")
        return redirect('organizations:settings')
    
    # Get organization members
    members = OrganizationMembership.objects.filter(
        organization=organization
    ).select_related('user', 'role').order_by('user__username')
    
    # Paginate members
    paginator = Paginator(members, 10)
    page_number = request.GET.get('page', 1)
    members_page = paginator.get_page(page_number)
    
    # Get available roles for dropdown
    available_roles = Role.objects.filter(
        organization=organization
    ) | Role.objects.filter(is_system_role=True)
    
    context = {
        'organization': organization,
        'members': members_page,
        'is_owner': is_owner,
        'is_admin': is_admin,
        'active_membership': active_membership,
        'available_roles': available_roles,
    }
    
    return render(request, 'organizations/members.html', context)

@login_required
def edit_organization(request, org_id):
    """
    View for editing organization details.
    Only organization owners and admins can edit organization details.
    """
    organization = get_object_or_404(Organization, pk=org_id)
    
    # Check if user has permission to edit organization
    try:
        membership = OrganizationMembership.objects.get(
            user=request.user, 
            organization=organization, 
            status='active'
        )
        is_owner = organization.owner == request.user
        is_admin = membership.role.permissions.filter(codename='manage_organization').exists()
        
        if not (is_owner or is_admin):
            messages.error(request, "You don't have permission to edit this organization.")
            return redirect('organizations:settings_specific', org_id=org_id)
            
    except OrganizationMembership.DoesNotExist:
        messages.error(request, "You are not a member of this organization.")
        return redirect('dashboard')
    
    if request.method == 'POST':
        form = OrganizationForm(request.POST, request.FILES, instance=organization)
        if form.is_valid():
            form.save()
            
            # Log the action
            logger.info(f"Organization {organization.name} updated by {request.user.username}")
            
            messages.success(request, "Organization details updated successfully.")
            return redirect('organizations:settings_specific', org_id=org_id)
    else:
        form = OrganizationForm(instance=organization)
    
    return render(request, 'organizations/edit_organization.html', {
        'form': form,
        'organization': organization,
        'is_owner': is_owner,
        'is_admin': is_admin,
    })

================
File: apps/research/static/research/js/research-websocket-init.js
================
import { ResearchWebSocketService } from './research-websocket.js';

console.log('Initializing research WebSocket...');
const researchId = window.RESEARCH_ID;

if (researchId) {
    const wsService = new ResearchWebSocketService(researchId);
    window.researchWsService = wsService;
    console.log('WebSocket service initialized');
} else {
    console.error('Error: RESEARCH_ID is not defined.');
}

================
File: apps/research/static/research/js/research-websocket.js
================
// Research-specific WebSocket service
export class ResearchWebSocketService {
    constructor(researchId) {
        this.researchId = researchId;
        this.socket = null;
        this.isConnected = false;
        
        // Get DOM elements
        this.progressContainer = document.getElementById('progress-container');
        this.urlsList = document.querySelector('#sourcesList .sources-list');
        this.learningsList = document.querySelector('.learnings-list');
        this.reportContainer = document.querySelector('.card.d-none');  // Select the hidden report card
        this.statusBadge = document.getElementById('status-badge');
        this.cancelButton = document.getElementById('cancel-research');
        
        // Initialize markdown-it
        this.md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            highlight: function (str, lang) {
                if (lang && window.hljs && window.hljs.getLanguage(lang)) {
                    try {
                        return window.hljs.highlight(str, { language: lang }).value;
                    } catch (__) {}
                }
                return '';
            }
        });
        
        // Initialize badge animation if research is pending or in progress
        if (this.statusBadge) {
            const status = this.statusBadge.textContent.trim();
            if (status === 'In Progress' || status === 'Pending') {
                this.statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-warning');
                this.statusBadge.classList.add('bg-info', 'badge-animated');
                this.statusBadge.textContent = 'In Progress';
            }
        }
        
        this.connect();
    }

    connect() {
        const wsScheme = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${wsScheme}${window.location.host}/ws/research/${this.researchId}/`;
        
        this.socket = new WebSocket(wsUrl);
        
        this.socket.onopen = () => {
            console.log('WebSocket connected');
            this.isConnected = true;
            this.setupCancelButton();
        };
        
        this.socket.onclose = () => {
            console.log('WebSocket disconnected');
            this.isConnected = false;
            // Try to reconnect after 5 seconds
            setTimeout(() => this.connect(), 5000);
        };
        
        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
        };
        
        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'research_update') {
                    this.handleResearchUpdate(data.data);
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        };
    }

    setupCancelButton() {
        if (this.cancelButton) {
            this.cancelButton.addEventListener('click', () => {
                if (confirm('Are you sure you want to cancel this research task?')) {
                    fetch(`/research/${this.researchId}/cancel/`, {
                        method: 'POST',
                        headers: {
                            'X-CSRFToken': this.getCsrfToken(),
                        },
                    })
                    .then(response => {
                        if (response.ok) {
                            this.updateProgress('Research task cancelled by user.');
                            this.cancelButton.remove();
                            if (this.statusBadge) {
                                this.statusBadge.textContent = 'Cancelled';
                                this.statusBadge.className = 'badge bg-warning';
                            }
                        } else {
                            console.error('Failed to cancel research task');
                        }
                    })
                    .catch(error => {
                        console.error('Error cancelling research task:', error);
                    });
                }
            });
        }
    }

    getCsrfToken() {
        const name = 'csrftoken';
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    handleResearchUpdate(data) {
        switch (data.update_type) {
            case 'timing_update':
                this.updateProgress(`[${data.current_time}] ${data.message}`);
                break;
                
            case 'timing_info':
                const timingMessage = `Research completed in ${data.duration_minutes} minutes
                    (Started: ${data.start_time}, 
                    Ended: ${data.end_time})
                    Query: "${data.query}"
                    Breadth: ${data.breadth}, Depth: ${data.depth}`;
                this.updateProgress(timingMessage);
                break;
                
            case 'generating_queries':
                this.updateProgress(data.message);
                if (this.statusBadge) {
                    this.statusBadge.textContent = 'In Progress';
                    this.statusBadge.classList.remove('bg-success', 'bg-danger', 'bg-warning');
                    this.statusBadge.classList.add('bg-info', 'badge-animated');
                }
                break;
                
            case 'queries_generated':
                this.updateProgress('Search queries generated: ' + data.queries.join(', '));
                break;
                
            case 'urls_found':
                this.updateUrls(data.urls);
                break;
                
            case 'processing_content':
                this.updateProgress(data.message);
                break;
                
            case 'learnings_extracted':
                this.updateLearnings(data.learnings);
                break;
                
            case 'completed':
                this.handleCompletion(data);
                break;
                
            case 'error':
                this.handleError(data.error);
                break;
                
            case 'cancelled':
                this.handleCancellation();
                break;
        }
    }

    updateProgress(message) {
        if (this.progressContainer) {
            const div = document.createElement('div');
            div.className = 'progress-update text-xs';
            
            // Handle long messages by adding word-wrap style
            div.style.whiteSpace = 'pre-wrap';
            div.style.wordBreak = 'break-word';
            
            // If message is a search query, format it nicely
            if (message.startsWith('Search queries generated:')) {
                const queries = message.replace('Search queries generated:', '').split(',');
                div.innerHTML = `<strong>Search queries generated:</strong><br>${queries.map(q => `• ${q.trim()}`).join('<br>')}`;
            } else {
                div.textContent = message;
            }
            
            this.progressContainer.appendChild(div);
            
            // Scroll to bottom of container
            this.progressContainer.scrollTop = this.progressContainer.scrollHeight;
        } else {
            console.error('Progress container not found for message:', message);
        }
    }

    updateUrls(urls) {
        if (this.urlsList && Array.isArray(urls)) {
            urls.forEach(url => {
                const sourceItem = document.createElement('div');
                sourceItem.className = 'source-item';
                sourceItem.innerHTML = `
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="text-xxs">
                        <i class="fas fa-link me-1"></i>
                        ${url.length > 50 ? url.substring(0, 47) + '...' : url}
                    </a>
                `;
                this.urlsList.appendChild(sourceItem);
            });
            
            // Scroll parent container to bottom when new URLs are added
            const sourcesContainer = this.urlsList.closest('.overflow-auto');
            if (sourcesContainer) {
                sourcesContainer.scrollTop = sourcesContainer.scrollHeight;
            }
        } else {
            console.error('URLs list container not found or invalid URLs:', urls);
        }
    }

    updateLearnings(learnings) {
        if (this.learningsList && Array.isArray(learnings)) {
            learnings.forEach((learning, index) => {
                // Skip if learning is null or undefined
                if (!learning) return;
                
                // Extract text based on learning type
                let learningText;
                let categoryText = '';
                
                if (typeof learning === 'object') {
                    if (learning.detail) {
                        learningText = learning.detail;
                        if (learning.category) {
                            categoryText = `<strong>${learning.category}</strong>`;
                        }
                    } else if (learning.fact) {
                        learningText = learning.fact;
                    } else {
                        learningText = JSON.stringify(learning);
                    }
                } else {
                    learningText = learning;
                }
                
                const learningBlock = document.createElement('div');
                learningBlock.className = 'learning-block';
                const uniqueId = `learning-${Date.now()}-${index}`;
                
                // Create a clean preview of the text (first sentence or truncated)
                const previewText = learningText.split('.')[0] + '.';
                const displayPreview = previewText.length > 50 ? previewText.substring(0, 50) + '...' : previewText;
                
                learningBlock.innerHTML = `
                    <div class="learning-header d-flex align-items-center justify-content-between">
                        <div class="d-flex align-items-center cursor-pointer" data-bs-toggle="collapse" data-bs-target="#${uniqueId}">
                            <i class="fas fa-chevron-down me-2 toggle-icon"></i>
                            <h6 class="text-xs mb-0">${displayPreview}</h6>
                        </div>
                    </div>
                    <div class="learning-content mt-2 collapse" id="${uniqueId}">
                        <div class="learning-body">
                            ${categoryText}
                            ${learningText}
                        </div>
                    </div>
                `;
                
                // Add to the learnings list
                this.learningsList.appendChild(learningBlock);
                
                // Scroll parent container to bottom when new learnings are added
                const learningsContainer = this.learningsList.closest('.card-body');
                if (learningsContainer) {
                    learningsContainer.scrollTop = learningsContainer.scrollHeight;
                }
            });
        } else {
            console.error('Learnings list container not found or invalid learnings:', learnings);
        }
    }

    handleCompletion(data) {
        if (data.status === 'completed') {
            if (this.reportContainer) {
                // Get the markdown content div
                let markdownContent = this.reportContainer.querySelector('.markdown-content');
                if (!markdownContent) {
                    markdownContent = document.createElement('div');
                    markdownContent.className = 'markdown-content';
                    this.reportContainer.querySelector('.card-body').appendChild(markdownContent);
                }

                // Render and set the report content
                const htmlContent = this.md.render(data.report || '');
                markdownContent.innerHTML = htmlContent;
                
                // Show the report container
                this.reportContainer.classList.remove('d-none');
                
                // Apply syntax highlighting if available
                if (window.hljs) {
                    this.reportContainer.querySelectorAll('pre code').forEach((block) => {
                        window.hljs.highlightBlock(block);
                    });
                }
            }

            if (this.statusBadge) {
                this.statusBadge.textContent = 'Completed';
                this.statusBadge.classList.remove('bg-info', 'bg-danger', 'bg-warning', 'badge-animated');
                this.statusBadge.classList.add('bg-success');
            }
        } else if (data.status === 'failed') {
            this.handleError(data.error);
        }
    }

    handleError(error) {
        if (this.progressContainer) {
            const div = document.createElement('div');
            div.className = 'progress-update';
            div.style.borderLeft = '3px solid #dc3545';  // Red border for errors
            div.textContent = `Error: ${error}`;
            this.progressContainer.appendChild(div);
            div.scrollIntoView({ behavior: 'smooth' });
        }
        
        if (this.statusBadge) {
            this.statusBadge.textContent = 'Failed';
            this.statusBadge.classList.remove('bg-info', 'bg-success', 'bg-warning', 'badge-animated');
            this.statusBadge.classList.add('bg-danger');
        }
    }

    handleCancellation() {
        this.updateProgress('Research task has been cancelled.');
        if (this.cancelButton) {
            this.cancelButton.remove();
        }
        if (this.statusBadge) {
            this.statusBadge.textContent = 'Cancelled';
            this.statusBadge.classList.remove('bg-info', 'bg-success', 'bg-danger', 'badge-animated');
            this.statusBadge.classList.add('bg-warning');
        }
    }
}

================
File: apps/research/templates/research/partials/_report.html
================
{% load markdown_filters %}
<div class="report-container">
    <div class="card">
        <div class="card-header pb-0">
            <h5 class="mb-0">Research Report</h5>
        </div>
        <div class="card-body">
            <div class="markdown-content">
                {{ research.report|markdown }}
            </div>
        </div>
    </div>
</div>

================
File: apps/research/templates/research/partials/_step.html
================
{% load research_tags %}
<div class="step-item {% if is_last and step.step_type != 'complete' %}active{% endif %}" 
     id="step-{{ step.step_type }}-{{ step_number }}" 
     data-step-type="{{ step.step_type }}">
    
    <div class="step-icon {% if step.step_type == 'complete' %}bg-gradient-success{% elif is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %}">
        {% if step.step_type == 'query_planning' %}
            <i class="fas fa-search text-white"></i>
        {% elif step.step_type == 'content_analysis' %}
            <i class="fas fa-file-alt text-white"></i>
        {% elif step.step_type == 'insights_extracted' %}
            <i class="fas fa-lightbulb text-white"></i>
        {% elif step.step_type == 'complete' %}
            <i class="fas fa-check text-white"></i>
        {% else %}
            <i class="fas fa-check text-white"></i>
        {% endif %}
    </div>
    
    <div class="step-content">
        <div class="d-flex justify-content-between align-items-center">
            <h6 class="mb-1">{{ step.title }}</h6>
            <div>
                <span class="badge {% if step.step_type == 'complete' %}bg-gradient-success{% elif is_last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %} me-2">Step {{ step_number }}</span>
                <button type="button" class="btn btn-link btn-sm p-0 toggle-details" 
                        data-bs-toggle="collapse" 
                        data-bs-target="#step-details-{{ step.step_type }}-{{ step_number }}">
                    <i class="fas fa-chevron-down"></i>
                </button>
            </div>
        </div>
        
        <p class="text-muted mb-2">{{ step.explanation }}</p>
        
        <div class="collapse" id="step-details-{{ step.step_type }}-{{ step_number }}">
            <div class="card card-body mt-2 mb-3 border">
                {% if step.step_type == 'query_planning' or step.step_type == 'search_queries' %}
                    {% if step.details.queries %}
                        <h6 class="text-sm mb-2">Search Queries</h6>
                        <div class="list-group mb-3">
                            {% for query in step.details.queries %}
                                <div class="list-group-item list-group-item-action">
                                    <div class="d-flex align-items-center">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-search text-white"></i>
                                        </div>
                                        <div>
                                            <code class="text-dark">{{ query }}</code>
                                            {% if step.details.goals %}
                                                <p class="text-xs text-muted mt-1 mb-0">Goal: {{ step.details.goals|index:forloop.counter0 }}</p>
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}

                {% if step.step_type == 'content_analysis' %}
                    <div class="mb-3">
                        <h6 class="text-sm mb-2">Source Information</h6>
                        <div class="d-flex align-items-center mb-2">
                            <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                <i class="fas fa-file-alt text-white"></i>
                            </div>
                            <span class="text-sm">Analyzing {{ step.details.source_length|filesizeformat }} from <a href="{{ step.details.url }}" target="_blank" class="text-primary">{{ step.details.url }}</a></span>
                        </div>
                        <div class="d-flex align-items-center">
                            <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                <i class="fas fa-bullseye text-white"></i>
                            </div>
                            <span class="text-sm">Focus: <code class="text-dark">{{ step.details.focus }}</code></span>
                        </div>
                    </div>

                    {% if step.details.key_findings %}
                        <h6 class="text-sm mb-2">Key Findings</h6>
                        <div class="list-group mb-3">
                            {% for finding in step.details.key_findings %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-lightbulb text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ finding }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}

                    {% if step.details.follow_up_questions %}
                        <h6 class="text-sm mb-2">Follow-up Questions</h6>
                        <div class="list-group">
                            {% for question in step.details.follow_up_questions %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-warning text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-question text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ question }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}

                {% if step.step_type == 'insights_extracted' %}
                    {% if step.details.key_findings %}
                        <h6 class="text-sm mb-2">Key Insights</h6>
                        <div class="list-group mb-3">
                            {% for finding in step.details.key_findings %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-lightbulb text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ finding }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                    
                    {% if step.details.follow_up_questions %}
                        <h6 class="text-sm mb-2">Follow-up Questions</h6>
                        <div class="list-group">
                            {% for question in step.details.follow_up_questions %}
                                <div class="list-group-item">
                                    <div class="d-flex">
                                        <div class="icon-shape icon-xs rounded-circle bg-gradient-warning text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-question text-white"></i>
                                        </div>
                                        <div class="text-sm">{{ question }}</div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </div>
</div>

================
File: apps/research/templates/research/partials/progress.html
================
<!-- Research Progress Section -->
<div class="progress-section card mb-4">
    <div class="card-body p-3">
        <div id="progress-container">
            <div class="progress mb-3">
                <div id="research-progress" 
                     class="progress-bar bg-gradient-{{ research.status|status_color }}" 
                     role="progressbar" 
                     style="width: {{ progress }}%"
                     aria-valuenow="{{ progress }}" 
                     aria-valuemin="0" 
                     aria-valuemax="100">
                </div>
            </div>
            
            <div class="d-flex justify-content-between align-items-center mb-3">
                <div>
                    <span id="status-badge" class="badge bg-gradient-{{ research.status|status_color }}">
                        {{ research.status|title }}
                    </span>
                    {% if research.status == 'in_progress' %}
                        <span class="text-sm text-muted ms-2">
                            <i class="fas fa-spinner fa-spin me-1"></i>Processing...
                        </span>
                    {% endif %}
                </div>
                
                <div>
                    {% if research.status == 'in_progress' or research.status == 'pending' %}
                    <button id="cancel-btn" 
                            class="btn btn-sm btn-outline-danger"
                            hx-post="{% url 'research:cancel' research.id %}"
                            hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'
                            hx-confirm="Are you sure you want to cancel this research?">
                        <i class="fas fa-times me-1"></i>Cancel
                    </button>
                    {% endif %}
                </div>
            </div>
        </div>
        
        <!-- Progress Updates -->
        <div class="progress-updates overflow-auto" style="max-height: 300px;">
            <div id="progress-container" class="d-flex flex-column gap-2">
                {% if research.error %}
                <div class="alert alert-danger text-white" role="alert">
                    {{ research.error }}
                </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Template for progress updates -->
<template id="progress-update-template">
    <div class="progress-item bg-white p-3 border-radius-lg shadow-sm">
        <div class="d-flex align-items-center">
            <div class="icon icon-shape icon-xs rounded-circle bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                <i class="fas fa-info-circle text-white"></i>
            </div>
            <div class="ms-2">
                <div class="text-xs update-message"></div>
                <div class="text-xxs text-muted update-time"></div>
            </div>
        </div>
    </div>
</template>

================
File: apps/research/templates/research/partials/reasoning.html
================
{% load research_tags %}

<div class="timeline timeline-one-side" hx-swap-oob="true" id="timeline-container">
    {% for step in research.reasoning_steps %}
    <div class="timeline-block mb-3" data-step-type="{{ step.step_type }}">
        <span class="timeline-step {% if step.step_type == 'complete' %}bg-gradient-success{% elif forloop.last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %}">
            {% if step.step_type == 'query_planning' %}
                <i class="fas fa-search text-white"></i>
            {% elif step.step_type == 'content_analysis' %}
                <i class="fas fa-file-alt text-white"></i>
            {% elif step.step_type == 'insights_extracted' %}
                <i class="fas fa-lightbulb text-white"></i>
            {% elif step.step_type == 'complete' %}
                <i class="fas fa-check text-white"></i>
            {% else %}
                <i class="fas fa-check text-white"></i>
            {% endif %}
        </span>
        <div class="timeline-content">
            <div class="d-flex justify-content-between">
                <h6 class="text-dark text-sm font-weight-bold mb-0">{{ step.title }}</h6>
                <div class="d-flex align-items-center">
                    <span class="badge badge-sm {% if step.step_type == 'complete' %}bg-gradient-success{% elif forloop.last %}bg-gradient-primary{% else %}bg-gradient-success{% endif %} me-3">Step {{ forloop.counter }}</span>
                    <a href="javascript:;" data-bs-toggle="collapse" data-bs-target="#step-{{ forloop.counter }}" 
                        class="text-secondary font-weight-bold text-xs">
                        <i class="fas fa-chevron-down"></i>
                    </a>
                </div>
            </div>
            <p class="text-secondary text-sm mt-1 mb-0">{{ step.explanation }}</p>
            <div class="collapse" id="step-{{ forloop.counter }}" data-step-number="{{ forloop.counter }}" hx-preserve="true">
                <div class="mt-3">
                    {% if step.step_type == 'query_planning' or step.step_type == 'search_queries' %}
                        {% if step.details.queries %}
                            {% for query in step.details.queries %}
                                <div class="alert alert-light border mb-3">
                                    <div class="d-flex">
                                        <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                            <i class="fas fa-search text-white"></i>
                                        </div>
                                        <div>
                                            <code class="text-dark">{{ query }}</code>
                                            {% if step.details.goals %}
                                                <p class="text-sm text-secondary mt-1 mb-0">Goal: {{ step.details.goals|index:forloop.counter0 }}</p>
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        {% endif %}
                    {% elif step.step_type == 'content_analysis' %}
                        <div class="alert alert-light border">
                            <div class="d-flex align-items-center mb-2">
                                <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-file-alt text-white"></i>
                                </div>
                                <span class="text-sm">Analyzing {{ step.details.source_length|filesizeformat }} of content</span>
                            </div>
                            <div class="d-flex align-items-center">
                                <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-bullseye text-white"></i>
                                </div>
                                <span class="text-sm">Focus: <code class="text-dark">{{ step.details.focus }}</code></span>
                            </div>
                        </div>
                    {% elif step.step_type == 'insights_extracted' %}
                        {% if step.details.key_findings %}
                            <div class="alert alert-light border mb-3">
                                <h6 class="text-dark mb-2 d-flex align-items-center">
                                    <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                        <i class="fas fa-lightbulb text-white"></i>
                                    </div>
                                    Key Findings
                                </h6>
                                <ul class="mb-0 ps-4">
                                    {% for finding in step.details.key_findings %}
                                        <li class="text-sm text-secondary">{{ finding }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                        {% if step.details.follow_up_areas %}
                            <div class="alert alert-light border">
                                <h6 class="text-dark mb-2 d-flex align-items-center">
                                    <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                        <i class="fas fa-forward text-white"></i>
                                    </div>
                                    Follow-up Areas
                                </h6>
                                <ul class="mb-0 ps-4">
                                    {% for question in step.details.follow_up_areas %}
                                        <li class="text-sm text-secondary">{{ question }}</li>
                                    {% endfor %}
                                </ul>
                            </div>
                        {% endif %}
                    {% else %}
                        <div class="alert alert-light border">
                            {% for key, value in step.details.items %}
                                <div class="text-sm mb-2">
                                    <strong class="text-dark">{{ key|title }}:</strong> 
                                    <span class="text-secondary">{{ value }}</span>
                                </div>
                            {% endfor %}
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}

    {% if research.status == 'in_progress' %}
        <div class="timeline-block">
            <span class="timeline-step bg-gradient-info">
                <i class="fas fa-circle-notch fa-spin text-white"></i>
            </span>
            <div class="timeline-content">
                <h6 class="text-dark text-sm font-weight-bold mb-0">Processing Next Step</h6>
                <p class="text-secondary text-sm mt-1 mb-0">
                    <i class="fas fa-spinner fa-spin me-2"></i>Analyzing and gathering information...
                </p>
            </div>
        </div>
    {% endif %}
</div>

<script>
    // Only initialize once
    if (!window.timelineManager) {
        window.timelineManager = {
            expandedSteps: new Set(),
            
            init: function() {
                document.addEventListener('show.bs.collapse', function(evt) {
                    if (evt.target.hasAttribute('data-step-number')) {
                        window.timelineManager.expandedSteps.add(evt.target.getAttribute('data-step-number'));
                    }
                });
                
                document.addEventListener('hide.bs.collapse', function(evt) {
                    if (evt.target.hasAttribute('data-step-number')) {
                        window.timelineManager.expandedSteps.delete(evt.target.getAttribute('data-step-number'));
                    }
                });
                
                document.addEventListener('htmx:afterSwap', function(evt) {
                    if (evt.target.id === 'timeline-container') {
                        window.timelineManager.expandedSteps.forEach(stepNumber => {
                            const collapseEl = document.querySelector(`#step-${stepNumber}`);
                            if (collapseEl) {
                                const bsCollapse = new bootstrap.Collapse(collapseEl, { toggle: false });
                                collapseEl.classList.add('show');
                            }
                        });
                    }
                });
            }
        };
        
        window.timelineManager.init();
    }
</script>

================
File: apps/research/templates/research/partials/sources.html
================
<!-- Sources Section -->
<div id="sources-container">
    <div class="card">
        <div class="card-header pb-0">
            <h6 class="mb-0">Sources <span class="badge bg-primary">{{ research.visited_urls|length }}</span></h6>
        </div>
        <div class="card-body p-3">
            {% if research.visited_urls %}
                <div class="list-group">
                    {% for url in research.visited_urls %}
                        <a href="{{ url }}" target="_blank" class="list-group-item list-group-item-action">
                            <div class="d-flex align-items-center">
                                <div class="icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                                    <i class="fas fa-link text-white"></i>
                                </div>
                                <div class="text-sm text-truncate">{{ url }}</div>
                            </div>
                        </a>
                    {% endfor %}
                </div>
            {% else %}
                <div class="text-center py-4">
                    <div class="icon icon-shape icon-md bg-gradient-secondary shadow text-center mb-3">
                        <i class="fas fa-search opacity-10"></i>
                    </div>
                    <p class="text-muted mb-0">No sources found yet</p>
                </div>
            {% endif %}
        </div>
    </div>
</div>

<!-- Template for source items -->
<template id="source-item-template">
    <div class="source-item bg-white p-2 border-radius-lg shadow-sm">
        <div class="d-flex align-items-center">
            <div class="icon icon-shape icon-xs rounded-circle bg-gradient-primary text-center me-2 d-flex align-items-center justify-content-center">
                <i class="fas fa-link text-white"></i>
            </div>
            <a href="" target="_blank" rel="noopener noreferrer" class="text-xs text-primary text-truncate source-url"></a>
        </div>
    </div>
</template>

================
File: apps/research/templates/research/partials/steps.html
================
{% load research_tags %}
<div id="steps-container" class="steps-timeline">
    {% for step in research.reasoning_steps %}
        {% include "research/partials/_step.html" with step=step step_number=forloop.counter is_last=forloop.last %}
    {% endfor %}
    
    {% if research.status == 'in_progress' %}
    <!-- Processing indicator -->
    <div id="processing-indicator" class="step-item processing">
        <div class="step-icon bg-gradient-info">
            <i class="fas fa-circle-notch fa-spin text-white"></i>
        </div>
        <div class="step-content">
            <h6 class="mb-1">Processing Next Step</h6>
            <p class="text-muted mb-0">
                <i class="fas fa-spinner fa-spin me-2"></i>Analyzing and gathering information...
            </p>
        </div>
    </div>
    {% endif %}
</div>

================
File: apps/research/templates/research/create.html
================
{% extends 'layouts/base.html' %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">New Research</h6>
                        <a href="{% url 'research:list' %}" class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-arrow-left me-2"></i>Back to List
                        </a>
                    </div>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        
                        <div class="form-group mb-4">
                            <label for="{{ form.query.id_for_label }}" class="form-control-label">Research Query</label>
                            {{ form.query }}
                            <small class="form-text text-muted">Enter a detailed research question or topic to investigate</small>
                            {% if form.query.errors %}
                                <div class="text-danger mt-1">{{ form.query.errors }}</div>
                            {% endif %}
                        </div>

                        <div class="card mb-4">
                            <div class="card-header p-3 pb-0">
                                <h6 class="mb-0">Advanced Settings</h6>
                            </div>
                            <div class="card-body pt-2">
                                <div class="row">
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="{{ form.breadth.id_for_label }}" class="form-control-label">Search Breadth</label>
                                            {{ form.breadth }}
                                            <small class="form-text text-muted">Number of parallel search queries (2-10)</small>
                                            {% if form.breadth.errors %}
                                                <div class="text-danger mt-1">{{ form.breadth.errors }}</div>
                                            {% endif %}
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="{{ form.depth.id_for_label }}" class="form-control-label">Search Depth</label>
                                            {{ form.depth }}
                                            <small class="form-text text-muted">Number of recursive iterations (1-5)</small>
                                            {% if form.depth.errors %}
                                                <div class="text-danger mt-1">{{ form.depth.errors }}</div>
                                            {% endif %}
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <div class="form-group mb-3">
                                            <label for="model" class="form-control-label">Language Model</label>
                                            <select name="model" id="model" class="form-control">
                                                {% for model in available_models %}
                                                    <option value="{{ model }}" {% if model == selected_model %}selected{% endif %}>{{ model }}</option>
                                                {% endfor %}
                                            </select>
                                            <small class="form-text text-muted">Model to use for research</small>
                                        </div>
                                    </div>
                                </div>

                                <div class="form-group mb-0">
                                    <label for="{{ form.guidance.id_for_label }}" class="form-control-label">Research Guidance</label>
                                    {{ form.guidance }}
                                    <small class="form-text text-muted">Optional guidance to influence how research findings are analyzed</small>
                                    {% if form.guidance.errors %}
                                        <div class="text-danger mt-1">{{ form.guidance.errors }}</div>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        
                        <div class="d-flex justify-content-end">
                            <button type="submit" class="btn bg-gradient-primary">
                                <i class="fas fa-search me-2"></i>Start Research
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Add form-control class to all form inputs
        document.querySelectorAll('input, textarea, select').forEach(function(el) {
            if (!el.classList.contains('form-control')) {
                el.classList.add('form-control');
            }
        });
        
        // Make textarea taller
        document.querySelectorAll('textarea').forEach(function(el) {
            el.style.minHeight = '100px';
        });
    });
</script>
{% endblock %}

================
File: apps/research/templates/research/detail.html
================
{% extends 'layouts/base.html' %}
{% load static %}
{% load research_tags %}
{% load markdown_filters %}

{% block content %}
<div class="container-fluid py-4" 
     hx-ext="ws"
     ws-connect="/ws/research/{{ research.id }}/">
    
    <!-- Research Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="mb-0">{{ research.query }}</h5>
                            <p class="text-sm text-muted mb-0">Created {{ research.created_at|date:"M d, Y" }}</p>
                        </div>
                        <div class="d-flex align-items-center">
                            <span class="text-sm text-muted me-3" id="sources-count">
                                <i class="fas fa-link me-1"></i>{{ research.visited_urls|length }} sources
                            </span>
                            <span id="status-badge" class="badge bg-gradient-{{ research.status|status_color }}">
                                {{ research.status|title }}
                            </span>
                        </div>
                    </div>
                </div>
                
                <div class="card-body p-3">
                    <!-- Progress Bar -->
                    <div class="progress mb-3">
                        <div id="research-progress" 
                             class="progress-bar bg-gradient-primary" 
                             role="progressbar" 
                             {% if research.status == 'completed' %}
                             style="width: 100%"
                             aria-valuenow="100"
                             {% elif research.status == 'in_progress' %}
                             style="width: 50%"
                             aria-valuenow="50"
                             {% else %}
                             style="width: 0%"
                             aria-valuenow="0"
                             {% endif %}
                             aria-valuemin="0"
                             aria-valuemax="100">
                        </div>
                    </div>
                    
                    <!-- Controls -->
                    <div class="d-flex justify-content-end mb-3">
                        {% if research.status == 'in_progress' or research.status == 'pending' %}
                        <button id="cancel-btn" 
                                class="btn btn-sm btn-outline-danger"
                                hx-post="{% url 'research:cancel' research.id %}"
                                hx-headers='{"X-CSRFToken": "{{ csrf_token }}"}'
                                hx-confirm="Are you sure you want to cancel this research?">
                            <i class="fas fa-times me-1"></i>Cancel
                        </button>
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Research Content -->
    <div class="row">
        <!-- Steps Timeline -->
        <div class="col-12 col-lg-8 mb-4">
            <div class="card h-100">
                <div class="card-header pb-0">
                    <h6 class="mb-0">Research Progress</h6>
                </div>
                <div class="card-body p-3">
                    <!-- Steps will be loaded here -->
                    {% include "research/partials/steps.html" with research=research %}
                </div>
            </div>
        </div>
        
        <!-- Report Section -->
        <div class="col-12 col-lg-4">
            <div id="report-section" class="h-100">
                {% if research.report %}
                    {% include "research/partials/_report.html" with research=research %}
                {% else %}
                    <div class="card h-100">
                        <div class="card-header pb-0">
                            <h5 class="mb-0">Research Report</h5>
                        </div>
                        <div class="card-body d-flex flex-column align-items-center justify-content-center text-center">
                            <div class="icon icon-shape icon-lg bg-gradient-secondary shadow text-center">
                                <i class="fas fa-file-alt opacity-10"></i>
                            </div>
                            <h6 class="mt-3">Report Not Available</h6>
                            <p class="text-sm text-muted">
                                {% if research.status == 'in_progress' %}
                                    The report will be generated once the research is complete.
                                {% elif research.status == 'pending' %}
                                    The research has not started yet.
                                {% elif research.status == 'failed' %}
                                    The research failed to complete.
                                {% elif research.status == 'cancelled' %}
                                    The research was cancelled.
                                {% else %}
                                    No report was generated for this research.
                                {% endif %}
                            </p>
                        </div>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<!-- Markdown Styling -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.2.0/github-markdown-light.min.css">
<style>
    /* Markdown Content Styling */
    .markdown-content {
        font-size: 0.875rem;
        line-height: 1.6;
    }
    .markdown-content h1, 
    .markdown-content h2, 
    .markdown-content h3 {
        margin-top: 1.5rem;
        margin-bottom: 1rem;
        font-weight: 600;
    }
    .markdown-content p {
        margin-bottom: 1rem;
    }
    .markdown-content code {
        background: #f8f9fa;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-size: 0.8125rem;
    }
    .markdown-content pre {
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 4px;
        overflow-x: auto;
    }
    
    /* Steps Timeline Styling */
    .steps-timeline {
        position: relative;
        margin-left: 1rem;
        padding-left: 2rem;
    }
    
    .steps-timeline::before {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0.75rem;
        width: 2px;
        background-color: #e9ecef;
        transform: translateX(-50%);
    }
    
    .step-item {
        position: relative;
        padding-bottom: 1.5rem;
    }
    
    .step-item:last-child {
        padding-bottom: 0;
    }
    
    .step-icon {
        position: absolute;
        left: -2.75rem;
        width: 2rem;
        height: 2rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1;
    }
    
    .step-content {
        padding-left: 0.5rem;
    }
    
    .step-item.active .step-icon {
        box-shadow: 0 0 0 3px rgba(94, 114, 228, 0.2);
    }
    
    .step-item.processing .step-icon {
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0% {
            box-shadow: 0 0 0 0 rgba(17, 205, 239, 0.4);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(17, 205, 239, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(17, 205, 239, 0);
        }
    }
</style>
{% endblock %}

{% block extra_js %}
<!-- HTMX WebSocket Extension (loaded locally) -->
<script src="{% static 'assets/js/plugins/ws.js' %}"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // WebSocket event listeners for debugging
        document.body.addEventListener('htmx:wsOpen', function(evt) {
            console.log('WebSocket connected');
        });
        
        document.body.addEventListener('htmx:wsClose', function(evt) {
            console.log('WebSocket disconnected');
        });
        
        document.body.addEventListener('htmx:wsError', function(evt) {
            console.error('WebSocket error:', evt.detail);
        });
        
        // Handle WebSocket messages
        document.body.addEventListener('htmx:wsAfterMessage', function(evt) {
            try {
                const data = JSON.parse(evt.detail.message);
                console.log('WebSocket message:', data);
                
                if (data.type === 'status_update') {
                    updateStatus(data);
                } else if (data.type === 'error') {
                    showError(data.message);
                }
            } catch (e) {
                // Not JSON data, likely HTML for HTMX to process
            }
        });
        
        // Update status badge and progress bar
        function updateStatus(data) {
            if (data.status) {
                const statusColors = {
                    'pending': 'secondary',
                    'in_progress': 'primary',
                    'completed': 'success',
                    'failed': 'danger',
                    'cancelled': 'warning'
                };
                
                const statusBadge = document.getElementById('status-badge');
                if (statusBadge) {
                    statusBadge.className = `badge bg-gradient-${statusColors[data.status] || 'secondary'}`;
                    statusBadge.textContent = data.status.charAt(0).toUpperCase() + data.status.slice(1);
                }
                
                // Update progress bar
                if (data.progress !== undefined) {
                    const progressBar = document.getElementById('research-progress');
                    if (progressBar) {
                        progressBar.style.width = `${data.progress}%`;
                    }
                }
                
                // Hide cancel button if research is complete
                if (data.status === 'completed' || data.status === 'failed' || data.status === 'cancelled') {
                    const cancelBtn = document.getElementById('cancel-btn');
                    if (cancelBtn) {
                        cancelBtn.style.display = 'none';
                    }
                }
            }
        }
        
        // Show error message
        function showError(message) {
            // You could use a toast notification library here
            console.error('Error:', message);
        }
    });
</script>
{% endblock %}

================
File: apps/research/templates/research/list.html
================
{% extends 'layouts/base.html' %}
{% load research_tags %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header pb-0 d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">Research History</h6>
                    <a href="{% url 'research:create' %}" class="btn btn-sm btn-primary">
                        <i class="fas fa-plus me-2"></i>New Research
                    </a>
                </div>
                
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <table class="table align-items-center mb-0">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Query</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Status</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Created</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Sources</th>
                                    <th class="text-secondary opacity-7"></th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for research in researches %}
                                <tr>
                                    <td>
                                        <div class="d-flex px-3 py-1">
                                            <div class="d-flex flex-column justify-content-center">
                                                <h6 class="mb-0 text-sm">{{ research.query|truncatechars:50 }}</h6>
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <span class="badge bg-gradient-{{ research.status|status_color }}">
                                            {{ research.status|title }}
                                        </span>
                                    </td>
                                    <td>
                                        <p class="text-xs font-weight-bold mb-0">{{ research.created_at|date:"M d, Y" }}</p>
                                        <p class="text-xs text-secondary mb-0">{{ research.created_at|date:"H:i" }}</p>
                                    </td>
                                    <td>
                                        <span class="text-xs font-weight-bold">
                                            <i class="fas fa-link me-1"></i>{{ research.visited_urls|length }}
                                        </span>
                                    </td>
                                    <td class="align-middle text-end pe-3">
                                        <a href="{% url 'research:detail' research_id=research.id %}" class="btn btn-link text-dark px-3 mb-0">
                                            <i class="fas fa-eye text-dark me-2"></i>View
                                        </a>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="5" class="text-center py-5">
                                        <div class="d-flex flex-column align-items-center">
                                            <div class="icon icon-shape icon-lg bg-gradient-secondary shadow text-center mb-3">
                                                <i class="fas fa-search opacity-10"></i>
                                            </div>
                                            <h6 class="mb-2">No Research Found</h6>
                                            <p class="text-sm text-muted mb-3">You haven't created any research tasks yet.</p>
                                            <a href="{% url 'research:create' %}" class="btn btn-sm btn-primary">
                                                <i class="fas fa-plus me-2"></i>Start Your First Research
                                            </a>
                                        </div>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: apps/research/templatetags/__init__.py
================
# This file is intentionally empty to make the directory a Python package

================
File: apps/research/templatetags/research_tags.py
================
from django import template
import json as json_lib
import hashlib

register = template.Library()

@register.filter
def index(indexable, i):
    """Get item at index i from an indexable object"""
    try:
        return indexable[i]
    except (IndexError, TypeError, KeyError):
        return ''

@register.filter
def json(value):
    """Convert a Python object to a JSON string"""
    try:
        return json_lib.dumps(value)
    except (TypeError, ValueError):
        return '{}'

@register.filter
def md5(value):
    """Generate MD5 hash of a string value"""
    try:
        if not value:
            return ''
        return hashlib.md5(str(value).encode()).hexdigest()
    except (TypeError, ValueError):
        return ''

@register.filter
def status_color(status):
    """Return Bootstrap color class for a status."""
    status_colors = {
        'pending': 'secondary',
        'in_progress': 'primary',
        'completed': 'success',
        'failed': 'danger',
        'cancelled': 'warning'
    }
    return status_colors.get(status, 'secondary')

================
File: apps/research/websockets/research_consumer.py
================
from channels.generic.websocket import AsyncWebsocketConsumer
from channels.db import database_sync_to_async
from django.template.loader import render_to_string
from ..models import Research
from ..services import ResearchService
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
import logging
import json
import asyncio

logger = logging.getLogger(__name__)

class ResearchConsumer(OrganizationAwareConsumer):
    """
    WebSocket consumer for research app that handles real-time updates.
    Uses a standardized message protocol for all communications.
    Supports organization context for multi-tenancy.
    """
    
    async def connect(self):
        """Handle WebSocket connection"""
        logger.debug(f"Starting connection for research WebSocket with URL route: {self.scope.get('url_route', {})}")
        
        try:
            # Set organization context first
            await super().connect()
            
            self.research_id = self.scope['url_route']['kwargs']['research_id']
            #logger.debug(f"Extracted research_id from URL route: {self.research_id}")
            self.group_name = f"research_{self.research_id}"
            
            # Join the group
            #logger.debug(f"Joining channel group: {self.group_name}")
            await self.channel_layer.group_add(
                self.group_name,
                self.channel_name
            )
            
            # Accept the connection
            #logger.debug("Accepting WebSocket connection")
            await self.accept()
            #logger.info(f"WebSocket connected for research {self.research_id}")
            
            # Send initial state
            #logger.debug("Sending initial state")
            await self.send_initial_state()
        except Exception as e:
            logger.error(f"Error in WebSocket connect: {str(e)}", exc_info=True)
            raise
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection"""
        logger.info(f"WebSocket disconnected for research {self.research_id} with code {close_code}")
        
        # Leave the group
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
        
        # Clear organization context
        await super().disconnect(close_code)
    
    async def receive(self, text_data):
        """Handle messages from WebSocket client"""
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'get_state':
                await self.send_initial_state()
            elif message_type == 'cancel_research':
                logger.info(f"Received cancel_research request for {self.research_id}")
                await self.cancel({"type": "cancel"})
            else:
                logger.warning(f"Unknown message type: {message_type}")
                
        except json.JSONDecodeError:
            logger.error(f"Invalid JSON received: {text_data}")
            await self.send_error("Invalid message format")
        except Exception as e:
            logger.error(f"Error processing message: {str(e)}", exc_info=True)
            await self.send_error(f"Error processing message: {str(e)}")

    @database_sync_to_async
    def get_research(self, research_id):
        """Fetch a research object by ID."""
        from apps.research.models import Research
        
        try:
            #logger.debug(f"Attempting to fetch research with ID: {research_id}")
            research = Research.objects.get(id=research_id)
            #logger.debug(f"Successfully found research with ID: {research_id}")
            return research
        except Research.DoesNotExist:
            # Fallback to unfiltered objects if filtered query fails
            logger.warning(f"Research {research_id} not found with filtered manager. Falling back to unfiltered_objects.")
            try:
                research = Research.unfiltered_objects.get(id=research_id)
                logger.info(f"Found research with unfiltered_objects. Organization: {research.organization_id}")
                return research
            except Research.DoesNotExist:
                logger.error(f"Research {research_id} not found")
                return None

    @database_sync_to_async
    def cancel_research(self):
        """Cancel the research in database"""
        from apps.research.models import Research
        
        try:
            # Try with objects manager first (organization-aware)
            research = Research.objects.get(id=self.research_id)
            logger.info(f"Found research to cancel with objects manager: {research.id}")
        except Research.DoesNotExist:
            # Fallback to unfiltered objects if filtered query fails
            try:
                research = Research.unfiltered_objects.get(id=self.research_id)
                logger.info(f"Found research to cancel with unfiltered_objects: {research.id}, org: {research.organization_id}")
            except Research.DoesNotExist:
                logger.error(f"Research {self.research_id} not found for cancellation")
                return None
        
        if research.status == 'completed':
            logger.info(f"Research {self.research_id} already completed, cannot cancel")
            return research
        
        research.status = 'cancelled'
        research.save()
        logger.info(f"Research {self.research_id} cancelled")
        return research
    
    @database_sync_to_async
    def render_template_async(self, template_name, context):
        """Render a template asynchronously"""
        return render_to_string(template_name, context)
    
    async def send_initial_state(self):
        """Send initial state to the client"""
        research = await self.get_research(self.research_id)
        if not research:
            await self.send_error("Research not found")
            return
        
        # Send current state
        await self.send_json({
            'type': 'initial_state',
            'research': {
                'id': research.id,
                'status': research.status,
                'progress': self._calculate_progress(research),
                'query': research.query,
                'created_at': research.created_at.isoformat(),
                'error': research.error
            }
        })
        
        # Send HTML for steps
        if research.reasoning_steps:
            html = await self.render_template_async(
                'research/partials/steps.html',
                {'research': research}
            )
            await self.send(text_data=html)
    
    def _calculate_progress(self, research):
        """Calculate progress percentage based on research state"""
        if research.status == 'completed':
            return 100
        elif research.status == 'failed' or research.status == 'cancelled':
            return 0
        elif research.status == 'pending':
            return 0
        
        # For in_progress, calculate based on steps
        if not research.reasoning_steps:
            return 5  # Just started
        
        # Estimate progress based on number of steps and expected total
        step_count = len(research.reasoning_steps)
        expected_total = 10  # Typical number of steps for a complete research
        
        progress = min(95, int((step_count / expected_total) * 100))
        return progress
    
    async def send_json(self, data):
        """Send JSON data to the WebSocket"""
        await self.send(text_data=json.dumps(data))
    
    async def send_error(self, message):
        """Send error message to the WebSocket"""
        await self.send_json({
            'type': 'error',
            'message': message
        })
    
    # Channel layer event handlers
    
    async def status_update(self, event):
        """Handle status update event from channel layer"""
        await self.send_json({
            'type': 'status_update',
            'status': event['status'],
            'message': event.get('message', ''),
            'progress': event.get('progress')
        })
    
    async def step_update(self, event):
        """Handle step update event from channel layer"""
        step_data = event.get('step', {})
        
        # Render the step HTML
        html = await self.render_template_async(
            'research/partials/_step.html',
            {
                'step': step_data,
                'step_number': event.get('step_number', 1),
                'is_last': True
            }
        )
        
        # Send both the raw data and the HTML
        await self.send_json({
            'type': 'step_update',
            'step': step_data,
            'step_number': event.get('step_number', 1)
        })
        
        # Send the HTML with OOB swap instruction
        step_id = f"step-{step_data.get('step_type', 'unknown')}-{event.get('step_number', 1)}"
        await self.send(text_data=f'''
            <div id="{step_id}" 
                 hx-swap-oob="beforeend:#steps-container">
                {html}
            </div>
        ''')
        
    async def report_update(self, event):
        """Handle report update event from channel layer"""
        research = await self.get_research(self.research_id)
        if not research or not research.report:
            return
        
        # Render the report HTML
        html = await self.render_template_async(
            'research/partials/_report.html',
            {'research': research}
        )
        
        # Send the HTML with OOB swap instruction
        await self.send(text_data=f'''
            <div id="report-section" hx-swap-oob="innerHTML">
                {html}
            </div>
        ''')

    async def cancel(self, event):
        """Handle cancel request from client"""
        logger.info(f"Cancel request received for research {self.research_id}")
        research = await self.cancel_research()
        
        if research:
            # Send cancellation message to group
            await self.channel_layer.group_send(
                self.group_name,
                {
                    "type": "status_update",
                    "status": "cancelled",
                    "message": "Research cancelled by user"
                }
            )
            await self.send_json({
                "type": "cancel_response",
                "success": True,
                "message": "Research cancelled"
            })
        else:
            await self.send_json({
                "type": "cancel_response",
                "success": False,
                "message": "Research not found or already completed"
            })

================
File: apps/research/admin.py
================
from django.contrib import admin
from django.utils.html import format_html
from .models import Research

@admin.register(Research)
class ResearchAdmin(admin.ModelAdmin):
    list_display = ['id', 'truncated_query', 'user', 'status', 'created_at', 'source_count', 'has_report']
    list_filter = ['status', 'created_at', 'user']
    search_fields = ['query', 'user__username', 'report']
    readonly_fields = ['created_at', 'updated_at', 'visited_urls', 'learnings', 'reasoning_steps']
    date_hierarchy = 'created_at'
    
    def truncated_query(self, obj):
        return obj.query[:50] + "..." if len(obj.query) > 50 else obj.query
    truncated_query.short_description = 'Query'
    
    def source_count(self, obj):
        return len(obj.visited_urls)
    source_count.short_description = 'Sources'
    
    def has_report(self, obj):
        return format_html(
            '<span style="color: {};">&#x2022;</span> {}',
            '#2ecc71' if obj.report else '#e74c3c',
            'Yes' if obj.report else 'No'
        )
    has_report.short_description = 'Report'
    
    fieldsets = [
        ('Basic Information', {
            'fields': ['user', 'query', 'status', 'created_at', 'updated_at']
        }),
        ('Research Parameters', {
            'fields': ['breadth', 'depth', 'guidance']
        }),
        ('Results', {
            'fields': ['report', 'error']
        }),
        ('Research Data', {
            'classes': ['collapse'],
            'fields': ['visited_urls', 'learnings', 'reasoning_steps']
        }),
    ]

================
File: apps/research/apps.py
================
from django.apps import AppConfig


class ResearchConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.research'
    path = __file__.replace('apps.py', '')

================
File: apps/research/forms.py
================
from django import forms
from .models import Research

class ResearchForm(forms.ModelForm):
    class Meta:
        model = Research
        fields = ['query', 'breadth', 'depth', 'guidance']
        widgets = {
            'query': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Enter your research query...'
            }),
            'breadth': forms.NumberInput(attrs={
                'class': 'form-control',
                'min': 2,
                'max': 10
            }),
            'depth': forms.NumberInput(attrs={
                'class': 'form-control',
                'min': 1,
                'max': 5
            }),
            'guidance': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Optional: Provide guidance on what aspects to focus on...'
            })
        }

================
File: apps/research/models.py
================
from django.db import models
from django.contrib.auth import get_user_model
from django.utils import timezone
from apps.organizations.models.mixins import OrganizationModelMixin

User = get_user_model()

def default_list():
    return []

class Research(OrganizationModelMixin, models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    query = models.TextField()
    breadth = models.IntegerField(default=4)
    depth = models.IntegerField(default=2)
    guidance = models.TextField(null=True, blank=True, help_text="Optional guidance for content processing")
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    report = models.TextField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    
    # Store intermediate results using callable defaults
    visited_urls = models.JSONField(default=default_list)
    learnings = models.JSONField(default=default_list)
    reasoning_steps = models.JSONField(default=default_list)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name_plural = 'Research'

    def __str__(self):
        return f"Research: {self.query[:50]}..."

================
File: apps/research/services.py
================
import logging
from typing import Dict, Optional, List
from .models import Research
import json
from django.db import transaction

logger = logging.getLogger(__name__)

class ResearchService:
    @staticmethod
    def update_research_steps(research_id: int, step_data: Dict) -> Optional[Research]:
        """Update research steps in the database."""
        try:
            #logger.info(f"Updating research steps for research {research_id}")
            #logger.info(f"Step data received: {json.dumps(step_data)}")
            
            # Use transaction context manager
            with transaction.atomic():
                # Get research object with select_for_update to prevent race conditions
                research = Research.objects.select_for_update().get(id=research_id)
                
                # Ensure we have a valid list for current_steps
                current_steps = research.reasoning_steps
                if current_steps is None or not isinstance(current_steps, list):
                    logger.warning(f"Current steps was not a valid list, resetting. Type was: {type(current_steps)}")
                    current_steps = []
                
                #logger.info(f"Current step count before update: {len(current_steps)}")
                
                # Validate step data
                if not all(key in step_data for key in ['step_type', 'title', 'explanation']):
                    logger.error(f"Invalid step data format: {json.dumps(step_data)}")
                    return None
                
                # Only append if this is a new step
                is_duplicate = False
                if current_steps:
                    # Check for duplicate step based on step_type and title
                    for existing_step in current_steps:
                        if (existing_step.get('step_type') == step_data.get('step_type') and 
                            existing_step.get('title') == step_data.get('title')):
                            # Update the existing step instead of adding a new one
                            existing_step.update(step_data)
                            is_duplicate = True
                            logger.info(f"Updated existing step: {step_data.get('title')}")
                            break
                    
                    # Special case: don't add 'complete' step if it's already there
                    if step_data.get('step_type') == 'complete' and any(s.get('step_type') == 'complete' for s in current_steps):
                        is_duplicate = True
                        logger.info("Skipping duplicate complete step")
                
                if not is_duplicate:
                    current_steps.append(step_data)
                    #logger.info(f"Added new step: {step_data.get('title')}")
                
                logger.info(f"Current step count after update: {len(current_steps)}")
                
                # Save the updated steps
                research.reasoning_steps = current_steps
                research.save(update_fields=['reasoning_steps'])
                
                # Verify the save
                research.refresh_from_db()
                #logger.info(f"Verified step count after save: {len(research.reasoning_steps)}")
                
                return research
                
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research steps: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_status(research_id: int, status: str) -> Optional[Research]:
        """Update research status."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.status = status
                research.save(update_fields=['status'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research status: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_error(research_id: int, error_message: str) -> Optional[Research]:
        """Update research error state."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.error = error_message
                research.status = 'failed'
                research.save(update_fields=['error', 'status'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research error: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_report(research_id: int, report: str) -> Optional[Research]:
        """Update research report."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                research.report = report
                research.save(update_fields=['report'])
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research report: {str(e)}", exc_info=True)
            return None

    @staticmethod
    def update_research_data(research_id: int, data: Dict) -> Optional[Research]:
        """Update research data fields (report, visited_urls, learnings)."""
        try:
            with transaction.atomic():
                research = Research.objects.select_for_update().get(id=research_id)
                
                fields_to_update = []
                
                if 'report' in data:
                    research.report = data['report']
                    fields_to_update.append('report')
                    
                if 'visited_urls' in data:
                    research.visited_urls = data['visited_urls']
                    fields_to_update.append('visited_urls')
                    
                if 'learnings' in data:
                    research.learnings = data['learnings']
                    fields_to_update.append('learnings')
                    
                if fields_to_update:
                    research.save(update_fields=fields_to_update)
                    
                return research
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error updating research data: {str(e)}", exc_info=True)
            return None

================
File: apps/research/tasks.py
================
from celery import shared_task
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from apps.agents.tools.deep_research_tool.deep_research_tool import DeepResearchTool
from .models import Research
from .services import ResearchService
import logging
from pydantic import Field
from typing import Any, Dict, List, Optional
from celery.exceptions import Ignore
import json
from contextlib import nullcontext
from apps.organizations.utils import OrganizationContext, get_current_organization

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

class ProgressTracker:
    """Tracks progress of research tasks and sends updates via WebSockets."""
    
    def __init__(self, research_id):
        self.research_id = research_id
        self.group_name = f"research_{research_id}"
        self.step_count = 0
        logger.info(f"Initialized ProgressTracker for research {research_id}")

    def send_update(self, update_type: str, data: Dict):
        """Send an update to the WebSocket group."""
        try:
            # Determine the message type based on the update type
            if update_type in ['generating_queries', 'queries_generated', 'urls_found']:
                message_type = 'status_update'
                message_data = {
                    'status': 'in_progress',
                    'message': data.get('message', f'Processing {update_type}'),
                    'progress': self._calculate_progress(update_type)
                }
            elif update_type == 'step_added':
                message_type = 'step_update'
                self.step_count += 1
                message_data = {
                    'step': data.get('step', {}),
                    'step_number': self.step_count
                }
            elif update_type == 'completed':
                message_type = 'status_update'
                message_data = {
                    'status': 'completed',
                    'message': 'Research completed successfully',
                    'progress': 100
                }
            elif update_type == 'report_ready':
                message_type = 'report_update'
                message_data = {
                    'report_id': self.research_id
                }
            elif update_type == 'error':
                message_type = 'status_update'
                message_data = {
                    'status': 'failed',
                    'message': data.get('error', 'An error occurred'),
                    'progress': 0
                }
            elif update_type == 'cancelled':
                message_type = 'status_update'
                message_data = {
                    'status': 'cancelled',
                    'message': 'Research was cancelled',
                    'progress': 0
                }
            else:
                # Default to status update
                message_type = 'status_update'
                message_data = {
                    'status': 'in_progress',
                    'message': f'Processing {update_type}',
                    'progress': self._calculate_progress(update_type)
                }
            
            # Send the message to the group
            async_to_sync(channel_layer.group_send)(
                self.group_name,
                {
                    "type": message_type,
                    **message_data
                }
            )
            logger.debug(f"Sent {message_type} update for research {self.research_id}")
            
        except Exception as e:
            logger.error(f"Error sending WebSocket update for research {self.research_id}: {str(e)}", exc_info=True)
    
    def _calculate_progress(self, update_type: str) -> int:
        """Calculate progress percentage based on the update type."""
        # Define progress milestones for different stages
        progress_map = {
            'generating_queries': 10,
            'queries_generated': 20,
            'urls_found': 30,
            # Steps will increment between 30-90%
        }
        
        if update_type in progress_map:
            return progress_map[update_type]
        
        # For step updates, calculate based on expected total steps
        expected_total_steps = 10
        progress = 30 + min(60, int((self.step_count / expected_total_steps) * 60))
        return progress

    def check_cancelled(self) -> bool:
        """Check if the research has been cancelled."""
        try:
            # Use objects manager which is now organization-aware through the mixin
            research = Research.objects.get(id=self.research_id)
            return research.status == 'cancelled'
        except Research.DoesNotExist:
            return True

class ProgressDeepResearchTool(DeepResearchTool):
    """Extended DeepResearchTool that tracks progress and sends updates."""
    
    progress_tracker: Any = Field(None, exclude=True)

    def __init__(self, progress_tracker: ProgressTracker, **kwargs):
        super().__init__(**kwargs)
        self.progress_tracker = progress_tracker
        logger.info("Initialized ProgressDeepResearchTool with progress tracker")

    def _generate_serp_queries(self, query, num_queries, learnings=None, guidance=None):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
            
        self.progress_tracker.send_update("generating_queries", {
            "message": f"Generating {num_queries} search queries..."
        })
        
        result = super()._generate_serp_queries(query, num_queries, learnings, guidance)
        
        self.progress_tracker.send_update("queries_generated", {
            "queries": [q["query"] for q in result]
        })
        
        return result

    def _extract_urls(self, search_results):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
            
        urls = super()._extract_urls(search_results)
        
        self.progress_tracker.send_update("urls_found", {
            "urls": urls
        })
        
        return urls

    def _process_content(self, query, content, num_learnings=3, guidance=None):
        if self.progress_tracker.check_cancelled():
            raise Ignore()
        
        # Log content type and size for debugging
        content_type = type(content).__name__
        content_size = len(content) if isinstance(content, (str, dict)) else "unknown"
        logger.info(f"Processing content of type {content_type}, size {content_size}")
        
        # Create a proper content dictionary if content is a string
        if isinstance(content, str):
            # Check if we have URL information from the parent class call context
            url = getattr(self, '_current_url', 'unknown source')
            content_dict = {
                'url': url,
                'content': content
            }
            # Store the original content string
            original_content = content
            # Use the dictionary for processing
            result = super()._process_content(query, original_content, num_learnings, guidance)
        else:
            # Content is already a dictionary
            content_dict = content
            result = super()._process_content(query, content.get('content', content), num_learnings, guidance)
        
        # Validate result
        if not result:
            logger.error("Empty result from content processing")
            return {
                'learnings': [f"Unable to extract learnings from content about: {query}"],
                'follow_up_questions': [f"What are the key aspects of {query}?"]
            }
        
        # Log the result for debugging
        logger.info(f"Content processing result has {len(result.get('learnings', []))} learnings")
        if result.get('learnings'):
            for i, learning in enumerate(result.get('learnings', [])[:2]):
                logger.info(f"Task processor learning {i+1}: {learning[:100]}...")
        
        # Send step update
        if result and 'learnings' in result:
            url = content_dict.get('url', 'unknown source')
            content_length = len(content_dict.get('content', content_dict))
                
            step_data = {
                'step_type': 'content_analysis',
                'title': f"Analyzing content from {url}",
                'explanation': f"Extracting information relevant to the research query",
                'details': {
                    'url': url,
                    'source_length': content_length,
                    'focus': query,
                    'key_findings': result.get('learnings', []),
                    'follow_up_questions': result.get('follow_up_questions', [])
                }
            }
            
            # Add step to database
            research = ResearchService.update_research_steps(self.progress_tracker.research_id, step_data)
            
            # Send WebSocket update
            self.progress_tracker.send_update("step_added", {
                "step": step_data
            })
        
        return result

    # Override _update_token_counters to include progress updates
    def _update_token_counters(self):
        """Update total token counts from the token counter callback and send progress updates."""
        # Call the parent implementation to update counters
        input_tokens, output_tokens = super()._update_token_counters()
        
        # Send token usage update through progress tracker
        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("token_usage", {
                "input_tokens": input_tokens,
                "output_tokens": output_tokens,
                "total_tokens": input_tokens + output_tokens
            })
        
        return input_tokens, output_tokens
        
    # Override _update_token_counters_from_subtool to include progress updates
    def _update_token_counters_from_subtool(self, input_tokens: int, output_tokens: int):
        """Update token counters with usage from a sub-tool and send progress updates."""
        # Call the parent implementation to update counters
        super()._update_token_counters_from_subtool(input_tokens, output_tokens)
        
        # Send token usage update through progress tracker
        if hasattr(self, 'progress_tracker'):
            self.progress_tracker.send_update("subtool_token_usage", {
                "input_tokens": input_tokens,
                "output_tokens": output_tokens,
                "total_tokens": input_tokens + output_tokens,
                "cumulative_input": self.total_input_tokens,
                "cumulative_output": self.total_output_tokens,
                "cumulative_total": self.total_input_tokens + self.total_output_tokens
            })

@shared_task
def run_research(research_id, model_name=None, tool_params=None, organization_id=None):
    """Run a research task with progress tracking."""
    research = None
    progress_tracker = None
    
    try:
        # Set organization context if provided
        from contextlib import nullcontext
        # Import Research model at the function level to avoid circular imports
        from apps.research.models import Research
        
        # Log the organization ID being passed to the task
        logger.info(f"Research task for ID {research_id} started with organization_id: {organization_id}")
        
        # If organization_id is not provided, try to get it from the research object first
        if not organization_id:
            try:
                # Use unfiltered_objects to avoid organization filtering when fetching initial object
                research_obj = Research.unfiltered_objects.get(id=research_id)
                organization_id = research_obj.organization_id
                logger.info(f"Got organization_id {organization_id} from research object")
            except Research.DoesNotExist:
                logger.error(f"Research {research_id} not found when trying to get organization ID")
                return {'success': False, 'error': f'Research {research_id} not found'}
            except Exception as e:
                logger.warning(f"Could not determine organization for research {research_id}: {str(e)}")
        
        # Verify that the Research object exists before entering context manager
        try:
            # Check if research exists using unfiltered manager (no organization context yet)
            research_obj = Research.unfiltered_objects.get(id=research_id)
            logger.info(f"Found research object with ID {research_id} using unfiltered manager. Organization ID: {research_obj.organization_id}")
        except Research.DoesNotExist:
            logger.error(f"Research {research_id} not found before entering organization context")
            return {'success': False, 'error': f'Research {research_id} not found'}
        except Exception as e:
            logger.error(f"Error checking if research {research_id} exists: {str(e)}")
            return {'success': False, 'error': f'Error checking research existence: {str(e)}'}
        
        # Use organization context manager if we have an organization ID
        context_manager = OrganizationContext.organization_context(organization_id) if organization_id else nullcontext()
        
        with context_manager:
            # Log the current organization context
            current_org = get_current_organization()
            logger.info(f"Current organization context inside context manager: {current_org.id if current_org else None}")
            
            try:
                # Try with objects manager first (organization-aware)
                logger.info(f"Attempting to get research {research_id} with objects manager")
                research = Research.objects.get(id=research_id)
                logger.info(f"Successfully found research with filtered objects manager")
            except Research.DoesNotExist:
                # Fallback to unfiltered objects if filtered query fails
                logger.warning(f"Research {research_id} not found with filtered manager. Falling back to unfiltered_objects.")
                try:
                    research = Research.unfiltered_objects.get(id=research_id)
                    logger.info(f"Found research with unfiltered_objects. Organization: {research.organization_id}")
                    
                    # Verify organization match
                    if organization_id and str(research.organization_id) != str(organization_id):
                        logger.warning(f"Organization mismatch! Task org: {organization_id}, Research org: {research.organization_id}")
                    
                except Research.DoesNotExist:
                    logger.error(f"Research {research_id} not found even with unfiltered_objects")
                    return {'success': False, 'error': f'Research {research_id} not found'}
            
            # Check if already cancelled before starting
            if research.status == 'cancelled':
                logger.info(f"Research task {research_id} was already cancelled")
                return {'success': False, 'status': 'cancelled'}
                
            # Update status to in_progress
            ResearchService.update_research_status(research_id, 'in_progress')

            # Initialize progress tracker
            progress_tracker = ProgressTracker(research_id)
            
            # Check if cancelled after tracker initialization
            if progress_tracker.check_cancelled():
                logger.info(f"Research task {research_id} was cancelled before starting")
                ResearchService.update_research_status(research_id, 'cancelled')
                progress_tracker.send_update("cancelled", {})
                return {'success': False, 'status': 'cancelled'}
                
            # Initialize tool with model name and any additional params
            tool_kwargs = {
                'progress_tracker': progress_tracker,
            }
            if tool_params:
                tool_kwargs.update(tool_params)
                
            # Create tool instance
            tool = ProgressDeepResearchTool(**tool_kwargs)

            # Get result from tool
            tool_result = tool._run(
                query=research.query,
                breadth=research.breadth,
                depth=research.depth,
                user_id=research.user_id,
                guidance=research.guidance
            )
            
            # For text-based output, store as is
            if isinstance(tool_result, str):
                logger.info(f"Report content length: {len(tool_result)}")
                report = tool_result
            # For JSON output, extract just the report field
            elif isinstance(tool_result, dict):
                # Check for deep_research_data structure
                if 'deep_research_data' in tool_result and 'report' in tool_result['deep_research_data']:
                    # Extract just the report content
                    report = tool_result['deep_research_data']['report']
                    logger.info(f"Extracted report content length: {len(report)}")
                else:
                    # Fallback to JSON string if structure is unexpected
                    logger.warning("Unexpected tool result structure, converting to JSON string")
                    report = json.dumps(tool_result, indent=2)
                
                # Get learnings from the appropriate location
                learnings = tool_result.get('deep_research_data', {}).get('learnings', [])
                visited_urls = tool_result.get('deep_research_data', {}).get('sources', [])
                
                logger.info(f"Received {len(learnings)} learnings from research tool")
                if learnings and len(learnings) > 0:
                    logger.debug(f"First few learnings: {', '.join(str(l) for l in learnings[:3])}")
            else:
                # Fallback for unexpected types
                report = str(tool_result)

            # Process the result
            if report:
                # Update research with all data including report
                ResearchService.update_research_data(research_id, {
                    'report': report,
                    'visited_urls': visited_urls if 'visited_urls' in locals() else [],
                    'learnings': learnings if 'learnings' in locals() else []
                })
                
                # Verify report was saved
                research.refresh_from_db()
                if not research.report:
                    logger.error(f"Report save failed for research {research_id}")
                    ResearchService.update_research_error(research_id, "Failed to save report")
                    progress_tracker.send_update("error", {"error": "Failed to save report"})
                else:
                    # Update status to completed
                    ResearchService.update_research_status(research_id, 'completed')
                    
                    # Send report ready notification
                    progress_tracker.send_update("report_ready", {})
                    
                    # Send completion notification
                    progress_tracker.send_update("completed", {})
            else:
                # Handle error
                error_message = "Unknown error occurred"
                ResearchService.update_research_error(research_id, error_message)
                progress_tracker.send_update("error", {"error": error_message})

    except Ignore:
        # Task was cancelled
        logger.info(f"Research task {research_id} was cancelled")
        if research:
            ResearchService.update_research_status(research_id, 'cancelled')
        if progress_tracker:
            progress_tracker.send_update("cancelled", {})

    except Exception as e:
        # Handle unexpected exceptions
        logger.error(f"Error in research task: {str(e)}", exc_info=True)
        if research:
            ResearchService.update_research_error(research_id, str(e))
            
            if progress_tracker:
                progress_tracker.send_update("error", {"error": str(e)}) 
    return {'success': True, 'status': research.status}

================
File: apps/research/urls.py
================
from django.urls import path
from . import views

app_name = 'research'

urlpatterns = [
    path('', views.research_list, name='list'),
    path('create/', views.research_create, name='create'),
    path('<int:research_id>/', views.research_detail, name='detail'),
    path('<int:research_id>/cancel/', views.cancel_research, name='cancel'),
    # HTMX endpoints
    path('<int:research_id>/progress/', views.research_progress, name='progress'),
    path('<int:research_id>/sources/', views.research_sources, name='sources'),
    path('<int:research_id>/reasoning/', views.research_reasoning, name='reasoning'),
]

================
File: apps/research/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse
from django.urls import reverse
from django.template.loader import render_to_string
from django.views.decorators.csrf import ensure_csrf_cookie
from django.views.decorators.http import require_POST
from django.conf import settings
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import json
import logging

from .models import Research
from .forms import ResearchForm
from .tasks import run_research
from apps.common.utils import get_models
from apps.organizations.utils import get_current_organization

logger = logging.getLogger(__name__)
channel_layer = get_channel_layer()

@login_required
def research_create(request):
    """Create a new research task."""
    available_models = get_models()
    selected_model = getattr(settings, 'GENERAL_MODEL', available_models[0] if available_models else None)
    
    if request.method == 'POST':
        form = ResearchForm(request.POST)
        if form.is_valid():
            # Create and save the research object
            research = form.save(commit=False)
            research.user = request.user
            research.save()
            
            # Get selected model from form
            model_name = request.POST.get('model', selected_model)
            
            # Get current organization
            organization = get_current_organization()
            organization_id = organization.id if organization else None
            
            # Start Celery task with selected model and organization context
            run_research.delay(
                research_id=research.id,
                model_name=model_name,
                tool_params={
                    'llm_model': model_name
                },
                organization_id=organization_id
            )
            
            return redirect('research:detail', research_id=research.id)
    else:
        form = ResearchForm()
    
    return render(request, 'research/create.html', {
        'form': form,
        'available_models': available_models,
        'selected_model': selected_model
    })

@ensure_csrf_cookie
@login_required
def research_detail(request, research_id):
    """View details of a research task."""
    research = get_object_or_404(Research, id=research_id, user=request.user)
    available_models = get_models()
    selected_model = getattr(settings, 'GENERAL_MODEL', available_models[0] if available_models else None)
    
    return render(request, 'research/detail.html', {
        'research': research,
        'available_models': json.dumps(available_models),
        'selected_model': selected_model
    })

@login_required
def research_list(request):
    """List all research tasks for the current user."""
    researches = Research.objects.filter(user=request.user)
    return render(request, 'research/list.html', {
        'researches': researches
    })

@require_POST
@login_required
def cancel_research(request, research_id):
    """Cancel a running research task."""
    try:
        # Log current user for debugging
        logger.info(f"Cancel research request for ID {research_id} by user {request.user.email} (ID: {request.user.id})")
        
        # Use get_object_or_404 with just the ID - the objects manager will filter by organization automatically
        research = get_object_or_404(Research, id=research_id)
        
        # Log for debugging
        logger.info(f"Found research {research_id}, owned by user {research.user.email} (ID: {research.user.id})")
        
        # Extra security check that this is the user's research
        if research.user.id != request.user.id:
            logger.warning(f"User mismatch: request user {request.user.id} != research user {research.user.id}")
            return HttpResponse(status=403)
        
        if research.status in ['pending', 'in_progress']:
            # Update status in database
            research.status = 'cancelled'
            research.save(update_fields=['status'])
            
            # Log for debugging
            logger.info(f"Research {research_id} cancelled successfully")
            
            # Send cancellation message through WebSocket
            async_to_sync(channel_layer.group_send)(
                f"research_{research_id}",
                {
                    "type": "status_update",
                    "status": "cancelled",
                    "message": "Research cancelled by user",
                    "progress": 0
                }
            )
            
            return HttpResponse(status=200)
        else:
            logger.info(f"Research {research_id} status is {research.status}, cannot cancel")
            return HttpResponse(status=400)
    except Exception as e:
        logger.error(f"Error cancelling research {research_id}: {str(e)}", exc_info=True)
        return HttpResponse(status=500)

@login_required
def research_progress(request, research_id):
    """HTMX endpoint for progress updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    # Calculate progress percentage
    progress = 0
    if research.status == 'completed':
        progress = 100
    elif research.status == 'in_progress':
        # Estimate progress based on steps
        step_count = len(research.reasoning_steps)
        expected_total = 10  # Typical number of steps
        progress = min(95, int((step_count / expected_total) * 100))
    
    return render(request, 'research/partials/progress.html', {
        'research': research,
        'progress': progress
    })

@login_required
def research_sources(request, research_id):
    """HTMX endpoint for sources updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    return render(request, 'research/partials/sources.html', {
        'research': research
    })

@login_required
def research_reasoning(request, research_id):
    """HTMX endpoint for reasoning chain updates."""
    if not request.headers.get('HX-Request'):
        return HttpResponse(status=400)
        
    research = get_object_or_404(Research, id=research_id, user=request.user)
    
    return render(request, 'research/partials/steps.html', {
        'research': research
    })

================
File: apps/seo_audit/services/remediation_service.py
================
from typing import List, Dict, Any
from apps.common.services.llm_service import LLMService
from apps.seo_audit.models import SEOAuditIssue, SEORemediationPlan
import logging
from apps.common.tools.user_activity_tool import user_activity_tool
import requests

logger = logging.getLogger(__name__)

class RemediationService:
    """Service for generating and managing SEO remediation plans"""

    def __init__(self, user=None):
        self.llm_service = LLMService(user=user)
        self.user = user
        
    async def generate_plan(
        self,
        url: str,
        issues: List[SEOAuditIssue],
        provider_type: str,
        model: str,
        client_profile: str = ""
    ) -> Dict[str, Any]:
        """Generate a remediation plan for given URL and issues"""
        try:
            logger.debug(f"Generating remediation plan for {url} with provider: {provider_type}, model: {model}")
            # Step 1: Analyze issues and create structured analysis
            analysis = await self._analyze_issues(
                provider_type=provider_type,
                model=model,
                url=url,
                issues=issues,
                client_profile=client_profile
            )
            # Step 2: Generate actionable recommendations
            recommendations = await self._generate_recommendations(
                provider_type=provider_type,
                model=model,
                analysis=analysis,
                issues=issues
            )
            # Step 3: Create validation steps
            validation_steps = await self._create_validation_steps(
                provider_type=provider_type,
                model=model,
                recommendations=recommendations
            )
            user_activity_tool.run(self.user, 'update', f"Generated remediation plan for {url}")

            return {
                'analysis': analysis,
                'recommendations': recommendations,
                'validation_steps': validation_steps,
                'metadata': {
                    'url': url,
                    'issue_count': len(issues),
                    'provider': provider_type,
                    'model': model
                }
            }

        except Exception as e:
            logger.error(f"Error generating remediation plan for {url}: {str(e)}")
            raise

    async def _analyze_issues(
        self, 
        provider_type: str,
        model: str,
        url: str,
        issues: List[SEOAuditIssue],
        client_profile: str
    ) -> Dict[str, Any]:
        """Analyze issues and create structured analysis"""
        
        prompt = self._create_analysis_prompt(issues, url, client_profile)
        
        response = await self.llm_service.get_completion(
            messages=[{"role": "user", "content": prompt}],
            provider_type=provider_type,
            model=model,
            response_format={
                "type": "json_object",
                "schema": {
                    "type": "object",
                    "properties": {
                        "critical_issues": {"type": "array"},
                        "high_priority": {"type": "array"},
                        "medium_priority": {"type": "array"},
                        "low_priority": {"type": "array"},
                        "summary": {"type": "string"},
                        "impact_analysis": {"type": "string"}
                    }
                }
            }
        )
        
        return response

    async def _generate_recommendations(
        self,
        provider_type: str,
        model: str,
        analysis: Dict[str, Any],
        issues: List[SEOAuditIssue]
    ) -> Dict[str, Any]:
        """Generate detailed recommendations based on analysis"""
        
        prompt = self._create_recommendations_prompt(analysis, issues)
        
        response = await self.llm_service.get_completion(
            messages=[{"role": "user", "content": prompt}],
            provider_type=provider_type,
            model=model,
            response_format={
                "type": "json_object",
                "schema": {
                    "type": "object",
                    "properties": {
                        "recommendations": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "issue": {"type": "string"},
                                    "solution": {"type": "string"},
                                    "implementation_steps": {"type": "array"},
                                    "priority": {"type": "string"},
                                    "estimated_effort": {"type": "string"}
                                }
                            }
                        }
                    }
                }
            }
        )
        
        return response

    async def _create_validation_steps(
        self,
        provider_type: str,
        model: str,
        recommendations: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create validation steps for each recommendation"""
        
        prompt = self._create_validation_prompt(recommendations)
        
        response = await self.llm_service.get_completion(
            messages=[{"role": "user", "content": prompt}],
            provider_type=provider_type,
            model=model,
            response_format={
                "type": "json_object",
                "schema": {
                    "type": "object",
                    "properties": {
                        "validation_steps": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "recommendation_id": {"type": "integer"},
                                    "validation_steps": {"type": "array"},
                                    "success_criteria": {"type": "string"},
                                    "tools_needed": {"type": "array"}
                                }
                            }
                        }
                    }
                }
            }
        )
        
        return response

    def _create_analysis_prompt(
        self,
        issues: List[SEOAuditIssue],
        url: str,
        client_profile: str
    ) -> str:
        """Create prompt for issue analysis"""
        return f"""Analyze the following SEO issues for {url}:
        
Issues:
{self._format_issues(issues)}

Client Profile:
{client_profile}

Provide a structured analysis including:
1. Categorization of issues by severity
2. Impact assessment
3. Summary of key problems
4. Potential business impact

Use terminology that a marketer could understand, not too technical, but accurate and precise enough for reader to be able to research.
Give guidance for a Wordpress user.
Format the response as a JSON object with critical_issues, high_priority, medium_priority, low_priority arrays, plus summary and impact_analysis strings."""

    def _create_recommendations_prompt(
        self,
        analysis: Dict[str, Any],
        issues: List[SEOAuditIssue]
    ) -> str:
        """Create prompt for generating recommendations"""
        return f"""Based on this analysis:
{analysis}

Generate detailed recommendations that:
1. Address each issue with specific solutions
2. Include step-by-step implementation instructions
3. Prioritize fixes based on impact and effort
4. Consider dependencies between fixes

Use terminology that a marketer could understand, not too technical, but accurate and precise enough for reader to be able to research.
Give guidance for a Wordpress/Rank Math SEO/Site Kit user.
Format as JSON with recommendations array containing objects with issue, solution, implementation_steps, priority, and estimated_effort."""

    def _create_validation_prompt(self, recommendations: Dict[str, Any]) -> str:
        """Create prompt for validation steps"""
        return f"""For these recommendations:
{recommendations}

Create validation steps that:
1. Verify each fix was implemented correctly
2. Include specific testing steps
3. Define success criteria
4. List required validation tools

Use terminology that a marketer could understand, not too technical, but accurate and precise enough for reader to be able to research.
Give guidance for a Wordpress user.
Format as JSON with validation_steps array containing objects with recommendation_id, validation_steps array, success_criteria, and tools_needed array."""

    def _format_issues(self, issues: List[SEOAuditIssue]) -> str:
        """Format issues for prompt inclusion"""
        return "\n".join([
            f"- {issue.get_issue_type_display()} ({issue.get_severity_display()}): "
            f"{issue.details.get('issue', str(issue.details))}"
            for issue in issues
        ])

================
File: apps/seo_audit/static/seo_audit/js/app.js
================
import { initializeTables } from '/static/seo_audit/js/table-init.js';
import { initializePlanGeneration, initializePlanViewing } from '/static/seo_audit/js/plan-handlers.js';
import { initializeCharts } from '/static/seo_audit/js/chart-init.js';

class AuditApp {
    constructor(config) {
        this.config = config;
    }

    initialize() {
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize tables
            const dataTableSearch = initializeTables();

            // Initialize plan generation and viewing
            initializePlanGeneration();
            initializePlanViewing();

            // Initialize charts if data is available
            if (this.config.severityData && this.config.issueTypeData) {
                initializeCharts(this.config.severityData, this.config.issueTypeData);
            }
        });
    }
}

export { AuditApp };

================
File: apps/seo_audit/static/seo_audit/js/chart-init.js
================
// Initialize charts with data
export function initializeCharts(severityData, issueTypeData) {
    // Severity Chart
    const severityCtx = document.getElementById('severityChart');
    if (severityCtx) {
        new Chart(severityCtx, {
            type: 'doughnut',
            data: {
                labels: severityData.labels,
                datasets: [{
                    data: severityData.values,
                    backgroundColor: [
                        '#f44335',  // Critical - Red
                        '#fb8c00',  // High - Orange
                        '#29b6f6',  // Medium - Light Blue
                        '#66bb6a'   // Low - Green
                    ],
                    borderWidth: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom'
                    }
                }
            }
        });
    }

    // Issue Type Chart
    const issueTypeCtx = document.getElementById('issueTypeChart');
    if (issueTypeCtx) {
        new Chart(issueTypeCtx, {
            type: 'bar',
            data: {
                labels: issueTypeData.labels,
                datasets: [{
                    label: 'Number of Issues',
                    data: issueTypeData.values,
                    backgroundColor: '#3b82f6',
                    borderRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            stepSize: 1
                        }
                    }
                }
            }
        });
    }
}

================
File: apps/seo_audit/static/seo_audit/js/json-renderer.js
================
import { escapeHtml } from './utils.js';

// Generic JSON to HTML renderer
export function renderJson(data, level = 0, parentKey = '') {
    if (data === null || data === undefined) {
        return '';
    }

    // Handle different data types
    if (Array.isArray(data)) {
        if (data.length === 0) return '';  // Don't show empty arrays
        
        // Special handling for arrays of objects
        if (typeof data[0] === 'object' && data[0] !== null) {
            return data.map(item => {
                // Check if this is a validation step object
                if (item.recommendation_id && item.validation_steps) {
                    return `
                        <div class="mb-3 p-3 border rounded">
                            <div class="mb-2">
                                <strong>For: </strong>
                                <span class="text-primary">${escapeHtml(item.recommendation_id)}</span>
                            </div>
                            ${item.validation_steps ? `
                                <div class="mb-2">
                                    <strong>Steps:</strong>
                                    <ul class="mb-2 list-unstyled ps-3">
                                        ${item.validation_steps.map(step => 
                                            `<li class="mb-1">• ${escapeHtml(step)}</li>`
                                        ).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                            ${item.success_criteria ? `
                                <div class="mb-2">
                                    <strong>Success Criteria:</strong>
                                    <div class="ps-3">${escapeHtml(item.success_criteria)}</div>
                                </div>
                            ` : ''}
                            ${item.tools_needed ? `
                                <div>
                                    <strong>Tools Needed:</strong>
                                    <div class="d-flex flex-wrap gap-1 ps-3">
                                        ${item.tools_needed.map(tool => 
                                            `<span class="badge bg-secondary">${escapeHtml(tool)}</span>`
                                        ).join(' ')}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
                
                // Check if this is a recommendation object
                if (item.issue || item.solution || item.implementation_steps) {
                    return `
                        <div class="mb-3 p-3 border rounded">
                            <div class="mb-2">
                                <h6 class="mb-2">${escapeHtml(item.issue || '')}</h6>
                                <p class="mb-3">${escapeHtml(item.solution || '')}</p>
                            </div>
                            ${item.implementation_steps ? `
                                <div class="mb-2">
                                    <strong>Implementation Steps:</strong>
                                    <ul class="mb-2 list-unstyled ps-3">
                                        ${item.implementation_steps.map(step => 
                                            `<li class="mb-1">• ${escapeHtml(step)}</li>`
                                        ).join('')}
                                    </ul>
                                </div>
                            ` : ''}
                            <div class="d-flex justify-content-between">
                                ${item.priority ? `
                                    <span class="badge bg-${
                                        (item.priority + '').toLowerCase() === 'high' ? 'danger' : 
                                        (item.priority + '').toLowerCase() === 'medium' ? 'warning' : 'info'
                                    }">${escapeHtml(item.priority)}</span>
                                ` : ''}
                                ${item.estimated_effort ? `
                                    <small class="text-muted">Effort: ${escapeHtml(item.estimated_effort)}</small>
                                ` : ''}
                            </div>
                        </div>
                    `;
                }
                
                // Default object rendering
                if (Object.keys(item).length === 0) return '';  // Don't render empty objects
                return `
                    <div class="mb-2">
                        ${renderJson(item, level + 2, parentKey)}
                    </div>
                `;
            }).join('');
        }
        
        // Regular arrays
        return `
            <ul class="list-unstyled ps-3 mb-0">
                ${data.map(item => `
                    <li class="mb-1">• ${typeof item === 'string' ? escapeHtml(item) : renderJson(item, level + 2, parentKey)}</li>
                `).join('')}
            </ul>
        `;
    }

    if (typeof data === 'object') {
        const entries = Object.entries(data)
            .filter(([key]) => !['model', 'usage', 'provider'].includes(key))
            .filter(([_, value]) => {
                // Filter out empty objects and arrays
                if (value === null || value === undefined) return false;
                if (Array.isArray(value) && value.length === 0) return false;
                if (typeof value === 'object' && Object.keys(value).length === 0) return false;
                return true;
            });
        
        if (entries.length === 0) return '';  // Don't show empty objects
        
        return entries.map(([key, value]) => {
            // Format key for display
            const formattedKey = key.split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
            
            // Special handling for recommendations and validation steps sections
            if ((key === 'recommendations' || key === 'validation_steps') && Array.isArray(value)) {
                // Only render if there's actual content
                const content = renderJson(value, level, key);  // Pass the current key
                if (!content) return '';
                
                // Only show header if it's not already in the content
                const showHeader = !parentKey || parentKey !== key;
                return `
                    <div class="mb-4">
                        ${showHeader ? `<h5 class="mb-3">${formattedKey}</h5>` : ''}
                        ${content}
                    </div>
                `;
            }
            
            // Skip rendering if the value is empty
            if (typeof value === 'object' && Object.keys(value).length === 0) return '';
            
            return `
                <div class="mb-2">
                    <strong>${formattedKey}:</strong>
                    ${typeof value === 'string' ? `<span>${escapeHtml(value)}</span>` : renderJson(value, level + 2, key)}
                </div>
            `;
        }).join('');
    }

    // Handle primitive values
    if (typeof data === 'string') {
        return `<span>${escapeHtml(data)}</span>`;
    }
    
    if (typeof data === 'number' || typeof data === 'boolean') {
        return `<span class="text-info">${data}</span>`;
    }

    return `<span class="text-muted">${escapeHtml(String(data))}</span>`;
}

================
File: apps/seo_audit/static/seo_audit/js/plan-handlers.js
================
import { renderJson } from './json-renderer.js';
import { extractJsonFromResponse } from './utils.js';

// Handle plan generation
export function initializePlanGeneration() {
    document.querySelectorAll('.generate-plan').forEach(button => {
        button.addEventListener('click', async function(e) {
            const currentButton = this;
            const url = this.dataset.url;
            const auditId = this.dataset.auditId;
            
            // Show provider selection modal
            const modal = new bootstrap.Modal(document.getElementById('providerModal'));
            modal.show();
            
            // Handle provider selection
            document.getElementById('confirmProvider').onclick = async function() {
                const provider = document.getElementById('llmProvider').value;
                const model = document.getElementById('llmModel').value;
                
                if (!provider || !model) {
                    Swal.fire({
                        title: 'Error',
                        text: 'Please select both provider and model',
                        icon: 'error'
                    });
                    return;
                }
                
                modal.hide();
                
                let loadingModal;
                try {
                    // Show loading state
                    loadingModal = Swal.fire({
                        title: 'Generating Plan',
                        text: 'Please wait while we generate your remediation plan...',
                        allowOutsideClick: false,
                        didOpen: () => {
                            Swal.showLoading();
                        }
                    });
                    
                    const response = await fetch('/seo-audit/api/remediation-plan/generate/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': window.csrfToken
                        },
                        body: JSON.stringify({
                            audit_id: auditId,
                            url: url,
                            provider: provider,
                            model: model
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || data.message || 'Server returned ' + response.status + ' ' + response.statusText);
                    }
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Failed to generate plan');
                    }
                    
                    // Close loading state
                    if (loadingModal) {
                        loadingModal.close();
                    }
                    
                    // Show success message
                    await Swal.fire({
                        title: 'Success!',
                        text: 'Remediation plan generated successfully',
                        icon: 'success'
                    });
                    
                    // Show/update view plan button
                    const viewBtn = currentButton.parentElement.querySelector('.view-plan');
                    viewBtn.style.display = 'inline-block';
                    viewBtn.dataset.planId = data.plan_id;
                    viewBtn.dataset.plans = JSON.stringify(data.all_plans);
                    
                } catch (error) {
                    console.error('Error:', error);
                    // Close loading state if it exists
                    if (loadingModal) {
                        loadingModal.close();
                    }
                    // Show error message
                    await Swal.fire({
                        title: 'Error',
                        text: 'Failed to generate remediation plan: ' + error.message,
                        icon: 'error'
                    });
                }
            };
        });
    });
    
    // Handle provider change to populate models
    document.getElementById('llmProvider').addEventListener('change', async function() {
        const modelSelect = document.getElementById('llmModel');
        const provider = this.value;
        
        if (!provider) {
            modelSelect.innerHTML = '<option value="">Select Provider First</option>';
            modelSelect.disabled = true;
            return;
        }
        
        try {
            // Show loading state
            modelSelect.disabled = true;
            modelSelect.innerHTML = '<option value="">Loading models...</option>';
            
            // Get models for selected provider using URL from template
            const response = await fetch(`${window.llmModelsUrl}?provider=${provider.toLowerCase()}`);
            if (!response.ok) throw new Error('Failed to fetch models');
            
            const data = await response.json();
            if (data.error) {
                throw new Error(data.error);
            }
            
            // Populate model select
            modelSelect.innerHTML = '<option value="">Select Model</option>';
            Object.entries(data).forEach(([modelId, modelData]) => {
                const option = document.createElement('option');
                option.value = modelId;
                option.textContent = modelId;
                modelSelect.appendChild(option);
            });
            
            modelSelect.disabled = false;
            
        } catch (error) {
            console.error('Error loading models:', error);
            modelSelect.innerHTML = '<option value="">Error loading models</option>';
            modelSelect.disabled = true;
            
            Swal.fire({
                title: 'Error',
                text: 'Failed to load models: ' + error.message,
                icon: 'error'
            });
        }
    });
}

// Handle plan viewing
export function initializePlanViewing() {
    document.querySelectorAll('.view-plan').forEach(button => {
        button.addEventListener('click', async function(e) {
            try {
                const response = await fetch(`/seo-audit/api/remediation-plan/${this.dataset.planId}/`);
                if (!response.ok) throw new Error('Failed to fetch plan');
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Failed to load plan');
                }

                // Sort plans by creation date, newest first
                const plans = data.all_plans;
                plans.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                console.log('Sorted plans:', plans);

                // Create plan selection dropdown HTML with delete button
                const planOptionsHtml = plans.map((plan, index) => `
                    <div class="mb-3">
                        <input type="radio" class="btn-check" name="plan-version" id="plan-${plan.id}" 
                               value="${plan.id}" ${index === 0 ? 'checked' : ''}>
                        <label class="btn btn-outline-primary w-100 text-start" for="plan-${plan.id}">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>${plan.provider} - ${plan.model}</strong>
                                </div>
                                <div class="d-flex align-items-center">
                                    <small class="text-muted me-3">
                                        ${new Date(plan.created_at).toLocaleString()}
                                    </small>
                                    <button type="button" class="btn btn-link text-danger p-0 delete-plan" data-plan-id="${plan.id}">
                                        <i class="fa-solid fa-trash-can"></i>
                                    </button>
                                </div>
                            </div>
                        </label>
                    </div>
                `).join('');

                // Show plan selection modal
                const result = await Swal.fire({
                    title: 'Select Plan Version',
                    html: `
                        <div class="plan-versions">
                            ${planOptionsHtml}
                        </div>
                    `,
                    showCancelButton: true,
                    confirmButtonText: 'View Selected Plan',
                    cancelButtonText: 'Cancel',
                    width: '600px',
                    didOpen: () => {
                        // Add click handlers for delete buttons
                        document.querySelectorAll('.delete-plan').forEach(deleteBtn => {
                            deleteBtn.addEventListener('click', async (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                
                                const planId = deleteBtn.dataset.planId;
                                
                                // Confirm deletion
                                const confirmResult = await Swal.fire({
                                    title: 'Delete Plan',
                                    text: 'Are you sure you want to delete this plan?',
                                    icon: 'warning',
                                    showCancelButton: true,
                                    confirmButtonText: 'Delete',
                                    cancelButtonText: 'Cancel',
                                    confirmButtonColor: '#dc3545'
                                });
                                
                                if (confirmResult.isConfirmed) {
                                    try {
                                        const response = await fetch(`/seo-audit/api/remediation-plan/${planId}/delete/`, {
                                            method: 'DELETE',
                                            headers: {
                                                'X-CSRFToken': window.csrfToken
                                            }
                                        });
                                        
                                        if (!response.ok) {
                                            const data = await response.json();
                                            throw new Error(data.error || 'Failed to delete plan');
                                        }
                                        
                                        // Remove the plan from the list
                                        const planElement = deleteBtn.closest('.mb-3');
                                        planElement.remove();
                                        
                                        // If no plans left, close the modal and hide view plan button
                                        if (document.querySelectorAll('.plan-versions .mb-3').length === 0) {
                                            const viewPlanBtn = document.querySelector('.view-plan[data-plan-id="' + planId + '"]');
                                            if (viewPlanBtn) {
                                                viewPlanBtn.style.display = 'none';
                                            }
                                            Swal.close();
                                            return;
                                        }
                                        
                                        // Select the first plan if the deleted one was selected
                                        const firstPlan = document.querySelector('input[name="plan-version"]');
                                        if (firstPlan) {
                                            firstPlan.checked = true;
                                            // Update the view plan button's data-plan-id to the first available plan
                                            const viewPlanBtn = document.querySelector('.view-plan[data-plan-id="' + planId + '"]');
                                            if (viewPlanBtn) {
                                                viewPlanBtn.dataset.planId = firstPlan.value;
                                            }
                                        }
                                        
                                        // Show success message as a toast in the modal
                                        const toast = Swal.mixin({
                                            toast: true,
                                            position: 'top',
                                            showConfirmButton: false,
                                            timer: 3000,
                                            timerProgressBar: true,
                                            didOpen: (toast) => {
                                                toast.addEventListener('mouseenter', Swal.stopTimer);
                                                toast.addEventListener('mouseleave', Swal.resumeTimer);
                                            }
                                        });
                                        await toast.fire({
                                            icon: 'success',
                                            title: 'Plan deleted successfully'
                                        });
                                    } catch (error) {
                                        console.error('Error deleting plan:', error);
                                        Swal.fire({
                                            icon: 'error',
                                            title: 'Error',
                                            text: error.message
                                        });
                                    }
                                }
                            });
                        });
                    },
                    preConfirm: () => {
                        const selectedPlanId = document.querySelector('input[name="plan-version"]:checked')?.value;
                        return plans.find(p => p.id.toString() === selectedPlanId);
                    }
                });

                if (result.isConfirmed && result.value) {
                    const selectedPlan = result.value;
                    console.log('Selected plan:', selectedPlan);
                    
                    // Parse content sections
                    const parsedSections = {};
                    if (selectedPlan.content) {
                        // Handle both object and array formats
                        const content = Array.isArray(selectedPlan.content) ? selectedPlan.content : [selectedPlan.content];
                        
                        // First try to parse each section directly
                        for (const item of content) {
                            if (typeof item === 'object' && !Array.isArray(item)) {
                                for (const [key, value] of Object.entries(item)) {
                                    // Skip empty values
                                    if (!value) continue;
                                    
                                    const parsed = extractJsonFromResponse(value);
                                    if (parsed) {
                                        parsedSections[key] = parsed;
                                    }
                                }
                            } else if (typeof item === 'string') {
                                // Try to parse string items directly
                                const parsed = extractJsonFromResponse(item);
                                if (parsed && typeof parsed === 'object') {
                                    Object.entries(parsed).forEach(([key, value]) => {
                                        if (value !== null && value !== undefined) {
                                            parsedSections[key] = value;
                                        }
                                    });
                                }
                            }
                        }
                    }

                    console.log('Final parsed sections:', parsedSections);

                    // Only show modal if we have parsed content
                    if (Object.keys(parsedSections).length > 0) {
                        // Render each section that has data
                        Swal.fire({
                            title: 'Remediation Plan',
                            html: `
                                <div class="text-start">
                                    ${Object.entries(parsedSections)
                                        .filter(([_, value]) => value !== null && (
                                            (Array.isArray(value) && value.length > 0) ||
                                            (typeof value === 'object' && Object.keys(value).length > 0) ||
                                            value.toString().trim() !== ''
                                        ))
                                        .map(([key, value]) => {
                                            const sectionTitle = key.charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
                                            return `
                                                <div class="mb-4">
                                                    <h6 class="mb-3 border-bottom pb-2">${sectionTitle}</h6>
                                                    ${renderJson(value)}
                                                </div>
                                            `;
                                        }).join('')}
                                </div>
                            `,
                            width: '800px',
                            showCloseButton: true,
                            showConfirmButton: false,
                            customClass: {
                                htmlContainer: 'remediation-plan-modal'
                            }
                        });
                    } else {
                        console.log('No valid sections found');
                        Swal.fire({
                            title: 'Error',
                            text: 'No valid content found in the plan',
                            icon: 'warning'
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading plan:', error);
                Swal.fire({
                    title: 'Error',
                    text: 'Failed to load remediation plan: ' + error.message,
                    icon: 'error'
                });
            }
        });
    });
}

================
File: apps/seo_audit/static/seo_audit/js/results.js
================
import { initializeTables } from './table-init.js?v=' + new Date().getTime();
import { initializePlanGeneration, initializePlanViewing, initializePlanDeletion } from './plan-handlers.js?v=' + new Date().getTime();
import { initializeCharts } from './chart-init.js?v=' + new Date().getTime();

// Ensure jQuery is properly initialized
if (typeof jQuery === 'undefined') {
    console.error('jQuery is not loaded');
} else {
    window.$ = window.jQuery = jQuery;
}

document.addEventListener('DOMContentLoaded', function() {
    // Initialize tables
    const dataTableSearch = initializeTables();

    // Initialize plan generation, viewing and deletion
    initializePlanGeneration();
    initializePlanViewing();
    initializePlanDeletion();

    // Initialize charts if data is available
    const severityData = window.severityData;
    const issueTypeData = window.issueTypeData;
    if (severityData && issueTypeData) {
        initializeCharts(severityData, issueTypeData);
    }
});

================
File: apps/seo_audit/static/seo_audit/js/table-init.js
================
// Initialize tables and scrollbars
export function initializeTables() {
    // Initialize Perfect Scrollbar for tables with fixed height
    const tableElements = document.querySelectorAll('.table-responsive');
    if (tableElements.length > 0) {
        tableElements.forEach(element => {
            element.style.maxHeight = '800px';
            new PerfectScrollbar(element, {
                wheelSpeed: 1,
                wheelPropagation: true,
                minScrollbarLength: 20,
                suppressScrollX: true
            });
        });
    }

    // Initialize DataTable
    const issuesTable = document.getElementById('issues-table');
    let dataTableSearch;
    if (issuesTable) {
        dataTableSearch = new simpleDatatables.DataTable("#issues-table", {
            searchable: true,
            fixedHeight: false,
            perPage: 50,
            perPageSelect: [25, 50, 100, 200],
            columns: [
                { select: 0, sort: "desc" },
                { select: 1, sort: "asc" },
                { select: 2, sort: "asc" },
                { select: 3, sortable: false }
            ],
            labels: {
                placeholder: "Search issues...",
                perPage: "{select} issues per page",
                noRows: "No issues found",
                info: "Showing {start} to {end} of {rows} entries",
                noResults: "No results match your search query"
            },
            layout: {
                top: "{search}{select}",
                bottom: "<div class='d-flex justify-content-between align-items-center'>{info}{pager}</div>"
            },
            classes: {
                wrapper: "datatable-wrapper",
                input: "form-control form-control-sm",
                selector: "form-select form-select-sm",
                pager: "pagination mb-0"
            }
        });

        // Move search and select elements to our toolbar
        const searchElement = document.querySelector('.datatable-search');
        const selectElement = document.querySelector('.datatable-dropdown');
        const dtSearchInput = document.querySelector('.datatable-input');
        const dtSelector = document.querySelector('.datatable-selector');

        if (searchElement && dtSearchInput && dtSearchInput.parentElement) {
            searchElement.appendChild(dtSearchInput.parentElement);
        }
        if (selectElement && dtSelector && dtSelector.parentElement) {
            selectElement.appendChild(dtSelector.parentElement);
        }
    }

    return dataTableSearch;
}

================
File: apps/seo_audit/static/seo_audit/js/utils.js
================
// Helper function to safely escape HTML and preserve backticks
export function escapeHtml(str) {
    if (typeof str !== 'string') return str;
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
        .replace(/`(.*?)`/g, '<code>$1</code>');
}

// Helper function to decode HTML entities
function decodeHtmlEntities(str) {
    if (typeof str !== 'string') return str;
    const textarea = document.createElement('textarea');
    textarea.innerHTML = str;
    return textarea.value;
}

// Helper function to clean JSON string
function cleanJsonString(str) {
    if (typeof str !== 'string') return str;
    
    // First pass: Extract JSON from markdown if present
    let cleaned = str;
    const codeBlockMatch = str.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
    if (codeBlockMatch) {
        cleaned = codeBlockMatch[1].trim();
    }
    
    // Second pass: Clean up the string
    cleaned = cleaned
        // Remove control characters
        .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
        // Normalize newlines and whitespace
        .replace(/\r?\n/g, ' ')
        .replace(/\s+/g, ' ')
        // Handle HTML tags by preserving them
        .replace(/(<[^>]*>)/g, match => match.replace(/"/g, '&quot;'))
        .trim();

    // Third pass: Decode HTML entities in the cleaned string
    cleaned = decodeHtmlEntities(cleaned);
    
    return cleaned;
}

// Helper function to find the most complete JSON structure
function findMostCompleteJson(matches) {
    let bestMatch = null;
    let maxScore = -1;

    for (const match of matches) {
        try {
            const cleanedMatch = cleanJsonString(match);
            const parsed = JSON.parse(cleanedMatch);
            
            // Score the completeness of the JSON
            const score = calculateJsonScore(parsed);
            if (score > maxScore) {
                maxScore = score;
                bestMatch = parsed;
            }
        } catch (e) {
            console.log('Failed to parse match:', e);
            continue;
        }
    }

    return bestMatch;
}

// Helper function to score JSON completeness
function calculateJsonScore(obj) {
    if (!obj) return 0;
    let score = 0;

    if (Array.isArray(obj)) {
        score += obj.length;
        for (const item of obj) {
            score += calculateJsonScore(item);
        }
    } else if (typeof obj === 'object') {
        const keys = Object.keys(obj);
        score += keys.length;
        for (const key of keys) {
            if (key !== 'metadata' && key !== 'model' && key !== 'usage') {
                score += calculateJsonScore(obj[key]) * 2; // Give more weight to actual content
            }
        }
    }

    return score;
}

// Helper function to extract JSON from any format
export function extractJsonFromResponse(input) {
    try {
        // Handle null/undefined
        if (!input) return null;

        // If already a parsed object/array, return as is
        if (typeof input === 'object') {
            // If array, try each element
            if (Array.isArray(input)) {
                let bestResult = null;
                let maxScore = -1;

                for (const item of input) {
                    const result = extractJsonFromResponse(item);
                    if (result) {
                        const score = calculateJsonScore(result);
                        if (score > maxScore) {
                            maxScore = score;
                            bestResult = result;
                        }
                    }
                }
                return bestResult;
            }
            // If object and not null, filter out metadata
            if (input !== null) {
                const {metadata, model, usage, ...content} = input;
                return Object.keys(content).length > 0 ? content : input;
            }
        }

        // If string, try to parse as JSON
        if (typeof input === 'string') {
            // Clean the string
            const cleaned = cleanJsonString(input);
            
            try {
                // Try direct parse first
                const parsed = JSON.parse(cleaned);
                const {metadata, model, usage, ...content} = parsed;
                return Object.keys(content).length > 0 ? content : parsed;
            } catch (e) {
                // Try to find and parse JSON-like structures
                const matches = cleaned.match(/(\{[\s\S]*?\}|\[[\s\S]*?\])/g) || [];
                
                if (matches.length > 0) {
                    // Find the most complete JSON structure
                    const bestMatch = findMostCompleteJson(matches);
                    if (bestMatch) {
                        const {metadata, model, usage, ...content} = bestMatch;
                        return Object.keys(content).length > 0 ? content : bestMatch;
                    }
                }
            }
        }

        return null;
    } catch (error) {
        console.error('JSON extraction failed:', error);
        return null;
    }
}

================
File: apps/seo_audit/templates/seo_audit/audit.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} SEO Audit {% endblock %}

{% block extrastyle %}
<style>
    .progress {
        height: 30px;
        background-color: #f0f2f5;
        border-radius: 8px;
        margin: 1rem 0;
        box-shadow: inset 0 1px 2px rgba(0,0,0,0.1);
    }
    
    .progress-bar {
        height: 100%;
        transition: width 0.5s ease;
        font-size: 14px;
        font-weight: 600;
        line-height: 30px;
        color: white;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        background-image: linear-gradient(45deg, #11cdef, #1171ef);
    }
    
    .progress-bar.in-progress {
        background-size: 30px 30px;
        background-image: linear-gradient(
            45deg,
            rgba(255, 255, 255, 0.15) 25%,
            transparent 25%,
            transparent 50%,
            rgba(255, 255, 255, 0.15) 50%,
            rgba(255, 255, 255, 0.15) 75%,
            transparent 75%,
            transparent
        ), linear-gradient(45deg, #11cdef, #1171ef);
        animation: progress-bar-stripes 1s linear infinite, pulse 2s ease infinite;
    }
    
    @keyframes progress-bar-stripes {
        from { background-position: 30px 0; }
        to { background-position: 0 0; }
    }

    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.8; }
        100% { opacity: 1; }
    }

    /* Add a pulsing effect to the status text when in progress */
    #audit-status.running {
        animation: status-pulse 2s ease infinite;
        color: #11cdef;
        font-weight: 600;
    }

    @keyframes status-pulse {
        0% { opacity: 1; }
        50% { opacity: 0.6; }
        100% { opacity: 1; }
    }

    /* Make the counters more prominent */
    .status-counter {
        font-size: 1.2rem;
        font-weight: 600;
        color: #344767;
    }

    .status-label {
        font-size: 0.875rem;
        color: #67748e;
        margin-bottom: 0.25rem;
    }
    
    .list-group-item {
        padding: 0.5rem 1rem;
    }
    #audit-chart-container {
        height: 300px;
        position: relative;
    }
    .timeline-block {
        margin-bottom: 1rem;
    }
    .timeline-step {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-right: 0.75rem;
    }
    .timeline-content {
        flex: 1;
    }
    .severity-critical { color: #dc3545; }
    .severity-high { color: #fd7e14; }
    .severity-medium { color: #ffc107; }
    .severity-low { color: #20c997; }
    .severity-info { color: #0dcaf0; }
</style>
{% endblock extrastyle %}

{% block content %}
<div class="main-content position-relative max-height-vh-100 h-100">
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <div class="card mb-4">
                    <div class="card-header pb-0 p-3">
                        <div class="row">
                            <div class="col-6 d-flex align-items-center">
                                <h6 class="mb-0">SEO Audit</h6>
                            </div>
                            <div class="col-6 text-end">
                                <a href="{% url 'seo_audit:audit_history' %}" class="btn btn-sm btn-outline-primary">View History</a>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mt-4">
            <div class="col-12 col-xl-4">
                <div class="card">
                    <div class="card-header pb-0 p-3">
                        <h6 class="mb-0">SEO Audit Configuration</h6>
                    </div>
                    <div class="card-body p-3">
                        <form id="audit-form">
                            <div class="mb-3">
                                <label for="client" class="form-label">Client</label>
                                <select class="form-select" id="client" name="client">
                                    <option value="">None (Custom URL)</option>
                                    {% for client in clients %}
                                        <option value="{{ client.id }}">{{ client.name }}</option>
                                    {% endfor %}
                                </select>
                                <div class="form-text">Select a client or choose 'None' for a custom URL</div>
                            </div>
                            <div class="mb-3">
                                <label for="website" class="form-label">Website URL</label>
                                <input type="url" class="form-control" id="website" name="website" placeholder="https://example.com" required>
                                <div class="form-text">Enter the full URL including https://</div>
                            </div>
                            <div class="mb-3">
                                <label for="max_pages" class="form-label">Maximum Pages</label>
                                <input type="number" class="form-control" id="max_pages" name="max_pages" value="100" min="1" max="1000">
                                <div class="form-text">Maximum number of pages to analyze (1-1000)</div>
                            </div>
                            <div class="mb-3">
                                <div class="form-check">
                                    <input type="checkbox" class="form-check-input" id="check_external_links" name="check_external_links">
                                    <label class="form-check-label" for="check_external_links">Check External Links</label>
                                </div>
                                <div class="form-text">Also check links to external websites</div>
                            </div>
                            <div class="mb-3">
                                <label for="crawl_delay" class="form-label">Crawl Delay (seconds)</label>
                                <input type="number" class="form-control" id="crawl_delay" name="crawl_delay" value="1.0" min="0.1" max="10" step="0.1">
                                <div class="form-text">Delay between requests (0.1-10 seconds)</div>
                            </div>
                            <button type="submit" class="btn btn-primary">Start Audit</button>
                        </form>
                    </div>
                </div>
            </div>

            <div class="col-12 col-xl-8">
                <div class="card mb-4">
                    <div class="card-header pb-0 p-3">
                        <h6 class="mb-0">Audit Progress</h6>
                    </div>
                    <div class="card-body p-3">
                        <div class="progress mb-3">
                            <div id="audit-progress" class="progress-bar bg-gradient-info" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                        <div class="row">
                            <div class="col-md-4">
                                <p class="text-sm mb-1">Status: <span id="audit-status" class="font-weight-bold">Not Started</span></p>
                            </div>
                            <div class="col-md-4">
                                <p class="text-sm mb-1">Pages Analyzed: <span id="pages-analyzed" class="font-weight-bold">0</span></p>
                            </div>
                            <div class="col-md-4">
                                <p class="text-sm mb-1">Issues Found: <span id="issues-found" class="font-weight-bold">0</span></p>
                            </div>
                        </div>
                        <div id="audit-chart-container" class="mt-4">
                            <canvas id="audit-chart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="card mb-4">
                    <div class="card-header pb-0 p-3">
                        <h6 class="mb-0">Live Issues</h6>
                    </div>
                    <div class="card-body p-3">
                        <div id="live-issues" class="timeline timeline-one-side"></div>
                    </div>
                </div>

                <div id="results-section" class="card" style="display: none;">
                    <div class="card-header pb-0 p-3">
                        <div class="row">
                            <div class="col-6 d-flex align-items-center">
                                <h6 class="mb-0">Audit Results</h6>
                            </div>
                            <div class="col-6 text-end">
                                <button id="export-results" class="btn btn-sm btn-outline-primary">Export Results</button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body px-0 pt-0 pb-2">
                        <div class="table-responsive p-0">
                            <table class="table align-items-center mb-0">
                                <thead>
                                    <tr>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Severity</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Type</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">URL</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Details</th>
                                        <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Time</th>
                                    </tr>
                                </thead>
                                <tbody id="results-table-body"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>

<script>
    let ws = null;
    let auditChart = null;
    let auditId = null;
    let isConnected = false;
    const MAX_DATA_POINTS = 50;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let reconnectAttempts = 0;

    // Check WebSocket connection
    function checkConnection() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.error('WebSocket not connected. State:', ws ? ws.readyState : 'null');
            return false;
        }
        return true;
    }

    // Safe WebSocket send
    function safeSend(message) {
        try {
            if (checkConnection()) {
                console.log('Sending message:', message);
                ws.send(JSON.stringify(message));
                return true;
            }
            return false;
        } catch (error) {
            console.error('Error sending message:', error);
            return false;
        }
    }

    // Initialize WebSocket connection
    function connectWebSocket(newAuditId) {
        console.log('Connecting WebSocket for audit:', newAuditId);
        auditId = newAuditId;
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}/ws/seo_audit/${auditId}/`;
        console.log('WebSocket URL:', wsUrl);
        
        if (ws) {
            console.log('Closing existing WebSocket connection');
            ws.close();
            isConnected = false;
        }
        
        try {
            ws = new WebSocket(wsUrl);
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            return;
        }
        
        ws.onopen = function() {
            console.log('WebSocket connected');
            isConnected = true;
            reconnectAttempts = 0;

            // Initialize chart when WebSocket connects
            if (!auditChart) {
                initializeAuditChart();
            }
            
            // Send test message
            safeSend({ 
                type: 'test',
                message: 'Testing WebSocket connection'
            });
        };
        
        ws.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'test') {
                    return;
                }

                handleWebSocketMessage(data);
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
                console.error('Raw message:', event.data);
            }
        };

        ws.onclose = function(event) {
            console.log('WebSocket closed:', event);
            isConnected = false;
            
            if (auditId && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                console.log(`Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})`);
                setTimeout(function() {
                    connectWebSocket(auditId);
                }, 1000);
            } else if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                console.error('Max reconnection attempts reached');
                handleAuditError('WebSocket connection failed after multiple attempts');
            }
        };

        ws.onerror = function(error) {
            console.error('WebSocket error:', error);
            isConnected = false;
            
            if (ws) {
                ws.close();
            }
        };
    }

    // Handle WebSocket messages
    function handleWebSocketMessage(data) {
        console.log('Handling WebSocket message:', data);
        try {
            if (!data.type) {
                console.warn('Message missing type:', data);
                return;
            }

            switch(data.type) {
                case 'audit.update':
                    if (data.data) {
                        console.log('Processing audit update:', data.data);
                        updateProgress(data.data);
                    } else {
                        console.warn('No data in audit.update message:', data);
                    }
                    break;
                case 'audit.complete':
                    if (data.data) {
                        console.log('Processing audit complete:', data.data);
                        handleAuditComplete(data.data);
                    } else {
                        console.warn('No data in audit.complete message:', data);
                    }
                    break;
                case 'audit.error':
                    console.error('Audit error:', data.error || 'Unknown error');
                    handleAuditError(data.error || 'Unknown error');
                    break;
                default:
                    console.warn('Unknown message type:', data.type);
            }
        } catch (error) {
            console.error('Error in handleWebSocketMessage:', error, 'Data:', data);
        }
    }

    // Initialize chart with error handling
    function initializeAuditChart() {
        console.log('Initializing chart...');
        const ctx = document.getElementById('audit-chart');
        if (!ctx) {
            console.error('Chart canvas element not found');
            return;
        }

        try {
            if (auditChart) {
                console.log('Destroying existing chart');
                try {
                    auditChart.destroy();
                } catch (destroyError) {
                    console.error('Error destroying existing chart:', destroyError);
                }
            }

            auditChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Pages Analyzed',
                            data: [],
                            borderColor: 'rgb(75, 192, 192)',
                            tension: 0.1,
                            fill: false,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Issues Found',
                            data: [],
                            borderColor: 'rgb(255, 99, 132)',
                            tension: 0.1,
                            fill: false,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Issues Found'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Pages Analyzed'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        }
                    },
                    animation: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
            console.log('Chart initialized successfully');
        } catch (error) {
            console.error('Error initializing chart:', error);
        }
    }

    // Update chart data
    function updateChart(issuesCount, pagesCount) {
        console.log('Updating chart with:', { issuesCount, pagesCount });
        if (!auditChart) {
            console.warn('Chart not initialized, initializing now...');
            initializeAuditChart();
            if (!auditChart) {
                console.error('Failed to initialize chart');
                return;
            }
        }

        try {
            const currentTime = new Date().toLocaleTimeString();
            auditChart.data.labels.push(currentTime);
            auditChart.data.datasets[0].data.push(pagesCount);
            auditChart.data.datasets[1].data.push(issuesCount);

            if (auditChart.data.labels.length > MAX_DATA_POINTS) {
                auditChart.data.labels.shift();
                auditChart.data.datasets[0].data.shift();
                auditChart.data.datasets[1].data.shift();
            }

            auditChart.update('none'); // Disable animation for smoother updates
            console.log('Chart updated successfully');
        } catch (error) {
            console.error('Error updating chart:', error);
        }
    }

    // Reset UI elements
    function resetUI() {
        console.log('Resetting UI elements');
        try {
            // Reset progress elements
            const progressBar = document.getElementById('audit-progress');
            if (progressBar) {
                progressBar.style.width = '0%';
                progressBar.textContent = '0%';
            }

            const pagesAnalyzed = document.getElementById('pages-analyzed');
            if (pagesAnalyzed) {
                pagesAnalyzed.textContent = '0';
            }

            const issuesFound = document.getElementById('issues-found');
            if (issuesFound) {
                issuesFound.textContent = '0';
            }

            const auditStatus = document.getElementById('audit-status');
            if (auditStatus) {
                auditStatus.textContent = 'Starting...';
            }
            
            // Reset live issues
            const liveIssues = document.getElementById('live-issues');
            if (liveIssues) {
                while (liveIssues.firstChild) {
                    liveIssues.removeChild(liveIssues.firstChild);
                }
            }
            
            // Reset results section
            const resultsSection = document.getElementById('results-section');
            if (resultsSection) {
                resultsSection.style.display = 'none';
            }

            const resultsTableBody = document.getElementById('results-table-body');
            if (resultsTableBody) {
                resultsTableBody.innerHTML = '';
            }
            
            // Initialize a fresh chart
            try {
                initializeAuditChart();
            } catch (chartError) {
                console.error('Error initializing chart:', chartError);
            }
            
            console.log('UI reset complete');
        } catch (error) {
            console.error('Error resetting UI:', error);
        }
    }

    // Form submission
    document.getElementById('audit-form').addEventListener('submit', function(e) {
        e.preventDefault();
        console.log('Form submitted');
        
        // Get form data
        const formData = new FormData(this);
        const data = {
            client: formData.get('client'),
            website: formData.get('website'),
            max_pages: parseInt(formData.get('max_pages')),
            check_external_links: formData.get('check_external_links') === 'on',
            crawl_delay: parseFloat(formData.get('crawl_delay'))
        };
        console.log('Form data:', data);

        // Validate required fields
        if (!data.website) {
            alert('Website URL is required');
            return;
        }

        // Disable form while submitting
        const submitButton = this.querySelector('button[type="submit"]');
        submitButton.disabled = true;
        submitButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Starting...';

        // Close existing WebSocket connection if any
        if (ws) {
            ws.close();
            ws = null;
        }

        fetch('{% url "seo_audit:start_audit" %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            console.log('Response status:', response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`HTTP error! status: ${response.status}, message: ${text}`);
                });
            }
            return response.json();
        })
        .then(data => {
            console.log('Response data:', data);
            if (data.audit_id) {
                // Reset UI only once, after getting audit_id
                resetUI();
                // Initialize WebSocket connection
                connectWebSocket(data.audit_id);
            } else {
                throw new Error('No audit ID received');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to start audit: ' + error.message);
        })
        .finally(() => {
            // Re-enable form
            submitButton.disabled = false;
            submitButton.innerHTML = 'Start Audit';
        });
    });

    // Update progress with error handling
    function updateProgress(data) {
        console.log('Updating progress with data:', data);
        try {
            const progressBar = document.getElementById('audit-progress');
            const pagesAnalyzed = document.getElementById('pages-analyzed');
            const issuesFound = document.getElementById('issues-found');
            const auditStatus = document.getElementById('audit-status');

            if (!progressBar || !pagesAnalyzed || !issuesFound || !auditStatus) {
                console.error('Required DOM elements not found');
                return;
            }

            // Extract progress data from the message
            const progress = data.progress || data;
            console.log('Progress object:', progress);
            
            const percentComplete = progress.percent_complete || 0;
            const pagesCount = progress.pages_analyzed || 0;
            const issuesCount = progress.issues_found || 0;
            const status = progress.status || data.status || 'In Progress';

            console.log('Updating UI with:', { percentComplete, pagesCount, issuesCount, status });

            // Update progress bar
            progressBar.style.width = `${percentComplete}%`;
            progressBar.setAttribute('aria-valuenow', percentComplete);
            progressBar.textContent = `${percentComplete}%`;
            
            // Add or remove the animation class based on completion
            if (percentComplete < 100) {
                progressBar.classList.add('in-progress');
            } else {
                progressBar.classList.remove('in-progress');
            }

            // Update counters
            pagesAnalyzed.textContent = pagesCount;
            issuesFound.textContent = issuesCount;
            auditStatus.textContent = status;

            // Update chart
            if (auditChart) {
                updateChart(issuesCount, pagesCount);
            } else {
                console.warn('Chart not initialized');
                initializeAuditChart();
                updateChart(issuesCount, pagesCount);
            }

            // Update live issues if any
            if (progress.recent_issues && progress.recent_issues.length > 0) {
                updateLiveIssues(progress.recent_issues);
            }
        } catch (error) {
            console.error('Error in updateProgress:', error, 'Data:', data);
        }
    }

    // Update live issues
    function updateLiveIssues(issues) {
        const container = document.getElementById('live-issues');
        if (!container) {
            console.warn('Live issues container not found');
            return;
        }
        
        if (!Array.isArray(issues)) {
            console.warn('Expected issues to be an array, got:', typeof issues);
            return;
        }
        
        issues.forEach(issue => {
            const issueElement = document.createElement('div');
            issueElement.className = 'alert alert-' + getSeverityColor(issue.severity) + ' text-white';
            issueElement.innerHTML = `
                <strong>${issue.issue_type}:</strong> ${formatDetails(issue.details)}
                <br>
                <small>${truncateUrl(issue.url)}</small>
            `;
            container.insertBefore(issueElement, container.firstChild);
            
            // Keep only the last 5 issues
            while (container.children.length > 5 && container.lastChild) {
                try {
                    container.removeChild(container.lastChild);
                } catch (error) {
                    console.warn('Error removing child:', error);
                    break;
                }
            }
        });
    }

    // Handle audit completion
    function handleAuditComplete(data) {
        console.log('Handling audit complete:', data);
        const progressBar = document.getElementById('audit-progress');
        if (progressBar) {
            progressBar.classList.remove('in-progress');  // Remove animation when complete
        }
        document.getElementById('audit-status').textContent = 'Completed';
        
        // Close WebSocket connection if open
        if (ws) {
            ws.close();
        }

        // Show completion message with SweetAlert2 and redirect
        Swal.fire({
            title: 'Audit Complete!',
            text: 'Redirecting to results page...',
            icon: 'success',
            timer: 2000,
            showConfirmButton: false,
            willClose: () => {
                // Update the URL to match the pattern in urls.py
                window.location.href = `{% url 'seo_audit:audit' %}results/${auditId}/`;
            }
        });
    }

    function populateResultsTable(issues) {
        const tbody = document.getElementById('results-table-body');
        if (!tbody) {
            console.error('Results table body not found');
            return;
        }
        
        tbody.innerHTML = ''; // Clear existing results
        
        if (!Array.isArray(issues)) {
            console.warn('Expected issues to be an array, got:', typeof issues);
            return;
        }

        if (issues.length === 0) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td colspan="5" class="text-center">
                    <span class="text-xs font-weight-bold">
                        No issues found
                    </span>
                </td>
            `;
            tbody.appendChild(row);
            return;
        }

        issues.forEach(issue => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>
                    <span class="badge badge-sm bg-gradient-${getSeverityColor(issue.severity)}">
                        ${issue.severity}
                    </span>
                </td>
                <td>
                    <span class="text-xs font-weight-bold">
                        ${issue.issue_type}
                    </span>
                </td>
                <td>
                    <a href="${issue.url}" target="_blank" class="text-xs font-weight-bold mb-0">
                        ${truncateUrl(issue.url)}
                    </a>
                </td>
                <td>
                    <span class="text-xs font-weight-bold">
                        ${formatDetails(issue.details)}
                    </span>
                </td>
                <td>
                    <span class="text-xs font-weight-bold">
                        ${formatTimestamp(issue.discovered_at)}
                    </span>
                </td>
            `;
            tbody.appendChild(row);
        });
    }

    function formatTimestamp(timestamp) {
        try {
            return new Date(timestamp).toLocaleString();
        } catch (e) {
            console.warn('Error formatting timestamp:', e);
            return timestamp || 'Unknown';
        }
    }

    // Helper function to get severity color
    function getSeverityColor(severity) {
        const colors = {
            'critical': 'danger',
            'high': 'warning',
            'medium': 'info',
            'low': 'success',
            'info': 'secondary'
        };
        return colors[severity] || 'secondary';
    }

    // Helper function to truncate long URLs
    function truncateUrl(url) {
        const maxLength = 50;
        return url.length > maxLength ? url.substring(0, maxLength) + '...' : url;
    }

    // Helper function to format details
    function formatDetails(details) {
        if (typeof details === 'string') {
            return details;
        }
        try {
            return JSON.stringify(details, null, 2);
        } catch (e) {
            return String(details);
        }
    }

    // Client selector handling
    document.getElementById('client').addEventListener('change', function() {
        const websiteInput = document.getElementById('website');
        if (this.value) {
            fetch(`{% url 'seo_audit:get_client_website' 0 %}`.replace('0', this.value))
                .then(response => response.json())
                .then(data => {
                    if (data.website_url) {
                        websiteInput.value = data.website_url;
                    }
                })
                .catch(error => console.error('Error:', error));
        } else {
            // Clear the website input if "None" is selected
            websiteInput.value = '';
        }
    });

    // Export results
    document.getElementById('export-results').addEventListener('click', function() {
        if (auditId) {
            window.location.href = `/seo_audit/export/${auditId}/`;
        }
    });

    // Handle audit error
    function handleAuditError(error) {
        console.error('Audit error:', error);
        document.getElementById('audit-status').textContent = 'Error: ' + error;
        document.getElementById('audit-progress').classList.remove('bg-info');
        document.getElementById('audit-progress').classList.add('bg-danger');
        
        if (ws) {
            ws.close();
        }
    }
</script>
{% endblock extra_js %}

================
File: apps/seo_audit/templates/seo_audit/history.html
================
{% extends "layouts/base.html" %}

{% block title %} SEO Audit History {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header pb-0 p-3">
                    <div class="row">
                        <div class="col-6">
                            <h6 class="mb-0">SEO Audit History</h6>
                        </div>
                        <div class="col-6 text-end">
                            <a href="{% url 'seo_audit:audit' %}" class="btn btn-sm btn-outline-primary">New Audit</a>
                        </div>
                    </div>
                </div>
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <table class="table align-items-center mb-0">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Client</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Website</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Start Time</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Duration</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Issues</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for audit in audits %}
                                <tr>
                                    <td>
                                        <div class="d-flex px-3 py-1">
                                            <div class="d-flex flex-column justify-content-center">
                                                <h6 class="mb-0 text-sm">{{ audit.client.name|default:"No Client" }}</h6>
                                            </div>
                                        </div>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">
                                            <a href="{{ audit.website }}" target="_blank">{{ audit.website }}</a>
                                        </p>
                                    </td>
                                    <td>
                                        <span class="badge badge-sm bg-gradient-{{ audit.status|lower }}">
                                            {{ audit.status }}
                                        </span>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ audit.start_time|date:"Y-m-d H:i" }}</p>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ audit.duration|default:"N/A" }}</p>
                                    </td>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ audit.issues.count }}</p>
                                    </td>
                                    <td class="align-middle">
                                        <a href="{% url 'seo_audit:audit_results' audit.id %}" 
                                           class="btn btn-link text-dark px-3 mb-0">
                                            <i class="fas fa-eye text-dark me-2"></i>View
                                        </a>
                                        <a href="{% url 'seo_audit:export_audit' audit.id %}" 
                                           class="btn btn-link text-dark px-3 mb-0">
                                            <i class="fas fa-download text-dark me-2"></i>Export
                                        </a>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="7" class="text-center py-4">
                                        <p class="text-sm mb-0">No audits found</p>
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    {% if is_paginated %}
    <div class="row">
        <div class="col-12">
            <nav aria-label="Page navigation">
                <ul class="pagination justify-content-center">
                    {% if page_obj.has_previous %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.previous_page_number }}">Previous</a>
                    </li>
                    {% endif %}

                    {% for num in page_obj.paginator.page_range %}
                    <li class="page-item {% if page_obj.number == num %}active{% endif %}">
                        <a class="page-link" href="?page={{ num }}">{{ num }}</a>
                    </li>
                    {% endfor %}

                    {% if page_obj.has_next %}
                    <li class="page-item">
                        <a class="page-link" href="?page={{ page_obj.next_page_number }}">Next</a>
                    </li>
                    {% endif %}
                </ul>
            </nav>
        </div>
    </div>
    {% endif %}
</div>
{% endblock content %}

================
File: apps/seo_audit/templates/seo_audit/results.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load cache %}

{% block title %} SEO Audit Results {% endblock %}

{% block extrastyle %}
{% cache 86400 'seo_audit_results_css_version' %}
{% with css_version=1|stringformat:"d" %}
<link rel="stylesheet" href="{% static 'seo_audit/css/results.css' %}?v={{ css_version }}_{% now "U" %}">
{% endwith %}
{% endcache %}
{% endblock extrastyle %}

{% block content %}
<div class="container-fluid py-4">
    <!-- Audit Summary Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <div class="row">
                        <div class="col-md-6">
                            <h6 class="mb-0">Audit Summary</h6>
                        </div>
                        <div class="col-md-6 text-end">
                            <a href="{% url 'seo_audit:export_audit' audit.id %}" class="btn btn-sm btn-primary">Export Results</a>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <p><strong>Website:</strong> {{ audit.website }}</p>
                            <p><strong>Start Time:</strong> {{ audit.start_time|date:"M d, Y H:i" }}</p>
                            <p><strong>Duration:</strong> <span id="duration-value">{{ audit.duration|default:"0" }}</span> seconds</p>
                        </div>
                        <div class="col-md-6">
                            <p><strong>Total Pages:</strong> <span id="pages-value">{{ total_pages }}</span></p>
                            <p><strong>Total Issues:</strong> <span id="issues-value">{{ audit.issues.count }}</span></p>
                            <p><strong>Status:</strong> {{ audit.get_status_display }}</p>
                            {% if audit.error %}
                                <p class="text-danger"><strong>Error:</strong> {{ audit.error }}</p>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- View Selector Tabs -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <ul class="nav nav-tabs card-header-tabs" role="tablist">
                        <li class="nav-item">
                            <a class="nav-link active" id="url-tab" data-bs-toggle="tab" href="#url-view" role="tab">URL Groups</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" id="table-tab" data-bs-toggle="tab" href="#table-view" role="tab">Table View</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" id="charts-tab" data-bs-toggle="tab" href="#charts-view" role="tab">Charts</a>
                        </li>
                    </ul>
                </div>
                <div class="card-body">
                    <div class="tab-content">
                        <!-- URL Groups View -->
                        <div class="tab-pane fade show active" id="url-view" role="tabpanel">
                            <div class="alert alert-info mb-3">
                                <i class="fas fa-info-circle me-2"></i>
                                Click on any URL below to view its detailed issues. URLs with critical issues are highlighted in red.
                            </div>
                            <div class="accordion" id="urlAccordion">
                                {% for group in url_groups %}
                                <div class="accordion-item mb-3 border rounded-3 shadow-sm">
                                    <h2 class="accordion-header m-0">
                                        <button class="accordion-button collapsed py-3 {% if group.critical_count > 0 %}bg-danger bg-opacity-10{% endif %} rounded-3" type="button" data-bs-toggle="collapse" data-bs-target="#collapse-{{ forloop.counter }}">
                                            <div class="d-flex align-items-center w-100">
                                                <div class="d-flex align-items-center" style="width: 70%;">
                                                    <i class="fas fa-link text-primary me-3"></i>
                                                    <a href="{{ group.url }}" target="_blank" class="text-dark text-decoration-none fw-semibold hover-primary text-truncate">
                                                        {{ group.url }}
                                                    </a>
                                                </div>
                                                <div class="d-flex align-items-center justify-content-end gap-3" style="width: 30%;">
                                                    {% if group.high_count > 0 %}
                                                    <div class="d-flex align-items-center gap-2">
                                                        <span class="badge rounded-pill bg-warning">{{ group.high_count }}</span>
                                                        <span class="text-xs">High Priority</span>
                                                    </div>
                                                    {% endif %}
                                                    <div class="d-flex align-items-center gap-2">
                                                        <span class="badge rounded-pill bg-secondary">{{ group.total_count }}</span>
                                                        <span class="text-xs">Total Issues</span>
                                                    </div>
                                                </div>
                                            </div>
                                        </button>
                                    </h2>
                                    <div id="collapse-{{ forloop.counter }}" class="accordion-collapse collapse" data-bs-parent="#urlAccordion">
                                        <div class="accordion-body p-3">
                                            <div class="ms-auto d-flex gap-2">
                                                <button class="btn btn-sm btn-primary generate-plan" 
                                                        data-url="{{ group.url }}" 
                                                        data-audit-id="{{ audit.id }}">
                                                    Generate Plan
                                                </button>
                                                <button class="btn btn-sm btn-outline-primary view-plan" 
                                                        data-url="{{ group.url }}" 
                                                        data-audit-id="{{ audit.id }}"
                                                        data-plan-id="{{ group.plan_id }}"
                                                        style="display: {% if group.has_plan %}inline-block{% else %}none{% endif %};">
                                                    View Plan
                                                </button>
                                            </div>
                                            <div class="table-responsive">
                                                <table class="table align-items-center mb-0">
                                                    <thead>
                                                        <tr>
                                                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Severity</th>
                                                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Type</th>
                                                            <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Details</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        {% for issue in group.issues %}
                                                        <tr>
                                                            <td class="text-sm ps-2" style="width: 100px;">
                                                                <span class="badge {% if issue.severity == 'critical' %}bg-danger{% elif issue.severity == 'high' %}bg-warning{% elif issue.severity == 'medium' %}bg-info{% else %}bg-success{% endif %}">
                                                                    {{ issue.get_severity_display }}
                                                                </span>
                                                            </td>
                                                            <td class="text-sm ps-2" style="width: 150px;">{{ issue.get_issue_type_display }}</td>
                                                            <td class="text-sm ps-2">
                                                                <div class="mb-1">
                                                                    {% if issue.details.issue %}
                                                                        {{ issue.details.issue }}
                                                                    {% else %}
                                                                        {{ issue.details }}
                                                                    {% endif %}
                                                                </div>
                                                                {% if issue.details.value or issue.details.element_type or issue.details.page_type or issue.details.directive or issue.details.user_agent or issue.details.details %}
                                                                <div class="text-muted small">
                                                                    {% if issue.details.value %}
                                                                        <div><strong>Value:</strong> {{ issue.details.value }}</div>
                                                                    {% endif %}
                                                                    {% if issue.details.element_type %}
                                                                        <div><strong>Element:</strong> {{ issue.details.element_type }}</div>
                                                                    {% endif %}
                                                                    {% if issue.details.page_type %}
                                                                        <div><strong>Page Type:</strong> {{ issue.details.page_type }}</div>
                                                                    {% endif %}
                                                                    {% if issue.details.directive %}
                                                                        <div><strong>Directive:</strong> {{ issue.details.directive }}</div>
                                                                    {% endif %}
                                                                    {% if issue.details.user_agent %}
                                                                        <div><strong>User Agent:</strong> {{ issue.details.user_agent }}</div>
                                                                    {% endif %}
                                                                    {% if issue.details.details %}
                                                                        {% for key, value in issue.details.details.items %}
                                                                            <div><strong>{{ key|title }}:</strong> {{ value }}</div>
                                                                        {% endfor %}
                                                                    {% endif %}
                                                                </div>
                                                                {% endif %}
                                                            </td>
                                                        </tr>
                                                        {% endfor %}
                                                    </tbody>
                                                </table>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                {% endfor %}
                            </div>
                        </div>

                        <!-- Table View -->
                        <div class="tab-pane fade" id="table-view" role="tabpanel">
                            <div class="bg-light rounded p-3 mb-3">
                                <div class="d-flex justify-content-between align-items-center flex-wrap gap-3">
                                    <div class="d-flex align-items-center gap-3">
                                        <div class="btn-group">
                                            <button type="button" class="btn btn-sm btn-primary" data-filter="critical">Critical</button>
                                            <button type="button" class="btn btn-sm btn-primary" data-filter="high">High</button>
                                            <button type="button" class="btn btn-sm btn-primary" data-filter="medium">Medium</button>
                                            <button type="button" class="btn btn-sm btn-primary" data-filter="low">Low</button>
                                        </div>
                                        <button type="button" class="btn btn-sm btn-secondary" data-filter="all">Show All</button>
                                    </div>
                                    <div class="d-flex align-items-center gap-3">
                                        <div class="datatable-search"></div>
                                        <div class="datatable-dropdown"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Table container with fixed height -->
                            <div class="table-container">
                                <table class="table table-hover align-middle mb-0" id="issues-table">
                                    <thead class="bg-white">
                                        <tr>
                                            <th class="text-uppercase text-secondary text-xxs fw-bolder">Severity</th>
                                            <th class="text-uppercase text-secondary text-xxs fw-bolder">Type</th>
                                            <th class="text-uppercase text-secondary text-xxs fw-bolder">URL</th>
                                            <th class="text-uppercase text-secondary text-xxs fw-bolder">Details</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {% for issue in audit.issues.all %}
                                        <tr>
                                            <td class="text-sm">
                                                <span class="badge {% if issue.severity == 'critical' %}bg-danger{% elif issue.severity == 'high' %}bg-warning{% elif issue.severity == 'medium' %}bg-info{% else %}bg-success{% endif %}">
                                                    {{ issue.get_severity_display }}
                                                </span>
                                            </td>
                                            <td class="text-sm">{{ issue.get_issue_type_display }}</td>
                                            <td class="text-sm">
                                                <a href="{{ issue.url }}" target="_blank" class="text-primary">
                                                    {{ issue.url|truncatechars:50 }}
                                                </a>
                                            </td>
                                            <td class="text-sm">
                                                <div>
                                                    <strong>Issue:</strong> 
                                                    {% if issue.details.issue %}
                                                        {{ issue.details.issue }}
                                                    {% else %}
                                                        {{ issue.details }}
                                                    {% endif %}
                                                </div>
                                                {% if issue.details.value %}
                                                    <div class="text-muted mt-1">
                                                        <strong>Value:</strong> {{ issue.details.value }}
                                                    </div>
                                                {% endif %}
                                                {% if issue.details.element_type %}
                                                    <div class="text-muted">
                                                        <strong>Element:</strong> {{ issue.details.element_type }}
                                                    </div>
                                                {% endif %}
                                                {% if issue.details.page_type %}
                                                    <div class="text-muted">
                                                        <strong>Page Type:</strong> {{ issue.details.page_type }}
                                                    </div>
                                                {% endif %}
                                                {% if issue.details.directive %}
                                                    <div class="text-muted">
                                                        <strong>Directive:</strong> {{ issue.details.directive }}
                                                    </div>
                                                {% endif %}
                                                {% if issue.details.user_agent %}
                                                    <div class="text-muted">
                                                        <strong>User Agent:</strong> {{ issue.details.user_agent }}
                                                    </div>
                                                {% endif %}
                                                {% if issue.details.details %}
                                                    <div class="text-muted mt-1">
                                                        {% for key, value in issue.details.details.items %}
                                                            <div><strong>{{ key|title }}:</strong> {{ value }}</div>
                                                        {% endfor %}
                                                    </div>
                                                {% endif %}
                                            </td>
                                        </tr>
                                        {% endfor %}
                                    </tbody>
                                </table>
                            </div>
                        </div>

                        <!-- Charts View -->
                        <div class="tab-pane fade" id="charts-view" role="tabpanel">
                            <div class="row">
                                <div class="col-xl-6">
                                    <div class="card mb-4">
                                        <div class="card-header pb-0">
                                            <h6 class="mb-0">Issue Severity Distribution</h6>
                                        </div>
                                        <div class="card-body">
                                            <div style="height: 300px;">
                                                <canvas id="severityChart"></canvas>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-xl-6">
                                    <div class="card mb-4">
                                        <div class="card-header pb-0">
                                            <h6 class="mb-0">Issue Type Distribution</h6>
                                        </div>
                                        <div class="card-body">
                                            <canvas id="issueTypeChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<!-- Modal for LLM Provider Selection -->
<div class="modal fade" id="providerModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select LLM Provider</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-3">
                    <label for="llmProvider">Provider</label>
                    <select class="form-control" id="llmProvider">
                        <option value="">Select Provider</option>
                        <option value="OPENAI">OpenAI</option>
                        <option value="ANTHROPIC">Anthropic</option>
                        <option value="GEMINI">Gemini</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="llmModel">Model</label>
                    <select class="form-control" id="llmModel" disabled>
                        <option value="">Select Model</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="confirmProvider">Generate Plan</button>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/perfect-scrollbar.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/countup.min.js' %}"></script>

<!-- Configuration for app -->
<script>
    // Define API endpoints and configuration
    window.auditConfig = {
        llmModelsUrl: "{% url 'common:llm-models' %}",
        csrfToken: "{{ csrf_token }}",
        severityData: {
            labels: JSON.parse('{{ severity_data.labels|safe }}'),
            values: JSON.parse('{{ severity_data.values|safe }}')
        },
        issueTypeData: {
            labels: JSON.parse('{{ issue_type_data.labels|safe }}'),
            values: JSON.parse('{{ issue_type_data.values|safe }}')
        }
    };
</script>

<!-- Initialize application -->
<script type="module">
    import { AuditApp } from "{% static 'seo_audit/js/app.js' %}";
    
    // Initialize audit application
    const app = new AuditApp(window.auditConfig);
    app.initialize();
</script>

<!-- Add URLs for JavaScript -->
<script>
    window.csrfToken = "{{ csrf_token }}";
    window.llmModelsUrl = "{% url 'common:llm-models' %}";
</script>
<script type="module">
    import { initializePlanGeneration, initializePlanViewing } from "{% static 'seo_audit/js/plan-handlers.js' %}";
    
    document.addEventListener('DOMContentLoaded', function() {
        initializePlanGeneration();
        initializePlanViewing();
    });
</script>
{% endblock extra_js %}

================
File: apps/seo_audit/templatetags/seo_audit_tags.py
================
from django import template

register = template.Library()

@register.filter
def is_string(value):
    """Check if a value is a string."""
    return isinstance(value, str)

================
File: apps/seo_audit/admin.py
================
from django.contrib import admin
from .models import SEOAuditResult, SEOAuditIssue

@admin.register(SEOAuditResult)
class SEOAuditResultAdmin(admin.ModelAdmin):
    list_display = ('client', 'website', 'status', 'start_time', 'end_time', 'duration')
    list_filter = ('status', 'client', 'start_time')
    search_fields = ('website', 'client__name')
    readonly_fields = ('start_time', 'end_time', 'duration', 'task_id')
    
    def has_add_permission(self, request):
        return False  # Audits should only be created through the interface

@admin.register(SEOAuditIssue)
class SEOAuditIssueAdmin(admin.ModelAdmin):
    list_display = ('issue_type', 'severity', 'url', 'audit', 'discovered_at')
    list_filter = ('issue_type', 'severity', 'audit__client')
    search_fields = ('url', 'audit__website')
    readonly_fields = ('discovered_at',)

================
File: apps/seo_audit/apps.py
================
from django.apps import AppConfig
import os

class SEOAuditConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.seo_audit'
    verbose_name = 'SEO Audit'
    path = os.path.dirname(os.path.abspath(__file__))

    def ready(self):
        try:
            import apps.seo_audit.signals  # noqa
        except ImportError:
            pass

================
File: apps/seo_audit/consumers.py
================
import json
import logging
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
from channels.db import database_sync_to_async
from .models import SEOAuditResult

logger = logging.getLogger(__name__)

class SEOAuditConsumer(OrganizationAwareConsumer):
    async def connect(self):
        # Set organization context first
        await super().connect()
        
        self.audit_id = self.scope['url_route']['kwargs']['audit_id']
        self.audit_group_name = f'audit_{self.audit_id}'
        
        #logger.info(f"WebSocket connecting for audit {self.audit_id}")
        #logger.debug(f"Channel name: {self.channel_name}")
        #logger.debug(f"Group name: {self.audit_group_name}")

        # Join audit group
        try:
            await self.channel_layer.group_add(
                self.audit_group_name,
                self.channel_name
            )
            # logger.info(f"Added to group {self.audit_group_name}")
        except Exception as e:
            logger.error(f"Error joining group: {str(e)}")
            return

        try:
            await self.accept()
            # logger.info(f"WebSocket connection accepted for audit {self.audit_id}")
        except Exception as e:
            logger.error(f"Error accepting connection: {str(e)}")

    async def disconnect(self, close_code):
        # logger.info(f"WebSocket disconnecting for audit {self.audit_id} with code {close_code}")
        # Leave audit group
        try:
            await self.channel_layer.group_discard(
                self.audit_group_name,
                self.channel_name
            )
            # logger.info(f"Left group {self.audit_group_name}")
        except Exception as e:
            logger.error(f"Error leaving group: {str(e)}")
            
        # Clear organization context
        await super().disconnect(close_code)

    async def receive(self, text_data):
        """Handle incoming messages from WebSocket"""
        try:
            text_data_json = json.loads(text_data)
            message_type = text_data_json.get('type')
            # logger.info(f"Received message type: {message_type}")
            
            if message_type == 'get_status':
                await self.send_audit_status()
            elif message_type == 'test':
                # logger.info("Received test message, echoing back")
                await self.send(text_data=json.dumps({
                    'type': 'test',
                    'message': 'WebSocket connection working'
                }))
        except json.JSONDecodeError as e:
            logger.error(f"Invalid message format: {str(e)}")
            await self.send_error("Invalid message format")
        except Exception as e:
            logger.error(f"Error handling message: {str(e)}")
            await self.send_error(f"Error processing message: {str(e)}")

    async def audit_update(self, event):
        """Handle audit update messages"""
        #logger.info(f"Received audit update for {self.audit_id}")
        #logger.debug(f"Update data: {event}")
        try:
            await self.send(text_data=json.dumps({
                'type': 'audit.update',
                'data': event.get('data', {})
            }))
            # logger.debug("Sent audit update to client")
        except Exception as e:
            logger.error(f"Error sending audit update: {str(e)}")

    async def audit_complete(self, event):
        """Handle audit completion messages"""
        # logger.info(f"Received audit complete for {self.audit_id}")
        # logger.debug(f"Complete data: {event}")
        try:
            await self.send(text_data=json.dumps({
                'type': 'audit.complete',
                'data': event.get('data', {})
            }))
            # logger.debug("Sent audit complete to client")
        except Exception as e:
            logger.error(f"Error sending audit complete: {str(e)}")

    async def audit_error(self, event):
        """Handle audit error messages"""
        logger.error(f"Received audit error for {self.audit_id}: {event.get('error', 'Unknown error')}")
        try:
            await self.send(text_data=json.dumps({
                'type': 'audit.error',
                'error': event.get('error', 'Unknown error')
            }))
            logger.debug("Sent audit error to client")
        except Exception as e:
            logger.error(f"Error sending audit error: {str(e)}")

    @database_sync_to_async
    def get_audit_status(self):
        """Get current audit status"""
        try:
            audit = SEOAuditResult.objects.get(id=self.audit_id)
            return {
                'status': audit.status,
                'progress': audit.progress,
                'error': audit.error
            }
        except SEOAuditResult.DoesNotExist:
            logger.error(f"Audit {self.audit_id} not found")
            return None
        except Exception as e:
            logger.error(f"Error getting audit status: {str(e)}")
            return None

    async def send_audit_status(self):
        """Send current audit status to client"""
        # logger.info(f"Getting status for audit {self.audit_id}")
        status = await self.get_audit_status()
        if status:
            try:
                await self.send(text_data=json.dumps({
                    'type': 'audit.status',
                    'data': status
                }))
                # logger.debug("Sent audit status to client")
            except Exception as e:
                logger.error(f"Error sending audit status: {str(e)}")
        else:
            await self.send_error("Audit not found")

    async def send_error(self, message):
        """Send error message to client"""
        logger.error(f"Sending error for audit {self.audit_id}: {message}")
        try:
            await self.send(text_data=json.dumps({
                'type': 'audit.error',
                'error': message
            }))
        except Exception as e:
            logger.error(f"Error sending error message: {str(e)}")

================
File: apps/seo_audit/models.py
================
from django.db import models
from django.utils import timezone
from apps.seo_manager.models import Client
from apps.organizations.models.mixins import OrganizationModelMixin

class SEOAuditResult(OrganizationModelMixin, models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('in_progress', 'In Progress'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled')
    ]

    client = models.ForeignKey(Client, null=True, blank=True, on_delete=models.CASCADE, related_name='seo_audits')
    start_time = models.DateTimeField(auto_now_add=True)
    end_time = models.DateTimeField(null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    website = models.URLField()
    max_pages = models.IntegerField(default=100)
    check_external_links = models.BooleanField(default=False)
    crawl_delay = models.FloatField(default=1.0)
    results = models.JSONField(null=True, blank=True)
    error = models.TextField(null=True, blank=True)
    progress = models.JSONField(default=dict, help_text="Stores progress information during the audit")
    task_id = models.CharField(max_length=100, null=True, blank=True, help_text="Celery task ID for tracking")

    class Meta:
        ordering = ['-start_time']
        get_latest_by = 'start_time'

    def __str__(self):
        client_name = self.client.name if self.client else 'No Client'
        return f"SEO Audit - {client_name} - {self.start_time.strftime('%Y-%m-%d %H:%M')}"

    def mark_completed(self, results):
        self.status = 'completed'
        self.end_time = timezone.now()
        self.results = results
        self.save()

    def mark_failed(self, error):
        self.status = 'failed'
        self.end_time = timezone.now()
        self.error = str(error)
        self.save()

    def update_progress(self, progress_data):
        self.progress = progress_data
        self.save(update_fields=['progress'])

    @property
    def duration(self):
        if self.end_time and self.start_time:
            return self.end_time - self.start_time
        return None

class SEOAuditIssue(models.Model):
    SEVERITY_CHOICES = [
        ('critical', 'Critical'),
        ('high', 'High'),
        ('medium', 'Medium'),
        ('low', 'Low'),
        ('info', 'Info')
    ]

    ISSUE_TYPES = [
        # Meta Issues
        ('title', 'Title Tag Issues'),
        ('meta_description', 'Meta Description Issues'),
        ('h1', 'H1 Tag Issues'),
        ('404', '404 Page Issues'),

        # Link Issues
        ('broken_link', 'Broken Link'),
        
        # Image Issues
        ('missing_alt', 'Missing Alt Text'),
        ('short_alt', 'Short Alt Text'),
        ('missing_dimensions', 'Missing Image Dimensions'),
        ('generic_filename', 'Generic Image Filename'),
        ('large_size', 'Large Image Size'),
        ('no_lazy_loading', 'No Lazy Loading'),
        ('no_srcset', 'Missing Srcset'),

        # Content Issues
        ('thin_content', 'Thin Content'),
        ('duplicate_content', 'Duplicate Content'),

        # Canonical Issues
        ('canonical_missing', 'Missing Canonical'),
        ('canonical_invalid_format', 'Invalid Canonical Format'),
        ('canonical_different', 'Different Canonical URL'),
        ('canonical_relative', 'Relative Canonical URL'),
        ('canonical_multiple', 'Multiple Canonical Tags'),
        ('canonical_on_pagination', 'Canonical on Pagination'),
        ('canonical_chain', 'Canonical Chain'),

        # Social Media Issues
        ('og_title_missing', 'Missing OG Title'),
        ('og_description_missing', 'Missing OG Description'),
        ('og_image_missing', 'Missing OG Image'),
        ('og_image_invalid', 'Invalid OG Image'),
        ('twitter_card_missing', 'Missing Twitter Card'),
        ('twitter_card_invalid', 'Invalid Twitter Card'),
        ('twitter_title_missing', 'Missing Twitter Title'),
        ('twitter_description_missing', 'Missing Twitter Description'),
        ('twitter_image_missing', 'Missing Twitter Image'),
        ('twitter_image_invalid', 'Invalid Twitter Image'),

        # Technical Issues
        ('sitemap_http_error', 'Sitemap HTTP Error'),
        ('missing_url', 'Missing URL in Sitemap'),
        ('invalid_url', 'Invalid URL Format'),
        ('invalid_lastmod', 'Invalid Lastmod Date'),
        ('invalid_changefreq', 'Invalid Change Frequency'),
        ('invalid_priority', 'Invalid Priority'),
        ('invalid_sitemap', 'Invalid Sitemap Format'),
        ('sitemap_error', 'Sitemap Error'),
        ('ssl_error', 'SSL Certificate Error'),
        
        # Other
        ('other', 'Other Issue'),

        # Core Web Vitals & Performance
        ('lcp_poor', 'Poor Largest Contentful Paint'),
        ('cls_poor', 'Poor Cumulative Layout Shift'),
        ('inp_poor', 'Poor Interaction to Next Paint'),
        ('fid_poor', 'Poor First Input Delay'),
        
        # HTML Structure
        ('semantic_structure', 'Invalid Semantic HTML Structure'),
        ('viewport_missing', 'Missing Viewport Meta Tag'),
        ('viewport_invalid', 'Invalid Viewport Configuration'),
        
        # Duplicate/Redirect Issues
        ('duplicate_titles', 'Duplicate Title Tags'),
        ('redirect_chain', 'Redirect Chain Detected'),
        ('redirect_loop', 'Redirect Loop Detected'),
        
        # Image Optimization
        ('modern_image_format', 'Not Using Modern Image Format'),
        ('responsive_images', 'Missing Responsive Image Setup'),
        
        # Indexing & Robots
        ('robots_misconfiguration', 'Robots.txt Misconfiguration'),
        ('noindex_detected', 'Noindex Tag Detected'),
        ('indexing_blocked', 'Indexing Blocked by X-Robots-Tag'),
        
        # E-E-A-T Signals
        ('author_missing', 'Missing Author Information'),
        ('expertise_signals', 'Missing Expertise Signals'),
        ('factual_accuracy', 'Potential Factual Accuracy Issues'),

        # Performance & Core Web Vitals
        ('performance_poor', 'Poor Performance Score'),
        ('performance_render-blocking-resources', 'Render-Blocking Resources'),
        ('performance_unoptimized-images', 'Unoptimized Images'),
        ('performance_unused-css', 'Unused CSS'),
        ('performance_unused-javascript', 'Unused JavaScript'),
        ('performance_server-response-time', 'Slow Server Response'),
        ('pagespeed_error', 'PageSpeed Analysis Error'),
    ]

    audit = models.ForeignKey(SEOAuditResult, on_delete=models.CASCADE, related_name='issues')
    issue_type = models.CharField(max_length=50, choices=ISSUE_TYPES)
    severity = models.CharField(max_length=20, choices=SEVERITY_CHOICES)
    url = models.URLField()
    details = models.JSONField()
    discovered_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['-severity', '-discovered_at']

    def __str__(self):
        return f"{self.get_issue_type_display()} - {self.get_severity_display()} - {self.url}" 

class SEORemediationPlan(models.Model):
    audit = models.ForeignKey(SEOAuditResult, on_delete=models.CASCADE, related_name='remediation_plans')
    url = models.URLField()
    created_at = models.DateTimeField(auto_now_add=True)
    llm_provider = models.CharField(max_length=50)
    llm_model = models.CharField(max_length=100)
    plan_content = models.JSONField(help_text="Structured remediation plan content")
    
    class Meta:
        ordering = ['-created_at']

================
File: apps/seo_audit/routing.py
================
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/seo_audit/(?P<audit_id>\d+)/$', consumers.SEOAuditConsumer.as_asgi()),
]

================
File: apps/seo_audit/tasks.py
================
import time
import json
import logging
from celery import shared_task, current_app
from django.conf import settings
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
from django.core.cache import cache
from apps.seo_audit.models import SEOAuditResult, SEOAuditIssue
from apps.agents.tools.seo_audit_tool.seo_audit_tool import SEOAuditTool
from django.utils import timezone
from datetime import datetime

logger = logging.getLogger(__name__)

@shared_task(bind=True, max_retries=3)
def run_seo_audit(self, audit_id, website, max_pages=100, check_external_links=False, crawl_delay=1.0):
    """Run SEO audit task."""
    logger.info(f"Starting SEO audit task for audit_id: {audit_id}, group: audit_{audit_id}")
    
    # Get the channel layer
    channel_layer = get_channel_layer()
    audit_group = f'audit_{audit_id}'
    
    # Use cache as message bus
    cache_key = f"seo_audit_progress_{audit_id}"
    last_update_id = 0

    def progress_callback(data):
        """Progress callback that uses cache as message bus"""
        try:
            nonlocal last_update_id
            last_update_id += 1
            
            # Store update in cache with ID
            cache.set(
                f"{cache_key}_{last_update_id}",
                data,
                timeout=3600  # 1 hour timeout
            )
            # Store latest update ID
            cache.set(cache_key, last_update_id, timeout=3600)
            
        except Exception as e:
            logger.error(f"Error in progress callback: {str(e)}")

    try:
        # First get the audit record and its organization ID using unfiltered_objects
        # This is safe because we're using a specific ID that was passed to the task
        try:
            audit = SEOAuditResult.unfiltered_objects.get(id=audit_id)
            org_id = audit.organization_id
            logger.info(f"Found audit {audit_id} for organization {org_id}")
        except SEOAuditResult.DoesNotExist as e:
            # If this is not the final retry, retry after 2 seconds
            if self.request.retries < self.max_retries:
                logger.warning(f"Audit {audit_id} not found, retrying in 2 seconds (attempt {self.request.retries + 1})")
                raise self.retry(exc=e, countdown=2)
            else:
                logger.error(f"Audit {audit_id} not found after {self.max_retries} retries")
                raise

        # Update audit status
        audit.status = 'running'
        audit.save()

        # Start SEO audit
        logger.info(f"Running audit tool for {website}")
        audit_tool = SEOAuditTool()
        
        # Start background task to process updates using current Celery app
        current_app.send_task(
            'apps.seo_audit.tasks.process_audit_updates',
            args=[audit_id, cache_key],
            countdown=1  # Start after 1 second
        )
        
        # Run the audit
        results = audit_tool._run(
            website=website,
            max_pages=max_pages,
            check_external_links=check_external_links,
            crawl_delay=crawl_delay,
            progress_callback=progress_callback
        )

        # Save results using unfiltered_objects to bypass organization check
        audit = SEOAuditResult.unfiltered_objects.get(id=audit_id)
        audit.results = results
        audit.status = 'completed'
        audit.end_time = timezone.now()
        audit.save()

        # Store completion marker
        cache.set(f"{cache_key}_complete", True, timeout=3600)
        
        return {
            'status': 'success',
            'audit_id': audit_id
        }

    except Exception as e:
        logger.error(f"Error running SEO audit: {str(e)}")
        try:
            # Use unfiltered_objects for error handling too
            audit = SEOAuditResult.unfiltered_objects.get(id=audit_id)
            audit.status = 'failed'
            audit.error = str(e)
            audit.save()
        except SEOAuditResult.DoesNotExist:
            logger.error(f"Could not update audit status for {audit_id}: record not found")
        except Exception as e:
            logger.error(f"Error updating audit status: {str(e)}")
        
        # Store error marker
        cache.set(f"{cache_key}_error", str(e), timeout=3600)
        raise

@shared_task(bind=True)
def process_audit_updates(self, audit_id, cache_key):
    """Process SEO audit updates from cache and send to WebSocket."""
    
    channel_layer = get_channel_layer()
    audit_group = f'audit_{audit_id}'
    last_processed_id = 0
    should_stop = False
    
    while True:
        try:
            # Get latest update ID
            latest_id = cache.get(cache_key, 0)
            
            # Process any new updates
            while last_processed_id < latest_id:
                last_processed_id += 1
                update = cache.get(f"{cache_key}_{last_processed_id}")
                
                if update:
                    async_to_sync(channel_layer.group_send)(
                        audit_group,
                        {
                            'type': 'audit.update',
                            'data': update
                        }
                    )
            
            # Check if audit is complete
            if should_stop or (cache.get(f"{cache_key}_complete") or cache.get(f"{cache_key}_error")):
                if last_processed_id >= latest_id:  # Only stop if we've processed everything
                    try:
                        # Use unfiltered_objects here as well
                        audit = SEOAuditResult.unfiltered_objects.get(id=audit_id)
                        if audit.status == 'completed' and audit.results:
                            logger.info(f"Processing issues for completed audit {audit_id}")
                            
                            # Clear existing issues
                            SEOAuditIssue.objects.filter(audit=audit).delete()
                            
                            try:
                                # Store all issues
                                for issue in audit.results.get('issues', []):
                                    # Ensure issue_type has a default value if not present
                                    issue_type = issue.get('type')
                                    if not issue_type:
                                        # Try to determine issue type from the issue details
                                        if 'ssl' in str(issue.get('issue', '')).lower():
                                            issue_type = 'ssl_error'
                                        elif 'link' in str(issue.get('issue', '')).lower():
                                            issue_type = 'broken_link'
                                        elif 'meta' in str(issue.get('issue', '')).lower():
                                            issue_type = 'meta_tag_issue'
                                        elif 'content' in str(issue.get('issue', '')).lower():
                                            issue_type = 'content_issue'
                                        else:
                                            issue_type = 'general_issue'  # Default fallback
                                    
                                    SEOAuditIssue.objects.create(
                                        audit=audit,
                                        severity=issue.get('severity', 'medium'),
                                        issue_type=issue_type,
                                        url=issue.get('url', audit.website),
                                        details=issue,
                                        discovered_at=timezone.now()
                                    )
                                
                                logger.info(f"Successfully processed {len(audit.results.get('issues', []))} issues for audit {audit_id}")
                                
                            except Exception as e:
                                logger.error(f"Error processing issues: {str(e)}", exc_info=True)
                                raise
                            
                            # Send completion message
                            formatted_results = {
                                'issues': [
                                    {
                                        'severity': issue.severity,
                                        'issue_type': issue.issue_type,
                                        'url': issue.url,
                                        'details': issue.details,
                                        'discovered_at': issue.discovered_at.isoformat()
                                    }
                                    for issue in audit.issues.all()
                                ],
                                'summary': audit.results.get('summary', {})
                            }
                            
                            async_to_sync(channel_layer.group_send)(
                                audit_group,
                                {
                                    'type': 'audit.complete',
                                    'data': {
                                        'results': formatted_results,
                                        'status': 'completed'
                                    }
                                }
                            )
                            logger.info(f"Sent completion message for audit {audit_id}")
                            
                        elif audit.status == 'failed':
                            async_to_sync(channel_layer.group_send)(
                                audit_group,
                                {
                                    'type': 'audit.error',
                                    'error': audit.error or "Unknown error occurred"
                                }
                            )
                    except Exception as e:
                        logger.error(f"Error processing completion: {str(e)}", exc_info=True)
                        raise
                    
                    logger.info(f"Audit {audit_id} finished, stopping update processor")
                    break
                should_stop = True
            
            time.sleep(0.1)
            
        except Exception as e:
            logger.error(f"Error in update processor for audit {audit_id}: {str(e)}", exc_info=True)
            break
    
    logger.info(f"Update processor finished for audit {audit_id}")

================
File: apps/seo_audit/urls.py
================
from django.urls import path
from django.views.decorators.csrf import csrf_protect
from . import views

app_name = 'seo_audit'

urlpatterns = [
    path('', views.AuditView.as_view(), name='audit'),
    path('start/', views.StartAuditView.as_view(), name='start_audit'),
    path('results/<int:audit_id>/', views.GetAuditResultsView.as_view(), name='audit_results'),
    path('history/', views.AuditHistoryView.as_view(), name='audit_history'),
    path('export/<int:audit_id>/', views.ExportAuditView.as_view(), name='export_audit'),
    path('cancel/<int:audit_id>/', views.CancelAuditView.as_view(), name='cancel_audit'),
    path('status/<int:audit_id>/', views.GetAuditStatusView.as_view(), name='audit_status'),
    path('client/<int:client_id>/website/', views.GetClientWebsiteView.as_view(), name='get_client_website'),
    path('api/remediation-plan/generate/', csrf_protect(views.generate_remediation_plan), name='generate_remediation_plan'),
    path('api/remediation-plan/<int:plan_id>/', views.get_remediation_plan, name='get_remediation_plan'),  # GET request
    path('api/remediation-plan/<int:plan_id>/delete/', csrf_protect(views.delete_remediation_plan), name='delete_remediation_plan'),  # DELETE request
]

================
File: apps/seo_audit/views.py
================
from django.views.generic import TemplateView, ListView, DetailView
from django.views.generic.edit import FormView
from django.views import View
from django.http import JsonResponse, HttpResponse
from django.shortcuts import get_object_or_404, render
from django.contrib.auth.mixins import LoginRequiredMixin
from django.db.models import Count, Q
from django.utils import timezone
from django.db import transaction
import json
import csv
from io import StringIO
from celery.result import AsyncResult
import logging
from asgiref.sync import sync_to_async
from functools import partial
import time
from apps.common.tools.user_activity_tool import user_activity_tool
from apps.seo_manager.models import Client
from .models import SEOAuditResult, SEORemediationPlan, SEOAuditIssue
from apps.agents.tools.seo_audit_tool.seo_audit_tool import SEOAuditTool
from .tasks import run_seo_audit

from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.contrib.auth.decorators import login_required
from .services.remediation_service import RemediationService

logger = logging.getLogger(__name__)

@login_required
@require_http_methods(["POST"])
async def generate_remediation_plan(request):
    """Generate a remediation plan for specific URL in an audit"""
    try:
        # Log incoming request
        logger.info(f"Received remediation plan request: {request.body.decode()}")
        
        data = json.loads(request.body)
        audit_id = data.get('audit_id')
        url = data.get('url')
        provider = data.get('provider')
        model = data.get('model')
        
        # Validate required fields
        if not all([audit_id, url, provider, model]):
            logger.error(f"Missing required fields: {data}")
            return JsonResponse({
                'success': False,
                'error': 'Missing required fields'
            }, status=400)
        
        try:
            audit = await SEOAuditResult.objects.aget(id=audit_id)
        except SEOAuditResult.DoesNotExist:
            logger.error(f"Audit not found: {audit_id}")
            return JsonResponse({
                'success': False,
                'error': 'Audit not found'
            }, status=404)
        
        # Get issues for this URL
        issues = [issue async for issue in audit.issues.filter(url__iexact=url)]
        
        if not issues:
            logger.error(f"No issues found for URL: {url}")
            return JsonResponse({
                'success': False,
                'error': 'No issues found for the specified URL'
            }, status=404)
        
        # Get client profile if available - wrapped in sync_to_async
        get_client = sync_to_async(lambda: audit.client.client_profile if audit.client else "")
        client_profile = await get_client()
        
        # Initialize remediation service
        remediation_service = RemediationService(user=request.user)
        
        logger.info(f"Generating plan for URL: {url} with provider: {provider}, model: {model}")
        
        # Generate plan - method is already async
        plan = await remediation_service.generate_plan(
            url=url,
            issues=issues,
            provider_type=provider,
            model=model,
            client_profile=client_profile
        )
        
        # Create new plan
        remediation_plan = await SEORemediationPlan.objects.acreate(
            audit=audit,
            url=url,
            llm_provider=provider,
            llm_model=model,
            plan_content=plan
        )
        logger.info(f"Created new plan ID: {remediation_plan.id}")
        
        # Get client name for activity log - handle async/sync properly
        client_name = audit.client.name if audit.client else "No client"
        await sync_to_async(user_activity_tool.run)(
            request.user, 
            'update', 
            f"Generated remediation plan for {client_name} - URL: {url}", 
            client=audit.client if audit.client else None
        )

        # Get all plans for this URL
        all_plans = [plan async for plan in SEORemediationPlan.objects.filter(audit=audit, url=url).order_by('-created_at')]
        
        return JsonResponse({
            'success': True,
            'plan': plan,
            'plan_id': remediation_plan.id,
            'all_plans': [{
                'id': p.id,
                'provider': p.llm_provider,
                'model': p.llm_model,
                'created_at': p.created_at.isoformat(),
                'content': p.plan_content
            } for p in all_plans]
        })
        
    except json.JSONDecodeError as e:
        logger.error(f"JSON decode error: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': 'Invalid JSON data'
        }, status=400)
    except Exception as e:
        logger.error(f"Error generating remediation plan: {str(e)}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

class AuditView(LoginRequiredMixin, TemplateView):
    template_name = 'seo_audit/audit.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['clients'] = Client.objects.filter(status='active').order_by('name')
        return context

class StartAuditView(LoginRequiredMixin, View):
    def post(self, request, *args, **kwargs):
        try:
            # Log the incoming request data
            logger.debug(f"Received audit request data: {request.body.decode()}")
            
            data = json.loads(request.body)
            client_id = data.get('client')
            website = data.get('website')
            max_pages = int(data.get('max_pages', 100))
            check_external_links = data.get('check_external_links', False)
            crawl_delay = float(data.get('crawl_delay', 1.0))

            # Validate required fields
            if not website:
                return JsonResponse({
                    'status': 'error',
                    'error': 'Website URL is required'
                }, status=400)
            
            # Create audit record in its own transaction
            with transaction.atomic():
                audit = SEOAuditResult.objects.create(
                    client_id=client_id if client_id else None,
                    website=website,
                    max_pages=max_pages,
                    check_external_links=check_external_links,
                    crawl_delay=crawl_delay,
                    status='pending'
                )
                logger.info(f"Created audit record: {audit.id} for website: {website}")
                logger.info(f"Parameters to be sent to task: website: {website}, max_pages: {max_pages}, check_external_links: {check_external_links}, crawl_delay: {crawl_delay}")
            
            # Transaction is now committed, start the Celery task
            task = run_seo_audit.delay(
                audit_id=audit.id,
                website=website,
                max_pages=max_pages,
                check_external_links=check_external_links,
                crawl_delay=crawl_delay
            )
            logger.info(f"Started Celery task: {task.id} for audit: {audit.id}")

            # Update audit with task ID in a new transaction
            with transaction.atomic():
                audit.refresh_from_db()
                audit.task_id = task.id
                audit.status = 'in_progress'
                audit.save()

            # Log user activity
            client_name = audit.client.name if audit.client else "No client"
            user_activity_tool.run(
                request.user,
                'create',
                f"Started SEO audit for {client_name} - Website: {website}",
                client=audit.client if audit.client else None
            )

            return JsonResponse({
                'status': 'success',
                'audit_id': audit.id,
                'task_id': task.id
            })

        except json.JSONDecodeError as e:
            logger.error(f"JSON decode error: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': 'Invalid JSON data'
            }, status=400)
        except ValueError as e:
            logger.error(f"Value error: {str(e)}")
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=400)
        except Exception as e:
            logger.error(f"Error starting audit: {str(e)}", exc_info=True)
            return JsonResponse({
                'status': 'error',
                'error': str(e)
            }, status=500)

class GetAuditStatusView(LoginRequiredMixin, View):
    def get(self, request, audit_id, *args, **kwargs):
        audit = get_object_or_404(SEOAuditResult, id=audit_id)
        
        # Get task status if task_id exists
        task_status = None
        if audit.task_id:
            task = AsyncResult(audit.task_id)
            task_status = task.status

        return JsonResponse({
            'status': audit.status,
            'progress': audit.progress,
            'error': audit.error,
            'task_status': task_status
        })

class GetAuditResultsView(LoginRequiredMixin, DetailView):
    model = SEOAuditResult
    template_name = 'seo_audit/results.html'
    context_object_name = 'audit'
    pk_url_kwarg = 'audit_id'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        audit = self.object

        # Log user activity
        client_name = audit.client.name if audit.client else "No client"
        user_activity_tool.run(
            self.request.user,
            'view',
            f"Viewed SEO audit results for {client_name} - Website: {audit.website}",
            client=audit.client if audit.client else None
        )

        # Get severity distribution data
        severity_counts = dict(audit.issues.values('severity').annotate(count=Count('id')).values_list('severity', 'count'))
        severity_data = {
            'labels': [label for value, label in SEOAuditIssue.SEVERITY_CHOICES],
            'values': [severity_counts.get(value, 0) for value, _ in SEOAuditIssue.SEVERITY_CHOICES]
        }

        # Get issue type distribution data
        type_counts = dict(audit.issues.values('issue_type').annotate(count=Count('id')).values_list('issue_type', 'count'))
        type_data = {
            'labels': [label for value, label in SEOAuditIssue.ISSUE_TYPES],
            'values': [type_counts.get(value, 0) for value, _ in SEOAuditIssue.ISSUE_TYPES]
        }

        # Get total pages from either results or progress
        total_pages = 0
        if audit.results and isinstance(audit.results, dict):
            total_pages = audit.results.get('summary', {}).get('total_pages', 0)
        if total_pages == 0 and audit.progress and isinstance(audit.progress, dict):
            total_pages = audit.progress.get('pages_analyzed', 0)

        # Prepare URL groups with severity counts
        url_groups = []
        
        # First, normalize URLs by removing trailing slashes and grouping issues
        normalized_issues = {}
        for issue in audit.issues.all():
            normalized_url = issue.url.rstrip('/')  # Remove trailing slash
            if normalized_url not in normalized_issues:
                # Get existing remediation plan for this URL
                plan = SEORemediationPlan.objects.filter(audit=audit, url=issue.url).first()
                normalized_issues[normalized_url] = {
                    'url': issue.url,  # Keep original URL for display
                    'issues': [],
                    'total_count': 0,
                    'critical_count': 0,
                    'high_count': 0,
                    'has_plan': bool(plan),
                    'plan_id': plan.id if plan else None
                }
            
            normalized_issues[normalized_url]['issues'].append(issue)
            normalized_issues[normalized_url]['total_count'] += 1
            if issue.severity == 'critical':
                normalized_issues[normalized_url]['critical_count'] += 1
            elif issue.severity == 'high':
                normalized_issues[normalized_url]['high_count'] += 1

        # Convert the normalized issues dictionary to a list and sort by URL
        url_groups = list(normalized_issues.values())
        url_groups.sort(key=lambda x: x['url'])

        context.update({
            'severity_data': {
                'labels': json.dumps(severity_data['labels']),
                'values': json.dumps(severity_data['values'])
            },
            'issue_type_data': {
                'labels': json.dumps(type_data['labels']),
                'values': json.dumps(type_data['values'])
            },
            'url_groups': url_groups,
            'severities': SEOAuditIssue.SEVERITY_CHOICES,
            'issue_types': SEOAuditIssue.ISSUE_TYPES,
            'total_pages': total_pages
        })
        return context

class AuditHistoryView(LoginRequiredMixin, ListView):
    model = SEOAuditResult
    template_name = 'seo_audit/history.html'
    context_object_name = 'audits'
    paginate_by = 12
    ordering = ['-start_time']

class CancelAuditView(LoginRequiredMixin, View):
    def post(self, request, audit_id, *args, **kwargs):
        audit = get_object_or_404(SEOAuditResult, id=audit_id)
        
        if audit.task_id:
            # Revoke Celery task
            AsyncResult(audit.task_id).revoke(terminate=True)
        
        audit.status = 'cancelled'
        audit.end_time = timezone.now()
        audit.save()

        return JsonResponse({'status': 'success'})

class ExportAuditView(LoginRequiredMixin, View):
    def get(self, request, audit_id, *args, **kwargs):
        audit = get_object_or_404(SEOAuditResult, id=audit_id)
        
        # Create CSV file
        output = StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            'Severity',
            'Issue Type',
            'URL',
            'Details',
            'Discovered At'
        ])
        
        # Write issues
        for issue in audit.issues.all():
            writer.writerow([
                issue.get_severity_display(),
                issue.get_issue_type_display(),
                issue.url,
                json.dumps(issue.details),
                issue.discovered_at.strftime('%Y-%m-%d %H:%M:%S')
            ])
        
        # Prepare response
        response = HttpResponse(output.getvalue(), content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="seo_audit_{audit_id}_{timezone.now().strftime("%Y%m%d")}.csv"'
        
        return response

class GetClientWebsiteView(LoginRequiredMixin, View):
    def get(self, request, client_id, *args, **kwargs):
        client = get_object_or_404(Client, id=client_id)
        return JsonResponse({
            'website_url': client.website_url
        })

def audit_results(request, audit_id):
    audit = get_object_or_404(SEOAuditResult, id=audit_id)
    
    # Prepare data for severity distribution chart
    severity_counts = audit.issues.values('severity').annotate(count=Count('id'))
    severity_data = {
        'labels': [issue['severity'] for issue in severity_counts],
        'values': [issue['count'] for issue in severity_counts]
    }
    
    # Prepare data for issue type distribution chart
    issue_type_counts = audit.issues.values('issue_type').annotate(count=Count('id'))
    issue_type_data = {
        'labels': [issue['issue_type'] for issue in issue_type_counts],
        'values': [issue['count'] for issue in issue_type_counts]
    }
    
    context = {
        'audit': audit,
        'severity_data': {
            'labels': json.dumps(severity_data['labels']),
            'values': json.dumps(severity_data['values'])
        },
        'issue_type_data': {
            'labels': json.dumps(issue_type_data['labels']),
            'values': json.dumps(issue_type_data['values'])
        },
        'severities': SEOAuditIssue.SEVERITY_CHOICES,
        'issue_types': SEOAuditIssue.ISSUE_TYPES
    }
    
    return render(request, 'seo_audit/results.html', context)

@login_required
@require_http_methods(["GET"])
def get_remediation_plan(request, plan_id):
    """Fetch a specific remediation plan and all plans for its URL"""
    try:
        plan = SEORemediationPlan.objects.get(id=plan_id)
        # Get all plans for this URL
        all_plans = SEORemediationPlan.objects.filter(
            audit=plan.audit, 
            url=plan.url
        ).order_by('-created_at')
        
        return JsonResponse({
            'success': True,
            'plan': plan.plan_content,
            'all_plans': [{
                'id': p.id,
                'provider': p.llm_provider,
                'model': p.llm_model,
                'created_at': p.created_at.isoformat(),
                'content': p.plan_content
            } for p in all_plans]
        })
    except SEORemediationPlan.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Plan not found'
        }, status=404) 

@login_required
@require_http_methods(["DELETE"])
def delete_remediation_plan(request, plan_id):
    """Delete a specific remediation plan"""
    try:
        plan = get_object_or_404(SEORemediationPlan, id=plan_id)
        
        # Check if user has permission to delete this plan
        if not request.user.has_perm('seo_audit.delete_seoremediationplan'):
            return JsonResponse({
                'success': False,
                'error': 'Permission denied'
            }, status=403)
            
        plan.delete()
        return JsonResponse({'success': True})
    except Exception as e:
        logger.error(f"Error deleting remediation plan {plan_id}: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

================
File: apps/seo_manager/static/seo_manager/js/client_detail.js
================
document.addEventListener('DOMContentLoaded', function() {
    const { clientId, urls, keywords } = window.clientData;

    // Initialize keyword charts
    keywords.forEach(keyword => {
        initializeKeywordChart(keyword);
    });

    // Collect Rankings Button
    document.getElementById('collectRankingsBtn')?.addEventListener('click', function() {
        Swal.fire({
            title: 'Collecting Rankings Data',
            text: 'This may take a few minutes...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });

        fetch(urls.collectRankings, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success!',
                    text: data.message
                }).then(() => {
                    window.location.reload();
                });
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.error
                });
            }
        });
    });

    // Generate Report Button
    document.getElementById('generateReportBtn')?.addEventListener('click', function() {
        Swal.fire({
            title: 'Generating Report',
            text: 'Please wait...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });

        fetch(urls.generateReport, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('reportContent').innerHTML = data.report_html;
                var reportModal = new bootstrap.Modal(document.getElementById('reportModal'));
                Swal.close();
                reportModal.show();
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.error
                });
            }
        });
    });

    // Backfill Rankings Button
    document.getElementById('backfillRankingsBtn')?.addEventListener('click', function() {
        Swal.fire({
            title: 'Backfill Historical Data',
            text: 'This will collect ranking data for the past 12 months. This may take several minutes. Continue?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, proceed',
            cancelButtonText: 'No, cancel'
        }).then((result) => {
            if (result.isConfirmed) {
                handleBackfillRankings();
            }
        });
    });

    // Magically Fill In Button
    document.getElementById('magicallyFillBtn')?.addEventListener('click', handleMagicFill);

    // Initialize Quill editors
    initializeQuillEditors();

    // Delete Client Button
    document.getElementById('deleteClientBtn')?.addEventListener('click', handleDeleteClient);

    // View switching functionality
    initializeViewSwitching();

    // Activity Timeline Filtering
    initializeActivityFiltering();

    // Initialize DataTables
    initializeDataTables();

    // Initialize Search Console import functionality
    initializeSearchConsoleImport();

    // Initialize Create Snapshot button
    initializeCreateSnapshot();
});

// Helper Functions

function initializeKeywordChart(keyword) {
    const modalId = `view-history-${keyword.id}`;
    const canvasId = `keyword-chart-${keyword.id}`;
    const modal = document.getElementById(modalId);
    let currentChart = null;

    if (!modal) return;

    function recreateCanvas(containerId) {
        const container = document.getElementById(containerId);
        if (!container) return null;
        
        const oldCanvas = document.getElementById(canvasId);
        if (oldCanvas) {
            oldCanvas.remove();
        }
        
        const newCanvas = document.createElement('canvas');
        newCanvas.id = canvasId;
        container.appendChild(newCanvas);
        return newCanvas;
    }

    function destroyChart() {
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
        Chart.helpers.each(Chart.instances, function(instance) {
            if (instance.canvas.id === canvasId) {
                instance.destroy();
            }
        });
    }

    modal.addEventListener('show.bs.modal', function() {
        destroyChart();
        
        const canvas = recreateCanvas(`chart-container-${keyword.id}`);
        if (!canvas) return;

        setTimeout(() => {
            currentChart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: keyword.history.map(entry => entry.date).reverse(),
                    datasets: [{
                        label: 'Position',
                        data: keyword.history.map(entry => entry.position).reverse(),
                        borderColor: '#5e72e4',
                        backgroundColor: 'rgba(94, 114, 228, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            reverse: true,
                            beginAtZero: false
                        }
                    }
                }
            });
        }, 0);
    });

    modal.addEventListener('hidden.bs.modal', destroyChart);
    window.addEventListener('unload', destroyChart);
}

function handleBackfillRankings() {
    const { urls } = window.clientData;

    Swal.fire({
        title: 'Collecting Historical Data',
        text: 'This may take several minutes...',
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading()
        }
    });

    fetch(urls.backfillRankings, {
        method: 'POST',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: data.message
            }).then(() => {
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error
            });
        }
    })
    .catch(error => {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'An error occurred while collecting historical data.'
        });
    });
}

function handleMagicFill() {
    const { urls } = window.clientData;
    
    const swalInstance = Swal.fire({
        title: 'Generating Client Profile',
        html: 'This may take a few minutes...',
        timerProgressBar: true,
        allowOutsideClick: false,
        showCancelButton: true,
        cancelButtonText: 'Cancel',
        didOpen: () => {
            Swal.showLoading();
        }
    });

    const controller = new AbortController();
    const signal = controller.signal;

    fetch(urls.generateMagicProfile, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        signal: signal
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            pollTaskStatus(data.task_id);
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error || 'Failed to start profile generation'
            });
        }
    })
    .catch(error => {
        if (error.name === 'AbortError') return;
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Failed to generate profile'
        });
    });

    swalInstance.then((result) => {
        if (result.dismiss === Swal.DismissReason.cancel) {
            controller.abort();
            Swal.fire({
                icon: 'info',
                title: 'Cancelled',
                text: 'Profile generation was cancelled'
            });
        }
    });
}

function pollTaskStatus(taskId) {
    const { urls, clientId } = window.clientData;
    const toolStatusUrl = urls.getToolStatus.replace('TASK_ID', taskId);
    
    const pollInterval = setInterval(() => {
        fetch(toolStatusUrl)
            .then(response => response.json())
            .then(statusData => {
                if (statusData.status === 'SUCCESS') {
                    clearInterval(pollInterval);
                    
                    // Instead of reloading, save the profile to database
                    saveProfileToDatabase(statusData.result, clientId);
                } else if (statusData.status === 'FAILURE') {
                    clearInterval(pollInterval);
                    Swal.fire({
                        icon: 'error',
                        title: 'Error',
                        text: statusData.error || 'Failed to generate profile'
                    });
                }
            })
            .catch(error => {
                clearInterval(pollInterval);
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: 'Failed to check task status'
                });
            });
    }, 2000);
}

function saveProfileToDatabase(result, clientId) {
    const { urls } = window.clientData;
    
    // Show loading indicator
    Swal.fire({
        title: 'Saving profile...',
        text: 'Please wait while we save the generated profile',
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading();
        }
    });
    
    // Send the result to the profile_generation_complete endpoint
    fetch(urls.profileGenerationComplete, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            result: result
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: data.message || 'Profile generated and saved successfully'
            }).then(() => {
                // Reload the page to show the new profile
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error || 'Failed to save profile'
            });
        }
    })
    .catch(error => {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'Failed to save profile: ' + (error.message || 'Unknown error')
        });
    });
}

function initializeQuillEditors() {
    const toolbarOptions = [
        ['bold', 'italic', 'underline', 'strike'],
        ['blockquote', 'code-block'],
        [{ 'header': 1 }, { 'header': 2 }],
        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
        [{ 'script': 'sub'}, { 'script': 'super' }],
        [{ 'indent': '-1'}, { 'indent': '+1' }],
        ['link'],
        ['clean']
    ];

    // Add Profile Editor
    const addProfileContainer = document.getElementById('add-profile-editor');
    if (addProfileContainer) {
        const addProfileEditor = new Quill('#add-profile-editor', {
            theme: 'snow',
            modules: { toolbar: toolbarOptions },
            placeholder: 'Enter client profile content...',
            bounds: addProfileContainer
        });

        document.getElementById('addProfileForm')?.addEventListener('submit', function(e) {
            e.preventDefault();
            const content = addProfileEditor.root.innerHTML;
            if (!content || content.trim() === '<p><br></p>') {
                Swal.fire({
                    icon: 'warning',
                    title: 'Empty Content',
                    text: 'Please enter some content for the client profile.'
                });
                return;
            }
            
            document.getElementById('add-profile-content').value = content;
            
            // Show loading state
            const submitBtn = this.querySelector('button[type="submit"]');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Saving...';
            submitBtn.disabled = true;
            
            fetch(this.action, {
                method: 'POST',
                body: new FormData(this),
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    Swal.fire({
                        icon: 'success',
                        title: 'Success!',
                        text: 'Client profile saved successfully'
                    }).then(() => {
                        window.location.reload();
                    });
                } else {
                    throw new Error(data.error || 'Failed to save profile');
                }
            })
            .catch(error => {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: error.message || 'An error occurred while saving the profile'
                });
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
            });
        });
    }

    // Edit Profile Editor
    const editProfileContainer = document.getElementById('edit-profile-editor');
    if (editProfileContainer) {
        const editProfileEditor = new Quill('#edit-profile-editor', {
            theme: 'snow',
            modules: { toolbar: toolbarOptions },
            placeholder: 'Enter client profile content...',
            bounds: editProfileContainer
        });

        document.getElementById('editProfileForm')?.addEventListener('submit', function(e) {
            e.preventDefault();
            const content = editProfileEditor.root.innerHTML;
            if (!content || content.trim() === '<p><br></p>') {
                Swal.fire({
                    icon: 'warning',
                    title: 'Empty Content',
                    text: 'Please enter some content for the client profile.'
                });
                return;
            }
            
            document.getElementById('edit-profile-content').value = content;
            
            // Show loading state
            const submitBtn = this.querySelector('button[type="submit"]');
            const originalText = submitBtn.innerHTML;
            submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Updating...';
            submitBtn.disabled = true;
            
            fetch(this.action, {
                method: 'POST',
                body: new FormData(this),
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    Swal.fire({
                        icon: 'success',
                        title: 'Success!',
                        text: 'Client profile updated successfully'
                    }).then(() => {
                        window.location.reload();
                    });
                } else {
                    throw new Error(data.error || 'Failed to update profile');
                }
            })
            .catch(error => {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: error.message || 'An error occurred while updating the profile'
                });
                submitBtn.innerHTML = originalText;
                submitBtn.disabled = false;
            });
        });
    }
}

function handleDeleteClient() {
    const { urls } = window.clientData;
    const clientName = this.dataset.clientName;

    Swal.fire({
        title: 'Are you sure?',
        html: `You are about to delete client: <strong>${clientName}</strong><br>This action cannot be undone!`,
        icon: 'warning',
        showCancelButton: true,
        confirmButtonColor: '#d33',
        cancelButtonColor: '#3085d6',
        confirmButtonText: 'Yes, delete it!',
        cancelButtonText: 'Cancel'
    }).then((result) => {
        if (result.isConfirmed) {
            deleteClientRequest();
        }
    });
}

function deleteClientRequest() {
    const { urls } = window.clientData;

    Swal.fire({
        title: 'Deleting...',
        html: 'Please wait',
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading()
        }
    });

    fetch(urls.deleteClient, {
        method: 'POST',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
            'Content-Type': 'application/json'
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire({
                icon: 'success',
                title: 'Deleted!',
                text: 'Client has been deleted successfully.',
                showConfirmButton: false,
                timer: 1500
            }).then(() => {
                window.location.href = urls.clientList;
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error || 'An error occurred while deleting the client.'
            });
        }
    })
    .catch(error => {
        console.error('Error:', error);
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'An error occurred while deleting the client.'
        });
    });
}

function initializeViewSwitching() {
    const listView = document.getElementById('projects-list-view');
    const kanbanView = document.getElementById('projects-kanban-view');
    const listViewBtn = document.getElementById('list-view');
    const kanbanViewBtn = document.getElementById('kanban-view');

    if (!listView || !kanbanView || !listViewBtn || !kanbanViewBtn) return;

    listViewBtn.addEventListener('change', function() {
        if (this.checked) {
            listView.style.display = 'block';
            kanbanView.style.display = 'none';
        }
    });

    kanbanViewBtn.addEventListener('change', function() {
        if (this.checked) {
            listView.style.display = 'none';
            kanbanView.style.display = 'block';
        }
    });
}

function initializeActivityFiltering() {
    const filterLinks = document.querySelectorAll('[data-filter]');
    const timelineBlocks = document.querySelectorAll('.timeline-block');
    
    filterLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            
            filterLinks.forEach(l => l.classList.remove('active'));
            this.classList.add('active');
            
            const filter = this.dataset.filter;
            
            timelineBlocks.forEach(block => {
                if (filter === 'all' || block.dataset.category === filter) {
                    block.style.display = 'flex';
                    block.style.opacity = '1';
                } else {
                    block.style.display = 'none';
                    block.style.opacity = '0';
                }
            });
        });
    });

    initializeLoadMore();
    initializeExport();
}

function initializeLoadMore() {
    const loadMoreBtn = document.getElementById('loadMoreActivities');
    if (!loadMoreBtn) return;

    let page = 1;
    loadMoreBtn.addEventListener('click', function() {
        const { urls } = window.clientData;
        page++;
        loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Loading...';
        
        fetch(`${urls.loadMoreActivities}?page=${page}`)
            .then(response => response.json())
            .then(data => {
                if (data.activities) {
                    const timeline = document.querySelector('.timeline');
                    timeline.insertAdjacentHTML('beforeend', data.activities);
                    
                    if (!data.has_more) {
                        loadMoreBtn.style.display = 'none';
                    }
                }
                loadMoreBtn.innerHTML = '<i class="fas fa-sync me-1"></i>Load More';
            });
    });
}

function initializeExport() {
    const exportBtn = document.getElementById('exportActivityBtn');
    if (!exportBtn) return;

    exportBtn.addEventListener('click', function() {
        const { urls } = window.clientData;
        const filter = document.querySelector('[data-filter].active').dataset.filter;
        window.location.href = `${urls.exportActivities}?filter=${filter}`;
    });
}

function initializeDataTables() {
    if (document.getElementById('projects-table')) {
        new simpleDatatables.DataTable("#projects-table", {
            searchable: true,
            fixedHeight: true,
            perPage: 10
        });
    }

    if (document.getElementById('snapshots-table')) {
        new simpleDatatables.DataTable("#snapshots-table", {
            searchable: true,
            fixedHeight: true,
            perPage: 7
        });
    }
}

// Export functions that need to be globally available
window.updateObjectiveStatus = function(clientId, objectiveIndex, newStatus) {
    fetch(`/seo/clients/${clientId}/objectives/${objectiveIndex}/status/`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        },
        body: JSON.stringify({
            status: newStatus
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: data.message,
                showConfirmButton: false,
                timer: 1500
            }).then(() => {
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error || 'Failed to update status'
            });
        }
    })
    .catch(error => {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'An error occurred while updating the status'
        });
    });
};

function initializeSearchConsoleImport() {
    const selectAllCheckbox = document.getElementById('select-all-keywords');
    const importButton = document.getElementById('import-selected-keywords');
    
    if (!selectAllCheckbox || !importButton) return;

    // Handle "Select All" checkbox
    selectAllCheckbox.addEventListener('change', function() {
        const checkboxes = document.querySelectorAll('.keyword-checkbox');
        checkboxes.forEach(checkbox => {
            checkbox.checked = this.checked;
        });
    });

    // Handle Import button click
    importButton.addEventListener('click', function() {
        const selectedKeywords = [];
        const checkboxes = document.querySelectorAll('.keyword-checkbox:checked');
        
        checkboxes.forEach(checkbox => {
            selectedKeywords.push({
                keyword: checkbox.value,
                position: parseFloat(checkbox.dataset.position),
                clicks: parseInt(checkbox.dataset.clicks),
                impressions: parseInt(checkbox.dataset.impressions),
                ctr: parseFloat(checkbox.dataset.ctr)
            });
        });

        if (selectedKeywords.length === 0) {
            Swal.fire({
                icon: 'warning',
                title: 'No Keywords Selected',
                text: 'Please select at least one keyword to import.'
            });
            return;
        }

        // Show loading state
        Swal.fire({
            title: 'Importing Keywords',
            text: 'Please wait...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });

        // Send import request
        fetch(`/seo/clients/${window.clientData.clientId}/keywords/import-from-search-console/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            },
            body: JSON.stringify(selectedKeywords)
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success!',
                    text: data.message
                }).then(() => {
                    window.location.reload();
                });
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.error || 'Failed to import keywords'
                });
            }
        })
        .catch(error => {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'An error occurred while importing keywords'
            });
        });
    });
}

function initializeCreateSnapshot() {
    const createSnapshotBtn = document.getElementById('createSnapshotBtn');
    if (!createSnapshotBtn) return;

    createSnapshotBtn.addEventListener('click', function() {
        const { clientId } = window.clientData;

        Swal.fire({
            title: 'Creating Meta Tags Snapshot',
            text: 'This may take a few moments...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });

        fetch(`/seo/clients/${clientId}/meta-tags/snapshot/`, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success!',
                    text: data.message,
                    showConfirmButton: true
                }).then(() => {
                    window.location.reload();
                });
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.message || 'Failed to create meta tags snapshot'
                });
            }
        })
        .catch(error => {
            console.error('Error:', error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'An error occurred while creating the snapshot.'
            });
        });
    });
}

================
File: apps/seo_manager/static/seo_manager/js/meta_tags_dashboard.js
================
document.addEventListener('DOMContentLoaded', function() {
    initializeCreateSnapshot();
    initializeUrlInput();
    initializeDataTables();
});

function initializeCreateSnapshot() {
    const createSnapshotBtn = document.getElementById('createSnapshotBtn');
    if (!createSnapshotBtn) return;

    createSnapshotBtn.addEventListener('click', function() {
        const clientId = this.dataset.clientId;

        Swal.fire({
            title: 'Creating Meta Tags Snapshot',
            text: 'This will start a background process to extract meta tags.',
            icon: 'question',
            showCancelButton: true,
            confirmButtonText: 'Start Extraction',
            cancelButtonText: 'Cancel',
            confirmButtonColor: '#3085d6',
            cancelButtonColor: '#d33'
        }).then((result) => {
            if (result.isConfirmed) {
                Swal.fire({
                    title: 'Starting Extraction',
                    text: 'Initializing the meta tags extraction process...',
                    allowOutsideClick: false,
                    didOpen: () => {
                        Swal.showLoading();
                    }
                });

                fetch(`/seo/clients/${clientId}/meta-tags/snapshot/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json',
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        Swal.close();
                        if (data.redirect_url) {
                            window.location.href = data.redirect_url;
                        } else if (data.task_id) {
                            // Connect to WebSocket if we have a task_id
                            connectWebSocket(data.task_id);
                        }
                    } else {
                        Swal.fire({
                            icon: 'error',
                            title: 'Error',
                            text: data.message || 'Failed to create meta tags snapshot'
                        });
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    Swal.fire({
                        icon: 'error',
                        title: 'Error',
                        text: 'An error occurred while creating the snapshot.'
                    });
                });
            }
        });
    });
}

function initializeUrlInput() {
    // Button click handler to show the URL input modal
    const createFromUrlBtn = document.getElementById('createFromUrlBtn');
    if (!createFromUrlBtn) return;

    createFromUrlBtn.addEventListener('click', function() {
        const urlInputModal = new bootstrap.Modal(document.getElementById('urlInputModal'));
        urlInputModal.show();
    });

    // URL submission handler
    const confirmUrlBtn = document.getElementById('confirmUrlBtn');
    if (!confirmUrlBtn) return;

    confirmUrlBtn.addEventListener('click', function() {
        const url = document.getElementById('urlInput').value.trim();
        
        if (!url) {
            Swal.fire({
                icon: 'warning',
                title: 'URL Required',
                text: 'Please enter a valid URL'
            });
            return;
        }

        // Hide the modal
        bootstrap.Modal.getInstance(document.getElementById('urlInputModal')).hide();

        // Show loading state
        Swal.fire({
            title: 'Starting Extraction',
            text: 'Initializing the meta tags extraction process...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });

        // Submit the URL
        fetch('/seo/meta-tags/snapshot-url/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ url: url })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                Swal.close();
                if (data.task_id) {
                    // Connect to WebSocket to track progress
                    connectWebSocket(data.task_id);
                }
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.message || 'Failed to start meta tags extraction'
                });
            }
        })
        .catch(error => {
            console.error('Error:', error);
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: 'An error occurred while starting the extraction.'
            });
        });
    });
}

function initializeDataTables() {
    if (document.getElementById('snapshots-table')) {
        new simpleDatatables.DataTable("#snapshots-table", {
            searchable: true,
            fixedHeight: true,
            perPage: 7
        });
    }
}

================
File: apps/seo_manager/static/seo_manager/js/ranking_data_management.js
================
document.addEventListener('DOMContentLoaded', function() {
    // Ensure urls are available
    if (!window.urls) {
        console.error('URLs not defined');
        return;
    }

    // Initialize DataTable
    new simpleDatatables.DataTable("#rankings-table", {
        perPage: 25,
        sort: { date: "desc" },
        searchable: true,
        fixedHeight: true,
        labels: {
            placeholder: "Search records..."
        }
    });

    // Initialize button handlers
    const collectRankingsBtn = document.getElementById('collectRankingsBtn');
    const generateReportBtn = document.getElementById('generateReportBtn');
    const backfillRankingsBtn = document.getElementById('backfillRankingsBtn');
    
    if (collectRankingsBtn) {
        collectRankingsBtn.addEventListener('click', function() {
        Swal.fire({
            title: 'Collecting Rankings Data',
            text: 'This may take a few minutes...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });

        fetch(window.urls.collectRankings, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                Swal.fire({
                    icon: 'success',
                    title: 'Success!',
                    text: data.message
                }).then(() => {
                    window.location.reload();
                });
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.error
                });
            }
        });
    });
    }

    if (generateReportBtn) {
        generateReportBtn.addEventListener('click', function() {
        Swal.fire({
            title: 'Generating Report',
            text: 'Please wait...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading()
            }
        });

        fetch(window.urls.generateReport, {
            method: 'POST',
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                document.getElementById('reportContent').innerHTML = data.report_html;
                var reportModal = new bootstrap.Modal(document.getElementById('reportModal'));
                Swal.close();
                reportModal.show();
            } else {
                Swal.fire({
                    icon: 'error',
                    title: 'Error',
                    text: data.error
                });
            }
        });
    });
    }

    if (backfillRankingsBtn) {
        backfillRankingsBtn.addEventListener('click', function() {
        Swal.fire({
            title: 'Backfill Historical Data',
            text: 'This will collect ranking data for the past 12 months. This may take several minutes. Continue?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonText: 'Yes, proceed',
            cancelButtonText: 'No, cancel'
        }).then((result) => {
            if (result.isConfirmed) {
                handleBackfillRankings();
                }
            });
        });
    }

    // Initialize column visibility handlers
    const checkboxes = document.querySelectorAll('#dropdownDefaultCheckbox input[type="checkbox"]');
    checkboxes.forEach(function(checkbox) {
        checkbox.addEventListener('change', function() {
            const targetColumnId = this.getAttribute('data-target');
            const targetColumn = document.getElementById('th_' + targetColumnId);
            const targetDataCells = document.querySelectorAll('.td_' + targetColumnId);
            
            if (this.checked) {
                targetColumn.style.display = 'none';
                targetDataCells.forEach(cell => cell.style.display = 'none');
            } else {
                targetColumn.style.display = '';
                targetDataCells.forEach(cell => cell.style.display = '');
            }
        });
    });
});

function handleBackfillRankings() {
    Swal.fire({
        title: 'Collecting Historical Data',
        text: 'This may take several minutes...',
        allowOutsideClick: false,
        didOpen: () => {
            Swal.showLoading()
        }
    });

    fetch(window.urls.backfillRankings, {
        method: 'POST',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            Swal.fire({
                icon: 'success',
                title: 'Success!',
                text: data.message
            }).then(() => {
                window.location.reload();
            });
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error
            });
        }
    })
    .catch(error => {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'An error occurred while collecting historical data.'
        });
    });
}

function getPageItems(selectObject) {
    var value = selectObject.value;
    window.location.href = updateQueryStringParameter(window.location.href, 'items', value);
}

function updateQueryStringParameter(uri, key, value) {
    var re = new RegExp("([?&])" + key + "=.*?(&|$)", "i");
    var separator = uri.indexOf('?') !== -1 ? "&" : "?";
    if (uri.match(re)) {
        return uri.replace(re, '$1' + key + "=" + value + '$2');
    }
    else {
        return uri + separator + key + "=" + value;
    }
}

================
File: apps/seo_manager/templates/seo_manager/credentials/add_ga_service_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Add GA Service Account - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Add Google Analytics Service Account</h6>
                    <p class="text-sm">Upload your service account JSON file for {{ client.name }}</p>
                </div>
                <div class="card-body">
                    <form method="post" enctype="multipart/form-data">
                        {% csrf_token %}
                        <div class="form-group">
                            <label class="form-control-label">Service Account JSON File</label>
                            <input type="file" name="service_account_file" class="form-control" required>
                            <small class="text-muted">Upload the JSON file containing your service account credentials</small>
                        </div>
                        <div class="mt-4">
                            <button type="submit" class="btn bg-gradient-primary">Upload Credentials</button>
                            <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn bg-gradient-secondary">Cancel</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/credentials/add_sc_service_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Add Search Console Service Account - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Add Search Console Service Account for {{ client.name }}</h6>
        </div>
        <div class="card-body">
          <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <div class="form-group">
              <label for="service_account_file">Service Account JSON File</label>
              <div class="form-control dropzone" id="dropzone">
                <div class="fallback">
                  <input name="service_account_file" type="file" accept="application/json" required />
                </div>
              </div>
              <small class="form-text text-muted">
                Upload your Google Search Console service account JSON key file
              </small>
            </div>
            <div class="d-flex justify-content-end mt-4">
              <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-light m-0 me-2">Cancel</a>
              <button type="submit" class="btn bg-gradient-primary m-0">Upload Service Account</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="/static/assets/js/plugins/dropzone.min.js"></script>
<script>
  Dropzone.autoDiscover = false;
  var drop = document.getElementById('dropzone')
  var myDropzone = new Dropzone(drop, {
    url: "#",
    addRemoveLinks: true,
    acceptedFiles: ".json",
    maxFiles: 1,
    autoProcessQueue: false,
    init: function() {
      this.on("addedfile", function(file) {
        if (this.files.length > 1) {
          this.removeFile(this.files[0]);
        }
      });
    }
  });
</script>
{% endblock extra_js %}

{% block extra_css %}
{{ block.super }}
<link href="/static/assets/css/dropzone.min.css" rel="stylesheet">
{% endblock extra_css %}

================
File: apps/seo_manager/templates/seo_manager/credentials/select_analytics_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Select Analytics Account - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Select Google Analytics Account</h6>
                    <p class="text-sm">Choose the Analytics account to connect for {{ client.name }}</p>
                </div>
                <div class="card-body">
                    <form method="post">
                        {% csrf_token %}
                        <div class="form-group">
                            <label class="form-control-label">Analytics Account</label>
                            <select name="selected_account" class="form-select" required>
                                <option value="">Select an account...</option>
                                {% for account in accounts %}
                                <option value="{{ account.property_id }}">
                                    {{ account.account_name }} - {{ account.property_name }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="mt-4">
                            <button type="submit" class="btn bg-gradient-primary">Connect Account</button>
                            <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn bg-gradient-secondary">Cancel</a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/includes/activity_items.html
================
{% for activity in client_activities %}
  <div class="timeline-block mb-4" data-category="{{ activity.category }}">
    <span class="timeline-step">
      {% if activity.category == 'keyword' %}
        <i class="fas fa-key text-primary"></i>
      {% elif activity.category == 'project' %}
        <i class="fas fa-project-diagram text-info"></i>
      {% elif activity.category == 'ranking' %}
        <i class="fas fa-chart-line text-success"></i>
      {% elif activity.category == 'analytics' %}
        <i class="fas fa-chart-bar text-warning"></i>
      {% else %}
        <i class="fas fa-circle text-secondary"></i>
      {% endif %}
    </span>
    <div class="timeline-content">
      <div class="d-flex justify-content-between">
        <div>
          <span class="badge badge-sm bg-gradient-{% if activity.category == 'keyword' %}primary{% elif activity.category == 'project' %}info{% elif activity.category == 'ranking' %}success{% elif activity.category == 'analytics' %}warning{% else %}secondary{% endif %} mb-2">
            {{ activity.get_category_display }}
          </span>
          <h6 class="text-dark mb-0">{{ activity.action }}</h6>
          <p class="text-secondary text-sm mt-1 mb-0">
            {% if activity.user %}
              <span class="font-weight-bold text-primary">{{ activity.user.username }}</span>
            {% endif %}
            {% if activity.details %}
              <span class="text-dark ms-2">{{ activity.details|pprint }}</span>
            {% endif %}
          </p>
        </div>
        <div class="ms-auto">
          <span class="text-secondary text-xs">
            {{ activity.timestamp|date:"M d, Y H:i" }}
          </span>
        </div>
      </div>
    </div>
  </div>
{% endfor %}

================
File: apps/seo_manager/templates/seo_manager/includes/keyword_import_modals.html
================
<!-- Import Keywords Modal -->
<div class="modal fade" id="import-keywords" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Import Keywords</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_import' client.id %}" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="modal-body">
          {{ import_form.as_p }}
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Import</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Import from Search Console Modal -->
<div class="modal fade" id="import-search-console" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Import from Search Console</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        {% if not client.sc_credentials %}
          <div class="text-center py-4">
            <div class="icon icon-shape icon-sm bg-gradient-warning shadow text-center mb-3">
              <i class="fas fa-exclamation-triangle opacity-10"></i>
            </div>
            <h6 class="text-dark">Search Console Not Connected</h6>
            <p class="text-secondary text-sm">Please connect Search Console first to import keywords.</p>
            <a href="{% url 'seo_manager:add_sc_credentials' client.id %}" class="btn btn-sm bg-gradient-info mt-3">
              <i class="fab fa-google me-2"></i>Connect Search Console
            </a>
          </div>
        {% elif not search_console_data %}
          <div class="text-center py-4">
            <div class="icon icon-shape icon-sm bg-gradient-info shadow text-center mb-3">
              <i class="fas fa-search opacity-10"></i>
            </div>
            <h6 class="text-dark">No Search Console Data</h6>
            <p class="text-secondary text-sm">No keyword data found in Search Console for the last 90 days.</p>
          </div>
        {% else %}
          <div class="table-responsive">
            <table class="table align-items-center mb-0" id="search-console-keywords-table">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <div class="form-check">
                      <input class="form-check-input" type="checkbox" id="select-all-keywords">
                    </div>
                  </th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Position</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Clicks</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Impressions</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">CTR</th>
                </tr>
              </thead>
              <tbody>
                {% for keyword in search_console_data %}
                  <tr>
                    <td>
                      <div class="form-check">
                        <input class="form-check-input keyword-checkbox" type="checkbox" 
                               value="{{ keyword.query }}" 
                               data-position="{{ keyword.position }}"
                               data-clicks="{{ keyword.clicks }}"
                               data-impressions="{{ keyword.impressions }}"
                               data-ctr="{{ keyword.ctr }}">
                      </div>
                    </td>
                    <td>
                      <p class="text-xs font-weight-bold mb-0">{{ keyword.query }}</p>
                    </td>
                    <td>
                      <p class="text-xs font-weight-bold mb-0">{{ keyword.position|floatformat:1 }}</p>
                    </td>
                    <td>
                      <p class="text-xs font-weight-bold mb-0">{{ keyword.clicks }}</p>
                    </td>
                    <td>
                      <p class="text-xs font-weight-bold mb-0">{{ keyword.impressions }}</p>
                    </td>
                    <td>
                      <p class="text-xs font-weight-bold mb-0">{{ keyword.ctr|floatformat:2 }}%</p>
                    </td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        {% endif %}
      </div>
      <div class="modal-footer">
        <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
        {% if search_console_data %}
          <button type="button" class="btn bg-gradient-primary" id="import-selected-keywords">
            Import Selected Keywords
          </button>
        {% endif %}
      </div>
    </div>
  </div>
</div>

================
File: apps/seo_manager/templates/seo_manager/includes/keyword_modals.html
================
{% include 'seo_manager/includes/keyword_import_modals.html' %}

<!-- Add Keyword Modal -->
<div class="modal fade" id="add-keyword" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Keyword</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_create' client.id %}">
        {% csrf_token %}
        <div class="modal-body">
          {{ keyword_form.as_p }}
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Keyword</button>
        </div>
      </form>
    </div>
  </div>
</div>

================
File: apps/seo_manager/templates/seo_manager/includes/objective_modals.html
================
<!-- Add Business Objective Modal -->
<div class="modal fade" id="add-objective" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Business Objective</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:add_business_objective' client.id %}" id="addObjectiveForm">
        {% csrf_token %}
        <div class="modal-body">
          <!-- Goal Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Goal</label>
            <textarea class="form-control" name="goal" rows="3" required></textarea>
            <small class="text-muted">What specific outcome do you want to achieve?</small>
          </div>
          
          <!-- Metric Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Metric</label>
            <textarea class="form-control" name="metric" rows="2" required></textarea>
            <small class="text-muted">Define the key metrics that will track progress</small>
          </div>
          
          <!-- Target Date Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Target Date</label>
            <input type="text" class="form-control datepicker" name="target_date" id="target_date" required>
            <small class="text-muted">When do you aim to achieve this objective?</small>
          </div>
          
          <!-- Status Field -->
          <div class="form-check form-switch mb-3">
            <input type="checkbox" class="form-check-input" name="status" checked>
            <label class="form-check-label ms-3">Active</label>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Objective</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Edit Business Objective Modal -->
<div class="modal fade" id="edit-objective" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Edit Business Objective</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:edit_business_objective' client.id 0 %}" id="editObjectiveForm">
        {% csrf_token %}
        <div class="modal-body">
          <!-- Goal Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Goal</label>
            <textarea class="form-control" name="goal" rows="3" required id="edit_goal"></textarea>
            <small class="text-muted">What specific outcome do you want to achieve?</small>
          </div>
          
          <!-- Metric Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Metric</label>
            <textarea class="form-control" name="metric" rows="2" required id="edit_metric"></textarea>
            <small class="text-muted">Define the key metrics that will track progress</small>
          </div>
          
          <!-- Target Date Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Target Date</label>
            <input type="text" class="form-control datepicker" name="target_date" id="edit_target_date" required>
            <small class="text-muted">When do you aim to achieve this objective?</small>
          </div>
          
          <!-- Status Field -->
          <div class="form-check form-switch mb-3">
            <input type="checkbox" class="form-check-input" name="status" id="edit_status">
            <label class="form-check-label ms-3">Active</label>
          </div>
          
          <input type="hidden" name="objective_index" id="edit_objective_index">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Update Objective</button>
        </div>
      </form>
    </div>
  </div>
</div>

================
File: apps/seo_manager/templates/seo_manager/keywords/keyword_list_table.html
================
{% load seo_tags %}

<table class="table table-flush align-items-center mb-0" id="keywords-table">
  <thead class="thead-light">
    <tr>
      <th class="text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
      <th class="text-secondary text-xxs font-weight-bolder opacity-7">Priority</th>
      <th class="text-center text-secondary text-xxs font-weight-bolder opacity-7">Current Position</th>
      <th class="text-center text-secondary text-xxs font-weight-bolder opacity-7">30d Change</th>
      <th class="text-secondary text-xxs font-weight-bolder opacity-7">Notes</th>
      <th class="text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
    </tr>
  </thead>
  <tbody>
    {% for keyword in keywords %}
    <tr>
      <td class="align-middle py-2">
        <div class="d-flex px-2">
          <span class="text-xs font-weight-bold">{{ keyword.keyword }}</span>
        </div>
      </td>
      <td class="align-middle py-2">
        <span class="badge badge-sm bg-gradient-{% if keyword.priority == 1 %}danger{% elif keyword.priority == 2 %}warning{% else %}info{% endif %}">
          {{ keyword.get_priority_display }}
        </span>
      </td>
      <td class="text-center">
        {% if keyword.current_position %}
          <span class="text-sm">{{ keyword.current_position }}</span>
        {% else %}
          <span class="text-sm text-secondary">-</span>
        {% endif %}
      </td>
      <td class="text-center">
        {% with change=keyword.get_position_change %}
          {% if change %}
            <div class="d-flex align-items-center justify-content-center">
              {% if keyword.position_trend == 'up' %}
                <i class="fas fa-arrow-up text-success me-1"></i>
              {% elif keyword.position_trend == 'down' %}
                <i class="fas fa-arrow-down text-danger me-1"></i>
              {% else %}
                <i class="fas fa-minus text-secondary me-1"></i>
              {% endif %}
              <span class="text-sm {% if change > 0 %}text-success{% elif change < 0 %}text-danger{% else %}text-secondary{% endif %}">
                {{ change|floatformat:1 }}
              </span>
            </div>
          {% else %}
            <span class="text-sm text-secondary">-</span>
          {% endif %}
        {% endwith %}
      </td>
      <td class="text-sm">{{ keyword.notes|truncatechars:50 }}</td>
      <td>
        <div class="d-flex">
          <a href="#" class="text-secondary font-weight-bold text-xs me-3" data-bs-toggle="modal" data-bs-target="#edit-keyword-{{ keyword.id }}">
            Edit
          </a>
          <a href="#" class="text-info font-weight-bold text-xs" data-bs-toggle="modal" data-bs-target="#view-history-{{ keyword.keyword|slugify }}">
            History
          </a>
        </div>
      </td>
    </tr>
    {% endfor %}
  </tbody>
</table>

<!-- Keyword History Modals -->
{% for keyword in keywords %}
<div class="modal fade" id="view-history-{{ keyword.keyword|slugify }}" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Ranking History: {{ keyword.keyword }}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="chart-container-{{ keyword.keyword|slugify }}" class="chart-container" style="position: relative; height: 300px;">
          <canvas id="keyword-chart-{{ keyword.keyword|slugify }}" class="chart-canvas"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>
{% endfor %}

<!-- Edit Keyword Modals -->
{% for keyword in keywords %}
<div class="modal fade" id="edit-keyword-{{ keyword.id }}" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Edit Keyword: {{ keyword.keyword }}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_update' client_id=client.id pk=keyword.id %}">
        {% csrf_token %}
        <div class="modal-body">
          <div class="form-group">
            <label for="keyword-{{ keyword.id }}">Keyword</label>
            <input type="text" class="form-control" id="keyword-{{ keyword.id }}" name="keyword" value="{{ keyword.keyword }}" required>
          </div>
          <div class="form-group mt-3">
            <label for="priority-{{ keyword.id }}">Priority</label>
            <select class="form-control" id="priority-{{ keyword.id }}" name="priority">
              {% for value, label in keyword.PRIORITY_CHOICES %}
                <option value="{{ value }}" {% if keyword.priority == value %}selected{% endif %}>{{ label }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="form-group mt-3">
            <label for="notes-{{ keyword.id }}">Notes</label>
            <textarea class="form-control" id="notes-{{ keyword.id }}" name="notes" rows="3">{{ keyword.notes }}</textarea>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Save Changes</button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endfor %}

<!-- Replace the existing script block at the bottom -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    {% for keyword in keywords %}
    (function() {
        const modal = document.getElementById('view-history-{{ keyword.keyword|slugify }}');
        if (!modal) return;


        const data = [
            {% for entry in keyword.get_ranking_history %}
                {
                    date: '{{ entry.date|date:"Y-m-d" }}',
                    position: {{ entry.average_position }},
                }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ];

        modal.addEventListener('show.bs.modal', function() {
            const ctx = document.getElementById('keyword-chart-{{ keyword.keyword|slugify }}');
            if (!ctx) return;

            // Sort data by date in ascending order
            const sortedData = [...data].sort((a, b) => new Date(a.date) - new Date(b.date));
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: sortedData.map(d => d.date),
                    datasets: [{
                        label: 'Position',
                        data: sortedData.map(d => d.position),
                        borderColor: '#5e72e4',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            reverse: true
                        }
                    }
                }
            });
        });
    })();
    {% endfor %}
});
</script>

================
File: apps/seo_manager/templates/seo_manager/keywords/keyword_list.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <!-- Card header -->
        <div class="card-header pb-0">
          <div class="d-lg-flex">
            <div>
              <h5 class="mb-0">Targeted Keywords - {{ client.name }}</h5>
              <p class="text-sm mb-0">
                Manage keywords and track their performance
              </p>
            </div>
            <div class="ms-auto my-auto mt-lg-0 mt-4">
              <div class="ms-auto my-auto">
                <a href="{% url 'seo_manager:keyword_create' client.id %}" class="btn bg-gradient-primary btn-sm mb-0">
                  <i class="fas fa-plus"></i>&nbsp;&nbsp;Add Keyword
                </a>
                <button type="button" class="btn btn-outline-primary btn-sm mb-0" data-bs-toggle="modal" data-bs-target="#import-keywords">
                  Import CSV
                </button>
              </div>
            </div>
          </div>
        </div>

        <div class="card-body px-0 pb-0">
          <div class="table-responsive">
            <table class="table table-flush" id="keywords-list">
              <thead class="thead-light">
                <tr>
                  <th>Keyword</th>
                  <th>Priority</th>
                  <th>Current Position</th>
                  <th>30d Change</th>
                  <th>Notes</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for keyword in keywords %}
                <tr>
                  <td>
                    <div class="d-flex align-items-center">
                      <span class="text-sm">{{ keyword.keyword }}</span>
                    </div>
                  </td>
                  <td>
                    <span class="badge bg-gradient-{% if keyword.priority == 1 %}danger{% elif keyword.priority == 2 %}warning{% else %}info{% endif %}">
                      {{ keyword.get_priority_display }}
                    </span>
                  </td>
                  <td>
                    {% with latest_ranking=keyword.ranking_history.first %}
                      {% if latest_ranking %}
                        {{ latest_ranking.average_position|floatformat:1 }}
                      {% else %}
                        -
                      {% endif %}
                    {% endwith %}
                  </td>
                  <td>
                    {% with change=keyword.get_30_day_change %}
                      {% if change %}
                        <span class="text-{% if change < 0 %}success{% elif change > 0 %}danger{% else %}secondary{% endif %}">
                          {{ change|floatformat:1 }}
                        </span>
                      {% else %}
                        -
                      {% endif %}
                    {% endwith %}
                  </td>
                  <td class="text-sm">{{ keyword.notes|truncatechars:50 }}</td>
                  <td>
                    <a href="{% url 'seo_manager:keyword_edit' keyword.id %}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit keyword">
                      Edit
                    </a>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Import Modal -->
<div class="modal fade" id="import-keywords" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Import Keywords</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_import' client.id %}" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="modal-body">
          <div class="form-group">
            {{ import_form.csv_file }}
            <small class="form-text text-muted">{{ import_form.csv_file.help_text }}</small>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Import</button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
  $(document).ready(function() {
    $('#keywords-list').DataTable({
      dom: 'Bfrtip',
      buttons: [
        'copy', 'csv', 'excel', 'pdf'
      ]
    });
  });
</script>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/keywords/ranking_history.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex align-items-center">
            <div>
              <h5 class="mb-0">Ranking History - {{ keyword.keyword }}</h5>
              <p class="text-sm mb-0">
                Track position changes over time
              </p>
            </div>
            <div class="ms-auto">
              <a href="{% url 'seo_manager:ranking_import' keyword.client.id %}" class="btn bg-gradient-primary btn-sm mb-0">
                Import Rankings
              </a>
            </div>
          </div>
        </div>
        
        <div class="card-body pt-4">
          <!-- Performance Metrics -->
          <div class="row">
            <div class="col-xl-3 col-sm-6 mb-4">
              <div class="card">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">Current Position</p>
                        <h5 class="font-weight-bolder mb-0">
                          {{ latest_ranking.average_position|floatformat:1|default:"-" }}
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                        <i class="ni ni-chart-bar-32 text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-xl-3 col-sm-6 mb-4">
              <div class="card">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">30d Change</p>
                        <h5 class="font-weight-bolder mb-0">
                          <span class="text-{% if thirty_day_change < 0 %}success{% elif thirty_day_change > 0 %}danger{% else %}secondary{% endif %}">
                            {{ thirty_day_change|floatformat:1|default:"-" }}
                          </span>
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                        <i class="ni ni-chart-line text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-xl-3 col-sm-6 mb-4">
              <div class="card">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">Impressions</p>
                        <h5 class="font-weight-bolder mb-0">
                          {{ latest_ranking.impressions|default:"-" }}
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                        <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-xl-3 col-sm-6 mb-4">
              <div class="card">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">CTR</p>
                        <h5 class="font-weight-bolder mb-0">
                          {{ latest_ranking.ctr|floatformat:2|default:"-" }}%
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                        <i class="ni ni-curved-next text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Ranking History Chart -->
          <div class="row mt-4">
            <div class="col-12">
              <div class="card z-index-2">
                <div class="card-header pb-0">
                  <h6>Position History</h6>
                </div>
                <div class="card-body p-3">
                  <div class="chart">
                    <canvas id="ranking-history-chart" class="chart-canvas" height="300"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Historical Data Table -->
          <div class="row mt-4">
            <div class="col-12">
              <div class="card">
                <div class="table-responsive">
                  <table class="table table-flush" id="ranking-history-table">
                    <thead class="thead-light">
                      <tr>
                        <th>Date</th>
                        <th>Position</th>
                        <th>Impressions</th>
                        <th>Clicks</th>
                        <th>CTR</th>
                      </tr>
                    </thead>
                    <tbody>
                      {% for ranking in ranking_history %}
                      <tr>
                        <td>{{ ranking.date }}</td>
                        <td>{{ ranking.average_position|floatformat:1 }}</td>
                        <td>{{ ranking.impressions }}</td>
                        <td>{{ ranking.clicks }}</td>
                        <td>{{ ranking.ctr|floatformat:2 }}%</td>
                      </tr>
                      {% endfor %}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize DataTable
    $('#ranking-history-table').DataTable({
      order: [[0, 'desc']],
      dom: 'Bfrtip',
      buttons: ['copy', 'csv', 'excel', 'pdf']
    });

    // Initialize Chart
    const ctx = document.getElementById("ranking-history-chart").getContext("2d");
    const chartData = JSON.parse('{{ chart_data|escapejs }}');
    
    new Chart(ctx, {
      type: "line",
      data: {
        labels: chartData.labels,
        datasets: [{
          label: "Position",
          tension: 0.4,
          borderWidth: 0,
          pointRadius: 2,
          pointBackgroundColor: "#cb0c9f",
          borderColor: "#cb0c9f",
          borderWidth: 3,
          data: chartData.positions,
          maxBarThickness: 6,
          fill: false
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          }
        },
        interaction: {
          intersect: false,
          mode: 'index',
        },
        scales: {
          y: {
            grid: {
              drawBorder: false,
              display: true,
              drawOnChartArea: true,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              padding: 10,
              color: '#b2b9bf',
              font: {
                size: 11,
                family: "Open Sans",
                style: 'normal',
                lineHeight: 2
              },
            },
            reverse: true
          },
          x: {
            grid: {
              drawBorder: false,
              display: true,
              drawOnChartArea: true,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              color: '#b2b9bf',
              padding: 10,
              font: {
                size: 11,
                family: "Open Sans",
                style: 'normal',
                lineHeight: 2
              },
            }
          },
        },
      },
    });
  });
</script>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/keywords/search_console_keywords.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Import Search Console Keywords - {{ client.name }} {% endblock %}

{% block content %}
{% csrf_token %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h5 class="mb-0">Import Keywords from Search Console</h5>
              <p class="text-sm mb-0 text-muted">
                <i class="fab fa-google me-1"></i> Import keywords from Google Search Console
              </p>
            </div>
            <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-sm bg-gradient-secondary">
              <i class="fas fa-arrow-left me-2"></i>Back to Client
            </a>
          </div>
        </div>
        
        <div class="card-body">
          {% if not client.sc_credentials %}
            <div class="text-center py-4">
              <div class="icon icon-shape icon-sm bg-gradient-warning shadow text-center mb-3">
                <i class="fas fa-exclamation-triangle opacity-10"></i>
              </div>
              <h6 class="text-dark">Search Console Not Connected</h6>
              <p class="text-secondary text-sm">Please connect Search Console first to import keywords.</p>
              <a href="{% url 'seo_manager:add_sc_credentials' client.id %}" class="btn btn-sm bg-gradient-info mt-3">
                <i class="fab fa-google me-2"></i>Connect Search Console
              </a>
            </div>
          {% elif not search_console_data %}
            <div class="text-center py-4">
              <div class="icon icon-shape icon-sm bg-gradient-info shadow text-center mb-3">
                <i class="fas fa-search opacity-10"></i>
              </div>
              <h6 class="text-dark">No Search Console Data</h6>
              <p class="text-secondary text-sm">No keyword data found in Search Console for the last 90 days.</p>
            </div>
          {% else %}
            <div class="table-responsive">
              <table class="table table-flush" id="search-console-keywords-table">
                <thead class="thead-light">
                  <tr>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                      <div class="form-check">
                        <input class="form-check-input" type="checkbox" id="select-all-keywords">
                      </div>
                    </th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Position</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Clicks</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Impressions</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">CTR</th>
                  </tr>
                </thead>
                <tbody>
                  {% for keyword in search_console_data %}
                    <tr>
                      <td>
                        <div class="form-check">
                          <input class="form-check-input keyword-checkbox" type="checkbox" 
                                 value="{{ keyword.query }}" 
                                 data-position="{{ keyword.position }}"
                                 data-clicks="{{ keyword.clicks }}"
                                 data-impressions="{{ keyword.impressions }}"
                                 data-ctr="{{ keyword.ctr }}">
                        </div>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ keyword.query }}</p>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ keyword.position|floatformat:1 }}</p>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ keyword.clicks }}</p>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ keyword.impressions }}</p>
                      </td>
                      <td>
                        <p class="text-xs font-weight-bold mb-0">{{ keyword.ctr|floatformat:2 }}%</p>
                      </td>
                    </tr>
                  {% endfor %}
                </tbody>
              </table>
            </div>
            
            <div class="text-end mt-4">
              <button type="button" class="btn bg-gradient-primary" id="import-selected-keywords">
                <i class="fas fa-file-import me-2"></i>Import Selected Keywords
              </button>
            </div>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize DataTable
    if (document.getElementById('search-console-keywords-table')) {
      new simpleDatatables.DataTable("#search-console-keywords-table", {
        searchable: true,
        fixedHeight: true,
        perPage: 25
      });
    }

    // Handle "Select All" checkbox
    const selectAllCheckbox = document.getElementById('select-all-keywords');
    if (selectAllCheckbox) {
      selectAllCheckbox.addEventListener('change', function() {
        const checkboxes = document.querySelectorAll('.keyword-checkbox');
        checkboxes.forEach(checkbox => {
          checkbox.checked = this.checked;
        });
      });
    }

    // Handle Import button
    const importButton = document.getElementById('import-selected-keywords');
    if (importButton) {
      importButton.addEventListener('click', handleImport);
    }
  });

  function handleImport() {
    const selectedKeywords = [];
    const checkboxes = document.querySelectorAll('.keyword-checkbox:checked');
    
    checkboxes.forEach(checkbox => {
      selectedKeywords.push({
        keyword: checkbox.value,
        position: parseFloat(checkbox.dataset.position),
        clicks: parseInt(checkbox.dataset.clicks),
        impressions: parseInt(checkbox.dataset.impressions),
        ctr: parseFloat(checkbox.dataset.ctr)
      });
    });

    if (selectedKeywords.length === 0) {
      Swal.fire({
        icon: 'warning',
        title: 'No Keywords Selected',
        text: 'Please select at least one keyword to import.'
      });
      return;
    }

    Swal.fire({
      title: 'Importing Keywords',
      text: 'Please wait...',
      allowOutsideClick: false,
      didOpen: () => {
        Swal.showLoading();
      }
    });

    fetch("{% url 'seo_manager:import_from_search_console' client.id %}", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
      },
      body: JSON.stringify(selectedKeywords)
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        Swal.fire({
          icon: 'success',
          title: 'Success!',
          text: data.message
        }).then(() => {
          window.location.href = "{% url 'seo_manager:client_detail' client.id %}";
        });
      } else {
        Swal.fire({
          icon: 'error',
          title: 'Error',
          text: data.error || 'Failed to import keywords'
        });
      }
    })
    .catch(error => {
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: 'An error occurred while importing keywords'
      });
    });
  }
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/meta_tags/partials/meta_tags_comparison.html
================
<div class="comparison-report">
  <h5>Comparing: {{ current_file }} with {{ previous_file }}</h5>
  
  {% if changes %}
    <div class="table-responsive">
      <table class="table">
        <thead>
          <tr>
            <th>Page</th>
            <th>Change Type</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody>
          {% for change in changes %}
            <tr>
              <td>
                <a href="{{ change.page }}" target="_blank">{{ change.page }}</a>
              </td>
              <td>
                <span class="badge bg-{% if change.type == 'added' %}success{% elif change.type == 'removed' %}danger{% else %}warning{% endif %}">
                  {{ change.type|title }}
                </span>
              </td>
              <td>{{ change.details }}</td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
  {% else %}
    <div class="alert alert-info">
      <i class="fas fa-info-circle me-2"></i>
      No changes detected between these two snapshots.
    </div>
  {% endif %}
  
  <div class="mt-3 text-end">
    <a href="{% url 'serve_protected_file' path=current_path %}" class="btn btn-sm btn-outline-primary" target="_blank">
      <i class="fas fa-download me-1"></i> Current Snapshot
    </a>
    <a href="{% url 'serve_protected_file' path=previous_path %}" class="btn btn-sm btn-outline-secondary" target="_blank">
      <i class="fas fa-download me-1"></i> Previous Snapshot
    </a>
  </div>
</div>

================
File: apps/seo_manager/templates/seo_manager/meta_tags/partials/meta_tags_csv.html
================
{% load seo_manager_filters %}

{% if rows %}
<div class="table-responsive">
  <table class="table table-hover text-sm">
    <thead>
      <tr>
        {% for header in headers %}
        <th>{{ header }}</th>
        {% endfor %}
      </tr>
    </thead>
    <tbody>
      {% for row in rows %}
      <tr>
        {% for header in headers %}
        <td>
          {% if header == 'url' and row.url %}
          <a href="{{ row.url }}" target="_blank">{{ row.url }}</a>
          {% else %}
          {{ row|get_item:header }}
          {% endif %}
        </td>
        {% endfor %}
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
{% else %}
<div class="alert alert-warning text-sm">
  <i class="fas fa-exclamation-triangle me-2"></i>
  No data found in the CSV file.
</div>
{% endif %}

================
File: apps/seo_manager/templates/seo_manager/meta_tags/partials/meta_tags_report.html
================
{% if report_data and report_data.pages %}
<div class="table-responsive">
  <table class="table table-hover">
    <thead>
      <tr>
        <th>Page URL</th>
        <th>Meta Tags</th>
        <th>Issues</th>
      </tr>
    </thead>
    <tbody>
      {% for page in report_data.pages %}
      <tr>
        <td>
          <a href="{{ page.url }}" target="_blank">{{ page.url }}</a>
        </td>
        <td>
          <ul class="list-unstyled mb-0">
            {% for tag in page.meta_tags %}
            <li class="mb-1">
              <code>{{ tag.name|default:tag.property }}: {{ tag.content }}</code>
            </li>
            {% endfor %}
          </ul>
        </td>
        <td>
          {% if page.meta_tags|dictsortby:"issues"|length > 0 %}
          <span class="badge bg-warning">Issues Found</span>
          {% else %}
          <span class="badge bg-success">OK</span>
          {% endif %}
        </td>
      </tr>
      {% endfor %}
    </tbody>
  </table>
</div>
{% else %}
<div class="alert alert-warning">
  <i class="fas fa-exclamation-triangle me-2"></i>
  No data found in the report.
</div>
{% endif %}

================
File: apps/seo_manager/templates/seo_manager/meta_tags/meta_tags_dashboard.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load seo_manager_filters %}

{% block title %} Meta Tags Monitor - {{ client.name }} {% endblock %}

{% block extrastyle %}
{{ block.super }}
<!-- SweetAlert2 CSS -->
<link href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-default@4/default.css" rel="stylesheet">
<style>
  .progress-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 9999;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
  }
  .progress-content {
    background-color: #1f283e;
    padding: 30px;
    border-radius: 10px;
    width: 80%;
    max-width: 500px;
    text-align: center;
  }
  .progress-bar {
    height: 10px;
    border-radius: 5px;
    margin: 20px 0;
  }
  .progress-stats {
    display: flex;
    justify-content: space-around;
    margin-top: 20px;
  }
  .progress-stat {
    text-align: center;
  }
  .progress-stat .label {
    font-size: 12px;
    opacity: 0.8;
  }
  .progress-stat .value {
    font-size: 18px;
    font-weight: bold;
  }
</style>
{% endblock extrastyle %}

{% block content %}
{% csrf_token %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h5 class="mb-0">Meta Tags Monitor</h5>
              <p class="text-sm mb-0 text-muted">
                <i class="fas fa-code me-1"></i> Track and analyze website meta tags
              </p>
            </div>
            <button type="button" class="btn bg-gradient-dark btn-sm" id="createSnapshotBtn" data-client-id="{{ client.id }}">
              <i class="fas fa-camera me-2"></i>Create Snapshot
            </button>
          </div>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-4">
              <div class="card card-body border-0 shadow-sm">
                <div class="d-flex">
                  <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                    <i class="fas fa-history text-lg opacity-10" aria-hidden="true"></i>
                  </div>
                  <div class="ms-3">
                    <h6 class="mb-0">Latest Snapshot</h6>
                    <span class="text-sm text-muted">
                      {% if meta_tags_files_info %}
                        {{ meta_tags_files_info.0.name|basename }}
                        <br>
                        <small class="text-xs">{{ latest_stats.total_pages|default:"N/A" }} pages scanned</small>
                      {% else %}
                        No snapshots yet
                      {% endif %}
                    </span>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card card-body border-0 shadow-sm">
                <div class="d-flex">
                  <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md">
                    <i class="fas fa-tag text-lg opacity-10" aria-hidden="true"></i>
                  </div>
                  <div class="ms-3">
                    <h6 class="mb-0">Total Tags Tracked</h6>
                    <span class="text-sm text-muted">
                      {% if latest_stats %}
                        {{ latest_stats.total_tags }}
                      {% else %}
                        No data available
                      {% endif %}
                    </span>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card card-body border-0 shadow-sm">
                <div class="d-flex">
                  <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md">
                    <i class="fas fa-exclamation-triangle text-lg opacity-10" aria-hidden="true"></i>
                  </div>
                  <div class="ms-3">
                    <h6 class="mb-0">Issues Found</h6>
                    <span class="text-sm text-muted">
                      {% if latest_stats %}
                        {{ latest_stats.issues }}
                      {% else %}
                        No data available
                      {% endif %}
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {% if meta_tags_files_info %}
            <div class="table-responsive mt-4">
              <table class="table table-flush" id="snapshots-table">
                <thead class="thead-light">
                  <tr>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Date</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Pages Scanned</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {% for file_info in meta_tags_files_info %}
                    <tr>
                      <td>
                        <div class="d-flex px-2 py-1">
                          <div class="d-flex flex-column justify-content-center">
                            <h6 class="mb-0 text-sm">{{ file_info.name|basename }}</h6>
                          </div>
                        </div>
                      </td>
                      <td>
                        <span class="text-xs font-weight-bold">{{ file_info.stats.total_pages|default:"N/A" }}</span>
                      </td>
                      <td>
                        <span class="badge badge-sm bg-gradient-success">Completed</span>
                      </td>
                      <td>
                        <div class="dropdown">
                          <button class="btn btn-link text-secondary mb-0" data-bs-toggle="dropdown">
                            <i class="fa fa-ellipsis-v text-xs"></i>
                          </button>
                          <ul class="dropdown-menu">
                            <li>
                              <a class="dropdown-item" href="#" 
                                 data-bs-toggle="modal" 
                                 data-bs-target="#viewMetaTagsModal"
                                 data-file-path="{{ file_info.path }}"
                                 data-file-name="{{ file_info.name|basename }}">
                                <i class="fas fa-eye me-2"></i>View Report
                              </a>
                            </li>
                            <li>
                              <a class="dropdown-item" href="{% url 'serve_protected_file' path=file_info.path %}">
                                <i class="fas fa-download me-2"></i>Download CSV
                              </a>
                            </li>
                            <li>
                              <a class="dropdown-item" href="#"
                                 data-bs-toggle="modal" 
                                 data-bs-target="#viewMetaTagsModal"
                                 data-file-path="{{ file_info.path }}"
                                 data-compare="true"
                                 data-file-name="{{ file_info.name|basename }}">
                                <i class="fas fa-code-branch me-2"></i>Compare Changes
                              </a>
                            </li>
                            <li><hr class="dropdown-divider"></li>
                            <li>
                              <a class="dropdown-item text-danger" href="#" data-bs-toggle="modal" data-bs-target="#delete-{{ forloop.counter }}">
                                <i class="fas fa-trash me-2"></i>Delete
                              </a>
                            </li>
                          </ul>
                        </div>
                      </td>
                    </tr>
                  {% endfor %}
                </tbody>
              </table>
            </div>
          {% else %}
            <div class="text-center py-4">
              <div class="icon icon-shape icon-sm bg-gradient-secondary shadow text-center mb-3 mx-auto">
                <i class="fas fa-code text-white opacity-10"></i>
              </div>
              <h6 class="text-dark">No Snapshots Available</h6>
              <p class="text-secondary text-sm">Create your first snapshot to start tracking meta tags.</p>
            </div>
          {% endif %}
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Meta Tags View Modal -->
<div class="modal fade" id="viewMetaTagsModal" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-xl" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Meta Tags Report <span id="reportFileName" class="text-muted"></span></h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div id="metaTagsReport" class="position-relative">
          <!-- Content will be loaded here via HTMX -->
          <div class="text-center py-4">
            <div class="spinner-border text-primary" role="status"></div>
            <p class="mt-2">Loading report data...</p>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
        <a id="downloadReportLink" href="" class="btn bg-gradient-primary">
          <i class="fas fa-download me-2"></i>Download Report
        </a>
      </div>
    </div>
  </div>
</div>

<!-- Progress Overlay for WebSocket -->
<div id="progressOverlay" class="progress-overlay d-none" hx-ext="ws">
  <div class="progress-content">
    <h5 id="progressAction">Initializing extraction...</h5>
    <div class="progress">
      <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated bg-gradient-primary" role="progressbar" style="width: 0%"></div>
    </div>
    <p id="progressMessage" class="text-sm mt-2">Starting meta tags extraction</p>
    
    <div class="progress-stats">
      <div class="progress-stat">
        <div class="label">URLs Found</div>
        <div id="urlsFound" class="value">0</div>
      </div>
      <div class="progress-stat">
        <div class="label">Processed</div>
        <div id="urlsProcessed" class="value">0</div>
      </div>
      <div class="progress-stat">
        <div class="label">Remaining</div>
        <div id="urlsRemaining" class="value">0</div>
      </div>
    </div>
  </div>
</div>

<!-- Delete Modals -->
{% for file_info in meta_tags_files_info %}
  <div class="modal fade" id="delete-{{ forloop.counter }}" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="exampleModalLabel">Delete File</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          Are you sure you want to delete {{ file_info.name|urlencode }}?
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
          <a class="btn btn-danger" href="/delete-file/{{ file_info.path|urlencode }}/">Delete</a>
        </div>
      </div>
    </div>
  </div>
{% endfor %}

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- SweetAlert2 -->
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<!-- DataTables -->
<script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
<!-- HTMX WebSocket Extension (loaded locally) -->
<script src="{% static 'assets/js/plugins/ws.js' %}"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    
    // --- WebSocket Progress Handling --- 
    const urlParams = new URLSearchParams(window.location.search);
    const taskId = urlParams.get('task_id');
    if (taskId) {
      console.log("Found task_id, connecting WebSocket:", taskId);
      const progressOverlay = document.getElementById('progressOverlay');
      if (progressOverlay) { // Ensure overlay exists
          progressOverlay.classList.remove('d-none');
          progressOverlay.setAttribute('ws-connect', `/ws/meta-tags/task/${taskId}/`);
          htmx.process(progressOverlay);
          setupProgressOverlayListeners();
      } else {
          console.warn("Progress overlay element not found.")
      }
    }
    
    // --- Initialize DataTable --- 
    const snapshotsTable = document.getElementById('snapshots-table');
    if (snapshotsTable) {
      try {
        const dataTableSearch = new simpleDatatables.DataTable("#snapshots-table", {
          searchable: true,
          fixedHeight: true,
          perPage: 25
        });
      } catch (e) {
        console.error("Failed to initialize DataTable:", e);
      }
    } else {
        console.warn("Snapshots table element not found.");
    }
    
    // --- Create Snapshot Button --- 
    const createSnapshotBtn = document.getElementById('createSnapshotBtn');
    if (createSnapshotBtn) {
      createSnapshotBtn.addEventListener('click', function() {
        const clientId = this.getAttribute('data-client-id');
        createSnapshot(clientId);
      });
    } else {
        console.warn("Create snapshot button not found.");
    }

    // --- WebSocket Debug Listeners --- 
    document.body.addEventListener('htmx:wsOpen', function(evt) { console.log('WebSocket opened'); });
    document.body.addEventListener('htmx:wsClose', function(evt) { console.log('WebSocket closed'); });
    document.body.addEventListener('htmx:wsError', function(evt) { console.error('WebSocket error:', evt.detail); });

    // --- HTMX Report Loading via Modal Event --- 
    const viewReportModalElement = document.getElementById('viewMetaTagsModal');
    if (viewReportModalElement) {
      console.log("Adding event listener for viewMetaTagsModal");
      viewReportModalElement.addEventListener('show.bs.modal', function (event) {
        console.log("'show.bs.modal' event fired");
        // Button that triggered the modal
        const button = event.relatedTarget;
        if (!button) {
            console.error("Could not find button that triggered the modal.");
            return; 
        }
        
        // Extract data from the button
        const filePath = button.getAttribute('data-file-path');
        const fileName = button.getAttribute('data-file-name') || (filePath ? filePath.split('/').pop() : 'Report');
        const isCompare = button.getAttribute('data-compare') === 'true';
        const clientId = "{{ client.id }}"; // Get client ID from Django context
        
        console.log(`Modal opening for file: ${filePath}, Compare: ${isCompare}, Client: ${clientId}`);

        // Update modal title
        const modalTitle = viewReportModalElement.querySelector('#reportFileName');
        if (modalTitle) {
          modalTitle.textContent = `- ${fileName}`;
          if (isCompare) {
            modalTitle.textContent += ' (Comparison)';
          }
        } else {
            console.warn("Report file name element not found in modal.");
        }

        // Update download link 
        const downloadLink = document.getElementById('downloadReportLink');
        if (downloadLink) {
          if (filePath) {
            downloadLink.href = `/media/secure/${encodeURIComponent(filePath)}`;
            downloadLink.style.display = ''; // Ensure it's visible
          } else {
            downloadLink.href = '#'; // No path, disable link
            downloadLink.style.display = 'none'; // Hide if no path
          }
        } else {
            console.warn("Download report link element not found.");
        }

        // Target div for HTMX content
        const reportTarget = document.getElementById('metaTagsReport');
        if (reportTarget && filePath && clientId) {
          // Clear previous content and show loading indicator
          reportTarget.innerHTML = '<div class="text-center py-4"><div class="spinner-border text-primary" role="status"></div><p class="mt-2">Loading report data...</p></div>';
          
          // Construct the URL for the view
          let url = `/seo/clients/${clientId}/meta-tags/report/${encodeURIComponent(filePath)}/`;
          if (isCompare) {
            url += '?compare=true';
          }
          
          console.log("Triggering HTMX GET request to:", url);
          
          // Manually trigger HTMX GET request
          htmx.ajax('GET', url, {
              target: reportTarget, // Target the div inside the modal
              swap: 'innerHTML' // Replace the content of the target
          }).then(function() {
             console.log("HTMX request completed successfully for URL:", url); 
          }).catch(function(error) {
              // Handle potential AJAX errors (e.g., network issues, server errors)
              console.error("HTMX request failed:", error);
              if (reportTarget) {
                  // Attempt to show error details from the response if possible
                  let errorMsg = 'Failed to load report data. Check network connection or server logs.';
                  if (error.xhr && error.xhr.responseText) {
                      // Basic attempt to extract error from response, might need refinement
                      // Avoid showing full HTML tracebacks directly to user in production
                      const tempDiv = document.createElement('div');
                      tempDiv.innerHTML = error.xhr.responseText;
                      const alertContent = tempDiv.querySelector('.alert');
                      if (alertContent) {
                          errorMsg = alertContent.textContent || alertContent.innerText;
                      }
                  }
                  reportTarget.innerHTML = `<div class="alert alert-danger">${errorMsg}</div>`;
              }
          });
        } else if (reportTarget) {
             // Handle cases where data is missing
             let errorReason = "Unknown error."
             if (!filePath) errorReason = "File path not found on triggering button.";
             else if (!clientId) errorReason = "Client ID is missing.";
             console.error("Cannot load report:", errorReason);
             reportTarget.innerHTML = `<div class="alert alert-danger">Could not load report: ${errorReason}</div>`;
        }
      });
    } else {
        console.warn("View report modal element (#viewMetaTagsModal) not found.");
    }
    
    // --- WebSocket Progress Update Logic (Functions remain the same) ---
    function setupProgressOverlayListeners() {
        console.log("Setting up WebSocket message listeners for progress");
        const progressOverlay = document.getElementById('progressOverlay');
        if (!progressOverlay) return;
        // Use a flag to prevent adding multiple listeners if modal opens multiple times
        if (progressOverlay.dataset.listenerAttached) return;
        progressOverlay.dataset.listenerAttached = 'true';
        
        document.body.addEventListener('htmx:wsAfterMessage', function(event) {
            // Ensure the event source is the progress overlay if needed
            // Or handle globally if only one WS connection is expected
            try {
                const data = JSON.parse(event.detail.message);
                console.log("WS Message Received:", data);
                if (data.progress) { updateProgressUI(data.progress); }
                else if (data.status === 'complete') { handleTaskCompletion(true); }
                else if (data.status === 'failed') { handleTaskCompletion(false, data.message); }
            } catch (e) { console.error("Error processing WS message:", e, "Raw:", event.detail.message); }
        });
    }

    function updateProgressUI(progress) {
        const progressBar = document.getElementById('progressBar');
        const progressAction = document.getElementById('progressAction');
        const urlsFound = document.getElementById('urlsFound');
        const urlsProcessed = document.getElementById('urlsProcessed');
        const urlsRemaining = document.getElementById('urlsRemaining');
        
        if (progressBar) progressBar.style.width = `${progress.percent || 0}%`;
        if (progressAction && progress.action) progressAction.textContent = progress.action;
        if (urlsFound && progress.urls_found !== undefined) urlsFound.textContent = progress.urls_found;
        if (urlsProcessed && progress.urls_processed !== undefined) urlsProcessed.textContent = progress.urls_processed;
        if (urlsRemaining && progress.urls_processed !== undefined && progress.total_urls !== undefined) {
            const remaining = progress.total_urls - progress.urls_processed;
            urlsRemaining.textContent = remaining > 0 ? remaining : 0;
        }
    }
    
    function handleTaskCompletion(success, message = 'Extraction completed successfully!') {
        const progressOverlay = document.getElementById('progressOverlay');
        const progressMessage = document.getElementById('progressMessage');
        const progressBar = document.getElementById('progressBar');
        const progressAction = document.getElementById('progressAction');
        
        if (!progressOverlay || !progressMessage || !progressBar || !progressAction) {
            console.error("Progress UI elements missing during task completion.");
            return;
        }

        progressMessage.textContent = message;
        if (success) {
            progressBar.style.width = '100%';
            // Reload without task_id query parameter
            setTimeout(() => { window.location.href = window.location.pathname; }, 2000);
        } else {
            progressAction.textContent = 'Extraction Failed';
            progressBar.classList.remove('bg-gradient-primary');
            progressBar.classList.add('bg-gradient-danger');
            
            // Remove existing close button if present
            const existingBtn = progressOverlay.querySelector('.close-progress-btn');
            if (existingBtn) existingBtn.remove();
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.className = 'btn btn-secondary mt-3 close-progress-btn';
            closeBtn.onclick = () => progressOverlay.classList.add('d-none');
            progressOverlay.querySelector('.progress-content')?.appendChild(closeBtn);
        }
    }

    function createSnapshot(clientId) {
        if (!clientId) {
             Swal.fire({ title: 'Error', text: 'Client ID is missing.', icon: 'error' });
             return;
        }
        console.log("Creating snapshot for client:", clientId);
        Swal.fire({ title: 'Starting extraction...', allowOutsideClick: false, didOpen: () => Swal.showLoading() });
        fetch(`/seo/clients/${clientId}/meta-tags/snapshot/`, { 
            method: 'POST', 
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]')?.value || '', 
                'Content-Type': 'application/json'
            } 
        })
        .then(response => {
            if (!response.ok) {
                // Try to get error message from response body
                return response.json().then(errData => {
                   throw new Error(errData.message || `Server error: ${response.status}`);
                }).catch(() => {
                    // Fallback if response is not JSON or parsing fails
                    throw new Error(`Server error: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            Swal.close();
            if (data.success && data.task_id) {
                const progressOverlay = document.getElementById('progressOverlay');
                const progressMessage = document.getElementById('progressMessage');
                const progressAction = document.getElementById('progressAction');
                const progressBar = document.getElementById('progressBar');
                
                if (!progressOverlay || !progressMessage || !progressAction || !progressBar) {
                    console.error("Progress UI elements missing for snapshot start.");
                    Swal.fire({ title: 'UI Error', text: 'Could not display progress overlay.', icon: 'warning' });
                    return;
                }
                // Reset UI
                progressMessage.textContent = 'Starting extraction';
                progressAction.textContent = 'Initializing...';
                progressBar.style.width = '0%';
                progressBar.classList.remove('bg-gradient-danger');
                progressBar.classList.add('bg-gradient-primary');
                
                // Remove existing close button if present
                const existingBtn = progressOverlay.querySelector('.close-progress-btn');
                if (existingBtn) existingBtn.remove();
                
                // Show overlay and connect WebSocket
                progressOverlay.classList.remove('d-none');
                progressOverlay.setAttribute('ws-connect', `/ws/meta-tags/task/${data.task_id}/`);
                htmx.process(progressOverlay);
                // Listener setup moved outside, ensure it's called if task_id is present
                // setupProgressOverlayListeners(); // Redundant if called earlier
            } else {
                Swal.fire({ title: 'Error', text: data.message || 'Failed to start snapshot task.', icon: 'error' });
            }
        })
        .catch(error => {
            Swal.close();
            console.error("Create snapshot fetch error:", error);
            Swal.fire({ title: 'Error', text: 'An unexpected error occurred: ' + error.message, icon: 'error' });
        });
    }

  }); // End DOMContentLoaded
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/projects/edit_project.html
================
{% extends "layouts/base.html" %}

{% block title %} Edit Project {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Edit Project</h6>
        </div>
        <div class="card-body">
          <form method="post">
            {% csrf_token %}
            
            {% for field in form %}
            <div class="form-group">
              <label for="{{ field.id_for_label }}" class="form-control-label">{{ field.label }}</label>
              {{ field }}
              {% if field.help_text %}
                <small class="form-text text-muted">{{ field.help_text }}</small>
              {% endif %}
              {% if field.errors %}
                {% for error in field.errors %}
                  <div class="text-danger">{{ error }}</div>
                {% endfor %}
              {% endif %}
            </div>
            {% endfor %}
            
            <div class="d-flex justify-content-end mt-4">
              <a href="{% url 'seo_manager:client_detail' client_id %}" class="btn btn-light m-0">Cancel</a>
              <button type="submit" class="btn bg-gradient-primary m-0 ms-2">Save Changes</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
  // Initialize any special form widgets here if needed
  document.addEventListener('DOMContentLoaded', function() {
    // Example: Initialize date pickers
    flatpickr('.datepicker', {
      dateFormat: 'Y-m-d'
    });
  });
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/projects/project_detail.html
================
{% extends 'layouts/base.html' %}
{% load static %}
{% load seo_tags %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12 col-xl-8">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex align-items-center">
            <h5 class="mb-0">{{ project.title }}</h5>
            <a href="{% url 'seo_manager:edit_project' project.client.id project.id %}" class="btn bg-gradient-primary btn-sm ms-auto">
              Edit Project
          </a>
          </div>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <div class="form-group">
                <label class="form-control-label">Status</label>
                <div>
                  <span class="badge bg-gradient-{% if project.status == 'completed' %}success{% elif project.status == 'in_progress' %}info{% elif project.status == 'planned' %}secondary{% else %}warning{% endif %}">
                    {{ project.get_status_display }}
                  </span>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="form-group">
                <label class="form-control-label">Implementation Date</label>
                <p>{{ project.implementation_date }}</p>
              </div>
            </div>
            <div class="col-md-12">
              <div class="form-group">
                <label class="form-control-label">Description</label>
                <p>{{ project.description }}</p>
              </div>
            </div>
          </div>

          {% if project.documentation_file %}
          <div class="row mt-4">
            <div class="col-12">
              <div class="card card-body border card-plain border-radius-lg">
                <h6 class="mb-0">Documentation</h6>
                <a href="{{ project.documentation_file.url }}" class="text-sm" target="_blank">
                  <i class="fas fa-file-pdf me-2"></i>
                  View Documentation
                </a>
              </div>
            </div>
          </div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-xl-4">
      <!-- Targeted Keywords Card -->
      <div class="card">
        <div class="card-header pb-0">
          <h6>Targeted Keywords</h6>
        </div>
        <div class="card-body p-3">
          <div class="table-responsive">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th>Keyword</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="The keyword's ranking position when the project started, or average position from 3 months before implementation">Initial Rank</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="The keyword's most recent ranking position">Current Rank</th>
                </tr>
              </thead>
              <tbody>
                {% for keyword in project.targeted_keywords.all %}
                <tr>
                  <td>{{ keyword.keyword }}</td>
                  <td class="text-center">
                    {{ project|get_initial_rank:keyword.keyword|default:"-" }}
                  </td>
                  <td class="text-center">
                    {% with latest_ranking=keyword.ranking_history.first %}
                      {% if latest_ranking %}
                        {{ latest_ranking.average_position|floatformat:1 }}
                      {% else %}
                        -
                      {% endif %}
                    {% endwith %}
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Ranking History Chart -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card z-index-2">
        <div class="card-header pb-0">
          <h6>Keyword Rankings Over Time</h6>
        </div>
        <div class="card-body p-3">
          <div class="chart">
            <canvas id="ranking-history-chart" class="chart-canvas" height="300"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add this section after the project details -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Project Impact Analysis</h6>
          <p class="text-sm mb-0">
            Comparing keyword performance 30 days before and after implementation
          </p>
        </div>
        <div class="card-body p-3">
          <div class="table-responsive">
            <table class="table align-items-center mb-0">
              <thead>
                <tr>
                  <th>Keyword</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="Average ranking position in the 3 months before implementation">Pre-Impl Avg</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="Average ranking position after implementation">Post-Impl Avg</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="How many positions the keyword moved up or down (positive numbers mean improvement)">Position Change</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="Percentage change in how often the keyword appeared in search results">Impressions Change</th>
                  <th class="text-center" data-bs-toggle="tooltip" title="Percentage change in how often users clicked on the keyword in search results">Clicks Change</th>
                </tr>
              </thead>
              <tbody>
                {% for metric in performance_metrics %}
                <tr>
                  <td>{{ metric.keyword }}</td>
                  <td class="text-center">{{ metric.pre_avg|default:"-" }}</td>
                  <td class="text-center">{{ metric.post_avg|default:"-" }}</td>
                  <td class="text-center">
                    {% if metric.improvement %}
                      <span class="text-{% if metric.improvement > 0 %}success{% elif metric.improvement < 0 %}danger{% else %}secondary{% endif %}">
                        {{ metric.improvement|floatformat:1 }}
                      </span>
                    {% else %}
                      -
                    {% endif %}
                  </td>
                  <td class="text-center">
                    {% if metric.impressions_change %}
                      <span class="text-{% if metric.impressions_change > 0 %}success{% elif metric.impressions_change < 0 %}danger{% else %}secondary{% endif %}">
                        {{ metric.impressions_change|floatformat:1 }}%
                      </span>
                    {% else %}
                      -
                    {% endif %}
                  </td>
                  <td class="text-center">
                    {% if metric.clicks_change %}
                      <span class="text-{% if metric.clicks_change > 0 %}success{% elif metric.clicks_change < 0 %}danger{% else %}secondary{% endif %}">
                        {{ metric.clicks_change|floatformat:1 }}%
                      </span>
                    {% else %}
                      -
                    {% endif %}
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    const ctx = document.getElementById("ranking-history-chart").getContext("2d");
    
    const datasets = [
        {% for keyword in project.targeted_keywords.all %}
            {
                label: '{{ keyword.keyword }}',
                data: [
                    {% for entry in keyword.get_ranking_history %}
                        {
                            x: '{{ entry.date|date:"Y-m-d" }}',
                            y: {{ entry.average_position }}
                        }{% if not forloop.last %},{% endif %}
                    {% endfor %}
                ],
                borderColor: ['#5e72e4', '#2dce89', '#fb6340', '#11cdef', '#f5365c', '#ffd600', '#8965e0', '#f3a4b5'][{{ forloop.counter0 }} % 8],
                tension: 0.4
            }{% if not forloop.last %},{% endif %}
        {% endfor %}
    ];

    new Chart(ctx, {
        type: 'line',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                }
            },
            interaction: {
                intersect: false,
                mode: 'index',
            },
            scales: {
                y: {
                    reverse: true,
                    grid: {
                        drawBorder: false,
                        display: true,
                        drawOnChartArea: true,
                        drawTicks: false,
                        borderDash: [5, 5]
                    },
                    ticks: {
                        display: true,
                        padding: 10,
                        color: '#b2b9bf',
                        font: {
                            size: 11,
                            family: "Open Sans",
                            style: 'normal',
                            lineHeight: 2
                        }
                    }
                },
                x: {
                    type: 'time',
                    time: {
                        unit: 'day'
                    },
                    grid: {
                        drawBorder: false,
                        display: true,
                        drawOnChartArea: true,
                        drawTicks: false,
                        borderDash: [5, 5]
                    },
                    ticks: {
                        display: true,
                        color: '#b2b9bf',
                        padding: 10,
                        font: {
                            size: 11,
                            family: "Open Sans",
                            style: 'normal',
                            lineHeight: 2
                        }
                    }
                }
            }
        }
    });
});
</script>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/projects/project_list_table.html
================
<table class="table table-flush" id="projects-table">
  <thead class="thead-light">
    <tr>
      <th>Project</th>
      <th>Status</th>
      <th>Implementation Date</th>
      <th>Completion Date</th>
      <th>Keywords</th>
      <th>Actions</th>
    </tr>
  </thead>
  <tbody>
    {% for project in projects %}
    <tr>
      <td>
        <div class="d-flex flex-column">
          <h6 class="mb-0 text-sm">{{ project.title }}</h6>
          <p class="text-xs text-secondary mb-0">{{ project.description|truncatechars:50 }}</p>
        </div>
      </td>
      <td>
        <span class="badge bg-gradient-{% if project.status == 'completed' %}success{% elif project.status == 'in_progress' %}info{% elif project.status == 'planned' %}secondary{% else %}warning{% endif %}">
          {{ project.get_status_display }}
        </span>
      </td>
      <td>{{ project.implementation_date }}</td>
      <td>{{ project.completion_date|default:"-" }}</td>
      <td>
        <span class="text-sm">{{ project.targeted_keywords.count }} keywords</span>
      </td>
      <td>
        <a href="#" class="text-secondary font-weight-bold text-xs" data-bs-toggle="modal" data-bs-target="#view-project-{{ project.id }}">
          View Details
        </a>
      </td>
    </tr>
    {% endfor %}
  </tbody>
</table>

================
File: apps/seo_manager/templates/seo_manager/projects/project_list.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-lg-flex">
            <div>
              <h5 class="mb-0">SEO Projects - {{ client.name }}</h5>
              <p class="text-sm mb-0">
                Track and manage SEO implementation projects
              </p>
            </div>
            <div class="ms-auto my-auto mt-lg-0 mt-4">
              <div class="ms-auto my-auto">
                <a href="{% url 'seo_manager:project_create' client.id %}" class="btn bg-gradient-primary btn-sm mb-0">
                  <i class="fas fa-plus"></i>&nbsp;&nbsp;New Project
                </a>
              </div>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pb-0">
          <div class="table-responsive">
            <table class="table table-flush" id="projects-list">
              <thead class="thead-light">
                <tr>
                  <th>Project</th>
                  <th>Status</th>
                  <th>Implementation Date</th>
                  <th>Completion Date</th>
                  <th>Keywords</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for project in projects %}
                <tr>
                  <td>
                    <div class="d-flex flex-column">
                      <h6 class="mb-0 text-sm">{{ project.title }}</h6>
                      <p class="text-xs text-secondary mb-0">{{ project.description|truncatechars:50 }}</p>
                    </div>
                  </td>
                  <td>
                    <span class="badge bg-gradient-{% if project.status == 'completed' %}success{% elif project.status == 'in_progress' %}info{% elif project.status == 'planned' %}secondary{% else %}warning{% endif %}">
                      {{ project.get_status_display }}
                    </span>
                  </td>
                  <td>{{ project.implementation_date }}</td>
                  <td>{{ project.completion_date|default:"-" }}</td>
                  <td>
                    <span class="text-sm">{{ project.targeted_keywords.count }} keywords</span>
                  </td>
                  <td>
                    <a href="{% url 'seo_manager:project_detail' project.id %}" class="text-secondary font-weight-bold text-xs">
                      View Details
                    </a>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
  $(document).ready(function() {
    $('#projects-list').DataTable({
      dom: 'Bfrtip',
      buttons: [
        'copy', 'csv', 'excel', 'pdf'
      ]
    });
  });
</script>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/reports/monthly_report.html
================
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h4 class="text-dark mb-2">SEO Performance Report - {{ report.period }}</h4>
            <p class="text-secondary mb-4">Generated for {{ client.name }}</p>
        </div>
    </div>

    <!-- Stats Cards Row -->
    <div class="row g-3">
        <!-- Total Keywords Card -->
        <div class="col-md-3">
            <div class="card h-100">
                <div class="card-body p-3">
                    <div class="d-flex align-items-center">
                        <div class="flex-grow-1">
                            <h6 class="text-secondary mb-1">Total Keywords</h6>
                            <h3 class="font-weight-bold mb-0">{{ report.keywords.total }}</h3>
                        </div>
                        <div class="icon icon-shape bg-gradient-dark text-white rounded-circle shadow">
                            <i class="fas fa-key"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Improved Card -->
        <div class="col-md-3">
            <div class="card h-100">
                <div class="card-body p-3">
                    <div class="d-flex align-items-center">
                        <div class="flex-grow-1">
                            <h6 class="text-secondary mb-1">Improved</h6>
                            <h3 class="font-weight-bold mb-0">{{ report.keywords.improved }}</h3>
                        </div>
                        <div class="icon icon-shape bg-gradient-success text-white rounded-circle shadow">
                            <i class="fas fa-arrow-up"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Declined Card -->
        <div class="col-md-3">
            <div class="card h-100">
                <div class="card-body p-3">
                    <div class="d-flex align-items-center">
                        <div class="flex-grow-1">
                            <h6 class="text-secondary mb-1">Declined</h6>
                            <h3 class="font-weight-bold mb-0">{{ report.keywords.declined }}</h3>
                        </div>
                        <div class="icon icon-shape bg-gradient-danger text-white rounded-circle shadow">
                            <i class="fas fa-arrow-down"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Unchanged Card -->
        <div class="col-md-3">
            <div class="card h-100">
                <div class="card-body p-3">
                    <div class="d-flex align-items-center">
                        <div class="flex-grow-1">
                            <h6 class="text-secondary mb-1">Unchanged</h6>
                            <h3 class="font-weight-bold mb-0">{{ report.keywords.unchanged }}</h3>
                        </div>
                        <div class="icon icon-shape bg-gradient-info text-white rounded-circle shadow">
                            <i class="fas fa-equals"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tables Row -->
    <div class="row mt-4">
        <!-- Top Improvements Table -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-body p-3">
                    <h6 class="text-dark mb-3">Top Improvements</h6>
                    <div class="table-responsive">
                        <table class="table align-items-center mb-0">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Improvement</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for item in report.top_improvements %}
                                <tr>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ item.keyword }}</p>
                                    </td>
                                    <td>
                                        <span class="text-success text-sm font-weight-bold">
                                            <i class="fas fa-arrow-up me-1"></i>{{ item.improvement }}
                                        </span>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="2" class="text-center text-sm text-secondary">
                                        No improvements to report
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Needs Attention Table -->
        <div class="col-md-6">
            <div class="card">
                <div class="card-body p-3">
                    <h6 class="text-dark mb-3">Needs Attention</h6>
                    <div class="table-responsive">
                        <table class="table align-items-center mb-0">
                            <thead>
                                <tr>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
                                    <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Decline</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for item in report.needs_attention %}
                                <tr>
                                    <td>
                                        <p class="text-sm font-weight-bold mb-0">{{ item.keyword }}</p>
                                    </td>
                                    <td>
                                        <span class="text-danger text-sm font-weight-bold">
                                            <i class="fas fa-arrow-down me-1"></i>{{ item.decline }}
                                        </span>
                                    </td>
                                </tr>
                                {% empty %}
                                <tr>
                                    <td colspan="2" class="text-center text-sm text-secondary">
                                        No keywords need immediate attention
                                    </td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.icon-shape {
    width: 48px;
    height: 48px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    flex-shrink: 0;
    margin-left: 1rem;
}

.icon-shape i {
    font-size: 1.25rem;
    line-height: 1;
    position: relative;
    top: 1px;
}

.card-body {
    padding: 1rem 1.5rem !important;
}

.d-flex.align-items-center {
    min-height: 48px;
}

.card {
    box-shadow: 0 0 2rem 0 rgba(136, 152, 170, .15);
    border: 0;
}

.text-secondary {
    color: #8392ab !important;
}

.font-weight-bold {
    font-weight: 600 !important;
}

.table > :not(caption) > * > * {
    padding: 0.75rem 1.5rem;
}

.bg-gradient-dark {
    background: linear-gradient(310deg, #141727, #3A416F);
}

.bg-gradient-success {
    background: linear-gradient(310deg, #17AD37, #98EC2D);
}

.bg-gradient-danger {
    background: linear-gradient(310deg, #EA0606, #FF667C);
}

.bg-gradient-info {
    background: linear-gradient(310deg, #2152FF, #21D4FD);
}
</style>

================
File: apps/seo_manager/templates/seo_manager/activity_log.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Activity Log</h6>
                </div>
                <div class="card-body p-3">
                    <div class="timeline timeline-one-side" data-timeline-axis-style="dotted">
                        {% for activity in activities %}
                            <div class="timeline-block mb-0">
                                <span class="timeline-step">
                                    <i class="ni ni-bell-55 text-success text-gradient"></i>
                                </span>
                                <div class="timeline-content">
                                    <p class="text-sm mb-0">
                                        <span class="font-weight-bold">{{ activity.timestamp|date:"d M Y H:i" }}</span> - 
                                        <span class="text-primary">{{ activity.user.username }}</span> 
                                        {{ activity.action }} 
                                        {% if activity.client %}
                                            for client <span class="text-info">{{ activity.client.name }}</span>
                                        {% endif %}
                                        <span class="badge badge-sm bg-gradient-{{ activity.category }}">{{ activity.get_category_display }}</span>
                                    </p>
                                    {% if activity.details %}
                                        <div class="mt-0">
                                            <pre class="text-xs">{{ activity.details|pprint }}</pre>
                                        </div>
                                    {% endif %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
    // Any additional JavaScript for the activity log page can be added here
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/add_client.html
================
{% extends "layouts/base.html" %}

{% block title %} Add Client {% endblock %}

{% block content %}

<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card mb-4">
                <div class="card-header pb-0">
                    <h6>Add New Client</h6>
                </div>
                <div class="card-body px-0 pt-0 pb-2">
                    <div class="table-responsive p-0">
                        <div class="card-body">
                            <form method="post">
                                {% csrf_token %}
                                {% for field in form %}
                                    <div class="form-group">
                                        <label for="{{ field.id_for_label }}">{{ field.label }}</label><br>
                                        {{ field }}
                                        {% if field.help_text %}
                                            <small class="form-text text-muted">{{ field.help_text }}</small>
                                        {% endif %}
                                        {% for error in field.errors %}
                                            <div class="invalid-feedback d-block">
                                                {{ error }}
                                            </div>
                                        {% endfor %}
                                    </div>
                                {% endfor %}
                                <button type="submit" class="btn btn-primary">Add Client</button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
    // Any additional JavaScript can be added here
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/add_ga_credentials_service_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Add GA Credentials (Service Account) - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Add Google Analytics Credentials (Service Account) for {{ client.name }}</h6>
        </div>
        <div class="card-body">
          <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <div class="form-group">
              <label for="service_account_file">Upload Service Account JSON File</label>
              <input type="file" class="form-control-file" id="service_account_file" name="service_account_file" required>
            </div>
            <button type="submit" class="btn btn-primary">Upload and Add Credentials</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

================
File: apps/seo_manager/templates/seo_manager/add_sc_credentials_service_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Add Search Console Credentials (Service Account) - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Add Search Console Credentials (Service Account) for {{ client.name }}</h6>
        </div>
        <div class="card-body">
          <form method="post" enctype="multipart/form-data">
            {% csrf_token %}
            <div class="form-group">
              <label for="service_account_file">Upload Service Account JSON File</label>
              <input type="file" class="form-control-file" id="service_account_file" name="service_account_file" required>
            </div>
            <button type="submit" class="btn btn-primary">Upload and Add Credentials</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

================
File: apps/seo_manager/templates/seo_manager/base.html
================
{% extends "layouts/base.html" %}

{% block title %}SEO Client Manager{% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            {% block seo_content %}{% endblock %}
        </div>
    </div>
</div>
{% endblock content %}

================
File: apps/seo_manager/templates/seo_manager/client_analytics.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Analytics - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body p-3">
                    <div class="row align-items-center">
                        <div class="col-md-4">
                            <h1 class="mb-0">Analytics for {{ client.name }}</h1>
                        </div>
                        <div class="col-md-4">
                            {% if analytics_data %}
                            <div class="d-flex justify-content-center">
                                <select id="dateRangeSelect" class="form-control">
                                    <option value="7" {% if selected_ga_range == '7' %}selected{% endif %}>Last 7 Days</option>
                                    <option value="14" {% if selected_ga_range == '14' %}selected{% endif %}>Last 14 Days</option>
                                    <option value="30" {% if selected_ga_range == '30' %}selected{% endif %}>Last 30 Days</option>
                                    <option value="60" {% if selected_ga_range == '60' %}selected{% endif %}>Last 60 Days</option>
                                    <option value="90" {% if selected_ga_range == '90' %}selected{% endif %}>Last 90 Days</option>
                                    <option value="365" {% if selected_ga_range == '365' %}selected{% endif %}>Last Year</option>
                                    <option value="custom" {% if selected_ga_range == 'custom' %}selected{% endif %}>Custom Range</option>
                                </select>
                            </div>
                            <!-- Custom Date Range Inputs (initially hidden) -->
                            <div id="customDateInputs" class="mt-2 d-none">
                                <div class="row">
                                    <div class="col-6">
                                        <input type="text" id="startDate" class="form-control datepicker" placeholder="Start Date">
                                    </div>
                                    <div class="col-6">
                                        <input type="text" id="endDate" class="form-control datepicker" placeholder="End Date">
                                    </div>
                                </div>
                                <div class="text-end mt-2">
                                    <button id="applyCustomDates" class="btn btn-primary btn-sm">Apply</button>
                                </div>
                            </div>
                            {% endif %}
                        </div>
                        <div class="col-md-4 d-flex justify-content-end">
                            <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-outline-primary btn-sm mb-0">
                                <i class="fas fa-arrow-left me-2"></i>Back to Client
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Google Analytics Section -->
    {% if analytics_data %}
    <!-- First Row -->
    <div class="row">
        <!-- Active Users Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row mb-0">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Active Users</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="active-users-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="active-users-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="active-users-chart" style="min-height: 250px;"></div>
                </div>
            </div>
        </div>

        <!-- Sessions Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Sessions</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="sessions-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="sessions-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="sessions-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>

        <!-- Average Session Duration Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Average Session Duration</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="avg-duration-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="avg-duration-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="avg-duration-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Second Row -->
    <div class="row">
        <!-- Page Views Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Page Views</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="page-views-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="page-views-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="page-views-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>

        <!-- Pages/Session Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Pages/Session</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="pages-per-session-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="pages-per-session-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="pages-per-session-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>

        <!-- New Users Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">New Users</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="new-users-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="new-users-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="new-users-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Third Row -->
    <div class="row">
        <!-- Bounce Rate Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Bounce Rate</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="bounce-rate-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="bounce-rate-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="bounce-rate-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>

        <!-- Engaged Sessions Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Engaged Sessions</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="engaged-sessions-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="engaged-sessions-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="engaged-sessions-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>

        <!-- Key Events Card -->
        <div class="col-xl-4 col-sm-6 mb-4">
            <div class="card">
                <div class="card-body p-2">
                    <div class="row">
                        <div class="col-8">
                            <div class="numbers">
                                <p class="text-sm mb-0 text-capitalize font-weight-bold">Key Events</p>
                                <div class="d-flex align-items-center">
                                    <h5 class="font-weight-bolder mb-0" id="key-events-count">Loading...</h5>
                                    <span class="text-sm ms-1" id="key-events-change"></span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="key-events-chart" class="mt-2 h-50"></div>
                </div>
            </div>
        </div>
    </div>
    {% else %}
    <div class="card mb-4">
        <div class="card-body">
            <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm bg-gradient-warning shadow text-center me-2">
                    <i class="fas fa-exclamation-triangle opacity-10"></i>
                </div>
                <div>
                    <h6 class="mb-0">Google Analytics Data Unavailable</h6>
                    <p class="text-sm mb-0">Analytics data is not available for this client.</p>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    <!-- Search Console Section -->
    {% if search_console_data %}
    <div class="card mb-4">
        <div class="card-header pb-0">
            <div class="row align-items-center">
                <div class="col-md-6">
                    <h6>Search Console Performance Data</h6>
                </div>
                <div class="col-md-6">
                    <div class="d-flex justify-content-end">
                        <select id="scDateRangeSelect" class="form-control">
                            <option value="7" {% if selected_sc_range == '7' %}selected{% endif %}>Last 7 Days</option>
                            <option value="14" {% if selected_sc_range == '14' %}selected{% endif %}>Last 14 Days</option>
                            <option value="30" {% if selected_sc_range == '30' %}selected{% endif %}>Last 30 Days</option>
                            <option value="60" {% if selected_sc_range == '60' %}selected{% endif %}>Last 60 Days</option>
                            <option value="90" {% if selected_sc_range == '90' %}selected{% endif %}>Last 90 Days</option>
                            <option value="365" {% if selected_sc_range == '365' %}selected{% endif %}>Last Year</option>
                            <option value="custom" {% if selected_sc_range == 'custom' %}selected{% endif %}>Custom Range</option>
                        </select>
                    </div>
                    <!-- Custom Date Range Inputs for Search Console (initially hidden) -->
                    <div id="scCustomDateInputs" class="mt-2 d-none">
                        <div class="row">
                            <div class="col-6">
                                <input type="text" id="scStartDate" class="form-control datepicker" placeholder="Start Date">
                            </div>
                            <div class="col-6">
                                <input type="text" id="scEndDate" class="form-control datepicker" placeholder="End Date">
                            </div>
                        </div>
                        <div class="text-end mt-2">
                            <button id="scApplyCustomDates" class="btn btn-primary btn-sm">Apply</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
            <div class="table-responsive p-0">
                <table class="table table-flush table-striped text-xs table-sm" id="search-console-table">
                    <thead class="thead-light">
                        <tr>
                            <th class="text-uppercase text-secondary text-xs font-weight-bolder opacity-7">Query</th>
                            <th class="text-uppercase text-secondary text-xs font-weight-bolder opacity-7">Impressions</th>
                            <th class="text-uppercase text-secondary text-xs font-weight-bolder opacity-7">Clicks</th>
                            <th class="text-uppercase text-secondary text-xs font-weight-bolder opacity-7">CTR</th>
                            <th class="text-uppercase text-secondary text-xs font-weight-bolder opacity-7">Position</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for item in search_console_data %}
                        <tr>
                            <td class="text-xs font-weight-normal">{{ item.query }}</td>
                            <td class="text-xs font-weight-normal">{{ item.impressions }}</td>
                            <td class="text-xs font-weight-normal">{{ item.clicks }}</td>
                            <td class="text-xs font-weight-normal">{{ item.ctr|floatformat:2 }}%</td>
                            <td class="text-xs font-weight-normal">{{ item.position|floatformat:1 }}</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    {% else %}
    <div class="card mb-4">
        <div class="card-body">
            <div class="d-flex align-items-center">
                <div class="icon icon-shape icon-sm bg-gradient-warning shadow text-center me-2">
                    <i class="fas fa-exclamation-triangle opacity-10"></i>
                </div>
                <div>
                    <h6 class="mb-0">Search Console Data Unavailable</h6>
                    <p class="text-sm mb-0">Search Console data is not available for this client.</p>
                </div>
            </div>
        </div>
    </div>
    {% endif %}

    {% if not analytics_data and not search_console_data %}
    <div class="card">
        <div class="card-body text-center py-5">
            <div class="icon icon-shape icon-xl bg-gradient-info shadow text-center mb-3">
                <i class="fas fa-chart-line opacity-10"></i>
            </div>
            <h4>No Data Available</h4>
            <p class="text-muted">No analytics or search console data is currently available for this client.</p>
        </div>
    </div>
    {% endif %}
</div>
{% endblock content %}
{% block extra_css %}
{% endblock extra_css %}
{% block extra_js %}
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
{% if analytics_data or search_console_data %}
    <script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
    <script src="{% static 'assets/js/plugins/flatpickr.min.js' %}"></script>
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Flatpickr config for date inputs - defined globally for both sections
            const dateConfig = {
                maxDate: "today",
                dateFormat: "Y-m-d"
            };
            
            {% if analytics_data %}
            // Initialize Analytics components
            const dateRangeSelect = new Choices('#dateRangeSelect', {
                searchEnabled: false,
                itemSelectText: '',
                shouldSort: false,
                classNames: {
                    containerOuter: 'choices w-50',
                    containerInner: 'choices__inner w-100'
                }
            });

            // Initialize Flatpickr for date inputs
            const startDatePicker = flatpickr("#startDate", dateConfig);
            const endDatePicker = flatpickr("#endDate", dateConfig);

            // Handle date range changes
            document.getElementById('dateRangeSelect').addEventListener('change', function(e) {
                const customDateInputs = document.getElementById('customDateInputs');
                if (e.target.value === 'custom') {
                    customDateInputs.classList.remove('d-none');
                } else {
                    customDateInputs.classList.add('d-none');
                    fetchAnalyticsData(e.target.value);
                }
            });

            // Handle custom date range submission
            document.getElementById('applyCustomDates').addEventListener('click', function() {
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                
                if (startDate && endDate) {
                    fetchAnalyticsData('custom', startDate, endDate);
                } else {
                    alert('Please select both start and end dates');
                }
            });

            function fetchAnalyticsData(range, startDate = null, endDate = null) {
                const url = new URL(window.location.href);
                url.searchParams.set('ga_range', range);
                if (startDate && endDate) {
                    url.searchParams.set('ga_start_date', startDate);
                    url.searchParams.set('ga_end_date', endDate);
                }
                window.location.href = url.toString();
            }

            (function setupAnalyticsCharts() {
                try {
                    const analyticsData = JSON.parse('{{ analytics_data|escapejs }}');
                    
                    // Common chart options
                    const commonChartOptions = {
                        chart: {
                            type: 'area',
                            height: 250,
                            sparkline: false,
                            toolbar: {
                                show: false
                            },
                            animations: {
                                enabled: true,
                                easing: 'easeinout',
                                speed: 1000,
                                animateGradually: {
                                    enabled: true,
                                    delay: 150
                                },
                                dynamicAnimation: {
                                    enabled: true,
                                    speed: 350
                                }
                            },
                            dropShadow: {
                                enabled: true,
                                top: 3,
                                left: 2,
                                blur: 4,
                                opacity: 0.1
                            }
                        },
                        stroke: {
                            curve: 'smooth',
                            width: 3,
                            lineCap: 'round',
                            colors: ['#5e72e4']
                        },
                        grid: {
                            show: true,
                            borderColor: '#f8f9fa',
                            strokeDashArray: 5,
                            position: 'back',
                            xaxis: {
                                lines: {
                                    show: true
                                }
                            },
                            yaxis: {
                                lines: {
                                    show: true
                                }
                            },
                            padding: {
                                top: 0,
                                right: 0,
                                bottom: 0,
                                left: 10
                            }
                        },
                        fill: {
                            type: 'gradient',
                            gradient: {
                                shade: 'light',
                                type: 'vertical',
                                shadeIntensity: 0.5,
                                gradientToColors: ['#fff'],
                                inverseColors: false,
                                opacityFrom: 0.7,
                                opacityTo: 0.1,
                                stops: [0, 100]
                            }
                        },
                        colors: ['#5e72e4'],
                        dataLabels: {
                            enabled: false
                        },
                        xaxis: {
                            type: 'datetime',
                            labels: {
                                show: true,
                                format: 'MMM dd',
                                style: {
                                    colors: '#8392ab',
                                    fontSize: '12px',
                                    fontFamily: 'Open Sans, sans-serif',
                                    fontWeight: 400
                                }
                            },
                            axisBorder: {
                                show: false
                            },
                            axisTicks: {
                                show: false
                            }
                        },
                        yaxis: {
                            show: true,
                            labels: {
                                show: true,
                                style: {
                                    colors: '#8392ab',
                                    fontSize: '12px',
                                    fontFamily: 'Open Sans, sans-serif',
                                    fontWeight: 400
                                },
                                formatter: function(value) {
                                    return value >= 1000 ? (value / 1000).toFixed(1) + 'k' : value;
                                }
                            }
                        },
                        tooltip: {
                            enabled: true,
                            shared: true,
                            intersect: false,
                            followCursor: true,
                            theme: 'dark',
                            x: {
                                format: 'MMM dd, yyyy'
                            },
                            y: {
                                formatter: function(value) {
                                    return value.toLocaleString()
                                }
                            },
                            style: {
                                fontSize: '12px',
                                fontFamily: 'Open Sans, sans-serif'
                            }
                        },
                        markers: {
                            size: 2,
                            colors: ['#5e72e4'],
                            strokeColors: '#fff',
                            strokeWidth: 2,
                            hover: {
                                size: 7,
                                sizeOffset: 3
                            }
                        },
                        states: {
                            hover: {
                                filter: {
                                    type: 'lighten',
                                    value: 0.04
                                }
                            },
                            active: {
                                allowMultipleDataPointsSelection: false,
                                filter: {
                                    type: 'darken',
                                    value: 0.2
                                }
                            }
                        }
                    };

                    // Create charts for each metric
                    const metrics = [
                        { 
                            id: 'active-users', 
                            key: 'active_users', 
                            format: value => value.toLocaleString()
                        },
                        { 
                            id: 'sessions', 
                            key: 'sessions', 
                            format: value => value.toLocaleString()
                        },
                        { 
                            id: 'avg-duration', 
                            key: 'avg_session_duration', 
                            format: value => formatDuration(value)
                        },
                        { 
                            id: 'page-views', 
                            key: 'page_views', 
                            format: value => value.toLocaleString()
                        },
                        { 
                            id: 'pages-per-session', 
                            key: 'pages_per_session', 
                            format: value => value.toFixed(2)
                        },
                        { 
                            id: 'new-users', 
                            key: 'new_users', 
                            format: value => value.toLocaleString()
                        },
                        { 
                            id: 'bounce-rate', 
                            key: 'bounce_rate', 
                            format: value => value.toFixed(2) + '%'
                        },
                        { 
                            id: 'engaged-sessions', 
                            key: 'engaged_sessions', 
                            format: value => value.toLocaleString()
                        },
                        { 
                            id: 'key-events', 
                            key: 'key_events', 
                            format: value => value.toLocaleString()
                        }
                    ];

                    metrics.forEach(metric => {
                        const data = analyticsData
                            .map(item => ({
                                x: new Date(item.date).getTime(),
                                y: parseFloat(item[metric.key]) || 0
                            }))
                            .sort((a, b) => a.x - b.x);

                        // Split data into current and previous periods
                        const midPoint = Math.floor(data.length / 2);
                        const previousPeriod = data.slice(0, midPoint);
                        const currentPeriod = data.slice(midPoint);

                        // Calculate period values based on metric type
                        let currentValue, previousValue;
                        if (['bounce_rate', 'pages_per_session', 'avg_session_duration'].includes(metric.key)) {
                            // Use average for rate-based metrics
                            currentValue = currentPeriod.reduce((sum, val) => sum + val.y, 0) / currentPeriod.length;
                            previousValue = previousPeriod.reduce((sum, val) => sum + val.y, 0) / previousPeriod.length;
                        } else {
                            // Use sum for count-based metrics
                            currentValue = currentPeriod.reduce((sum, val) => sum + val.y, 0);
                            previousValue = previousPeriod.reduce((sum, val) => sum + val.y, 0);
                        }

                        // Update the header value with the current value
                        const headerElement = document.getElementById(`${metric.id}-count`);
                        if (headerElement) {
                            headerElement.textContent = metric.format(currentValue);  // Use current value, not summary
                        }

                        // Calculate and display the percentage change
                        if (previousValue) {
                            const change = ((currentValue - previousValue) / previousValue) * 100;
                            const changeElement = document.getElementById(`${metric.id}-change`);
                            if (changeElement) {
                                changeElement.textContent = `${change >= 0 ? '+' : ''}${change.toFixed(2)}%`;
                                changeElement.className = `text-sm font-weight-bolder ${change >= 0 ? 'text-info' : 'text-danger'}`;
                            }
                        }

                        // Calculate nice round number for max value
                        const maxValue = Math.max(...data.map(point => point.y));
                        const orderOfMagnitude = Math.pow(10, Math.floor(Math.log10(maxValue)));
                        const niceMax = Math.ceil(maxValue / orderOfMagnitude) * orderOfMagnitude;

                        // Create chart with dynamic y-axis configuration
                        const chartOptions = {
                            ...commonChartOptions,
                            chart: {
                                ...commonChartOptions.chart,
                                id: metric.id,
                                toolbar: { show: false }
                            },
                            yaxis: {
                                ...commonChartOptions.yaxis,
                                min: 0,
                                max: niceMax,
                                tickAmount: 4,
                                labels: {
                                    formatter: function(value) {
                                        if (metric.key === 'avg_session_duration') {
                                            return formatDuration(value);
                                        }
                                        if (metric.key === 'bounce_rate') {
                                            return value.toFixed(0) + '%';
                                        }
                                        if (value >= 1000) {
                                            return (value / 1000).toFixed(1) + 'k';
                                        }
                                        return value.toFixed(0);
                                    }
                                }
                            },
                            series: [{
                                name: metric.id,
                                data: data
                            }]
                        };

                        new ApexCharts(document.querySelector(`#${metric.id}-chart`), chartOptions).render();
                    });
                } catch (error) {
                    console.error("Error parsing analytics data:", error);
                    // Fallback to display raw data
                    const rawData = '{{ analytics_data|escapejs }}';
                    document.getElementById('active-users-count').textContent = rawData;
                    document.getElementById('sessions-count').textContent = rawData;
                    document.getElementById('avg-duration-count').textContent = rawData;
                    document.getElementById('page-views-count').textContent = rawData;
                    document.getElementById('pages-per-session-count').textContent = rawData;
                    document.getElementById('new-users-count').textContent = rawData;
                    document.getElementById('bounce-rate-count').textContent = rawData;
                    document.getElementById('engaged-sessions-count').textContent = rawData;
                    document.getElementById('key-events-count').textContent = rawData;
                }
            })();
            {% endif %}

            {% if search_console_data %}
            // Initialize Search Console components
            const dataTableSearchConsole = new simpleDatatables.DataTable("#search-console-table", {
                searchable: true,
                fixedHeight: true,
                perPage: 25,
                perPageSelect: [25, 50, 100],
                columns: [{
                    select: [3, 4],
                    sortable: true,
                    type: 'number'
                }]
            });

            // Initialize Choices.js for Search Console dropdown
            const scDateRangeSelect = new Choices('#scDateRangeSelect', {
                searchEnabled: false,
                itemSelectText: '',
                shouldSort: false,
                classNames: {
                    containerOuter: 'choices w-100',
                    containerInner: 'choices__inner w-100'
                }
            });

            // Initialize Flatpickr for Search Console date inputs
            const scStartDatePicker = flatpickr("#scStartDate", dateConfig);
            const scEndDatePicker = flatpickr("#scEndDate", dateConfig);

            // Show/hide custom date inputs based on initial selection for Search Console
            const scCustomDateInputs = document.getElementById('scCustomDateInputs');
            if (document.getElementById('scDateRangeSelect').value === 'custom') {
                scCustomDateInputs.classList.remove('d-none');
            }

            // Handle Search Console date range changes
            document.getElementById('scDateRangeSelect').addEventListener('change', function(e) {
                const customDateInputs = document.getElementById('scCustomDateInputs');
                if (e.target.value === 'custom') {
                    customDateInputs.classList.remove('d-none');
                } else {
                    customDateInputs.classList.add('d-none');
                    const url = new URL(window.location.href);
                    url.searchParams.set('sc_range', e.target.value);
                    // Preserve GA parameters
                    const gaRange = url.searchParams.get('ga_range');
                    const gaStartDate = url.searchParams.get('ga_start_date');
                    const gaEndDate = url.searchParams.get('ga_end_date');
                    if (gaRange) url.searchParams.set('ga_range', gaRange);
                    if (gaStartDate) url.searchParams.set('ga_start_date', gaStartDate);
                    if (gaEndDate) url.searchParams.set('ga_end_date', gaEndDate);
                    window.location.href = url.toString();
                }
            });

            // Handle Search Console custom date range submission
            document.getElementById('scApplyCustomDates').addEventListener('click', function() {
                const startDate = document.getElementById('scStartDate').value;
                const endDate = document.getElementById('scEndDate').value;
                
                if (startDate && endDate) {
                    const url = new URL(window.location.href);
                    url.searchParams.set('sc_range', 'custom');
                    url.searchParams.set('sc_start_date', startDate);
                    url.searchParams.set('sc_end_date', endDate);
                    // Preserve GA parameters
                    const gaRange = url.searchParams.get('ga_range');
                    const gaStartDate = url.searchParams.get('ga_start_date');
                    const gaEndDate = url.searchParams.get('ga_end_date');
                    if (gaRange) url.searchParams.set('ga_range', gaRange);
                    if (gaStartDate) url.searchParams.set('ga_start_date', gaStartDate);
                    if (gaEndDate) url.searchParams.set('ga_end_date', gaEndDate);
                    window.location.href = url.toString();
                } else {
                    alert('Please select both start and end dates');
                }
            });
            {% endif %}
        });

        {% if analytics_data %}
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        {% endif %}
    </script>
{% endif %}

<script>
    document.addEventListener('DOMContentLoaded', function() {
        {% for message in messages %}
            {% if 'sweetalert' in message.tags %}
                try {
                    const messageData = JSON.parse('{{ message|escapejs }}');
                    Swal.fire({
                        title: messageData.title,
                        text: messageData.text,
                        icon: messageData.icon,
                        confirmButtonText: 'OK'
                    }).then((result) => {
                        if (result.isConfirmed && messageData.redirect_url) {
                            window.location.href = messageData.redirect_url;
                        }
                    });
                } catch (error) {
                    console.error("Error parsing message data:", error);
                    // Fallback to display raw message
                    Swal.fire({
                        title: "Error",
                        text: "{{ message|escapejs }}",
                        icon: "error",
                        confirmButtonText: 'OK'
                    });
                }
            {% endif %}
        {% endfor %}
    });
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/client_detail.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% load custom_filters %}

{% block title %} Client Detail - {{ client.name }} {% endblock %}

{% block extrastyle %}
{{ block.super }}
<link rel="stylesheet" type="text/css" href="{% static 'seo_manager/css/client_detail.css' %}?v={% now 'YmdHis' %}" crossorigin="anonymous"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

<style>
  .ql-editor {
    min-height: 300px;
    max-height: 500px;
    overflow-y: auto;
  }
  
  .modal-dialog-large {
    max-width: 800px;
  }
  
  .h-300 {
    height: 300px !important;
  }
  
  #add-profile-editor, #edit-profile-editor {
    height: 300px;
    margin-bottom: 20px;
  }
  
  .ql-toolbar.ql-snow {
    border-top-left-radius: 0.5rem;
    border-top-right-radius: 0.5rem;
  }
  
  .ql-container.ql-snow {
    border-bottom-left-radius: 0.5rem;
    border-bottom-right-radius: 0.5rem;
  }
</style>
{% endblock extrastyle %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-md-5">
      <div class="card mb-4">
        <div class="card-header pb-0 d-flex justify-content-between align-items-center bg-gradient-primary">
          <div class="d-flex align-items-center">
            <h6 class="mb-0 me-3 text-white"></h6>
            <h6 class="mb-0 text-white">{{ client.name }}</h6>
          </div>
          <a href="{% url 'seo_manager:edit_client' client.id %}" class="btn btn-xxs btn-white ms-3">
            <i class="fas fa-edit"></i> Edit
          </a>
        </div>
        <div class="card-body px-3 pt-3 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0">
              <tbody>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-globe me-2"></i> Website URL
                  </td>
                  <td>
                    <a href="{{ client.website_url }}" target="_blank" class="text-xs font-weight-bold mb-0 text-primary">
                      {{ client.website_url }} <i class="fas fa-external-link-alt ms-1"></i>
                    </a>
                  </td>
                </tr>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-circle me-2"></i> Status
                  </td>
                  <td>
                    <span class="badge bg-gradient-{% if client.status == 'active' %}success{% elif client.status == 'inactive' %}secondary{% else %}warning{% endif %} text-xs">
                      {{ client.get_status_display }}
                    </span>
                  </td>
                </tr>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-users me-2"></i> Group
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ client.group.name|default:"N/A" }}</p>
                  </td>
                </tr>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-bullseye me-2"></i> Target Audience
                  </td>
                  <td style="max-width: 250px;">
                    <p class="text-xs font-weight-bold mb-0" style="white-space: normal; word-wrap: break-word;">{{ client.target_audience|default:"N/A" }}</p>
                  </td>
                </tr>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-calendar-plus me-2"></i> Created At
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ client.created_at|date:"F d, Y H:i" }}</p>
                  </td>
                </tr>
                <tr>
                  <td class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">
                    <i class="fas fa-calendar-check me-2"></i> Last Updated
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ client.updated_at|date:"F d, Y H:i" }}</p>
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="col-md-7">
      <div class="card mb-4">
        <div class="card-header pb-0 p-3 bg-gradient-dark">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6 class="mb-0 text-white">Business Objectives</h6>
              <p class="text-sm mb-0 text-white opacity-8">Track and manage business goals</p>
            </div>
            <button type="button" class="btn bg-gradient-light" data-bs-toggle="modal" data-bs-target="#add-objective">
              <i class="fas fa-plus me-2"></i>New Objective
            </button>
          </div>
        </div>
        <div class="card-body p-3">
          <div class="timeline timeline-one-side" data-timeline-axis-style="dashed">
            {% for objective in business_objectives %}
              <div class="timeline-block mb-3">
                <span class="timeline-step">
                  {% if objective.status %}
                    <i class="fas fa-check-circle text-success"></i>
                  {% else %}
                    <i class="fas fa-clock text-warning"></i>
                  {% endif %}
                </span>
                <div class="timeline-content">
                  <div class="d-flex justify-content-between">
                    <div>
                      <h6 class="text-dark text-sm font-weight-bold mb-0">{{ objective.goal }}</h6>
                      <div class="d-flex align-items-center mt-2">
                        <div class="me-3">
                          <span class="text-dark text-xs">Metric:</span>
                          <span class="text-xs ms-1 badge bg-gradient-info">{{ objective.metric }}</span>
                        </div>
                        <div class="me-3">
                          <span class="text-dark text-xs">Target:</span>
                          <span class="text-xs ms-1 badge bg-gradient-warning">{{ objective.target_date }}</span>
                        </div>
                        <div>
                          <span class="text-dark text-xs">Status:</span>
                          <span class="text-xs ms-1 badge bg-gradient-{% if objective.status %}success{% else %}secondary{% endif %}">
                            {% if objective.status %}Active{% else %}Inactive{% endif %}
                          </span>
                        </div>
                      </div>
                    </div>
                    <div class="dropdown">
                      <button class="btn btn-link text-secondary mb-0" data-bs-toggle="dropdown" id="objectiveMenu{{ forloop.counter }}">
                        <i class="fa fa-ellipsis-v text-xs"></i>
                      </button>
                      <ul class="dropdown-menu" aria-labelledby="objectiveMenu{{ forloop.counter }}">
                        <li>
                          <a class="dropdown-item objective-status-toggle" href="#"
                             data-client-id="{{ client.id }}"
                             data-objective-index="{{ forloop.counter0 }}"
                             data-new-status="active">
                            <i class="fas fa-check-circle text-success me-2"></i>Mark as Active
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item objective-status-toggle" href="#"
                             data-client-id="{{ client.id }}"
                             data-objective-index="{{ forloop.counter0 }}"
                             data-new-status="completed">
                            <i class="fas fa-check-double text-info me-2"></i>Mark as Completed
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item objective-status-toggle" href="#"
                             data-client-id="{{ client.id }}"
                             data-objective-index="{{ forloop.counter0 }}"
                             data-new-status="on_hold">
                            <i class="fas fa-pause-circle text-warning me-2"></i>Put on Hold
                          </a>
                        </li>
                        <li><hr class="dropdown-divider"></li>
                        <li>
                          <a class="dropdown-item edit-objective" href="#" 
                             data-bs-toggle="modal" 
                             data-bs-target="#edit-objective"
                             data-objective-index="{{ forloop.counter0 }}"
                             data-goal="{{ objective.goal }}"
                             data-metric="{{ objective.metric }}"
                             data-target-date="{{ objective.target_date|date:'Y-m-d' }}"
                             data-status="{{ objective.status|yesno:'true,false' }}">
                            <i class="fas fa-edit me-2"></i>Edit
                          </a>
                        </li>
                        <li>
                          <form method="post" action="{% url 'seo_manager:delete_business_objective' client_id=client.id objective_index=forloop.counter0 %}" class="d-inline">
                            {% csrf_token %}
                            <button type="submit" class="dropdown-item text-danger" onclick="return confirm('Are you sure you want to delete this objective?')">
                              <i class="fas fa-trash me-2"></i>Delete
                            </button>
                          </form>
                        </li>
                      </ul>
                    </div>
                  </div>
                  <p class="text-secondary text-xs mt-2 mb-0">
                    <i class="fas fa-history me-1"></i>
                    Created: {{ objective.date_created|format_iso_date:"%Y-%m-%d %H:%M" }} | Modified: {{ objective.date_last_modified|format_iso_date:"%Y-%m-%d %H:%M" }}
                  </p>
                </div>
              </div>
            {% empty %}
              <div class="text-center py-4">
                <div class="icon icon-shape icon-sm bg-gradient-secondary shadow text-center mb-3">
                  <i class="fas fa-tasks text-white opacity-10"></i>
                </div>
                <h6 class="text-dark">No business objectives set</h6>
                <p class="text-secondary text-sm">Click the "New Objective" button to add your first business objective.</p>
              </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Targeted Keywords Section -->
<div class="row mt-4">
  <div class="col-12">
    <div class="card">
      <div class="card-header pb-0">
        <div class="d-lg-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Targeted Keywords</h5>
            <p class="text-sm mb-0 text-muted">
              <i class="fas fa-chart-line me-1"></i> Track performance metrics and rankings
            </p>
          </div>
          <div class="ms-auto my-auto mt-lg-0 mt-4">
            <div class="d-flex gap-2">
              <div class="input-group input-group-sm me-2" style="width: 200px;">
                <span class="input-group-text bg-white border-end-0">
                  <i class="fas fa-search text-muted"></i>
                </span>
                <input type="text" class="form-control border-start-0 ps-0" id="keywordSearch" 
                       placeholder="Search keywords..." style="border-left: none;">
              </div>
              <button type="button" class="btn btn-sm bg-gradient-success" data-bs-toggle="modal" data-bs-target="#add-keyword">
                <i class="fas fa-plus me-1"></i>Add
              </button>
              <div class="dropdown">
                <button class="btn btn-sm btn-outline-primary dropdown-toggle" type="button" data-bs-toggle="dropdown">
                  <i class="fas fa-file-import me-1"></i>Import
                </button>
                <ul class="dropdown-menu">
                  <li>
                    <a class="dropdown-item" href="#" data-bs-toggle="modal" data-bs-target="#import-keywords">
                      <i class="fas fa-file-csv me-2"></i>Import CSV
                    </a>
                  </li>
                  <li>
                    <a class="dropdown-item" href="{% url 'seo_manager:search_console_keywords' client.id %}">
                      <i class="fab fa-google me-2"></i>From Search Console
                    </a>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
        <div class="row mt-3">
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Keywords</p>
                      <h5 class="mb-0 font-weight-bold">
                        {{ client.targeted_keywords.count }}
                      </h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                      <i class="fas fa-key text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Avg. Position</p>
                      <h5 class="mb-0 font-weight-bold">
                        {{ avg_position|default:"N/A" }}
                      </h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md">
                      <i class="fas fa-chart-line text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Clicks</p>
                      <h5 class="mb-0 font-weight-bold">
                        {{ total_clicks|default:"0" }}
                      </h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md">
                      <i class="fas fa-mouse-pointer text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Avg. CTR</p>
                      <h5 class="mb-0 font-weight-bold">
                        {{ avg_ctr|default:"0" }}%
                      </h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-info shadow text-center border-radius-md">
                      <i class="fas fa-percentage text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="card-body px-0 pt-0 pb-0">
        <div class="table-responsive p-0">
          {% include 'seo_manager/keywords/keyword_list_table.html' with keywords=client.targeted_keywords.all %}
        </div>
      </div>
    </div>
  </div>
</div>

<!-- SEO Projects Section -->
<div class="row mt-4">
  <div class="col-12">
    <div class="card">
      <div class="card-header pb-0">
        <div class="d-lg-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">SEO Projects</h5>
            <p class="text-sm mb-0 text-muted">
              <i class="fas fa-tasks me-1"></i> Implementation projects and campaigns
            </p>
          </div>
          <div class="ms-auto my-auto mt-lg-0 mt-4">
            <div class="d-flex gap-2">
              <div class="btn-group" role="group">
                <input type="radio" class="btn-check" name="project-view" id="list-view" checked>
                <label class="btn btn-outline-primary btn-sm" for="list-view">
                  <i class="fas fa-list"></i>
                </label>
                <input type="radio" class="btn-check" name="project-view" id="kanban-view">
                <label class="btn btn-outline-primary btn-sm" for="kanban-view">
                  <i class="fas fa-th-large"></i>
                </label>
              </div>
              <button type="button" class="btn btn-sm bg-gradient-dark" data-bs-toggle="modal" data-bs-target="#add-project">
                <i class="fas fa-plus me-1"></i>New Project
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="card-body">
        <div class="row mb-4">
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Projects</p>
                      <h5 class="mb-0 font-weight-bold">{{ client.seo_projects.count }}</h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                      <i class="fas fa-project-diagram text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">In Progress</p>
                      <h5 class="mb-0 font-weight-bold">{{ in_progress_count|default:"0" }}</h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-info shadow text-center border-radius-md">
                      <i class="fas fa-spinner text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Completed</p>
                      <h5 class="mb-0 font-weight-bold">{{ completed_count|default:"0" }}</h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md">
                      <i class="fas fa-check text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="col-md-3">
            <div class="card card-sm border">
              <div class="card-body p-3">
                <div class="row">
                  <div class="col-8">
                    <div class="numbers">
                      <p class="text-sm mb-0 text-capitalize font-weight-bold">Success Rate</p>
                      <h5 class="mb-0 font-weight-bold">{{ success_rate|default:"0" }}%</h5>
                    </div>
                  </div>
                  <div class="col-4 text-end">
                    <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md">
                      <i class="fas fa-chart-pie text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- List View -->
        <div id="projects-list-view">
          <div class="table-responsive">
            <table class="table table-flush" id="projects-table">
              <thead class="thead-light">
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Project</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Progress</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Timeline</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
                </tr>
              </thead>
              <tbody>
                {% for project in client.seo_projects.all %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">{{ project.title }}</h6>
                        <p class="text-xs text-secondary mb-0">{{ project.description|truncatechars:100 }}</p>
                      </div>
                    </div>
                  </td>
                  <td>
                    <span class="badge badge-sm bg-gradient-{% if project.status == 'completed' %}success{% elif project.status == 'in_progress' %}info{% elif project.status == 'planned' %}secondary{% else %}warning{% endif %}">
                      {{ project.get_status_display }}
                    </span>
                  </td>
                  <td>
                    <div class="d-flex align-items-center">
                      <span class="me-2 text-xs font-weight-bold">{{ project.progress|default:"0" }}%</span>
                      <div>
                        <div class="progress">
                          <div class="progress-bar bg-gradient-info" role="progressbar" 
                               aria-valuenow="{{ project.progress|default:'0' }}" 
                               aria-valuemin="0" 
                               aria-valuemax="100" 
                               style="width: {{ project.progress|default:'0' }}%"></div>
                        </div>
                      </div>
                    </div>
                  </td>
                  <td>
                    <div class="d-flex flex-column">
                      <span class="text-xs text-secondary mb-0">Start: {{ project.implementation_date|date:"M d, Y" }}</span>
                      <span class="text-xs text-secondary">End: {{ project.completion_date|date:"M d, Y"|default:"Ongoing" }}</span>
                    </div>
                  </td>
                  <td>
                    <div class="dropdown">
                      <button class="btn btn-link text-secondary mb-0" data-bs-toggle="dropdown">
                        <i class="fa fa-ellipsis-v text-xs"></i>
                      </button>
                      <ul class="dropdown-menu">
                        <li>
                          <a class="dropdown-item" href="{% url 'seo_manager:project_detail' client.id project.id %}">
                            <i class="fas fa-eye me-2"></i>View Details
                          </a>
                        </li>
                        <li>
                          <a class="dropdown-item" href="{% url 'seo_manager:edit_project' client.id project.id %}">
                            <i class="fas fa-edit me-2"></i>Edit
                          </a>
                        </li>
                        <li>
                          <hr class="dropdown-divider">
                        </li>
                        <li>
                          <form method="post" action="{% url 'seo_manager:delete_project' client.id project.id %}" class="d-inline">
                            {% csrf_token %}
                            <button type="submit" class="dropdown-item text-danger" onclick="return confirm('Are you sure you want to delete this project?')">
                              <i class="fas fa-trash me-2"></i>Delete
                            </button>
                          </form>
                        </li>
                      </ul>
                    </div>
                  </td>
                </tr>
                {% empty %}
                <tr>
                  <td colspan="5" class="text-center py-4">
                    <div class="icon icon-shape icon-sm bg-gradient-secondary shadow text-center mb-3 mx-auto">
                      <i class="fas fa-tasks text-white opacity-10"></i>
                    </div>
                    <h6 class="text-dark">No projects yet</h6>
                    <p class="text-secondary text-sm">Start by creating your first SEO project.</p>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>

        <!-- Kanban View (Initially Hidden) -->
        <div id="projects-kanban-view" style="display: none;">
          <div class="row">
            <div class="col-md-4">
              <div class="card">
                <div class="card-header bg-gradient-secondary p-3">
                  <h6 class="mb-0 text-white">Planned</h6>
                </div>
                <div class="card-body">
                  {% for project in client.seo_projects.all %}
                    {% if project.status == 'planned' %}
                      <div class="card mb-3">
                        <div class="card-body p-3">
                          <h6 class="mb-0">{{ project.title }}</h6>
                          <p class="text-sm text-muted mb-2">{{ project.description|truncatechars:100 }}</p>
                          <div class="d-flex align-items-center">
                            <span class="text-sm me-auto">{{ project.implementation_date|date:"M d, Y" }}</span>
                            <button class="btn btn-link text-secondary p-0" data-bs-toggle="modal" data-bs-target="#view-project-{{ project.id }}">
                              <i class="fas fa-eye"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    {% endif %}
                  {% endfor %}
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card">
                <div class="card-header bg-gradient-info p-3">
                  <h6 class="mb-0 text-white">In Progress</h6>
                </div>
                <div class="card-body">
                  {% for project in client.seo_projects.all %}
                    {% if project.status == 'in_progress' %}
                      <div class="card mb-3">
                        <div class="card-body p-3">
                          <h6 class="mb-0">{{ project.title }}</h6>
                          <p class="text-sm text-muted mb-2">{{ project.description|truncatechars:100 }}</p>
                          <div class="d-flex align-items-center">
                            <div class="progress w-100 me-2" style="height: 5px;">
                              <div class="progress-bar bg-gradient-info" role="progressbar" style="width: {{ project.progress }}%"></div>
                            </div>
                            <span class="text-sm text-muted">{{ project.progress }}%</span>
                          </div>
                        </div>
                      </div>
                    {% endif %}
                  {% endfor %}
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card">
                <div class="card-header bg-gradient-success p-3">
                  <h6 class="mb-0 text-white">Completed</h6>
                </div>
                <div class="card-body">
                  {% for project in client.seo_projects.all %}
                    {% if project.status == 'completed' %}
                      <div class="card mb-3">
                        <div class="card-body p-3">
                          <h6 class="mb-0">{{ project.title }}</h6>
                          <p class="text-sm text-muted mb-2">{{ project.description|truncatechars:100 }}</p>
                          <div class="d-flex align-items-center">
                            <span class="text-sm me-auto">Completed: {{ project.completion_date|date:"M d, Y" }}</span>
                            <button class="btn btn-link text-secondary p-0" data-bs-toggle="modal" data-bs-target="#view-project-{{ project.id }}">
                              <i class="fas fa-eye"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    {% endif %}
                  {% endfor %}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Add Keyword Modal -->
<div class="modal fade" id="add-keyword" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Keyword</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_create' client.id %}">
        {% csrf_token %}
        <div class="modal-body">
          {{ keyword_form.as_p }}
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Keyword</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Import Keywords Modal -->
<div class="modal fade" id="import-keywords" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Import Keywords</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:keyword_import' client.id %}" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="modal-body">
          {{ import_form.as_p }}
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Import</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Add Project Modal -->
<div class="modal fade" id="add-project" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">New SEO Project</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:project_create' client.id %}" enctype="multipart/form-data">
        {% csrf_token %}
        <div class="modal-body">
          {{ project_form.as_p }}
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Create Project</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Add this after the client details card and before the business objectives -->
<div class="col-md-12">
  <div class="card mb-4 mt-4">
    <div class="card-header pb-0 d-flex justify-content-between align-items-center">
      <div>
        <h5>Client Profile</h5>
        <p class="text-sm text-muted mb-0">Background information on client</p>
      </div>
      <div>
        <button type="button" class="btn bg-gradient-primary btn-sm" id="magicallyFillBtn">
          Magically Fill In
        </button>
        {% if client.client_profile %}
          <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#edit-profile">
            Edit Profile
          </button>
        {% else %}
          <button type="button" class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#add-profile">
            Add Profile
          </button>
        {% endif %}
      </div>
    </div>
    
    <div class="card-body">
      {% if client_profile_html %}
        <div class="markdown-content">
          {{ client_profile_html|safe }}
        </div>
      {% else %}
        <p class="text-sm text-muted">No profile has been added for this client yet.</p>
      {% endif %}
    </div>
  </div>
</div>

<!-- Add Profile Modal -->
<div class="modal fade" id="add-profile" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-dialog-large" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Client Profile</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:update_client_profile' client.id %}" id="addProfileForm">
        {% csrf_token %}
        <div class="modal-body">
          <div id="add-profile-editor">
            {{ client.client_profile|default:"" }}
          </div>
          <input type="hidden" name="client_profile" id="add-profile-content">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Save Profile</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Edit Profile Modal -->
<div class="modal fade" id="edit-profile" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-dialog-large" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Edit Client Profile</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:update_client_profile' client.id %}" id="editProfileForm">
        {% csrf_token %}
        <div class="modal-body">
          <div id="edit-profile-editor">
            {{ client.client_profile|safe }}
          </div>
          <input type="hidden" name="client_profile" id="edit-profile-content">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Update Profile</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Project Details Modals -->
{% for project in client.seo_projects.all %}
<div class="modal fade" id="view-project-{{ project.id }}" tabindex="-1" role="dialog" aria-labelledby="project-modal-{{ project.id }}" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="project-modal-{{ project.id }}">{{ project.title }}</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="row">
          <div class="col-md-12">
            <h6 class="text-sm">Description</h6>
            <p class="text-sm text-muted">{{ project.description }}</p>
          </div>
        </div>
        
        <div class="row mt-3">
          <div class="col-md-12">
            <h6 class="text-sm">Status</h6>
            <span class="badge bg-gradient-{% if project.status == 'completed' %}success{% elif project.status == 'in_progress' %}info{% elif project.status == 'planned' %}secondary{% else %}warning{% endif %}">
              {{ project.get_status_display }}
            </span>
          </div>
        </div>

        <div class="row mt-3">
          <div class="col-md-6">
            <h6 class="text-sm">Implementation Date</h6>
            <p class="text-sm">{{ project.implementation_date }}</p>
          </div>
          <div class="col-md-6">
            <h6 class="text-sm">Completion Date</h6>
            <p class="text-sm">{{ project.completion_date|default:"Not set" }}</p>
          </div>
        </div>

        <div class="row mt-3">
          <div class="col-md-12">
            <h6 class="text-sm">Targeted Keywords</h6>
            <div class="d-flex flex-wrap gap-2">
              {% for keyword in project.targeted_keywords.all %}
                <span class="badge bg-light text-dark">{{ keyword.keyword }}</span>
              {% empty %}
                <p class="text-sm text-muted">No keywords assigned</p>
              {% endfor %}
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <a href="{% url 'seo_manager:edit_project' client.id project.id %}" class="btn bg-gradient-primary btn-sm">Edit Project</a>
        <form method="post" action="{% url 'seo_manager:delete_project' client.id project.id %}" class="d-inline">
          {% csrf_token %}
          <button type="submit" class="btn bg-gradient-danger btn-sm" onclick="return confirm('Are you sure you want to delete this project?')">Delete Project</button>
        </form>
        <button type="button" class="btn bg-gradient-secondary btn-sm" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>
{% endfor %}

<!-- Add this after the Targeted Keywords Section -->
<div class="row mt-4">
  <div class="col-12">
    <div class="card">
      <div class="card-header pb-0">
        <div class="d-lg-flex">
          <div>
            <h5 class="mb-0">Ranking Data Management</h5>
            <p class="text-sm mb-0">
              Manage Search Console data collection and reporting
              <a href="{% url 'seo_manager:ranking_data_management' client.id %}" class="text-primary">View Details</a>
            </p>
          </div>
        </div>
      </div>
      <div class="card-body px-0 pb-0">
        <div class="table-responsive">
          <table class="table align-items-center mb-0">
            <thead>
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-3">Last Collection</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-3">Data Coverage</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-3">Keywords Tracked</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-3">Status</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td class="ps-3">
                  <span class="text-sm">
                    {% if latest_collection_date %}
                      {{ latest_collection_date|date:"F d, Y" }}
                    {% else %}
                      No data collected yet
                    {% endif %}
                  </span>
                </td>
                <td class="ps-3">
                  <span class="text-sm">
                    {% if data_coverage_months %}
                      {{ data_coverage_months }} month{{ data_coverage_months|pluralize }}
                    {% else %}
                      -
                    {% endif %}
                  </span>
                </td>
                <td class="ps-3">
                  <span class="text-sm">
                    {% if tracked_keywords_count %}
                      {{ tracked_keywords_count }}
                    {% else %}
                      0
                    {% endif %}
                  </span>
                </td>
                <td class="ps-3">
                  {% if latest_collection_date %}
                    <span class="badge badge-sm bg-gradient-success">Active</span>
                  {% else %}
                    <span class="badge badge-sm bg-gradient-warning">No Data</span>
                  {% endif %}
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Add the Report Modal -->
<div class="modal fade" id="reportModal" tabindex="-1" aria-labelledby="reportModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
          <div class="modal-header">
              <h5 class="modal-title" id="reportModalLabel">Rankings Report</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
              <div id="reportContent"></div>
          </div>
          <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
              <button type="button" class="btn btn-primary" onclick="window.print()">Print Report</button>
          </div>
      </div>
  </div>
</div>

<!-- Client Activity Timeline --> 
<div class="row mt-4">
  <div class="col-12">
    <div class="card">
      <div class="card-header pb-0">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Activity Timeline</h5>
            <p class="text-sm mb-0 text-muted">
              <i class="fas fa-history me-1"></i> Track all changes and activities
            </p>
          </div>
          <div class="d-flex gap-2">
            <div class="btn-group">
              <button type="button" class="btn btn-outline-primary btn-sm dropdown-toggle" data-bs-toggle="dropdown">
                <i class="fas fa-filter me-1"></i>Filter
              </button>
              <ul class="dropdown-menu">
                <li><a class="dropdown-item active" href="#" data-filter="all">All Activities</a></li>
                <li><hr class="dropdown-divider"></li>
                <li><a class="dropdown-item" href="#" data-filter="keyword">Keywords</a></li>
                <li><a class="dropdown-item" href="#" data-filter="project">Projects</a></li>
                <li><a class="dropdown-item" href="#" data-filter="ranking">Rankings</a></li>
                <li><a class="dropdown-item" href="#" data-filter="analytics">Analytics</a></li>
              </ul>
            </div>
            <button type="button" class="btn btn-sm bg-gradient-dark" id="exportActivityBtn">
              <i class="fas fa-download me-1"></i>Export
            </button>
          </div>
        </div>
      </div>
      <div class="card-body pt-4">
        <div class="timeline timeline-one-side" data-timeline-axis-style="dashed">
          {% include 'seo_manager/includes/activity_items.html' %}
          {% if not client_activities %}
            <div class="text-center py-4">
              <div class="icon icon-shape icon-sm bg-gradient-secondary shadow text-center mb-3 mx-auto">
                <i class="fas fa-history text-white opacity-10"></i>
              </div>
              <h6 class="text-dark">No activity recorded</h6>
              <p class="text-secondary text-sm">Activities will appear here as changes are made.</p>
            </div>
          {% endif %}
        </div>

        <!-- Load More Button -->
        {% if client_activities.count > 10 %}
          <div class="text-center mt-4">
            <button type="button" class="btn btn-outline-primary btn-sm" id="loadMoreActivities">
              <i class="fas fa-sync me-1"></i>Load More
            </button>
          </div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

    <div class="col-md-6">


      <!-- Add this section below the Search Console Credentials section -->



  <!-- Add Delete Client Button -->
  <div class="row mt-4">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-body">
          <button id="deleteClientBtn" class="btn btn-danger" 
                  data-client-id="{{ client.id }}" 
                  data-client-name="{{ client.name }}">
            Delete Client
          </button>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Add this after the existing cards in client_detail.html -->

<!-- Add Business Objective Modal -->
<div class="modal fade" id="add-objective" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add Business Objective</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:add_business_objective' client.id %}" id="addObjectiveForm">
        {% csrf_token %}
        <div class="modal-body">
          <!-- Goal Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Goal</label>
            <textarea class="form-control" name="goal" rows="3" required></textarea>
            <small class="text-muted">What specific outcome do you want to achieve?</small>
          </div>
          
          <!-- Metric Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Metric</label>
            <textarea class="form-control" name="metric" rows="2" required></textarea>
            <small class="text-muted">Define the key metrics that will track progress</small>
          </div>
          
          <!-- Target Date Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Target Date</label>
            <input type="text" class="form-control datepicker" name="target_date" id="target_date" required>
            <small class="text-muted">When do you aim to achieve this objective?</small>
          </div>
          
          <!-- Status Field -->
          <div class="form-check form-switch mb-3">
            <input type="checkbox" class="form-check-input" name="status" checked>
            <label class="form-check-label ms-3">Active</label>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Objective</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Edit Business Objective Modal -->
<div class="modal fade" id="edit-objective" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Edit Business Objective</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:edit_business_objective' client.id 0 %}" id="editObjectiveForm">
        {% csrf_token %}
        <div class="modal-body">
          <!-- Goal Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Goal</label>
            <textarea class="form-control" name="goal" rows="3" required id="edit_goal"></textarea>
            <small class="text-muted">What specific outcome do you want to achieve?</small>
          </div>
          
          <!-- Metric Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Metric</label>
            <textarea class="form-control" name="metric" rows="2" required id="edit_metric"></textarea>
            <small class="text-muted">Define the key metrics that will track progress</small>
          </div>
          
          <!-- Target Date Field -->
          <div class="form-group mb-3">
            <label class="form-control-label">Target Date</label>
            <input type="text" class="form-control datepicker" name="target_date" id="edit_target_date" required>
            <small class="text-muted">When do you aim to achieve this objective?</small>
          </div>
          
          <!-- Status Field -->
          <div class="form-check form-switch mb-3">
            <input type="checkbox" class="form-check-input" name="status" id="edit_status">
            <label class="form-check-label ms-3">Active</label>
          </div>
          
          <input type="hidden" name="objective_index" id="edit_objective_index">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Update Objective</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Replace the existing keyword modals with this include -->
{% include 'seo_manager/includes/keyword_modals.html' %}

</div>

<!-- Modals -->
<div id="modals">
  <!-- Add Profile Modal -->
  <div class="modal fade" id="add-profile" ...>
    <!-- ... modal content ... -->
  </div>

  <!-- Edit Profile Modal -->
  <div class="modal fade" id="edit-profile" ...>
    <!-- ... modal content ... -->
  </div>

  <!-- Report Modal -->
  <div class="modal fade" id="reportModal" ...>
    <!-- ... modal content ... -->
  </div>

  <!-- Other modals -->
</div>

{% endblock content %}

{% block extra_js %}
<!-- Core Libraries - Load these first -->
<!-- SweetAlert2 -->
<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

<!-- Simple DataTables -->
<script src="{% static "assets/js/plugins/datatables.js" %}"></script>

<!-- Chart.js -->
<script src="{% static 'assets/js/plugins/chartjs.min.js' %}"></script>

<!-- Existing libraries -->
<script src="{% static 'assets/js/plugins/quill.min.js' %}"></script>

<!-- Add Flatpickr CSS and JS -->
<script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

<script>
  window.clientData = {
    clientId: {{ client.id }},
    urls: {
      collectRankings: "{% url 'seo_manager:collect_rankings' client.id %}",
      generateReport: "{% url 'seo_manager:generate_report' client.id %}",
      backfillRankings: "{% url 'seo_manager:backfill_rankings' client.id %}",
      generateMagicProfile: "{% url 'seo_manager:generate_magic_profile' client.id %}",
      profileGenerationComplete: "{% url 'seo_manager:profile_generation_complete' client.id %}",
      getToolStatus: "{% url 'agents:get_tool_status' 'TASK_ID' %}",
      deleteClient: "{% url 'seo_manager:delete_client' client.id %}",
      clientList: "{% url 'seo_manager:client_list' %}",
      loadMoreActivities: "{% url 'seo_manager:load_more_activities' client.id %}",
      exportActivities: "{% url 'seo_manager:export_activities' client.id %}",
      importFromSearchConsole: "{% url 'seo_manager:import_from_search_console' client.id %}"
    },
    keywords: [
      {% for keyword in client.targeted_keywords.all %}
        {
          id: {{ keyword.id }},
          history: [
            {% for entry in keyword.ranking_history.all %}
              {
                date: '{{ entry.date|date:"M d, Y" }}',
                position: {{ entry.average_position }},
                impressions: {{ entry.impressions }},
                clicks: {{ entry.clicks }},
                ctr: {{ entry.ctr }}
              }{% if not forloop.last %},{% endif %}
            {% endfor %}
          ]
        }{% if not forloop.last %},{% endif %}
      {% endfor %}
    ]
  };
</script>
<script src="{% static 'seo_manager/js/client_detail.js' %}?v={% now 'YmdHis' %}"></script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/client_form.html
================
{% extends "layouts/base.html" %}
{% load organization_tags %}

{% block title %} Create New Client {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Create New Client</h6>
        </div>
        <div class="card-body">
          <form method="post">
            {% csrf_token %}
            {% for field in form %}
              <div class="form-group">
                <label for="{{ field.id_for_label }}" class="form-control-label">{{ field.label }}</label>
                {{ field }}
                {% if field.errors %}
                  <div class="text-danger">
                    {% for error in field.errors %}
                      {{ error }}
                    {% endfor %}
                  </div>
                {% endif %}
                {% if field.help_text %}
                  <small class="form-text text-muted">{{ field.help_text }}</small>
                {% endif %}
              </div>
            {% endfor %}
            <div class="form-group">
              <button type="submit" class="btn btn-primary">Create Client</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>

</div>
{% endblock content %}

{% block extra_js %}
<!-- Remove any unnecessary JavaScript here -->
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/client_integrations.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Client Integrations - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h5 class="mb-0">Integrations</h5>
              <p class="text-sm mb-0 text-muted">
                <i class="fas fa-plug me-1"></i> Connected services and data sources
              </p>
            </div>
            <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-outline-primary btn-sm mb-0">
              <i class="fas fa-arrow-left me-2"></i>Back to Client
            </a>
          </div>
        </div>
        <div class="card-body">
          <div class="row">
            <!-- Google Analytics Card -->
            <div class="col-md-6">
              <div class="card card-plain">
                <div class="card-body p-3">
                  <div class="d-flex align-items-center mb-3">
                    <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md me-3">
                      <i class="fab fa-google text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1">Google Analytics</h6>
                      <span class="text-xs text-muted">Track website traffic and user behavior</span>
                    </div>
                    {% if client.ga_credentials %}
                      <span class="badge badge-sm bg-gradient-success ms-auto">Connected</span>
                    {% else %}
                      <span class="badge badge-sm bg-gradient-secondary ms-auto">Not Connected</span>
                    {% endif %}
                  </div>
                  
                  {% if client.ga_credentials %}
                    <div class="p-3 bg-gray-100 rounded-3 mb-3">
                      <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-chart-bar text-primary me-2"></i>
                        <span class="text-sm">View ID: {{ client.ga_credentials.view_id }}</span>
                      </div>
                      <div class="d-flex align-items-center">
                        <i class="fas fa-user text-primary me-2"></i>
                        <span class="text-sm">Client ID: {{ client.ga_credentials.ga_client_id }}</span>
                      </div>
                    </div>
                    <div class="d-flex gap-2">
                      <a href="{% url 'seo_manager:remove_ga_credentials' client.id %}?next=integrations" 
                         class="btn btn-sm btn-outline-danger"
                         onclick="return confirm('Are you sure you want to remove these credentials?')">
                        <i class="fas fa-unlink me-2"></i>Disconnect
                      </a>
                    </div>
                  {% else %}
                    <div class="d-grid gap-2">
                      <a href="{% url 'seo_manager:add_ga_credentials_oauth' client.id %}?next=integrations" class="btn btn-primary btn-sm">
                        <i class="fas fa-key me-2"></i>Connect with OAuth
                      </a>
                      <a href="{% url 'seo_manager:add_ga_credentials_service_account' client.id %}?next=integrations" class="btn btn-outline-primary btn-sm">
                        <i class="fas fa-user-shield me-2"></i>Use Service Account
                      </a>
                    </div>
                  {% endif %}
                </div>
              </div>
            </div>

            <!-- Search Console Card -->
            <div class="col-md-6">
              <div class="card card-plain">
                <div class="card-body p-3">
                  <div class="d-flex align-items-center mb-3">
                    <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md me-3">
                      <i class="fas fa-search text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1">Search Console</h6>
                      <span class="text-xs text-muted">Monitor search performance and rankings</span>
                    </div>
                    {% if client.sc_credentials %}
                      <span class="badge badge-sm bg-gradient-success ms-auto">Connected</span>
                    {% else %}
                      <span class="badge badge-sm bg-gradient-secondary ms-auto">Not Connected</span>
                    {% endif %}
                  </div>
                  
                  {% if client.sc_credentials %}
                    <div class="p-3 bg-gray-100 rounded-3 mb-3">
                      <div class="d-flex align-items-center">
                        <i class="fas fa-globe text-success me-2"></i>
                        <span class="text-sm">{{ client.sc_credentials.property_url }}</span>
                      </div>
                    </div>
                    <div class="d-flex gap-2">
                      <a href="{% url 'seo_manager:remove_sc_credentials' client.id %}?next=integrations" 
                         class="btn btn-sm btn-outline-danger"
                         onclick="return confirm('Are you sure you want to remove these credentials?')">
                        <i class="fas fa-unlink me-2"></i>Disconnect
                      </a>
                    </div>
                  {% else %}
                    <div class="d-grid gap-2">
                      <a href="{% url 'seo_manager:add_sc_credentials' client.id %}?next=integrations" class="btn btn-success btn-sm">
                        <i class="fas fa-key me-2"></i>Connect with OAuth
                      </a>
                      <a href="{% url 'seo_manager:add_sc_credentials_service_account' client.id %}?next=integrations" class="btn btn-outline-success btn-sm">
                        <i class="fas fa-user-shield me-2"></i>Use Service Account
                      </a>
                    </div>
                  {% endif %}
                </div>
              </div>
            </div>

            <!-- Google Ads Card -->
            <div class="col-md-6">
              <div class="card card-plain">
                <div class="card-body p-3">
                  <div class="d-flex align-items-center mb-3">
                    <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md me-3">
                      <i class="fas fa-ad text-lg opacity-10" aria-hidden="true"></i>
                    </div>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1">Google Ads</h6>
                      <span class="text-xs text-muted">Monitor and analyze ad campaigns</span>
                    </div>
                    {% if client.ads_credentials %}
                      <span class="badge badge-sm bg-gradient-success ms-auto">Connected</span>
                    {% else %}
                      <span class="badge badge-sm bg-gradient-secondary ms-auto">Not Connected</span>
                    {% endif %}
                  </div>
                  
                  {% if client.ads_credentials %}
                    <div class="p-3 bg-gray-100 rounded-3 mb-3">
                      <div class="d-flex align-items-center mb-2">
                        <i class="fas fa-id-card text-warning me-2"></i>
                        <span class="text-sm">Customer ID: {{ client.ads_credentials.customer_id }}</span>
                      </div>
                      <div class="d-flex align-items-center">
                        <i class="fas fa-envelope text-warning me-2"></i>
                        <span class="text-sm">{{ client.ads_credentials.user_email }}</span>
                      </div>
                    </div>
                    <div class="d-flex gap-2">
                      <a href="{% url 'seo_manager:remove_ads_credentials' client.id %}?next=integrations" 
                         class="btn btn-sm btn-outline-danger"
                         onclick="return confirm('Are you sure you want to remove these credentials?')">
                        <i class="fas fa-unlink me-2"></i>Disconnect
                      </a>
                    </div>
                  {% else %}
                    <div class="d-grid gap-2">
                      <a href="{% url 'seo_manager:initiate_ads_oauth' client.id %}?next=integrations" class="btn btn-warning btn-sm">
                        <i class="fas fa-key me-2"></i>Connect with OAuth
                      </a>
                    </div>
                  {% endif %}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/client_list.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Clients {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Clients</h5>
            <p class="text-sm mb-0">
              View and manage your SEO clients.
            </p>
          </div>
          <a href="#" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#add-client">Add Client</a>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="clients-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Client Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Website URL</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Group</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Created</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for client in clients %}
              <tr data-id="{{ client.id }}">
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'seo_manager:client_detail' client.id %}">{{ client.name }}</a>
                </td>
                <td class="text-sm font-weight-normal">
                  <a href="{{ client.website_url }}" target="_blank" rel="noopener noreferrer">{{ client.website_url }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ client.status }}</td>
                <td class="text-sm font-weight-normal">{{ client.group }}</td>
                <td class="text-sm font-weight-normal" data-order="{{ client.created_at|date:'Y-m-d' }}">
                  {{ client.created_at|date:"Y-m-d" }}
                </td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'seo_manager:client_detail' client.id %}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit client">
                    Edit
                  </a>
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Add this modal markup just before the closing content block -->
<div class="modal fade" id="add-client" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add New Client</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:add_client' %}" id="addClientForm">
        {% csrf_token %}
        <div class="modal-body">
          <div class="form-group">
            <label for="{{ form.name.id_for_label }}" class="form-control-label">Client Name</label>
            {{ form.name }}
            {% if form.name.errors %}
            <div class="text-danger text-xs">{{ form.name.errors }}</div>
            {% endif %}
          </div>
          
          <div class="form-group mt-3">
            <label for="{{ form.website_url.id_for_label }}" class="form-control-label">Website URL</label>
            {{ form.website_url }}
            {% if form.website_url.errors %}
            <div class="text-danger text-xs">{{ form.website_url.errors }}</div>
            {% endif %}
          </div>
          
          <div class="row mt-3">
            <div class="col-md-6">
              <div class="form-group">
                <label for="{{ form.status.id_for_label }}" class="form-control-label">Status</label>
                {{ form.status }}
                {% if form.status.errors %}
                <div class="text-danger text-xs">{{ form.status.errors }}</div>
                {% endif %}
              </div>
            </div>
            <div class="col-md-6">
              <div class="form-group">
                <label for="{{ form.group.id_for_label }}" class="form-control-label">Group</label>
                {{ form.group }}
                {% if form.group.errors %}
                <div class="text-danger text-xs">{{ form.group.errors }}</div>
                {% endif %}
              </div>
            </div>
          </div>
          
          <div class="form-group mt-3">
            <label for="{{ form.target_audience.id_for_label }}" class="form-control-label">Target Audience</label>
            {{ form.target_audience }}
            {% if form.target_audience.errors %}
            <div class="text-danger text-xs">{{ form.target_audience.errors }}</div>
            {% endif %}
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Client</button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#clients-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      perPageSelect: [25, 50, 100, 150]
    });
  </script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/dashboard.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Dashboard {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
      <div class="card h-100">
        <div class="card-body p-3 d-flex flex-column justify-content-between">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Total Clients</p>
                <h5 class="font-weight-bolder mb-0">
                  {{ clients.count }}
                </h5>
              </div>
            </div>
            <div class="col-4 text-end">
              <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Updated Meta-Tags Snapshot Card -->
    <div class="col-xl-4 col-sm-6 mb-xl-0 mb-2">
      <div class="card h-100">
        <div class="card-body p-3 d-flex flex-column justify-content-between">
          <div class="row">
            <div class="col-8">
              <div class="numbers">
                <p class="text-sm mb-0 text-capitalize font-weight-bold">Meta-Tags Snapshot</p>
                <div class="input-group input-group-sm mt-2">
                  <input type="url" id="snapshotUrl" class="form-control" placeholder="Enter URL">
                </div>
              </div>
            </div>
            <div class="col-4 text-end">
              <div id="createSnapshotBtn" class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md" style="cursor: pointer;">
                <i class="ni ni-paper-diploma text-lg opacity-10" aria-hidden="true"></i>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Add more summary cards here -->
  </div>
  
  <!-- Clients Table -->
  <div class="row mt-2">
    <div class="col-12">
      <div class="card">
        <!-- Card header -->
        <div class="card-header d-flex justify-content-between align-items-center">
          <div>
            <h5 class="mb-0">Clients</h5>
            <p class="text-sm mb-0">
              View and manage your SEO clients.
            </p>
          </div>
          <a href="#" class="btn btn-primary btn-sm" data-bs-toggle="modal" data-bs-target="#add-client">Add Client</a>
        </div>
        <div class="table-responsive">
          <table class="table table-flush" id="clients-table">
            <thead class="thead-light">
              <tr>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Client Name</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Website URL</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Status</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Group</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Created</th>
                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Actions</th>
              </tr>
            </thead>
            <tbody>
              {% for client in clients %}
              <tr data-id="{{ client.id }}">
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'seo_manager:client_detail' client.id %}" class="text-primary font-weight-bold">{{ client.name }}</a>
                </td>
                <td class="text-sm font-weight-normal">
                  <a href="{{ client.website_url }}" target="_blank" rel="noopener noreferrer">{{ client.website_url }}</a>
                </td>
                <td class="text-sm font-weight-normal">{{ client.status }}</td>
                <td class="text-sm font-weight-normal">{{ client.group }}</td>
                <td class="text-sm font-weight-normal" data-order="{{ client.created_at|date:'Y-m-d' }}">
                  {{ client.created_at|date:"Y-m-d" }}
                </td>
                <td class="text-sm font-weight-normal">
                  <a href="{% url 'seo_manager:client_detail' client.id %}" class="text-secondary font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit client">
                    Edit
                  </a>
                </td>
              </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Add the same modal markup just before the closing content block -->
<div class="modal fade" id="add-client" tabindex="-1" role="dialog" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Add New Client</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <form method="post" action="{% url 'seo_manager:add_client' %}" id="addClientForm">
        {% csrf_token %}
        <div class="modal-body">
          <div class="form-group">
            <label for="{{ form.name.id_for_label }}" class="form-control-label">Client Name</label>
            {{ form.name }}
            {% if form.name.errors %}
            <div class="text-danger text-xs">{{ form.name.errors }}</div>
            {% endif %}
          </div>
          
          <div class="form-group mt-3">
            <label for="{{ form.website_url.id_for_label }}" class="form-control-label">Website URL</label>
            {{ form.website_url }}
            {% if form.website_url.errors %}
            <div class="text-danger text-xs">{{ form.website_url.errors }}</div>
            {% endif %}
          </div>
          
          <div class="row mt-3">
            <div class="col-md-6">
              <div class="form-group">
                <label for="{{ form.status.id_for_label }}" class="form-control-label">Status</label>
                {{ form.status }}
                {% if form.status.errors %}
                <div class="text-danger text-xs">{{ form.status.errors }}</div>
                {% endif %}
              </div>
            </div>
            <div class="col-md-6">
              <div class="form-group">
                <label for="{{ form.group.id_for_label }}" class="form-control-label">Group</label>
                {{ form.group }}
                {% if form.group.errors %}
                <div class="text-danger text-xs">{{ form.group.errors }}</div>
                {% endif %}
              </div>
            </div>
          </div>
          
          <div class="form-group mt-3">
            <label for="{{ form.target_audience.id_for_label }}" class="form-control-label">Target Audience</label>
            {{ form.target_audience }}
            {% if form.target_audience.errors %}
            <div class="text-danger text-xs">{{ form.target_audience.errors }}</div>
            {% endif %}
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn bg-gradient-secondary" data-bs-dismiss="modal">Close</button>
          <button type="submit" class="btn bg-gradient-primary">Add Client</button>
        </div>
      </form>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_css %}
<style>
  .card.h-100 {
    display: flex;
    flex-direction: column;
  }
  .card-body {
    flex: 1 0 auto;
  }
</style>
{% endblock extra_css %}

{% block extra_js %}
  {{ block.super }}
  <script src="{% static 'assets/js/plugins/datatables.js' %}"></script>
  <script>
    const dataTableSearch = new simpleDatatables.DataTable("#clients-table", {
      searchable: true,
      fixedHeight: true,
      perPage: 25,
      perPageSelect: [25, 50, 100, 150]
    });

    // Meta-Tags Snapshot functionality
    document.addEventListener('DOMContentLoaded', function() {
      var createSnapshotBtn = document.getElementById('createSnapshotBtn');
      var snapshotUrlInput = document.getElementById('snapshotUrl');

      if (createSnapshotBtn && snapshotUrlInput) {
        createSnapshotBtn.addEventListener('click', function(e) {
          e.preventDefault();
          
          var url = snapshotUrlInput.value.trim();
          if (!url) {
            Swal.fire({
              title: 'Error!',
              text: 'Please enter a valid URL.',
              icon: 'error',
              confirmButtonText: 'OK'
            });
            return;
          }

          // Show a loading message
          Swal.fire({
            title: 'Creating snapshot...',
            text: 'This may take a few minutes.',
            allowOutsideClick: false,
            allowEscapeKey: false,
            showConfirmButton: false,
            willOpen: () => {
              Swal.showLoading();
            }
          });
          
          // Send the request to create the snapshot
          fetch('{% url "seo_manager:create_meta_tags_snapshot_url" %}', {
            method: 'POST',
            headers: {
              'X-CSRFToken': '{{ csrf_token }}',
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ url: url })
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              Swal.fire({
                title: 'Success!',
                text: data.message,
                icon: 'success',
                confirmButtonText: 'OK'
              });
            } else {
              Swal.fire({
                title: 'Error!',
                text: data.message,
                icon: 'error',
                confirmButtonText: 'OK'
              });
            }
          })
          .catch(error => {
            console.error('Error:', error);
            Swal.fire({
              title: 'Error!',
              text: 'An error occurred while creating the snapshot.',
              icon: 'error',
              confirmButtonText: 'OK'
            });
          });
        });
      }
    });
  </script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/edit_business_objective.html
================
{% extends "layouts/base.html" %}

{% block title %} Edit Business Objective - {{ client.name }} {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex align-items-center">
            <h6 class="mb-0">Edit Business Objective</h6>
          </div>
          <p class="text-sm mb-0">Update business objective details for {{ client.name }}</p>
        </div>
        <div class="card-body">
          <form method="post">
            {% csrf_token %}
            <div class="row">
              <div class="col-md-12 mb-4">
                <label class="form-label">Business Objective</label>
                {{ form.goal }}
                {% if form.goal.help_text %}
                  <div class="form-text text-muted">{{ form.goal.help_text }}</div>
                {% endif %}
              </div>
              
              <div class="col-md-12 mb-4">
                <label class="form-label">Success Metrics</label>
                {{ form.metric }}
                {% if form.metric.help_text %}
                  <div class="form-text text-muted">{{ form.metric.help_text }}</div>
                {% endif %}
              </div>

              <div class="col-md-6 mb-4">
                <label class="form-label">Target Date</label>
                {{ form.target_date }}
                {% if form.target_date.help_text %}
                  <div class="form-text text-muted">{{ form.target_date.help_text }}</div>
                {% endif %}
              </div>

              <div class="col-md-6 mb-4">
                <div class="form-check form-switch mt-4">
                  {{ form.status }}
                  <label class="form-check-label" for="{{ form.status.id_for_label }}">
                    Active Objective
                  </label>
                </div>
              </div>
            </div>

            <div class="d-flex justify-content-end mt-4">
              <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-light m-0 me-2">Cancel</a>
              <button type="submit" class="btn bg-gradient-primary m-0">Update Objective</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script>
  document.addEventListener("DOMContentLoaded", function() {
    flatpickr(".flatpickr-date", {
      dateFormat: "Y-m-d",
      allowInput: true
    });
  });
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/edit_client.html
================
{% extends "layouts/base.html" %}

{% block title %} Edit Client - {{ client.name }} {% endblock %}

{% block content %}

<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mt-4" id="basic-info">
        <div class="card-header">
          <h5>Edit Client: {{ client.name }}</h5>
        </div>
        <div class="card-body pt-0">
          <form method="post">
            {% csrf_token %}
            <div class="row">
              <div class="col-6">
                <label class="form-label">Name</label><br>
                <div class="input-group">
                  {{ form.name }}
                </div>
              </div>
              <div class="col-6">
                <label class="form-label">Website URL</label><br>
                <div class="input-group">
                  {{ form.website_url }}
                </div>
              </div>
            </div>
            <div class="row">
              <div class="col-6">
                <label class="form-label mt-4">Status</label><br>
                {{ form.status }}
              </div>
              <div class="col-6">
                <label class="form-label mt-4">Group</label><br>
                {{ form.group }}
              </div>
            </div>
            <div class="row">
              <div class="col-12">
                <label class="form-label mt-4">Target Audience</label><br>
                <div class="input-group">
                  {{ form.target_audience }}
                </div>
              </div>
            </div>
            <div class="row">
              <div class="col-12 mt-4">
                <button type="submit" class="btn bg-gradient-dark btn-sm float-end mt-6 mb-0">Update Client</button>
                <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-outline-secondary btn-sm float-end mt-6 mb-0 me-2">Cancel</a>
              </div>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
  // Add any necessary JavaScript for the edit client form
</script>
{% endblock extra_js %}

================
File: apps/seo_manager/templates/seo_manager/input_view_id.html
================
{% extends "layouts/base.html" %}

{% block title %} Input Google Analytics View ID {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Input Google Analytics View ID for {{ client.name }}</h6>
        </div>
        <div class="card-body">
          <form method="post">
            {% csrf_token %}
            <div class="form-group">
              <label for="view_id">Google Analytics View ID</label>
              <input type="text" class="form-control" id="view_id" name="view_id" required>
            </div>
            <button type="submit" class="btn btn-primary">Submit</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

================
File: apps/seo_manager/templates/seo_manager/ranking_data_management.html
================
{% extends "layouts/base.html" %}
{% load static %}
{% load seo_manager_filters %}

{% block title %} Ranking Data Management - {{ client.name }} {% endblock %}

{% block content %}

<div class="container-fluid py-4">
    <div class="row">
        <div class="d-flex justify-content-between mb-4">
            <div>
                <h5 class="mb-0">Ranking Data Management - {{ client.name }}</h5>
                <p class="text-sm mb-0">Detailed view of Search Console ranking data</p>
            </div>
            <div class="d-flex gap-2">
                <button type="button" class="btn bg-gradient-primary btn-sm" id="collectRankingsBtn">
                    <i class="fas fa-sync"></i>&nbsp;&nbsp;Collect Latest Rankings
                </button>
                <button type="button" class="btn bg-gradient-info btn-sm" id="generateReportBtn">
                    <i class="fas fa-file-alt"></i>&nbsp;&nbsp;Generate Report
                </button>
                <button type="button" class="btn btn-outline-primary btn-sm" id="backfillRankingsBtn">
                    Backfill Historical Data
                </button>
            </div>
        </div>

        <!-- Stats Cards Row -->
        <div class="row mb-4">
            <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
                <div class="card">
                    <div class="card-body p-3">
                        <div class="row">
                            <div class="col-8">
                                <div class="numbers">
                                    <p class="text-sm mb-0 text-capitalize font-weight-bold">Last Collection</p>
                                    <h5 class="font-weight-bolder mb-0">
                                        {% if latest_collection_date %}
                                            {{ latest_collection_date|date:"M d, Y" }}
                                        {% else %}
                                            No Data
                                        {% endif %}
                                    </h5>
                                </div>
                            </div>
                            <div class="col-4 text-end">
                                <div class="icon icon-shape bg-gradient-primary shadow text-center border-radius-md">
                                    <i class="ni ni-calendar-grid-58 text-lg opacity-10" aria-hidden="true"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
                <div class="card">
                    <div class="card-body p-3">
                        <div class="row">
                            <div class="col-8">
                                <div class="numbers">
                                    <p class="text-sm mb-0 text-capitalize font-weight-bold">Data Coverage</p>
                                    <h5 class="font-weight-bolder mb-0">
                                        {{ data_coverage_months }} months
                                    </h5>
                                </div>
                            </div>
                            <div class="col-4 text-end">
                                <div class="icon icon-shape bg-gradient-info shadow text-center border-radius-md">
                                    <i class="ni ni-chart-bar-32 text-lg opacity-10" aria-hidden="true"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-xl-3 col-sm-6 mb-xl-0 mb-4">
                <div class="card">
                    <div class="card-body p-3">
                        <div class="row">
                            <div class="col-8">
                                <div class="numbers">
                                    <p class="text-sm mb-0 text-capitalize font-weight-bold">Keywords Tracked</p>
                                    <h5 class="font-weight-bolder mb-0">
                                        {{ tracked_keywords_count }}
                                    </h5>
                                </div>
                            </div>
                            <div class="col-4 text-end">
                                <div class="icon icon-shape bg-gradient-success shadow text-center border-radius-md">
                                    <i class="ni ni-collection text-lg opacity-10" aria-hidden="true"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-xl-3 col-sm-6">
                <div class="card">
                    <div class="card-body p-3">
                        <div class="row">
                            <div class="col-8">
                                <div class="numbers">
                                    <p class="text-sm mb-0 text-capitalize font-weight-bold">Status</p>
                                    <h5 class="font-weight-bolder mb-0">
                                        {% if latest_collection_date %}
                                            <span class="text-success">Active</span>
                                        {% else %}
                                            <span class="text-warning">No Data</span>
                                        {% endif %}
                                    </h5>
                                </div>
                            </div>
                            <div class="col-4 text-end">
                                <div class="icon icon-shape bg-gradient-warning shadow text-center border-radius-md">
                                    <i class="ni ni-check-bold text-lg opacity-10" aria-hidden="true"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Add this section for search and controls -->
        <div class="d-flex justify-content-between mb-4">
            <form class="search">
                <div class="d-flex gap-3 align-items-start">
                    <input type="text" placeholder="Search for keywords" name="search" value="{{ search_query }}" class="form-control">
                    <button type="submit" class="btn btn-primary px-3">
                        <i class="fas fa-search"></i>
                    </button>
                </div>
            </form>
            <div class="hide-show">
                <form method="post">
                    <div class="dropdown">
                        <button class="btn btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                            Hide / Show Column
                        </button>
                        <div id="dropdownDefaultCheckbox">
                            <ul class="dropdown-menu hide-show-dropdown px-3">
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="keyword_text" value="" id="checkbox-keyword">
                                    <label class="form-check-label" for="checkbox-keyword">Keyword</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="position" value="" id="checkbox-position">
                                    <label class="form-check-label" for="checkbox-position">Position</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="change" value="" id="checkbox-change">
                                    <label class="form-check-label" for="checkbox-change">Change</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="impressions" value="" id="checkbox-impressions">
                                    <label class="form-check-label" for="checkbox-impressions">Impressions</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="clicks" value="" id="checkbox-clicks">
                                    <label class="form-check-label" for="checkbox-clicks">Clicks</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="ctr" value="" id="checkbox-ctr">
                                    <label class="form-check-label" for="checkbox-ctr">CTR</label>
                                </div>
                                <div class="form-check mb-2">
                                    <input class="form-check-input" type="checkbox" data-target="date" value="" id="checkbox-date">
                                    <label class="form-check-label" for="checkbox-date">Date</label>
                                </div>
                            </ul>
                        </div>
                    </div>
                </form>
            </div>
            <div class="page-size">
                <div class="d-flex gap-2">
                    <form method="post">
                        {% csrf_token %}
                        <select onchange="getPageItems(this)" name="" id="" class="form-select">
                            <option {% if items == 25 %} selected {% endif %} value="25">25 Items</option>
                            <option {% if items == 100 %} selected {% endif %} value="100">100 Items</option>
                            <option {% if items == 250 %} selected {% endif %} value="250">250 Items</option>
                            <option {% if items == 500 %} selected {% endif %} value="500">500 Items</option>
                            <option {% if items == 1000 %} selected {% endif %} value="1000">1000 Items</option>
                        </select>
                    </form>
                    <div class="d-flex">
                        <a data-bs-toggle="modal" data-bs-target="#exportCSV">
                            <img class="export-csv-img" src="{% static 'assets/img/csv.png' %}" alt="">
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Update your table section -->
        <div class="card">
            <div class="card-header">
                <h5>Rankings History</h5>
                <small>Complete history of keyword rankings with filtering and sorting capabilities.</small>
            </div>
            <div class="card-body">
                <div class="table-responsive">
                    <table id="rankings-table" class="table align-items-center mb-0">
                        <thead>
                            <tr>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Keyword</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Position</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Change</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Impressions</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Clicks</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">CTR</th>
                                <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Date</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% for ranking in rankings %}
                            <tr>
                                <td>
                                    <div class="d-flex px-2 py-1">
                                        <div class="d-flex flex-column justify-content-center">
                                            <h6 class="mb-0 text-sm">{{ ranking.keyword_text }}</h6>
                                        </div>
                                    </div>
                                </td>
                                <td>
                                    <p class="text-sm font-weight-bold mb-0">{{ ranking.average_position|floatformat:1 }}</p>
                                </td>
                                <td>
                                    {% with change=ranking.position_change %}
                                        {% if change > 0 %}
                                            <span class="text-success text-sm font-weight-bolder">
                                                <i class="fas fa-arrow-up"></i> {{ change|floatformat:1 }}
                                            </span>
                                        {% elif change < 0 %}
                                            <span class="text-danger text-sm font-weight-bolder">
                                                <i class="fas fa-arrow-down"></i> {{ change|floatformat:1|slice:"1:" }}
                                            </span>
                                        {% else %}
                                            <span class="text-secondary text-sm">
                                                <i class="fas fa-minus"></i>
                                            </span>
                                        {% endif %}
                                    {% endwith %}
                                </td>
                                <td>
                                    <p class="text-sm font-weight-bold mb-0">{{ ranking.impressions }}</p>
                                </td>
                                <td>
                                    <p class="text-sm font-weight-bold mb-0">{{ ranking.clicks }}</p>
                                </td>
                                <td>
                                    <p class="text-sm font-weight-bold mb-0">{{ ranking.ctr|floatformat:2 }}%</p>
                                </td>
                                <td>
                                    <p class="text-sm font-weight-bold mb-0">{{ ranking.date|date:"M d, Y" }}</p>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add the export CSV modal -->
<div class="modal fade" id="exportCSV" tabindex="-1" aria-labelledby="exportCSVLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <div class="d-flex justify-content-between">
                    <div>
                        <h1 class="modal-title fs-5" id="exportCSVLabel">Export as CSV</h1>
                    </div>
                    <div>
                        <a href="{% url 'seo_manager:export_rankings_csv' client.id %}{% if search_query %}?search={{ search_query }}{% endif %}">
                            <img class="export-img" src="{% static 'assets/img/export.png' %}" alt="">
                        </a>
                    </div>
                    <div>
                        <button type="button" class="btn-close text-dark" data-bs-dismiss="modal" aria-label="Close">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div class="modal-body">
                <!-- Add a preview table here -->
            </div>
        </div>
    </div>
</div>

<!-- Add the report modal -->
<div class="modal fade" id="reportModal" tabindex="-1" aria-labelledby="reportModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="reportModalLabel">Rankings Report</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div id="reportContent"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary" onclick="window.print()">Print Report</button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block extra_js %}
{{ block.super }}
<!-- DataTables -->
<script src="{% static "assets/js/plugins/datatables.js" %}"></script>

<!-- SweetAlert2 -->
<script src="{% static "assets/js/plugins/sweetalert.min.js" %}"></script>

<!-- Pass URLs to JavaScript -->
<script>
    const urls = {
        collectRankings: "{% url 'seo_manager:collect_rankings' client.id %}",
        generateReport: "{% url 'seo_manager:generate_report' client.id %}",
        backfillRankings: "{% url 'seo_manager:backfill_rankings' client.id %}"
    };
    // Make urls globally available
    Object.defineProperty(window, 'urls', {
        value: urls,
        writable: false,
        configurable: false
    });
</script>

<!-- Custom JS -->
<script src="{% static 'seo_manager/js/ranking_data_management.js' %}?v={% now 'YmdHis' %}"></script>
{% endblock extra_js %}

{% block extrastyle %}
<style>
    .hide-show-dropdown {
        max-height: 350px;
        overflow-y: scroll;
    }
    .page-size .export-csv-img {
        width: 35px;
        cursor: pointer;
    }
    .export-img {
        width: 30px;
    }
    .modal-header {
        display: block !important;
    }
    .height {
        height: 40px !important;
    }
    th a {
        display: flex;
        align-items: center;
        justify-content: space-between;
        text-decoration: none;
    }
    th a:hover {
        text-decoration: none;
        opacity: 0.8;
    }
    th a i {
        margin-left: 5px;
    }
    .fa-sort {
        color: #ccc;
    }
    .fa-sort-up, .fa-sort-down {
        color: #344767;
    }
    #reportContent {
        padding: 20px;
    }
    @media print {
        body * {
            visibility: hidden;
        }
        #reportModal, #reportModal * {
            visibility: visible;
        }
        #reportModal {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
        }
    }
    .dataTables_wrapper .dataTables_filter {
        float: left;
        margin-bottom: 1rem;
    }
    .dataTables_wrapper .dataTables_filter input {
        width: 300px;
    }
    .dataTables_wrapper .dataTables_length {
        float: right;
    }
    .dataTables_wrapper .dataTables_info {
        clear: both;
        padding-top: 1rem;
    }
    .dataTables_wrapper .dataTables_paginate {
        padding-top: 1rem;
    }
</style>
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/select_ads_account.html
================
{% extends "seo_manager/base.html" %}
{% load static %}

{% block content %}
<div class="container mt-4">
    <h2>Select Google Ads Account</h2>
    <p class="lead">Select the Google Ads account you want to connect for {{ client.name }}</p>

    {% if messages %}
    <div class="messages">
        {% for message in messages %}
        <div class="alert alert-{{ message.tags }}">
            {{ message }}
        </div>
        {% endfor %}
    </div>
    {% endif %}

    <div class="card">
        <div class="card-body">
            <form method="post" action="{% url 'seo_manager:select_ads_account' client.id %}">
                {% csrf_token %}
                
                <div class="form-group">
                    <label for="selected_customer_id">Select Account:</label>
                    <select class="form-control" id="selected_customer_id" name="selected_customer_id" required>
                        <option value="">Choose an account...</option>
                        {% for account in customer_ids %}
                        <option value="{{ account.id }}">{{ account.name }} ({{ account.id }})</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">
                        Select the Google Ads account you want to connect. This is typically your main advertising account.
                    </small>
                </div>

                <div class="form-group">
                    <label for="selected_login_customer_id">Manager Account ID (Optional):</label>
                    <select class="form-control" id="selected_login_customer_id" name="selected_login_customer_id">
                        <option value="">None (Direct Access)</option>
                        {% for account in customer_ids %}
                        <option value="{{ account.id }}">{{ account.name }} ({{ account.id }})</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">
                        If you're accessing this account through a manager account (MCC), select it here. Otherwise, leave as "None".
                    </small>
                </div>

                <div class="mt-4">
                    <button type="submit" class="btn btn-primary">Connect Account</button>
                    <a href="{% url 'seo_manager:client_integrations' client.id %}" class="btn btn-secondary ml-2">Cancel</a>
                </div>
            </form>
        </div>
    </div>
</div>

{% block extra_js %}
<script>
    // Optional: Add any client-side validation or UI enhancement here
    document.addEventListener('DOMContentLoaded', function() {
        const customerSelect = document.getElementById('selected_customer_id');
        const managerSelect = document.getElementById('selected_login_customer_id');

        // Prevent selecting same account for both dropdowns
        customerSelect.addEventListener('change', function() {
            const selectedValue = this.value;
            Array.from(managerSelect.options).forEach(option => {
                if (option.value === selectedValue) {
                    option.disabled = true;
                } else {
                    option.disabled = false;
                }
            });
        });
    });
</script>
{% endblock %}
{% endblock %}

================
File: apps/seo_manager/templates/seo_manager/select_analytics_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Select Analytics Account - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-lg-flex">
            <div>
              <h5 class="mb-0">Select Google Analytics Account</h5>
              <p class="text-sm mb-0">Choose the Analytics property to connect for {{ client.name }}</p>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0" id="analytics-properties-table">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Property Name</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Property ID</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Account</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for account in accounts %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">{{ account.property_name }}</h6>
                      </div>
                    </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ account.property_id }}</p>
                  </td>
                  <td>
                    <p class="text-xs text-secondary mb-0">{{ account.account_name }}</p>
                  </td>
                  <td class="align-middle text-center">
                    <form method="post" class="d-inline">
                      {% csrf_token %}
                      <input type="hidden" name="selected_account" value="{{ account.property_id }}">
                      {% if next %}
                      <input type="hidden" name="next" value="{{ next }}">
                      {% endif %}
                      <button type="submit" class="btn btn-link text-secondary mb-0">
                        <span class="bg-gradient-primary btn px-3 mb-0 text-white">Select</span>
                      </button>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="d-flex justify-content-end">
        <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-light m-0">
          <span class="btn-inner--icon"><i class="fas fa-times"></i></span>
          <span class="btn-inner--text">Cancel</span>
        </a>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="/static/assets/js/plugins/datatables.js"></script>
<script>
  if (document.getElementById('analytics-properties-table')) {
    const dataTableSearch = new simpleDatatables.DataTable("#analytics-properties-table", {
      searchable: true,
      fixedHeight: false,
      perPage: 10,
      columns: [
        { select: [3], sortable: false }
      ]
    });
  }
</script>
{% endblock extra_js %}

{% block extra_css %}
{{ block.super }}
<style>
  .dataTable-wrapper .dataTable-container {
    font-size: 0.875rem;
  }
  
  .dataTable-wrapper .dataTable-top {
    padding: 1rem 1.5rem;
  }
  
  .dataTable-wrapper .dataTable-search {
    float: right;
  }
  
  .dataTable-wrapper .dataTable-input {
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid #d2d6da;
  }
  
  .dataTable-wrapper .dataTable-info {
    margin: 0;
    font-size: 0.75rem;
  }
  
  .table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .dataTable-pagination .active a, 
  .dataTable-pagination .active a:hover {
    background-color: #cb0c9f;
    border-color: #cb0c9f;
    color: white;
  }
  
  .dataTable-pagination a {
    border-radius: 0.5rem;
    margin: 0 3px;
  }
  
  .dataTable-pagination a:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
  }
</style>
{% endblock extra_css %}

================
File: apps/seo_manager/templates/seo_manager/select_search_console_property.html
================
{% extends "layouts/base.html" %}

{% block title %} Select Search Console Property - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-lg-flex">
            <div>
              <h5 class="mb-0">Select Google Search Console Property</h5>
              <p class="text-sm mb-0">Choose the Search Console property to connect for {{ client.name }}</p>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0" id="search-console-properties-table">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Property URL</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Permission Level</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Owner Verified</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for property in properties %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">{{ property.url }}</h6>
                      </div>
                    </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ property.permission_level }}</p>
                  </td>
                  <td>
                    <p class="text-xs text-secondary mb-0">{{ property.owner_verified|yesno:"Yes,No" }}</p>
                  </td>
                  <td class="align-middle text-center">
                    <form method="post" class="d-inline">
                      {% csrf_token %}
                      <input type="hidden" name="selected_property" value="{{ property.url }}">
                      <button type="submit" class="btn btn-link text-secondary mb-0">
                        <span class="bg-gradient-primary btn px-3 mb-0 text-white">Select</span>
                      </button>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="d-flex justify-content-end">
        <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-light m-0">
          <span class="btn-inner--icon"><i class="fas fa-times"></i></span>
          <span class="btn-inner--text">Cancel</span>
        </a>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="/static/assets/js/plugins/datatables.js"></script>
<script>
  if (document.getElementById('search-console-properties-table')) {
    const dataTableSearch = new simpleDatatables.DataTable("#search-console-properties-table", {
      searchable: true,
      fixedHeight: false,
      perPage: 10,
      columns: [
        { select: [3], sortable: false }
      ]
    });
  }
</script>
{% endblock extra_js %}

{% block extra_css %}
{{ block.super }}
<style>
  .dataTable-wrapper .dataTable-container {
    font-size: 0.875rem;
  }
  
  .dataTable-wrapper .dataTable-top {
    padding: 1rem 1.5rem;
  }
  
  .dataTable-wrapper .dataTable-search {
    float: right;
  }
  
  .dataTable-wrapper .dataTable-input {
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid #d2d6da;
  }
  
  .dataTable-wrapper .dataTable-info {
    margin: 0;
    font-size: 0.75rem;
  }
  
  .table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .dataTable-pagination .active a, 
  .dataTable-pagination .active a:hover {
    background-color: #cb0c9f;
    border-color: #cb0c9f;
    color: white;
  }
  
  .dataTable-pagination a {
    border-radius: 0.5rem;
    margin: 0 3px;
  }
  
  .dataTable-pagination a:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
  }
</style>
{% endblock extra_css %}

================
File: apps/seo_manager/templates/seo_manager/select_search_console.html
================
{% extends "layouts/base.html" %}

{% block title %} Select Search Console Property - {{ client.name }} {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <div class="d-lg-flex">
            <div>
              <h5 class="mb-0">Select Search Console Property</h5>
              <p class="text-sm mb-0">Choose the Search Console property to connect for {{ client.name }}</p>
            </div>
          </div>
        </div>
        <div class="card-body px-0 pt-0 pb-2">
          <div class="table-responsive p-0">
            <table class="table align-items-center mb-0" id="search-console-table">
              <thead>
                <tr>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7">Website URL</th>
                  <th class="text-uppercase text-secondary text-xxs font-weight-bolder opacity-7 ps-2">Permission Level</th>
                  <th class="text-secondary opacity-7"></th>
                </tr>
              </thead>
              <tbody>
                {% for property in properties %}
                <tr>
                  <td>
                    <div class="d-flex px-2 py-1">
                      <div class="d-flex flex-column justify-content-center">
                        <h6 class="mb-0 text-sm">{{ property.url }}</h6>
                      </div>
                    </div>
                  </td>
                  <td>
                    <p class="text-xs font-weight-bold mb-0">{{ property.permission_level }}</p>
                  </td>
                  <td class="align-middle text-center">
                    <form method="post" class="d-inline">
                      {% csrf_token %}
                      <input type="hidden" name="selected_property" value="{{ property.url }}">
                      <button type="submit" class="btn btn-link text-secondary mb-0">
                        <span class="bg-gradient-primary btn-sm px-3 mb-0 text-white">Select</span>
                      </button>
                    </form>
                  </td>
                </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="d-flex justify-content-end">
        <a href="{% url 'seo_manager:client_detail' client.id %}" class="btn btn-light m-0">
          <span class="btn-inner--icon"><i class="fas fa-times"></i></span>
          <span class="btn-inner--text">Cancel</span>
        </a>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<script src="/static/assets/js/plugins/datatables.js"></script>
<script>
  if (document.getElementById('search-console-table')) {
    const dataTableSearch = new simpleDatatables.DataTable("#search-console-table", {
      searchable: true,
      fixedHeight: false,
      perPage: 10,
      columns: [
        { select: [2], sortable: false }
      ]
    });
  }
</script>
{% endblock extra_js %}

{% block extra_css %}
{{ block.super }}
<style>
  .dataTable-wrapper .dataTable-container {
    font-size: 0.875rem;
  }
  
  .dataTable-wrapper .dataTable-top {
    padding: 1rem 1.5rem;
  }
  
  .dataTable-wrapper .dataTable-search {
    float: right;
  }
  
  .dataTable-wrapper .dataTable-input {
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: 1px solid #d2d6da;
  }
  
  .dataTable-wrapper .dataTable-info {
    margin: 0;
    font-size: 0.75rem;
  }
  
  .table tbody tr:last-child td {
    border-bottom: none;
  }
  
  .dataTable-pagination .active a, 
  .dataTable-pagination .active a:hover {
    background-color: #cb0c9f;
    border-color: #cb0c9f;
    color: white;
  }
  
  .dataTable-pagination a {
    border-radius: 0.5rem;
    margin: 0 3px;
  }
  
  .dataTable-pagination a:hover {
    background-color: #f8f9fa;
    border-color: #dee2e6;
  }
</style>
{% endblock extra_css %}

================
File: apps/seo_manager/templates/seo_manager/setup_service_account.html
================
{% extends "layouts/base.html" %}

{% block title %} Setup Google Analytics Service Account {% endblock %}

{% block content %}
<div class="container-fluid py-4">
  <div class="row">
    <div class="col-12">
      <div class="card mb-4">
        <div class="card-header pb-0">
          <h6>Setup Google Analytics Service Account for {{ client.name }}</h6>
        </div>
        <div class="card-body">
          <form method="post">
            {% csrf_token %}
            <div class="form-group">
              <label for="service_account_json">Service Account JSON</label>
              <textarea class="form-control" id="service_account_json" name="service_account_json" rows="10" required></textarea>
            </div>
            <button type="submit" class="btn btn-primary">Submit</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock content %}

================
File: apps/seo_manager/templatetags/__init__.py
================
# Empty file, just needs to exist

================
File: apps/seo_manager/templatetags/custom_filters.py
================
from django import template
from datetime import datetime

register = template.Library()

@register.filter(name='format_iso_date')
def format_iso_date(value, format_string):
  try:
      date = datetime.fromisoformat(value)
      return date.strftime(format_string)
  except (ValueError, TypeError):
      return value  # Return the original value if parsing fails

================
File: apps/seo_manager/templatetags/form_tags.py
================
from django import template

register = template.Library()

@register.filter(name='addclass')
def addclass(field, css_class):
    return field.as_widget(attrs={"class": css_class})

================
File: apps/seo_manager/templatetags/seo_manager_filters.py
================
from django import template
import os

register = template.Library()

@register.filter
def abs_value(value):
    try:
        return abs(value)
    except (TypeError, ValueError):
        return value

@register.filter
def basename(value):
    """Return the basename of a path."""
    return os.path.basename(str(value))

@register.filter
def split(value, arg):
    return value.split(arg)

@register.filter
def get_item(dictionary, key):
    """Get an item from a dictionary."""
    return dictionary.get(key, '')

@register.filter
def dictsortby(value, arg):
    """Return a list of dictionaries sorted by the given key."""
    if not value:
        return []
    return [item for item in value if arg in item and item[arg]]

================
File: apps/seo_manager/templatetags/seo_tags.py
================
from django import template

register = template.Library()

@register.filter
def get_item(dictionary, key):
    """Get an item from a dictionary using bracket notation"""
    return dictionary.get(key)

@register.filter
def get_initial_rank(project, keyword):
    """Get initial rank for a keyword from a project"""
    return project.get_initial_rank(keyword)

================
File: apps/seo_manager/utils/meta_tags_analyzer.py
================
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin
import xml.etree.ElementTree as ET

def analyze_website_meta_tags(website_url):
    try:
        # Get sitemap URL
        sitemap_url = urljoin(website_url, 'sitemap.xml')
        
        # Fetch sitemap
        response = requests.get(sitemap_url)
        root = ET.fromstring(response.content)
        
        urls = []
        for url in root.findall('.//{http://www.sitemaps.org/schemas/sitemap/0.9}loc'):
            urls.append(url.text)
        
        total_tags = 0
        issues = []
        meta_data = []
        
        # Analyze each URL
        for url in urls[:10]:  # Limit to first 10 URLs for performance
            response = requests.get(url)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Collect meta tags
            meta_tags = soup.find_all('meta')
            total_tags += len(meta_tags)
            
            page_meta = {
                'url': url,
                'title': soup.title.string if soup.title else None,
                'meta_tags': []
            }
            
            for tag in meta_tags:
                tag_data = {
                    'name': tag.get('name', tag.get('property', '')),
                    'content': tag.get('content', '')
                }
                page_meta['meta_tags'].append(tag_data)
                
                # Check for common issues
                if not tag.get('content'):
                    issues.append(f"Empty content in meta tag {tag_data['name']} on {url}")
            
            meta_data.append(page_meta)
        
        return {
            'total_tags': total_tags,
            'issues_count': len(issues),
            'issues': issues,
            'pages': meta_data
        }
        
    except Exception as e:
        raise Exception(f"Error analyzing meta tags: {str(e)}")

================
File: apps/seo_manager/views/__init__.py
================
from .client_views import *
from .keyword_views import *
from .project_views import *
from .analytics_views import *
from .search_console_views import *
from .business_objective_views import *
from .ranking_views import *
from .report_views import *
from .activity_views import *
from .meta_tags_views import *

================
File: apps/seo_manager/views/activity_views.py
================
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from ..models import UserActivity

@login_required
def activity_log(request):
    activities = UserActivity.objects.all().order_by('-timestamp')
    return render(request, 'seo_manager/activity_log.html', {'activities': activities})

================
File: apps/seo_manager/views/ads_views.py
================
import logging
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.exceptions import ValidationError
from ..models import Client, GoogleAdsCredentials, OAuthManager
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from google.ads.googleads.client import GoogleAdsClient
from google.ads.googleads.errors import GoogleAdsException
from django.conf import settings
from google.oauth2.credentials import Credentials
from django.urls import reverse

logger = logging.getLogger(__name__)

@login_required
def initiate_google_ads_oauth(request, client_id):
    """Initiate OAuth flow for Google Ads"""
    try:
        client = get_object_or_404(Client, id=client_id)
        
        # Create state key for this OAuth flow
        state_key = f"{client_id}_ads"
        
        # Create OAuth flow
        flow = OAuthManager.create_oauth_flow(
            request=request,
            state_key=state_key
        )
        
        # Store state in session - use the state_key we created
        request.session['oauth_state'] = state_key
        request.session['service_type'] = 'ads'
        
        # Redirect to authorization URL
        auth_url = flow.authorization_url()[0]
        return redirect(auth_url)
        
    except Exception as e:
        logger.error(f"Error initiating Google Ads OAuth: {str(e)}", exc_info=True)
        messages.error(request, "Failed to initiate Google Ads authentication.")
        return redirect('seo_manager:client_integrations', client_id=client_id)

@login_required
def select_ads_account(request, client_id):
    """Handle Google Ads account selection"""
    try:
        client = get_object_or_404(Client, id=client_id)
        
        if request.method == 'POST':
            customer_id = request.POST.get('customer_id')
            login_customer_id = request.POST.get('login_customer_id')
            
            if not customer_id:
                raise ValidationError("No customer ID selected")
                
            # Get OAuth credentials from session
            credentials_dict = request.session.get('oauth_credentials')
            if not credentials_dict:
                raise ValidationError("OAuth credentials not found")
                
            # Create or update GoogleAdsCredentials
            credentials, created = GoogleAdsCredentials.objects.update_or_create(
                client=client,
                defaults={
                    'customer_id': customer_id,
                    'login_customer_id': login_customer_id or customer_id,
                    'access_token': credentials_dict['token'],
                    'refresh_token': credentials_dict['refresh_token'],
                    'token_uri': credentials_dict['token_uri'],
                    'ads_client_id': credentials_dict['client_id'],
                    'client_secret': credentials_dict['client_secret'],
                    'scopes': credentials_dict['scopes'],
                    'user_email': credentials_dict.get('user_email', '')
                }
            )
            
            # Clean up session
            request.session.pop('oauth_credentials', None)
            request.session.pop('customer_ids', None)
            
            messages.success(request, "Google Ads account connected successfully!")
            return redirect('seo_manager:client_integrations', client_id=client_id)
            
        # If GET request, try to fetch accessible customers
        credentials_dict = request.session.get('oauth_credentials')
        if not credentials_dict:
            messages.error(request, "OAuth credentials not found")
            return redirect('seo_manager:client_integrations', client_id=client_id)
            
        customer_ids = request.session.get('customer_ids')
        if not customer_ids:
            try:
                # Log credentials dictionary to diagnose issues (excluding sensitive data)
                safe_creds = {k: ('***REDACTED***' if k in ['token', 'refresh_token', 'client_secret'] else v) 
                             for k, v in credentials_dict.items()}
                logger.debug(f"OAuth credentials retrieved: {safe_creds}")
                
                # First, create proper OAuth credentials
                logger.debug("Creating OAuth Credentials object...")
                oauth_credentials = Credentials(
                    token=credentials_dict['token'],
                    refresh_token=credentials_dict['refresh_token'],
                    token_uri=credentials_dict['token_uri'],
                    client_id=credentials_dict['client_id'],
                    client_secret=credentials_dict['client_secret'],
                    scopes=credentials_dict['scopes']
                )
                logger.debug("OAuth Credentials object created successfully.")
                
                # Then use the GoogleAdsClient with the OAuth credentials
                logger.debug("Initializing GoogleAdsClient...")
                ads_client = GoogleAdsClient(
                    credentials=oauth_credentials,
                    developer_token=settings.GOOGLE_ADS_DEVELOPER_TOKEN,
                    use_proto_plus=True
                )
                logger.debug("GoogleAdsClient initialized successfully.")
                
                # Fetch accessible customers
                logger.info("Attempting to list accessible Google Ads customers...")
                customer_service = ads_client.get_service("CustomerService")
                accessible_customers = customer_service.list_accessible_customers()
                logger.info(f"Successfully listed {len(accessible_customers.resource_names)} Google Ads customers.")
                
                # Store customer IDs in session
                customer_ids = [
                    resource_name.split('/')[-1] 
                    for resource_name in accessible_customers.resource_names
                ]
                request.session['customer_ids'] = customer_ids
                logger.debug(f"Stored customer IDs in session: {customer_ids}")
                
            except GoogleAdsException as e:
                # Catch Google Ads specific exceptions for more detailed logging
                logger.error(f"Google Ads API error occurred while fetching customers: {e}", exc_info=True)
                messages.error(request, f"Google Ads API error: {e}. Please check permissions and API access.")
                return redirect('seo_manager:client_integrations', client_id=client_id)
            except Exception as e:
                # Catch any other exceptions
                logger.error(f"Generic error fetching Google Ads customers: {str(e)}", exc_info=True)
                messages.error(request, "Failed to fetch Google Ads accounts. Please try again.")
                return redirect('seo_manager:client_integrations', client_id=client_id)
                
        return render(request, 'seo_manager/select_ads_account.html', {
            'client': client,
            'customer_ids': customer_ids
        })
        
    except Exception as e:
        logger.error(f"Error in select_ads_account: {str(e)}", exc_info=True)
        messages.error(request, "An error occurred while setting up Google Ads integration.")
        return redirect('seo_manager:client_integrations', client_id=client_id)

@login_required
def remove_ads_credentials(request, client_id):
    """Remove Google Ads credentials for a client"""
    try:
        client = get_object_or_404(Client, id=client_id)
        
        # Delete the credentials
        if hasattr(client, 'ads_credentials'):
            client.ads_credentials.delete()
            messages.success(request, "Google Ads credentials removed successfully.")
        else:
            messages.warning(request, "No Google Ads credentials found to remove.")
            
        # Get the next URL from query parameters or default to client integrations
        next_url = request.GET.get('next', '')
        if next_url == 'integrations':
            return redirect('seo_manager:client_integrations', client_id=client_id)
        return redirect('seo_manager:client_detail', client_id=client_id)
        
    except Exception as e:
        logger.error(f"Error removing Google Ads credentials: {str(e)}", exc_info=True)
        messages.error(request, "Failed to remove Google Ads credentials.")
        return redirect('seo_manager:client_integrations', client_id=client_id)

================
File: apps/seo_manager/views/analytics_views.py
================
import json
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.exceptions import ValidationError
from ..models import Client, GoogleAnalyticsCredentials, OAuthManager, SearchConsoleCredentials
from ..google_auth import (
    get_analytics_accounts_oauth, 
    get_analytics_accounts_service_account,
    get_search_console_properties
)
from apps.common.tools.user_activity_tool import user_activity_tool
from ..exceptions import AuthError
from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
import logging
import google.oauth2.credentials
from google_auth_oauthlib.flow import Flow
from django.conf import settings
from django.urls import reverse

logger = logging.getLogger(__name__)

def _get_redirect_url(request, client_id):
    """Helper function to determine redirect URL based on 'next' parameter"""
    next_page = request.GET.get('next')
    if next_page == 'integrations':
        return 'seo_manager:client_integrations'
    return 'seo_manager:client_detail'

@login_required
def client_ads(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    # Add page_title to the context
    context = {
        'client': client,
        'page_title': 'Google Ads',
    }
    return render(request, 'seo_manager/client_ads.html', context)

@login_required
def client_dataforseo(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    # Add page_title to the context
    context = {
        'client': client,
        'page_title': 'DataforSEO',
    }
    return render(request, 'seo_manager/client_dataforseo.html', context)

@login_required
def initiate_google_oauth(request, client_id, service_type):
    """Start OAuth flow for Google services"""
    client = get_object_or_404(Client, id=client_id)
    
    try:
        # Create state key
        state_key = f"{client_id}_{service_type}"
        
        # Get the current domain and scheme
        scheme = request.scheme
        domain = request.get_host()
        redirect_uri = f'{scheme}://{domain}/google/login/callback/'
        
        # Define scopes based on service type
        scopes = []
        if service_type == 'ga':
            scopes = [
                'https://www.googleapis.com/auth/analytics.readonly',
                'https://www.googleapis.com/auth/userinfo.email'
            ]
        elif service_type == 'sc':
            scopes = [
                'https://www.googleapis.com/auth/webmasters.readonly',
                'https://www.googleapis.com/auth/userinfo.email'
            ]
        
        # Create OAuth flow with correct callback URL
        flow = Flow.from_client_secrets_file(
            settings.GOOGLE_CLIENT_SECRETS_FILE,
            scopes=scopes,
            state=state_key,
            redirect_uri=redirect_uri
        )
        
        # Store both state and redirect URI in session
        request.session['oauth_state'] = state_key
        request.session['oauth_redirect_uri'] = redirect_uri
        request.session['oauth_service_type'] = service_type
        request.session.modified = True
        
        # Get authorization URL with proper parameters
        authorization_url, _ = flow.authorization_url(
            access_type='offline',
            include_granted_scopes='true',
            prompt='select_account'
        )
        
        logger.info(f"Initiating OAuth flow for client {client.name} ({service_type})")
        
        return redirect(authorization_url)
        
    except Exception as e:
        logger.error(f"OAuth initiation error: {str(e)}", exc_info=True)
        messages.error(request, "Failed to start authentication process")
        return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def google_oauth_callback(request):
    """Handle OAuth callback"""
    try:
        # Verify state
        state = request.GET.get('state')
        stored_state = request.session.get('oauth_state')
        
        if not state or state != stored_state:
            logger.error("Invalid OAuth state")
            messages.error(request, "Invalid authentication state. Please try again.")
            return redirect('seo_manager:dashboard')
        
        # Extract client_id from state
        try:
            client_id = int(state.split('_')[0])
            service_type = state.split('_')[1]
        except (IndexError, ValueError):
            logger.error(f"Invalid state format: {state}")
            messages.error(request, "Invalid authentication data. Please try again.")
            return redirect('seo_manager:dashboard')
        
        client = get_object_or_404(Client, id=client_id)
        
        # Get the current domain and scheme for redirect URI
        scheme = request.scheme
        domain = request.get_host()
        redirect_uri = f'{scheme}://{domain}/google/login/callback/'
        
        # Complete OAuth flow
        try:
            flow = Flow.from_client_secrets_file(
                settings.GOOGLE_CLIENT_SECRETS_FILE,
                scopes=[
                    'https://www.googleapis.com/auth/analytics.readonly',
                    'https://www.googleapis.com/auth/webmasters.readonly',
                    'https://www.googleapis.com/auth/adwords',  # Add Google Ads scope
                    'openid',
                    'https://www.googleapis.com/auth/userinfo.email',
                    'https://www.googleapis.com/auth/userinfo.profile'
                ],
                state=state,
                redirect_uri=redirect_uri
            )
            
            # Fetch token
            token = flow.fetch_token(code=request.GET.get('code'))
            
            # Convert token to Google Credentials
            credentials = google.oauth2.credentials.Credentials(
                token=token['access_token'],
                refresh_token=token.get('refresh_token'),
                token_uri='https://oauth2.googleapis.com/token',
                client_id=flow.client_config['client_id'],
                client_secret=flow.client_config['client_secret'],
                scopes=token.get('scope', '').split(' ') if isinstance(token.get('scope'), str) else token.get('scope', [])
            )
            
            # Store credentials in session
            request.session['oauth_credentials'] = OAuthManager.credentials_to_dict(credentials)
            
            if service_type == 'ga':
                try:
                    # Get available accounts using the Google Credentials
                    accounts = get_analytics_accounts_oauth(credentials)
                    
                    if not accounts:
                        logger.warning(f"No GA4 properties found for client {client.name}")
                        messages.warning(request, "No Google Analytics 4 properties were found.")
                        redirect_url = _get_redirect_url(request, client_id)
                        return redirect(redirect_url, client_id=client_id)
                    
                    request.session['accounts'] = accounts
                    # Pass the next parameter to the select account view
                    next_page = request.GET.get('next')
                    url = reverse('seo_manager:select_analytics_account', args=[client_id])
                    if next_page:
                        url += f'?next={next_page}'
                    return redirect(url)
                    
                except Exception as e:
                    logger.error(f"Error fetching GA4 properties: {str(e)}", exc_info=True)
                    messages.error(request, "Failed to fetch Google Analytics properties.")
                    redirect_url = _get_redirect_url(request, client_id)
                    return redirect(redirect_url, client_id=client_id)
            
            elif service_type == 'sc':
                try:
                    # Get available Search Console properties
                    properties = get_search_console_properties(credentials)
                    if not properties:
                        messages.warning(request, "No Search Console properties found. Please verify your permissions.")
                        return redirect('seo_manager:client_detail', client_id=client_id)
                    
                    request.session['sc_properties'] = properties
                    return redirect('seo_manager:select_search_console_property', client_id=client_id)
                    
                except Exception as e:
                    logger.error(f"Error fetching Search Console properties: {str(e)}", exc_info=True)
                    messages.error(request, "Failed to fetch Search Console properties. Please verify your permissions.")
                    return redirect('seo_manager:client_detail', client_id=client_id)
            
            elif service_type == 'ads':
                try:
                    # Redirect to account selection
                    return redirect('seo_manager:select_ads_account', client_id=client_id)
                except Exception as e:
                    logger.error(f"Error handling Google Ads OAuth: {str(e)}", exc_info=True)
                    messages.error(request, "Failed to complete Google Ads authentication.")
                    return redirect('seo_manager:client_integrations', client_id=client_id)
            
        except Exception as e:
            logger.error(f"OAuth flow error: {str(e)}", exc_info=True)
            messages.error(request, "Authentication failed. Please try again.")
            return redirect('seo_manager:client_detail', client_id=client_id)
            
    except Exception as e:
        logger.error(f"OAuth callback error: {str(e)}", exc_info=True)
        messages.error(request, "Authentication failed. Please try again.")
        return redirect('seo_manager:dashboard')
    
    return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def add_ga_credentials_oauth(request, client_id):
    """Handle Google Analytics OAuth credential addition"""
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'GET':
        try:
            # Create state key
            state_key = f"{client_id}_ga"
            
            # Get the current domain and scheme
            scheme = request.scheme
            domain = request.get_host()
            redirect_uri = f'{scheme}://{domain}/google/login/callback/'
            
            # Create OAuth flow with minimal required scopes for GA4
            flow = Flow.from_client_secrets_file(
                settings.GOOGLE_CLIENT_SECRETS_FILE,
                scopes=[
                    'https://www.googleapis.com/auth/analytics.readonly',
                    'https://www.googleapis.com/auth/userinfo.email'
                ],
                state=state_key,
                redirect_uri=redirect_uri
            )
            
            # Get authorization URL with proper parameters
            authorization_url, _ = flow.authorization_url(
                access_type='offline',
                include_granted_scopes='true',
                prompt='consent'
            )
            
            # Store state in session
            request.session['oauth_state'] = state_key
            request.session['oauth_service_type'] = 'ga'
            request.session['oauth_client_id'] = client_id
            request.session['oauth_redirect_uri'] = redirect_uri
            request.session.modified = True
            
            return redirect(authorization_url)
            
        except Exception as e:
            logger.error(f"Error starting GA OAuth flow: {str(e)}")
            messages.error(request, "Failed to start authentication process")
            return redirect('seo_manager:client_detail', client_id=client_id)
    
    return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def add_ga_credentials_service_account(request, client_id):
    """Handle Google Analytics service account credential addition"""
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'GET':
        return render(request, 'seo_manager/credentials/add_ga_service_account.html', {
            'client': client
        })
        
    elif request.method == 'POST':
        try:
            if 'service_account_file' not in request.FILES:
                raise AuthError("No service account file provided")
                
            service_account_file = request.FILES['service_account_file']
            service_account_json = json.load(service_account_file)
            
            ga_credentials, created = GoogleAnalyticsCredentials.objects.get_or_create(
                client=client,
                defaults={'user_email': request.user.email}
            )
            
            ga_credentials.handle_service_account(json.dumps(service_account_json))
            
            messages.success(request, "Service account credentials added successfully")
            return redirect('seo_manager:client_detail', client_id=client.id)
            
        except AuthError as e:
            messages.error(request, str(e))
        except json.JSONDecodeError:
            messages.error(request, "Invalid JSON file")
        except Exception as e:
            logger.error(f"Error adding service account: {str(e)}")
            messages.error(request, "Failed to add service account credentials")
            
        return redirect('seo_manager:client_detail', client_id=client.id)

@login_required
def remove_ga_credentials(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    if client.ga_credentials:
        client.ga_credentials.delete()
        user_activity_tool.run(request.user, 'delete', f"Removed Google Analytics credentials for client: {client.name}", client=client)
        messages.success(request, "Google Analytics credentials removed successfully.")
    
    return redirect('seo_manager:client_integrations', client_id=client.id)

@login_required
def client_detail(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    try:
        # Handle GA credentials check
        ga_credentials = getattr(client, 'ga_credentials', None)
        if ga_credentials:
            try:
                ga_credentials.validate_credentials()
            except AuthError:
                messages.warning(request, "Google Analytics credentials need to be re-authenticated.")
                ga_credentials.delete()
        
        # Handle SC credentials check similarly
        sc_credentials = getattr(client, 'sc_credentials', None)
        if sc_credentials:
            try:
                sc_credentials.validate_credentials()
            except AuthError:
                messages.warning(request, "Search Console credentials need to be re-authenticated.")
                sc_credentials.delete()
                
    except Exception as e:
        logger.error(f"Error checking credentials: {str(e)}")
        messages.error(request, "Error validating credentials")

    return redirect('seo_manager:client_integrations', client_id=client.id)

@login_required
def add_sc_credentials(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Start OAuth flow
    try:
        flow = OAuthManager.create_oauth_flow(
            request, 
            state=f"{client_id}_sc"
        )
        authorization_url, _ = flow.authorization_url(
            access_type='offline',
            include_granted_scopes='true',
            prompt='consent'
        )
        request.session['oauth_state'] = f"{client_id}_sc"
        return redirect(authorization_url)
        
    except Exception as e:
        logger.error(f"Error initiating Search Console OAuth: {str(e)}")
        messages.error(request, "Failed to start authentication process")
        return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def select_analytics_account(request, client_id):
    """Handle Analytics account selection"""
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'POST':
        try:
            selected_account = request.POST.get('selected_account')
            if not selected_account:
                raise ValidationError("No account selected")
                
            credentials_dict = request.session.get('oauth_credentials')
            if not credentials_dict:
                raise AuthError("No OAuth credentials found in session")
            
            logger.info(f"Creating/updating GA credentials for client {client.name}")
            logger.debug(f"Credentials dict: {credentials_dict}")
                
            ga_credentials, created = GoogleAnalyticsCredentials.objects.get_or_create(
                client=client,
                defaults={'user_email': request.user.email}
            )
            
            # Save credentials and account info
            ga_credentials.handle_oauth_response(credentials_dict)
            ga_credentials.view_id = selected_account
            ga_credentials.save()
            
            logger.info(f"Successfully saved GA credentials for client {client.name}")
            
            # Clean up session
            for key in ['oauth_credentials', 'accounts', 'oauth_state', 'oauth_service_type', 'oauth_client_id']:
                request.session.pop(key, None)
            
            messages.success(request, "Google Analytics credentials added successfully")
            return redirect('seo_manager:client_integrations', client_id=client.id)
            
        except Exception as e:
            logger.error(f"Error saving GA credentials: {str(e)}", exc_info=True)
            messages.error(request, f"Failed to save Google Analytics credentials: {str(e)}")
            return redirect('seo_manager:client_integrations', client_id=client.id)
    
    # For GET requests
    context = {
        'client': client,
        'accounts': request.session.get('accounts', []),
    }
    return render(request, 'seo_manager/select_analytics_account.html', context)

@login_required
def select_search_console_property(request, client_id):
    """Handle Search Console property selection"""
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'POST':
        try:
            selected_property = request.POST.get('selected_property')
            if not selected_property:
                raise ValidationError("No property selected")
                
            credentials_dict = request.session.get('oauth_credentials')
            if not credentials_dict:
                raise AuthError("No OAuth credentials found in session")
            
            logger.info(f"Creating/updating SC credentials for client {client.name}")
            logger.debug(f"Credentials dict: {credentials_dict}")
                
            sc_credentials, created = SearchConsoleCredentials.objects.get_or_create(
                client=client,
                defaults={}
            )
            
            # Save credentials and property info
            sc_credentials.handle_oauth_response(credentials_dict)
            sc_credentials.property_url = selected_property
            if request.user.email:
                sc_credentials.user_email = request.user.email
            sc_credentials.save()
            
            logger.info(f"Successfully saved SC credentials for client {client.name}")
            
            # Clean up session
            for key in ['oauth_credentials', 'sc_properties', 'oauth_state']:
                request.session.pop(key, None)
            
            messages.success(request, "Search Console credentials added successfully")
            return redirect('seo_manager:client_integrations', client_id=client.id)
            
        except Exception as e:
            logger.error(f"Error saving SC credentials: {str(e)}", exc_info=True)
            messages.error(request, f"Failed to save Search Console credentials: {str(e)}")
            return redirect('seo_manager:client_integrations', client_id=client.id)
    
    # Handle GET request
    properties = request.session.get('sc_properties', [])
    if not properties:
        messages.error(request, "No Search Console properties found in session. Please try authenticating again.")
        return redirect('seo_manager:client_integrations', client_id=client.id)
        
    return render(request, 'seo_manager/select_search_console_property.html', {
        'client': client,
        'properties': properties
    })

@login_required
def add_sc_credentials_service_account(request, client_id):
    """Handle Search Console service account credential addition"""
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'GET':
        return render(request, 'seo_manager/credentials/add_sc_service_account.html', {
            'client': client
        })
        
    elif request.method == 'POST':
        try:
            if 'service_account_file' not in request.FILES:
                raise AuthError("No service account file provided")
                
            service_account_file = request.FILES['service_account_file']
            service_account_json = json.load(service_account_file)
            
            sc_credentials, created = SearchConsoleCredentials.objects.get_or_create(
                client=client,
                defaults={'user_email': request.user.email}
            )
            
            sc_credentials.handle_service_account(json.dumps(service_account_json))
            
            messages.success(request, "Service account credentials added successfully")
            return redirect('seo_manager:client_integrations', client_id=client.id)
            
        except AuthError as e:
            messages.error(request, str(e))
        except json.JSONDecodeError:
            messages.error(request, "Invalid JSON file")
        except Exception as e:
            logger.error(f"Error adding service account: {str(e)}")
            messages.error(request, "Failed to add service account credentials")
            
        return redirect('seo_manager:client_integrations', client_id=client.id)

@login_required
def client_analytics(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Check if client has GA credentials
    if not hasattr(client, 'ga_credentials'):
        messages.warning(request, {
            'title': 'Google Analytics Not Connected',
            'text': 'Please connect your Google Analytics account first.',
            'icon': 'warning',
            'redirect_url': reverse('seo_manager:client_integrations', args=[client_id])
        }, extra_tags='sweetalert')
        return redirect('seo_manager:client_integrations', client_id=client.id)
    
    try:
        # Try to get GA service
        service = client.ga_credentials.get_service()
        
        # If we get here, credentials are valid
        context = {
            'client': client,
            'page_title': 'Google Analytics',
        }
        return render(request, 'seo_manager/client_analytics.html', context)
        
    except Exception as e:
        error_str = str(e)
        logger.error(f"Error accessing Google Analytics: {error_str}")
        
        if 'invalid_grant' in error_str.lower():
            # Remove invalid credentials
            client.ga_credentials.delete()
            
            # Log the removal
            logger.info(f"Removed invalid Google Analytics credentials for client: {client.name}")
            
            # Log the activity
            user_activity_tool.run(
                None,  # System action
                'delete',
                f"Google Analytics credentials automatically removed due to invalid grant",
                client=client
            )
            
            messages.error(request, {
                'title': 'Google Analytics Connection Expired',
                'text': 'Your Google Analytics connection has expired or been revoked. Please reconnect your account.',
                'icon': 'error',
                'redirect_url': reverse('seo_manager:client_integrations', args=[client_id])
            }, extra_tags='sweetalert')
            return redirect('seo_manager:client_integrations', client_id=client.id)
        else:
            messages.error(request, {
                'title': 'Error',
                'text': 'An error occurred accessing Google Analytics. Please try again later.',
                'icon': 'error',
                'redirect_url': reverse('seo_manager:client_detail', args=[client_id])
            }, extra_tags='sweetalert')
            return redirect('seo_manager:client_detail', client_id=client.id)

================
File: apps/seo_manager/views/auth_views.py
================


================
File: apps/seo_manager/views/business_objective_views.py
================
from datetime import datetime
from django.shortcuts import get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.shortcuts import render
from ..models import Client
from ..forms import BusinessObjectiveForm
from apps.common.tools.user_activity_tool import user_activity_tool
import json
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods

@login_required
def add_business_objective(request, client_id):
    if request.method == 'POST':
        client = get_object_or_404(Client, id=client_id)
        form = BusinessObjectiveForm(request.POST)
        
        if form.is_valid():
            new_objective = {
                'goal': form.cleaned_data['goal'],
                'metric': form.cleaned_data['metric'],
                'target_date': form.cleaned_data['target_date'].isoformat(),
                'status': form.cleaned_data['status'],
                'date_created': datetime.now().isoformat(),
                'date_last_modified': datetime.now().isoformat(),
            }
            
            if not client.business_objectives:
                client.business_objectives = []
            
            client.business_objectives.append(new_objective)
            client.save()
            
            user_activity_tool.run(
                request.user, 
                'create', 
                f"Added business objective for client: {client.name}", 
                client=client,
                details=new_objective
            )
            
            messages.success(request, "Business objective added successfully.")
        else:
            messages.error(request, "Error adding business objective. Please check the form.")
            
    return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def edit_business_objective(request, client_id, objective_index):
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'POST':
        form = BusinessObjectiveForm(request.POST)
        if form.is_valid():
            updated_objective = {
                'goal': form.cleaned_data['goal'],
                'metric': form.cleaned_data['metric'],
                'target_date': form.cleaned_data['target_date'].isoformat(),
                'status': form.cleaned_data['status'],
                'date_created': client.business_objectives[objective_index]['date_created'],
                'date_last_modified': datetime.now().isoformat(),
            }
            client.business_objectives[objective_index] = updated_objective
            client.save()
            user_activity_tool.run(request.user, 'update', f"Updated business objective for client: {client.name}", client=client, details=updated_objective)
            messages.success(request, "Business objective updated successfully.")
            return redirect('seo_manager:client_detail', client_id=client.id)
    else:
        objective = client.business_objectives[objective_index]
        initial_data = {
            'goal': objective['goal'],
            'metric': objective['metric'],
            'target_date': datetime.fromisoformat(objective['target_date']),
            'status': objective['status'],
        }
        form = BusinessObjectiveForm(initial=initial_data)
    
    context = {
        'page_title': 'Edit Business Objective',
        'client': client,
        'form': form,
        'objective_index': objective_index,
    }
    
    return render(request, 'seo_manager/edit_business_objective.html', context)

@login_required
def delete_business_objective(request, client_id, objective_index):
    if request.method == 'POST':
        client = get_object_or_404(Client, id=client_id)
        deleted_objective = client.business_objectives.pop(objective_index)
        client.save()
        user_activity_tool.run(request.user, 'delete', f"Deleted business objective for client: {client.name}", client=client, details=deleted_objective)
        messages.success(request, "Business objective deleted successfully.")
    return redirect('seo_manager:client_detail', client_id=client_id)

@require_http_methods(["POST"])
def update_objective_status(request, client_id, objective_index):
    try:
        client = Client.objects.get(id=client_id)
        data = json.loads(request.body)
        new_status = data.get('status')
        
        # Get the objectives list
        objectives = client.business_objectives
        
        # Update the status of the specific objective
        if 0 <= objective_index < len(objectives):
            objectives[objective_index]['status'] = new_status == 'active'
            
            # Update the last modified date
            objectives[objective_index]['date_last_modified'] = datetime.now().isoformat()
            
            # Save the updated objectives
            client.business_objectives = objectives
            client.save()
            
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'success': False, 'error': 'Objective not found'})
            
    except Client.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Client not found'})
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)})

================
File: apps/seo_manager/views/client_views.py
================
import json
import logging
import os
import csv
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse, HttpResponse
from django.conf import settings
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.db.models import Min, Max, Q
from ..models import Client, KeywordRankingHistory, UserActivity, SearchConsoleCredentials
from ..forms import ClientForm, BusinessObjectiveForm, TargetedKeywordForm, KeywordBulkUploadForm, SEOProjectForm, ClientProfileForm
from apps.common.tools.user_activity_tool import user_activity_tool
from apps.agents.tools.client_profile_tool.client_profile_tool import ClientProfileTool
from apps.agents.models import Tool
from datetime import datetime, timedelta
from markdown_it import MarkdownIt  # Import markdown-it
from django.urls import reverse
from .search_console_views import get_search_console_data

logger = logging.getLogger(__name__)
__all__ = [
    'dashboard',
    'client_list',
    'add_client',
    'client_detail',
    'edit_client',
    'delete_client',
    'update_client_profile',
    'generate_magic_profile',
    'load_more_activities',
    'export_activities',
    'client_integrations',
    'profile_generation_complete',
]

@login_required
def dashboard(request):
    clients = Client.objects.all().order_by('name')
    form = ClientForm()
    return render(request, 'seo_manager/dashboard.html', {'page_title': 'Dashboard', 'clients': clients, 'form': form})

@login_required
def client_list(request):
    clients = Client.objects.all().order_by('name').select_related('group')
    form = ClientForm()
    return render(request, 'seo_manager/client_list.html', {'page_title': 'Clients', 'clients': clients, 'form': form})

@login_required
def add_client(request):
    if request.method == 'POST':
        form = ClientForm(request.POST)
        if form.is_valid():
            client = form.save()
            user_activity_tool.run(request.user, 'create', f"Added new client: {client.name}", client=client)
            messages.success(request, f"Client '{client.name}' has been added successfully.")
            
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'message': f"Client '{client.name}' has been added successfully.",
                    'redirect_url': reverse('seo_manager:client_detail', args=[client.id])
                })
            
            return redirect('seo_manager:client_detail', client_id=client.id)
        else:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                })
    else:
        form = ClientForm()
    
    return render(request, 'seo_manager/add_client.html', {'form': form})

def get_meta_tags_files(client_id: int) -> list:
    """
    Get list of meta tags files from cloud storage.
    
    Args:
        client_id: The client ID
        
    Returns:
        list: List of file names sorted by modification time
    """
    try:
        prefix = os.path.join('meta-tags', str(client_id))
        files = []
        
        if hasattr(default_storage, 'listdir'):
            # For traditional storage backends
            _, file_names = default_storage.listdir(prefix)
            for name in file_names:
                if name.endswith('.json'):
                    path = os.path.join(prefix, name)
                    files.append({
                        'name': name,
                        'path': path,
                        'modified': default_storage.get_modified_time(path)
                    })
        else:
            # For S3-like storage
            for obj in default_storage.bucket.objects.filter(Prefix=prefix):
                if obj.key.endswith('.json'):
                    files.append({
                        'name': os.path.basename(obj.key),
                        'path': obj.key,
                        'modified': obj.last_modified
                    })
        
        # Sort files by modification time
        return sorted(files, key=lambda x: x['modified'], reverse=True)
        
    except Exception as e:
        logger.error(f"Error getting meta tags files: {str(e)}")
        return []

@login_required
def client_detail(request, client_id):
    """Client detail view."""
    try:
        # Get all keyword history
        keyword_history = (KeywordRankingHistory.objects
            .filter(client_id=client_id)
            .order_by('keyword_text', '-date'))
            
        # Create history dictionary
        history_by_keyword = {}
        for history in keyword_history:
            if history.keyword_text not in history_by_keyword:
                history_by_keyword[history.keyword_text] = []
            history_by_keyword[history.keyword_text].append(history)

        # Convert to list
        keyword_history_list = []
        for keyword_text, histories in history_by_keyword.items():
            keyword_history_list.extend(histories)

        # Get client with related data
        client = get_object_or_404(
            Client.objects.prefetch_related(
                'targeted_keywords',
                'seo_projects',
                'seo_projects__targeted_keywords',
            ),
            id=client_id
        )

        # Get activities
        important_categories = ['create', 'update', 'delete', 'export', 'import', 'other']
        client_activities = UserActivity.objects.filter(
            client=client,
            category__in=important_categories
        ).select_related('user').order_by('-timestamp')[:10]

        # Initialize forms
        forms = {
            'keyword_form': TargetedKeywordForm(),
            'import_form': KeywordBulkUploadForm(),
            'project_form': SEOProjectForm(client=client),
            'business_objective_form': BusinessObjectiveForm(),
            'profile_form': ClientProfileForm(initial={'client_profile': client.client_profile})
        }

        # Get meta tags files
        meta_tags_files = get_meta_tags_files(client_id)

        # Get ranking stats
        ranking_stats = KeywordRankingHistory.objects.filter(
            client_id=client_id
        ).aggregate(
            earliest_date=Min('date'),
            latest_date=Max('date')
        )

        latest_collection_date = ranking_stats['latest_date']
        data_coverage_months = 0
        if ranking_stats['earliest_date'] and ranking_stats['latest_date']:
            date_diff = ranking_stats['latest_date'] - ranking_stats['earliest_date']
            data_coverage_months = round(date_diff.days / 30)

        tracked_keywords_count = (KeywordRankingHistory.objects
            .filter(client_id=client_id)
            .values('keyword_text')
            .distinct()
            .count())

        # Get Search Console data
        search_console_data = []
        try:
            sc_credentials = getattr(client, 'sc_credentials', None)
            if sc_credentials:
                service = sc_credentials.get_service()
                if service:
                    property_url = sc_credentials.get_property_url()
                    if property_url:
                        end_date = datetime.now().strftime('%Y-%m-%d')
                        start_date = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')
                        search_console_data = get_search_console_data(
                            service,
                            property_url,
                            start_date,
                            end_date
                        )
        except Exception as e:
            logger.error(f"Error fetching search console data: {str(e)}")

        context = {
            'page_title': 'Client Detail',
            'client': client,
            'client_activities': client_activities,
            'business_objectives': client.business_objectives,
            **forms,
            'meta_tags_files': meta_tags_files,
            'client_profile_html': client.client_profile,
            'latest_collection_date': latest_collection_date,
            'data_coverage_months': data_coverage_months,
            'tracked_keywords_count': tracked_keywords_count,
            'search_console_data': search_console_data,
        }

        return render(request, 'seo_manager/client_detail.html', context)
        
    except Exception as e:
        logger.error(f"Error in client_detail view: {str(e)}")
        raise

@login_required
def edit_client(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    if request.method == 'POST':
        form = ClientForm(request.POST, instance=client)
        if form.is_valid():
            form.save()
            user_activity_tool.run(request.user, 'update', f"Updated client details: {client.name}", client=client)
            
            # Check if request is AJAX
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'message': f"Client '{client.name}' has been updated successfully.",
                })
            
            messages.success(request, f"Client '{client.name}' has been updated successfully.")
            return redirect('seo_manager:client_detail', client_id=client.id)
        else:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'errors': {field: [str(error) for error in errors] 
                              for field, errors in form.errors.items()}
                })
            
    else:
        form = ClientForm(instance=client)
    
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return JsonResponse({
            'success': False,
            'errors': {'form': ['Invalid form submission']}
        })
        
    return render(request, 'seo_manager/edit_client.html', {'form': form, 'client': client})

@login_required
def delete_client(request, client_id):
    if request.method == 'POST':
        client = get_object_or_404(Client, id=client_id)
        user_activity_tool.run(request.user, 'delete', f"Deleted client: {client.name}", client=client)
        client.delete()
        return JsonResponse({'success': True})
    return JsonResponse({'success': False}, status=400)

@login_required
def update_client_profile(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'POST':
        try:
            client_profile = request.POST.get('client_profile', '')
            if not client_profile:
                raise ValueError("Profile content cannot be empty")
                
            client.client_profile = client_profile
            client.save()
            
            user_activity_tool.run(
                request.user,
                'update',
                f"Updated client profile for: {client.name}",
                client=client
            )
            
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': True,
                    'message': "Client profile updated successfully."
                })
            
            messages.success(request, "Client profile updated successfully.")
            return redirect('seo_manager:client_detail', client_id=client.id)
            
        except Exception as e:
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return JsonResponse({
                    'success': False,
                    'error': str(e)
                })
            
            messages.error(request, f"Error updating profile: {str(e)}")
            return redirect('seo_manager:client_detail', client_id=client.id)
    
    messages.error(request, "Invalid form submission.")
    return redirect('seo_manager:client_detail', client_id=client.id)

@login_required
def generate_magic_profile(request, client_id):
    if request.method == 'POST':
        try:
            # Get the client (get_object_or_404 should handle org context)
            client = get_object_or_404(Client, id=client_id)
            
            # Get the tool 
            tool = get_object_or_404(Tool, tool_subclass='OrganizationAwareClientProfileTool')
            
            # Get the current organization ID from the request
            organization = getattr(request, 'organization', None)
            if not organization:
                logger.error("Organization context not found in request for generate_magic_profile")
                return JsonResponse({'success': False, 'error': 'Organization context missing'}, status=500)
            organization_id = str(organization.id)
            
            # Prepare the inputs for the tool
            # The OrganizationAwareClientProfileTool now expects just 'client_id'
            inputs = {
                'client_id': str(client.id) # Pass client ID as string
            }
            
            # Log the operation
            logger.info(f"Starting profile generation for client: {client.name} (ID: {client_id}) in organization {organization_id}")
            
            # Start Celery task - Pass organization_id as the third argument
            from apps.agents.tasks import run_tool
            task = run_tool.delay(tool.id, inputs, organization_id)
            
            # Create user activity for tracking
            user_activity_tool.run(
                request.user,
                'create',
                f"Started generating profile for client: {client.name}",
                client=client
            )
            
            return JsonResponse({
                'success': True,
                'task_id': task.id,
                'message': 'Profile generation started'
            })
                
        except Exception as e:
            logger.error(f"Error generating magic profile: {str(e)}")
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
            
    return JsonResponse({'success': False, 'error': 'Invalid request method'})

@login_required
def profile_generation_complete(request, client_id):
    """Handle the completion of profile generation task and save results to database"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        # Get the result data
        data = json.loads(request.body)
        result = data.get('result')
        
        if not result:
            return JsonResponse({'success': False, 'error': 'Missing required data'}, status=400)
        
        # Parse the result
        result_data = json.loads(result) if isinstance(result, str) else result
        
        # Get the client using the URL parameter
        client = get_object_or_404(Client, id=client_id)
        
        # Save to database if successful
        if result_data.get('success'):
            client.client_profile = result_data.get('profile_html')
            client.distilled_website = result_data.get('website_text')
            client.save()
            
            # Log the activity
            user_activity_tool.run(
                request.user,
                'update',
                f"Generated profile for client: {client.name}",
                client=client
            )
            
            return JsonResponse({
                'success': True,
                'message': f"Profile generated and saved for {client.name}"
            })
        else:
            # Handle error case
            error_message = result_data.get('message', 'Unknown error')
            logger.error(f"Error in profile generation: {error_message}")
            
            return JsonResponse({
                'success': False,
                'error': error_message
            })
    
    except Exception as e:
        logger.error(f"Error processing profile generation result: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@login_required
def load_more_activities(request, client_id):
    page = int(request.GET.get('page', 1))
    per_page = 10
    start = (page - 1) * per_page
    end = start + per_page

    client = get_object_or_404(Client, id=client_id)
    important_categories = ['create', 'update', 'delete', 'export', 'import', 'other']
    
    activities = UserActivity.objects.filter(
        client=client,
        category__in=important_categories
    ).order_by('-timestamp')[start:end + 1]  # Get one extra to check if there are more

    has_more = len(activities) > per_page
    activities = activities[:per_page]  # Remove the extra item if it exists

    # Render activities to HTML
    html = render(request, 'seo_manager/includes/activity_items.html', {
        'client_activities': activities
    }).content.decode('utf-8')

    return JsonResponse({
        'success': True,
        'activities': html,
        'has_more': has_more
    })

@login_required
def export_activities(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    filter_type = request.GET.get('filter', 'all')
    
    # Get activities based on filter
    activities = UserActivity.objects.filter(client=client).order_by('-timestamp')
    if filter_type != 'all':
        activities = activities.filter(category=filter_type)
    
    # Create the HttpResponse object with CSV header
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="{client.name}_activities_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv"'
    
    # Create CSV writer
    writer = csv.writer(response)
    writer.writerow(['Timestamp', 'User', 'Category', 'Action', 'Details'])
    
    # Write data
    for activity in activities:
        writer.writerow([
            activity.timestamp.strftime('%Y-%m-%d %H:%M:%S'),
            activity.user.username if activity.user else 'System',
            activity.get_category_display(),
            activity.action,
            activity.details if activity.details else ''
        ])
    
    # Log the export activity
    user_activity_tool.run(
        request.user,
        'export',
        f"Exported {filter_type} activities",
        client=client
    )
    
    return response

@login_required
def client_integrations(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    context = {
        'page_title': 'Client Integrations',
        'client': client,
        'segment': 'clients',
        'subsegment': 'integrations'
    }
    return render(request, 'seo_manager/client_integrations.html', context)

================
File: apps/seo_manager/views/keyword_views.py
================
import csv
import io
import logging
from django.shortcuts import get_object_or_404, redirect, render
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib import messages
from django.views.generic import ListView, CreateView, UpdateView
from django.urls import reverse_lazy
from django.http import JsonResponse
from ..models import Client, TargetedKeyword, KeywordRankingHistory, SearchConsoleCredentials
from ..forms import TargetedKeywordForm, KeywordBulkUploadForm
from apps.common.tools.user_activity_tool import user_activity_tool
import json
from datetime import datetime, timedelta
from .search_console_views import get_search_console_data

logger = logging.getLogger(__name__)

class KeywordListView(LoginRequiredMixin, ListView):
    template_name = 'seo_manager/keywords/keyword_list.html'
    context_object_name = 'keywords'

    def get_queryset(self):
        return TargetedKeyword.objects.filter(client_id=self.kwargs['client_id'])

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['client'] = get_object_or_404(Client, id=self.kwargs['client_id'])
        context['import_form'] = KeywordBulkUploadForm()
        return context

class KeywordCreateView(LoginRequiredMixin, CreateView):
    model = TargetedKeyword
    form_class = TargetedKeywordForm
    template_name = 'seo_manager/keywords/keyword_form.html'

    def form_valid(self, form):
        form.instance.client_id = self.kwargs['client_id']
        response = super().form_valid(form)
        user_activity_tool.run(self.request.user, 'create', f"Added keyword: {form.instance.keyword}", client=form.instance.client)
        return response

    def get_success_url(self):
        return reverse_lazy('seo_manager:client_detail', kwargs={'client_id': self.kwargs['client_id']})

class KeywordUpdateView(LoginRequiredMixin, UpdateView):
    model = TargetedKeyword
    form_class = TargetedKeywordForm
    template_name = 'seo_manager/keywords/keyword_form.html'

    def get_queryset(self):
        # Ensure the keyword belongs to the correct client
        return TargetedKeyword.objects.filter(
            client_id=self.kwargs['client_id']
        )

    def form_valid(self, form):
        response = super().form_valid(form)
        user_activity_tool.run(
            self.request.user, 
            'update', 
            f"Updated keyword: {form.instance.keyword}", 
            client=form.instance.client
        )
        messages.success(self.request, "Keyword updated successfully.")
        return response

    def get_success_url(self):
        return reverse_lazy('seo_manager:client_detail', 
                          kwargs={'client_id': self.kwargs['client_id']})

@login_required
def keyword_import(request, client_id):
    if request.method == 'POST':
        form = KeywordBulkUploadForm(request.POST, request.FILES)
        if form.is_valid():
            client = get_object_or_404(Client, id=client_id)
            csv_file = request.FILES['csv_file']
            decoded_file = csv_file.read().decode('utf-8')
            csv_data = csv.DictReader(io.StringIO(decoded_file))
            
            for row in csv_data:
                TargetedKeyword.objects.create(
                    client=client,
                    keyword=row['keyword'],
                    priority=int(row['priority']),
                    notes=row.get('notes', '')
                )
            
            user_activity_tool.run(request.user, 'import', f"Imported keywords from CSV", client=client)
            messages.success(request, "Keywords imported successfully.")
            return redirect('seo_manager:client_detail', client_id=client_id)
    
    messages.error(request, "Invalid form submission.")
    return redirect('seo_manager:client_detail', client_id=client_id)

@login_required
def debug_keyword_data(request, client_id, keyword_id):
    """Debug view to check keyword data"""
    keyword = get_object_or_404(TargetedKeyword, id=keyword_id, client_id=client_id)
    
    rankings = KeywordRankingHistory.objects.filter(
        keyword=keyword
    ).order_by('-date')
    
    data = {
        'keyword': keyword.keyword,
        'current_position': keyword.current_position,
        'position_change': keyword.get_position_change(),
        'rankings': [
            {
                'date': r.date.strftime('%Y-%m-%d'),
                'position': r.average_position,
                'impressions': r.impressions,
                'clicks': r.clicks,
                'ctr': r.ctr
            }
            for r in rankings
        ]
    }
    
    return JsonResponse(data)

@login_required
def import_from_search_console(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    if request.method == 'POST':
        try:
            keywords_data = json.loads(request.body)
            imported_count = 0
            
            for keyword_data in keywords_data:
                keyword = keyword_data.get('keyword')
                if keyword:
                    # Check if keyword already exists
                    if not TargetedKeyword.objects.filter(client=client, keyword=keyword).exists():
                        # Create the keyword
                        keyword_obj = TargetedKeyword.objects.create(
                            client=client,
                            keyword=keyword,
                            notes=f"""Imported from Search Console
Initial Position: {keyword_data.get('position', 'N/A')}
Clicks: {keyword_data.get('clicks', 0)}
Impressions: {keyword_data.get('impressions', 0)}
CTR: {keyword_data.get('ctr', 0)}%"""
                        )

                        # Create initial ranking history entry
                        KeywordRankingHistory.objects.create(
                            keyword=keyword_obj,
                            client=client,
                            keyword_text=keyword,
                            date=datetime.now().date(),
                            average_position=keyword_data.get('position', 0),
                            clicks=keyword_data.get('clicks', 0),
                            impressions=keyword_data.get('impressions', 0),
                            ctr=keyword_data.get('ctr', 0)
                        )
                        
                        imported_count += 1
            
            user_activity_tool.run(
                request.user, 
                'import', 
                f"Imported {imported_count} keywords from Search Console", 
                client=client
            )
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully imported {imported_count} keywords'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({
                'success': False,
                'error': 'Invalid data format'
            }, status=400)
        except Exception as e:
            logger.error(f"Error importing keywords: {str(e)}")
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=500)
            
    return JsonResponse({
        'success': False,
        'error': 'Invalid request method'
    }, status=405)

@login_required
def search_console_keywords(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    search_console_data = []
    
    try:
        sc_credentials = SearchConsoleCredentials.objects.get(client=client)
        if sc_credentials:
            service = sc_credentials.get_service()
            if service:
                property_url = sc_credentials.get_property_url()
                if property_url:
                    # Get last 90 days of data
                    end_date = datetime.now().strftime('%Y-%m-%d')
                    start_date = (datetime.now() - timedelta(days=90)).strftime('%Y-%m-%d')
                    search_console_data = get_search_console_data(
                        service, 
                        property_url,
                        start_date,
                        end_date
                    )
    except SearchConsoleCredentials.DoesNotExist:
        pass
    except Exception as e:
        logger.error(f"Error fetching search console data: {str(e)}")
    
    context = {
        'page_title': 'Search Console Keywords',
        'client': client,
        'search_console_data': search_console_data,
    }
    return render(request, 'seo_manager/keywords/search_console_keywords.html', context)

================
File: apps/seo_manager/views/meta_tags_views.py
================
import json
import os
from django.shortcuts import get_object_or_404, render
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_http_methods
from django.core.files.base import ContentFile
from ..models import Client
from ..sitemap_extractor import extract_sitemap_and_meta_tags, extract_sitemap_and_meta_tags_from_url, meta_tag_storage
from ..tasks import extract_sitemap_task, extract_sitemap_from_url_task
import logging
from datetime import datetime
import time
from django.contrib import messages
from django.utils import timezone
from django.contrib.auth import get_user_model
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings
from celery.result import AsyncResult
import io
from urllib.parse import unquote
from django.utils.html import escape

logger = logging.getLogger(__name__)
User = get_user_model()

def get_snapshot_stats(file_path: str) -> dict:
    """
    Get statistics from a meta tags snapshot file using SecureFileStorage.
    
    Args:
        file_path: The relative path to the file
        
    Returns:
        dict: Statistics about the meta tags
    """
    try:
        if not meta_tag_storage.exists(file_path):
            return {
                'total_pages': 0,
                'total_tags': 0,
                'issues': 0
            }

        # Check file extension
        if file_path.endswith('.csv'):
            import csv
            total_pages = 0
            total_tags = 0
            issues = 0
            
            with meta_tag_storage._open(file_path, 'rb') as file_bytes:
                try:
                    file_content = file_bytes.read().decode('utf-8')
                except UnicodeDecodeError:
                    logger.warning(f"UTF-8 decoding failed for stats file {file_path}, trying latin-1")
                    file_bytes.seek(0)
                    file_content = file_bytes.read().decode('latin-1', errors='ignore')
                
                file_text_io = io.StringIO(file_content)
                csv_reader = csv.DictReader(file_text_io)
                for row in csv_reader:
                    total_pages += 1
                    # Count non-empty meta tag fields from our known meta tag columns
                    meta_tag_fields = ['meta_description', 'meta_charset', 'viewport', 
                                      'robots', 'canonical', 'og_title', 'og_description', 'og_image', 
                                      'twitter_card', 'twitter_title', 'twitter_description', 
                                      'twitter_image', 'author']
                    
                    for field in meta_tag_fields:
                        if field in row and row[field]:
                            total_tags += 1
                    
                    # Count issues if there's an issues column
                    if 'issues' in row and row['issues']:
                        issues += 1
                        
            return {
                'total_pages': total_pages,
                'total_tags': total_tags,
                'issues': issues
            }
        else:
            # Handle JSON files
            with meta_tag_storage._open(file_path, 'rb') as file_bytes:
                try:
                    file_content = file_bytes.read().decode('utf-8')
                except UnicodeDecodeError:
                    logger.warning(f"UTF-8 decoding failed for stats file {file_path}, trying latin-1")
                    file_bytes.seek(0)
                    file_content = file_bytes.read().decode('latin-1', errors='ignore')
                
                data = json.loads(file_content)
                total_pages = len(data.get('pages', []))
                total_tags = sum(len(page.get('meta_tags', [])) for page in data.get('pages', []))
                issues = sum(1 for page in data.get('pages', []) 
                           for tag in page.get('meta_tags', []) 
                           if tag.get('issues'))
                return {
                    'total_pages': total_pages,
                    'total_tags': total_tags,
                    'issues': issues
                }
    except Exception as e:
        logger.error(f"Error reading meta tags file: {file_path} - {str(e)}")
        return {
            'total_pages': 0,
            'total_tags': 0,
            'issues': 0
        }

@login_required
def meta_tags(request, client_id):
    """Meta tags dashboard view for specified client"""
    try:
        client = Client.objects.get(id=client_id)
    except Client.DoesNotExist:
        messages.error(request, "Client not found.")
        return redirect('seo_clients')

    meta_tags_prefix = f"{request.user.id}/meta-tags/"
    meta_tag_files_info = []
    latest_stats = None
    underlying_storage = meta_tag_storage.storage

    try:
        file_paths = []
        client_name_safe = client.name.lower().replace(' ', '_')

        # Consolidate file discovery
        if hasattr(underlying_storage, 'listdir'):
            _dirs, file_names = underlying_storage.listdir(meta_tags_prefix)
            for filename in file_names:
                if filename.endswith(('.csv', '.json')) and client_name_safe in filename:
                    file_paths.append(os.path.join(meta_tags_prefix, filename))
        elif hasattr(underlying_storage, 'bucket') and hasattr(underlying_storage.bucket, 'objects'):
            for obj in underlying_storage.bucket.objects.filter(Prefix=meta_tags_prefix):
                if not obj.key.endswith('/'):
                    filename = os.path.basename(obj.key)
                    if filename.endswith(('.csv', '.json')) and client_name_safe in filename:
                        file_paths.append(obj.key)
        else:
            logger.warning(f"Underlying storage for meta tags does not support listdir or bucket.objects.filter")

        # Sort discovered file paths by name (descending)
        file_paths.sort(reverse=True)

        # Get stats for each file
        for full_path in file_paths:
            try:
                stats = get_snapshot_stats(full_path)
                meta_tag_files_info.append({
                    'name': os.path.basename(full_path),
                    'path': full_path,
                    'stats': stats # Store the full stats dictionary
                })
                # Update latest_stats if this is the first (most recent) file
                if latest_stats is None:
                    latest_stats = stats
            except Exception as e:
                logger.error(f"Error extracting stats from meta tags file {full_path}: {e}")
                # Add placeholder if stats extraction fails for a specific file
                meta_tag_files_info.append({
                    'name': os.path.basename(full_path),
                    'path': full_path,
                    'stats': {'total_pages': 'N/A', 'total_tags': 'N/A', 'issues': 'N/A'} # Indicate unavailable stats
                })

    except Exception as e:
        logger.error(f"Error listing meta tags files: {e}", exc_info=True)
        messages.error(request, "An error occurred while listing snapshot files.")

    # Note: Sorting is now done on file_paths before fetching stats

    context = {
        'client': client,
        'meta_tags_files_info': meta_tag_files_info,
        'latest_stats': latest_stats,
    }

    task_id = request.GET.get('task_id')
    if task_id:
        context['task_id'] = task_id

    return render(request, 'seo_manager/meta_tags/meta_tags_dashboard.html', context)

@login_required
@csrf_exempt
def create_snapshot(request, client_id):
    """Create a new meta tags snapshot from client's website"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Method not allowed'}, status=405)
    
    try:
        client = Client.objects.get(id=client_id)
        # Verify the user has access to this client (could be based on group permissions)
        # This is a simplified check - you may need more comprehensive permission logic
        # Additional permission check could be added here if needed
    except Client.DoesNotExist:
        return JsonResponse({'success': False, 'message': 'Client not found'}, status=404)
    
    website_url = client.website_url  # Fixed property name from website to website_url
    if not website_url:
        return JsonResponse({'success': False, 'message': 'Client has no website URL defined'}, status=400)
    
    # Set up file path using storage-compatible path handling
    user_id = request.user.id
    
    # File name format: client_name_YYYY-MM-DD_HH-MM-SS.csv
    timestamp = timezone.now().strftime('%Y-%m-%d_%H-%M-%S')
    filename = f"{client.name.lower().replace(' ', '_')}_{timestamp}.csv"
    relative_path = f"{user_id}/meta-tags/{filename}"
    
    try:
        # Enqueue the Celery task
        task = extract_sitemap_task.delay(
            website_url=website_url,
            output_file=relative_path,
            user_id=user_id
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Meta tags extraction started',
            'task_id': task.id
        })
    except Exception as e:
        logger.error(f"Error starting meta tags extraction: {e}")
        return JsonResponse({
            'success': False,
            'message': f'Error starting extraction: {str(e)}'
        }, status=500)

@login_required
@csrf_exempt
def create_snapshot_from_url(request):
    """Create a new meta tags snapshot from a user-provided URL"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'message': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        website_url = data.get('url')
        
        if not website_url:
            return JsonResponse({'success': False, 'message': 'No URL provided'}, status=400)
        
        # Set up file path using storage-compatible path handling
        user_id = request.user.id
        
        # Extract domain from URL for the filename
        import re
        domain = re.sub(r'^https?://', '', website_url)
        domain = re.sub(r'/.*$', '', domain)  # Remove path
        
        # File name format: domain_YYYY-MM-DD_HH-MM-SS.csv
        timestamp = timezone.now().strftime('%Y-%m-%d_%H-%M-%S')
        filename = f"{domain.replace('.', '_')}_{timestamp}.csv"
        relative_path = f"{user_id}/meta-tags/{filename}"
        
        # Enqueue the Celery task
        task = extract_sitemap_from_url_task.delay(
            website_url=website_url,
            output_file=relative_path,
            user_id=user_id
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Meta tags extraction started',
            'task_id': task.id
        })
    except Exception as e:
        logger.error(f"Error starting meta tags extraction from URL: {e}")
        return JsonResponse({
            'success': False,
            'message': f'Error starting extraction: {str(e)}'
        }, status=500)

@login_required
def check_task_status(request, task_id):
    """Check the status of a meta tags extraction task"""
    try:
        # Get the task result
        task_result = AsyncResult(task_id)
        
        # Check task status
        if task_result.ready():
            if task_result.successful():
                return JsonResponse({
                    'success': True,
                    'status': 'complete',
                    'result': task_result.result
                })
            else:
                # Task failed
                error = str(task_result.result) if task_result.result else "Unknown error"
                return JsonResponse({
                    'success': False,
                    'status': 'failed',
                    'message': error
                })
        else:
            # Task still in progress
            return JsonResponse({
                'success': True,
                'status': 'pending',
                'state': task_result.state
            })
    
    except Exception as e:
        logger.error(f"Error checking task status: {e}")
        return JsonResponse({
            'success': False,
            'status': 'error',
            'message': str(e)
        }, status=500)

@login_required
def view_meta_tags_report(request, client_id, file_path):
    """
    Render the content of a meta tags report for HTMX.
    Handles both single file view and comparison view.
    Args:
        request: The HTTP request
        client_id: The ID of the client (added for context)
        file_path: The encoded file path to load

    Returns:
        HttpResponse with the report content rendered as HTML or an error status.
    """
    try:
        start_time = time.time()
        file_path = unquote(file_path)
        logger.info(f"[HTMX View Start] Client {client_id}: Loading report for: {file_path}")

        compare_mode = request.GET.get('compare', 'false').lower() == 'true'
        meta_tags_prefix = f"{request.user.id}/meta-tags/"
        underlying_storage = meta_tag_storage.storage

        if compare_mode:
            logger.info(f"[HTMX View] Client {client_id}: Entering comparison mode for {file_path}")
            # --- Comparison Logic ---
            meta_tag_files = []
            try:
                client = Client.objects.get(id=client_id)
                if hasattr(underlying_storage, 'listdir'):
                    _dirs, file_names = underlying_storage.listdir(meta_tags_prefix)
                    client_name_safe = client.name.lower().replace(' ', '_')
                    for filename in file_names:
                        if filename.endswith(('.csv', '.json')) and client_name_safe in filename:
                            full_path = os.path.join(meta_tags_prefix, filename)
                            meta_tag_files.append(full_path)
                # TODO: Add S3 listing logic if needed
            except Client.DoesNotExist:
                 logger.error(f"Client {client_id} not found for comparison.")
                 return HttpResponse('<div class="alert alert-danger">Client not found.</div>', status=404)
            except Exception as e:
                logger.error(f"Client {client_id}: Error listing files for comparison: {str(e)}", exc_info=True)
                return HttpResponse('<div class="alert alert-danger">Error listing files for comparison.</div>', status=500)
            
            meta_tag_files.sort(reverse=True)
            
            try:
                current_index = meta_tag_files.index(file_path)
            except ValueError:
                logger.error(f"Client {client_id}: Current file {file_path} not found in list for comparison.")
                return HttpResponse('<div class="alert alert-danger">Current file not found in list.</div>', status=404)
                
            if current_index == len(meta_tag_files) - 1:
                return HttpResponse('<div class="alert alert-info">This is the oldest snapshot, no comparison available.</div>')
                
            previous_file_path = meta_tag_files[current_index + 1]
            
            # Function to load and parse data (avoids code duplication)
            def load_and_parse(path):
                if not meta_tag_storage.exists(path):
                    logger.error(f"Client {client_id}: File not found during comparison: {path}")
                    raise FileNotFoundError(f"File not found: {os.path.basename(path)}")
                with meta_tag_storage._open(path, 'rb') as fb:
                    try:
                        content = fb.read().decode('utf-8')
                    except UnicodeDecodeError:
                        logger.warning(f"Client {client_id}: UTF-8 decode failed for {path}, trying latin-1")
                        fb.seek(0)
                        content = fb.read().decode('latin-1', errors='ignore')
                    
                    if path.endswith('.json'):
                        return json.loads(content)
                    elif path.endswith('.csv'):
                        from io import StringIO
                        import csv
                        reader = csv.DictReader(StringIO(content))
                        data = {'pages': []}
                        for row in reader:
                            url = row.get('url')
                            if url:
                                page = {'url': url, 'meta_tags': []}
                                for key, value in row.items():
                                    if key != 'url' and value:
                                        page['meta_tags'].append({'name': key, 'content': value})
                                data['pages'].append(page)
                        return data
                    else:
                         raise ValueError("Unsupported file type for comparison")

            try:
                current_data = load_and_parse(file_path)
                previous_data = load_and_parse(previous_file_path)
            except FileNotFoundError as e:
                return HttpResponse(f'<div class="alert alert-danger">{str(e)}</div>', status=404)
            except (json.JSONDecodeError, ValueError, Exception) as e:
                 logger.error(f"Client {client_id}: Error parsing file during comparison: {str(e)}", exc_info=True)
                 return HttpResponse(f'<div class="alert alert-danger">Error parsing file: {str(e)}</div>', status=500)

            # --- Comparison Logic (simplified from before, assuming structure) ---
            changes = []
            current_pages = {p.get('url'): p for p in current_data.get('pages', []) if p.get('url')} 
            previous_pages = {p.get('url'): p for p in previous_data.get('pages', []) if p.get('url')}
            
            # Added/Modified
            for url, current_page in current_pages.items():
                previous_page = previous_pages.get(url)
                if not previous_page:
                    changes.append({'page': url, 'type': 'added', 'details': 'New page added'})
                else:
                    # Compare tags
                    current_tags = {(t.get('name') or t.get('property')): t.get('content', '') 
                                    for t in current_page.get('meta_tags', []) if (t.get('name') or t.get('property'))}
                    previous_tags = {(t.get('name') or t.get('property')): t.get('content', '') 
                                     for t in previous_page.get('meta_tags', []) if (t.get('name') or t.get('property'))}
                    
                    for tag_name, current_content in current_tags.items():
                        previous_content = previous_tags.get(tag_name)
                        if previous_content is None:
                            changes.append({'page': url, 'type': 'added', 'details': f'Added tag: {tag_name}'})
                        elif previous_content != current_content:
                             changes.append({
                                 'page': url, 
                                 'type': 'modified', 
                                 'details': f'Changed {tag_name} from "{previous_content}" to "{current_content}"'
                             }) 
            # Removed
            for url in previous_pages:
                if url not in current_pages:
                    changes.append({'page': url, 'type': 'removed', 'details': 'Page removed'})

            context = {
                'changes': changes,
                'current_file': os.path.basename(file_path),
                'previous_file': os.path.basename(previous_file_path),
                'current_path': file_path,
                'previous_path': previous_file_path
            }
            logger.info(f"[HTMX View] Client {client_id}: Comparison mode finished for {file_path}. Time: {time.time() - start_time:.2f}s")
            return render(request, 'seo_manager/meta_tags/partials/meta_tags_comparison.html', context)

        else:
            # --- Single File View Logic ---
            logger.info(f"[HTMX View] Client {client_id}: Loading single file: {file_path}")
            if not meta_tag_storage.exists(file_path):
                logger.error(f"[HTMX View Error] Client {client_id}: File not found: {file_path}")
                return HttpResponse('<div class="alert alert-danger">File not found.</div>', status=404)

            logger.debug(f"[HTMX View] Client {client_id}: Reading file content for {file_path}")
            with meta_tag_storage._open(file_path, 'rb') as file_bytes:
                try:
                    file_content = file_bytes.read().decode('utf-8')
                    logger.debug(f"[HTMX View] Client {client_id}: File content read (UTF-8) for {file_path}. Length: {len(file_content)}")
                except UnicodeDecodeError:
                    logger.warning(f"[HTMX View Warning] Client {client_id}: UTF-8 decoding failed for {file_path}, trying latin-1")
                    file_bytes.seek(0)
                    file_content = file_bytes.read().decode('latin-1', errors='ignore')
                    logger.debug(f"[HTMX View] Client {client_id}: File content read (Latin-1) for {file_path}. Length: {len(file_content)}")

                try:
                    context = {
                        'file_path': file_path,
                        'file_name': os.path.basename(file_path)
                    }
                    target_template = None

                    if file_path.endswith('.json'):
                        logger.info(f"[HTMX View] Client {client_id}: Processing as JSON: {file_path}")
                        data = json.loads(file_content)
                        context['report_data'] = data
                        target_template = 'seo_manager/meta_tags/partials/meta_tags_report.html'
                        logger.debug(f"[HTMX View] Client {client_id}: JSON Parsed. Keys: {list(data.keys()) if isinstance(data, dict) else 'N/A'}")

                    elif file_path.endswith('.csv'):
                        logger.info(f"[HTMX View] Client {client_id}: Processing as CSV: {file_path}")
                        from io import StringIO
                        import csv
                        reader = csv.DictReader(StringIO(file_content))
                        rows = list(reader)
                        context['rows'] = rows
                        context['headers'] = reader.fieldnames if rows else []
                        target_template = 'seo_manager/meta_tags/partials/meta_tags_csv.html'
                        logger.debug(f"[HTMX View] Client {client_id}: CSV Parsed. Rows: {len(rows)}. Headers: {context['headers']}")

                    else:
                        logger.warning(f"[HTMX View Warning] Client {client_id}: Attempting to view unsupported file type: {file_path}")
                        return HttpResponse(f'<pre class="bg-dark text-light p-3">{escape(file_content)}</pre>', content_type='text/html')

                    # Check if context seems valid before rendering
                    if target_template:
                        if (target_template.endswith('csv.html') and not context.get('rows')) or \
                           (target_template.endswith('report.html') and not context.get('report_data')):
                           logger.warning(f"[HTMX View Warning] Client {client_id}: Context data for template {target_template} appears empty. File: {file_path}")

                        logger.info(f"[HTMX View] Client {client_id}: Rendering template {target_template} for {file_path}")
                        response = render(request, target_template, context)
                        logger.info(f"[HTMX View Success] Client {client_id}: Rendered {target_template} for {file_path}. Time: {time.time() - start_time:.2f}s")
                        return response
                    else:
                        # This case should technically be handled by the 'else' above, but as a safeguard:
                         logger.error(f"[HTMX View Error] Client {client_id}: No target template determined for {file_path}")
                         return HttpResponse('<div class="alert alert-danger">Could not determine how to display this file type.</div>', status=500)

                except json.JSONDecodeError as e:
                    logger.error(f"[HTMX View Error] Client {client_id}: Error parsing JSON file: {file_path} - {str(e)}", exc_info=True)
                    return HttpResponse('<div class="alert alert-danger">Failed to parse JSON content.</div>', status=500)
                except Exception as e: # Catch potential CSV errors or others
                    logger.error(f"[HTMX View Error] Client {client_id}: Error processing file content: {file_path} - {str(e)}", exc_info=True)
                    return HttpResponse(f'<div class="alert alert-danger">Error processing file: {str(e)}</div>', status=500)

    except Exception as e:
        # Catch-all for unexpected errors like unquote failure etc.
        logger.error(f"[HTMX View Fatal Error] Client {client_id}: Unexpected error in view_meta_tags_report for {file_path}: {str(e)}", exc_info=True)
        return HttpResponse(f'<div class="alert alert-danger">An unexpected server error occurred: {str(e)}</div>', status=500)

================
File: apps/seo_manager/views/project_views.py
================
from datetime import timedelta
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib import messages
from django.views.generic import ListView, CreateView, DetailView
from django.urls import reverse_lazy
from django.db.models import Avg
import json
import logging
from ..models import Client, SEOProject
from ..forms import SEOProjectForm
from apps.common.tools.user_activity_tool import user_activity_tool
from apps.common.utils import create_box

logger = logging.getLogger(__name__)

class ProjectListView(LoginRequiredMixin, ListView):
    template_name = 'seo_manager/projects/project_list.html'
    context_object_name = 'projects'

    def get_queryset(self):
        return SEOProject.objects.filter(client_id=self.kwargs['client_id'])

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['client'] = get_object_or_404(Client, id=self.kwargs['client_id'])
        return context

class ProjectCreateView(LoginRequiredMixin, CreateView):
    model = SEOProject
    form_class = SEOProjectForm
    
    def get(self, request, *args, **kwargs):
        # Redirect GET requests to client detail page since we're using modal
        return redirect('seo_manager:client_detail', client_id=self.kwargs['client_id'])
    
    def post(self, request, *args, **kwargs):
        form = self.get_form()
        logger.info(f"Form data: {request.POST}")
        if form.is_valid():
            logger.info("Form is valid")
            return self.form_valid(form)
        else:
            logger.error(f"Form errors: {form.errors}")
            # Redirect back to client detail with form errors in session
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")
            return redirect('seo_manager:client_detail', client_id=self.kwargs['client_id'])
    
    def get_form_kwargs(self):
        kwargs = super().get_form_kwargs()
        kwargs['client'] = get_object_or_404(Client, id=self.kwargs['client_id'])
        return kwargs

    def form_valid(self, form):
        form.instance.client_id = self.kwargs['client_id']
        # Capture initial rankings for targeted keywords
        initial_rankings = {}
        for keyword in form.cleaned_data['targeted_keywords']:
            latest_ranking = keyword.ranking_history.first()
            if latest_ranking:
                initial_rankings[keyword.keyword] = latest_ranking.average_position
        form.instance.initial_rankings = initial_rankings
        
        try:
            self.object = form.save()
            logger.info(f"Project saved successfully: {self.object.id}")
            user_activity_tool.run(self.request.user, 'create', f"Created SEO project: {form.instance.title}", client=form.instance.client)
            messages.success(self.request, 'Project created successfully!')
        except Exception as e:
            logger.error(f"Error saving project: {str(e)}")
            messages.error(self.request, f"Error creating project: {str(e)}")
            
        return redirect('seo_manager:client_detail', client_id=self.kwargs['client_id'])
    
class ProjectDetailView(LoginRequiredMixin, DetailView):
    model = SEOProject
    template_name = 'seo_manager/projects/project_detail.html'
    context_object_name = 'project'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        
        implementation_date = self.object.implementation_date
        pre_period_start = implementation_date - timedelta(days=30)
        post_period_end = implementation_date + timedelta(days=30)
        
        ranking_data = {
            'labels': [],
            'datasets': []
        }

        # Get impact analysis results with null check
        impact_analysis = self.object.analyze_impact() or {}
        performance_metrics = []
        logger.debug(f"Impact analysis results: {impact_analysis}")
        for keyword in self.object.targeted_keywords.all():
            rankings = keyword.ranking_history.filter(
                date__range=(pre_period_start, post_period_end)
            ).order_by('date')

            # Get impact metrics with safe defaults
            keyword_impact = impact_analysis.get(keyword.keyword, {})
            current_ranking = keyword.ranking_history.first()
            
            metrics = {
                'keyword': keyword.keyword,
                'initial_position': self.object.initial_rankings.get(keyword.keyword),
                'current_position': current_ranking.average_position if current_ranking else None,
                'pre_avg': None,
                'post_avg': None,
                'improvement': None,
                'impressions_change': None,
                'clicks_change': None
            }
            
            # Safely get and round values only if they exist
            if keyword_impact.get('pre_implementation_avg') is not None:
                metrics['pre_avg'] = round(float(keyword_impact['pre_implementation_avg']), 1)
            
            if keyword_impact.get('post_implementation_avg') is not None:
                metrics['post_avg'] = round(float(keyword_impact['post_implementation_avg']), 1)
            
            if keyword_impact.get('improvement') is not None:
                metrics['improvement'] = round(float(keyword_impact['improvement']), 1)
            
            if keyword_impact.get('impressions_change') is not None:
                metrics['impressions_change'] = round(float(keyword_impact['impressions_change']), 1)
            
            if keyword_impact.get('clicks_change') is not None:
                metrics['clicks_change'] = round(float(keyword_impact['clicks_change']), 1)
            
            performance_metrics.append(metrics)

            # Prepare chart dataset
            dataset = {
                'label': keyword.keyword,
                'data': [],
                'borderColor': f'#{hash(keyword.keyword) % 0xFFFFFF:06x}',
                'tension': 0.4,
                'fill': False
            }

            for ranking in rankings:
                if ranking.date.isoformat() not in ranking_data['labels']:
                    ranking_data['labels'].append(ranking.date.isoformat())
                dataset['data'].append(ranking.average_position)

            ranking_data['datasets'].append(dataset)

        # Add implementation date marker to chart
        ranking_data['implementation_date'] = implementation_date.isoformat()

        context.update({
            'ranking_history_data': json.dumps(ranking_data),
            'performance_metrics': performance_metrics,
            'implementation_date': implementation_date,
            'pre_period_start': pre_period_start,
            'post_period_end': post_period_end
        })

        return context

        return context
@login_required
def edit_project(request, client_id, project_id):
    """View for editing an existing SEO project."""
    project = get_object_or_404(SEOProject, id=project_id, client_id=client_id)
    
    if request.method == 'POST':
        form = SEOProjectForm(request.POST, instance=project, client=project.client)
        if form.is_valid():
            form.save()
            messages.success(request, 'Project updated successfully.')
            return redirect('seo_manager:client_detail', client_id=client_id)
    else:
        form = SEOProjectForm(instance=project, client=project.client)
    
    context = {
        'page_title': 'Edit Project',
        'form': form,
        'project': project,
        'client_id': client_id,
    }
    
    return render(request, 'seo_manager/projects/edit_project.html', context)

@login_required
def delete_project(request, client_id, project_id):
    """View for deleting an SEO project."""
    project = get_object_or_404(SEOProject, id=project_id, client_id=client_id)
    
    if request.method == 'POST':
        project.delete()
        messages.success(request, 'Project deleted successfully.')
        return redirect('seo_manager:client_detail', client_id=client_id)
    
    return redirect('seo_manager:client_detail', client_id=client_id)

================
File: apps/seo_manager/views/ranking_views.py
================
import csv
from django.shortcuts import get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_http_methods
from django.utils import timezone
from datetime import datetime, timedelta
from django.core.paginator import Paginator
from django.shortcuts import render
from django.db.models import Min, Max
from django.db import transaction
from ..models import Client, KeywordRankingHistory, TargetedKeyword
from ..forms import RankingImportForm
from apps.agents.tools.google_report_tool.google_rankings_tool import GoogleRankingsTool
import logging
import json

logger = logging.getLogger(__name__)

@login_required
def ranking_import(request, client_id):
    if request.method == 'POST':
        form = RankingImportForm(request.POST, request.FILES)
        if form.is_valid():
            form.process_import(request.user)
            messages.success(request, "Rankings imported successfully.")
            return redirect('seo_manager:client_detail', client_id=client_id)
    else:
        form = RankingImportForm()
    
    return render(request, 'seo_manager/keywords/ranking_import.html', {
        'form': form,
        'client': get_object_or_404(Client, id=client_id)
    })

@login_required
@require_http_methods(["POST"])
def collect_rankings(request, client_id):
    try:
        # Get the client
        client = get_object_or_404(Client, id=client_id)
        
        # Ensure client has Search Console credentials
        if not hasattr(client, 'sc_credentials'):
            return JsonResponse({
                'success': False,
                'error': "This client does not have Search Console credentials configured."
            })
        
        sc_creds = client.sc_credentials
        
        # Extract credentials for multi-tenant tool
        credentials = {
            'sc_client_id': sc_creds.sc_client_id,
            'client_secret': sc_creds.client_secret,
            'refresh_token': sc_creds.refresh_token,
            'token_uri': sc_creds.token_uri,
            'access_token': sc_creds.access_token
        }
        
        # Get property URL
        property_url = sc_creds.get_property_url()
        if not property_url:
            return JsonResponse({
                'success': False,
                'error': "No valid Search Console property URL configured for this client."
            })
        
        tool = GoogleRankingsTool()
        # Get just the last 30 days of data
        end_date = timezone.now().date()
        start_date = end_date - timedelta(days=7)
        
        # Call the tool with explicit parameters instead of client_id
        result_json = tool._run(
            start_date=start_date.strftime('%Y-%m-%d'),
            end_date=end_date.strftime('%Y-%m-%d'),
            search_console_property_url=property_url,
            search_console_credentials=credentials
        )
        
        # Parse the JSON result
        result = json.loads(result_json)
        
        if result.get('success'):
            # Process and store the data in the database
            total_stored = store_keyword_rankings(client, result.get('keyword_data', []))
            
            # Only show success if we actually stored some data
            if total_stored > 0:
                messages.success(request, "Latest rankings collected successfully")
                return JsonResponse({
                    'success': True,
                    'message': "Latest rankings data has been collected and stored",
                    'stored_count': total_stored
                })
            else:
                return JsonResponse({
                    'success': False,
                    'error': "No ranking data was collected. Please check your Search Console credentials."
                })
        else:
            error_msg = result.get('error', 'Failed to collect rankings')
            if 'invalid_grant' in error_msg or 'expired' in error_msg:
                error_msg = "Your Search Console access has expired. Please reconnect your Search Console account."
            
            return JsonResponse({
                'success': False,
                'error': error_msg
            })
    except Exception as e:
        logger.error(f"Error in collect_rankings view: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        })

@login_required
@require_http_methods(["POST"])
def backfill_rankings(request, client_id):
    try:
        # Get the client
        client = get_object_or_404(Client, id=client_id)
        
        # Ensure client has Search Console credentials
        if not hasattr(client, 'sc_credentials'):
            return JsonResponse({
                'success': False,
                'error': "This client does not have Search Console credentials configured."
            })
        
        sc_creds = client.sc_credentials
        
        # Extract credentials for multi-tenant tool
        credentials = {
            'sc_client_id': sc_creds.sc_client_id,
            'client_secret': sc_creds.client_secret,
            'refresh_token': sc_creds.refresh_token,
            'token_uri': sc_creds.token_uri,
            'access_token': sc_creds.access_token
        }
        
        # Get property URL
        property_url = sc_creds.get_property_url()
        if not property_url:
            return JsonResponse({
                'success': False,
                'error': "No valid Search Console property URL configured for this client."
            })
        
        tool = GoogleRankingsTool()
        
        # Call the tool with explicit parameters instead of client_id
        result_json = tool._run(
            start_date=None,
            end_date=None,
            search_console_property_url=property_url,
            search_console_credentials=credentials
        )
        
        # Parse the JSON result
        result = json.loads(result_json)
        
        if result.get('success'):
            # Process and store the data in the database
            total_stored = store_keyword_rankings(client, result.get('keyword_data', []))
            
            if total_stored > 0:
                messages.success(request, "Historical rankings collected successfully")
                return JsonResponse({
                    'success': True,
                    'message': "12 months of historical ranking data has been collected and stored",
                    'stored_count': total_stored
                })
            else:
                return JsonResponse({
                    'success': False,
                    'error': "No ranking data was collected."
                })
        else:
            return JsonResponse({
                'success': False,
                'error': result.get('error', 'Unknown error occurred')
            })
    except Exception as e:
        logger.error(f"Error in backfill_rankings view: {str(e)}", exc_info=True)
        return JsonResponse({
            'success': False,
            'error': str(e)
        })

@transaction.atomic
def store_keyword_rankings(client, keyword_data_periods):
    """
    Store keyword rankings in the database.
    This handles the database operations that were previously in the tool.
    """
    total_stored = 0
    
    try:
        # Get all targeted keywords for this client
        targeted_keywords = {
            kw.keyword.lower(): kw 
            for kw in TargetedKeyword.objects.filter(client=client)
        }
        
        for period_data in keyword_data_periods:
            # Parse the date from the returned data
            month_date = datetime.strptime(period_data['date'], '%Y-%m-%d').date()
            keyword_data = period_data['data']
            
            # Delete existing rankings for this month
            KeywordRankingHistory.objects.filter(
                client=client,
                date__year=month_date.year,
                date__month=month_date.month
            ).delete()
            
            # Process and store rankings
            rankings_to_create = []
            
            for data in keyword_data:
                keyword_text = data['Keyword']
                
                ranking = KeywordRankingHistory(
                    client=client,
                    keyword_text=keyword_text,
                    date=month_date,  # Use first day of month as reference date
                    impressions=data['Impressions'],
                    clicks=data['Clicks'],
                    ctr=data['CTR (%)'] / 100,
                    average_position=data['Avg Position']
                )
                
                # Link to TargetedKeyword if exists
                targeted_keyword = targeted_keywords.get(keyword_text.lower())
                if targeted_keyword:
                    ranking.keyword = targeted_keyword
                
                rankings_to_create.append(ranking)
            
            # Bulk create new rankings
            if rankings_to_create:
                KeywordRankingHistory.objects.bulk_create(
                    rankings_to_create,
                    batch_size=1000
                )
                
                count = len(rankings_to_create)
                total_stored += count
                logger.info(
                    f"Stored {count} rankings for {month_date.strftime('%B %Y')}"
                )
        
        return total_stored
            
    except Exception as e:
        logger.error(f"Error storing keyword rankings: {str(e)}")
        raise

@login_required
def ranking_data_management(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Get ranking data statistics
    ranking_stats = KeywordRankingHistory.objects.filter(
        client_id=client_id
    ).aggregate(
        earliest_date=Min('date'),
        latest_date=Max('date')
    )
    
    latest_collection_date = ranking_stats['latest_date']

    # Calculate data coverage in months
    data_coverage_months = 0
    if ranking_stats['earliest_date'] and ranking_stats['latest_date']:
        date_diff = ranking_stats['latest_date'] - ranking_stats['earliest_date']
        data_coverage_months = round(date_diff.days / 30)
    
    # Get search query
    search_query = request.GET.get('search', '')
    
    # Get sort parameters
    sort_by = request.GET.get('sort', '-date')  # Default sort by date descending
    if sort_by.startswith('-'):
        order_by = sort_by
        sort_dir = 'desc'
    else:
        order_by = sort_by
        sort_dir = 'asc'
    
    # Get items per page
    items_per_page = int(request.GET.get('items', 25))
    
    # Get rankings with filtering, sorting and pagination
    rankings_list = KeywordRankingHistory.objects.filter(client_id=client_id)
    
    # Apply search filter if provided
    if search_query:
        rankings_list = rankings_list.filter(keyword_text__icontains=search_query)
    
    # Apply sorting
    rankings_list = rankings_list.order_by(order_by)
    
    paginator = Paginator(rankings_list, items_per_page)
    page = request.GET.get('page')
    rankings = paginator.get_page(page)
    
    # Count unique keywords
    tracked_keywords_count = KeywordRankingHistory.objects.filter(
        client_id=client_id
    ).values('keyword_text').distinct().count()
    
    context = {
        'page_title': 'Rankings',
        'client': client,
        'latest_collection_date': latest_collection_date,
        'data_coverage_months': data_coverage_months,
        'tracked_keywords_count': tracked_keywords_count,
        'rankings': rankings,
        'sort_by': sort_by,
        'sort_dir': sort_dir,
        'search_query': search_query,
        'items': items_per_page,
    }
    
    return render(request, 'seo_manager/ranking_data_management.html', context)

@login_required
def export_rankings_csv(request, client_id):
    # Get search query
    search_query = request.GET.get('search', '')
    
    # Get rankings
    rankings = KeywordRankingHistory.objects.filter(client_id=client_id)
    if search_query:
        rankings = rankings.filter(keyword_text__icontains=search_query)
    
    # Create CSV response
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="rankings_{client_id}.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Keyword', 'Position', 'Change', 'Impressions', 'Clicks', 'CTR', 'Date'])
    
    for ranking in rankings:
        writer.writerow([
            ranking.keyword_text,
            ranking.average_position,
            ranking.position_change,
            ranking.impressions,
            ranking.clicks,
            f"{ranking.ctr:.2f}%",
            ranking.date.strftime("%Y-%m-%d")
        ])
    
    return response

================
File: apps/seo_manager/views/report_views.py
================
import logging
from django.shortcuts import get_object_or_404
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.template.loader import render_to_string
from django.utils import timezone
from dateutil.relativedelta import relativedelta
from ..models import Client

logger = logging.getLogger(__name__)

@login_required
@require_http_methods(["POST"])
def generate_report(request, client_id):
    try:
        client = get_object_or_404(Client.objects.select_related(), id=client_id)
        
        # Get the report data
        today = timezone.now().date()
        last_month = today - relativedelta(months=1)
        
        # Use select_related to optimize queries
        keywords = client.targeted_keywords.select_related().all()
        
        report = {
            'period': last_month.strftime('%B %Y'),
            'keywords': {
                'total': keywords.count(),
                'improved': 0,
                'declined': 0,
                'unchanged': 0
            },
            'top_improvements': [],
            'needs_attention': []
        }

        # Process keyword data
        for keyword in keywords:
            change = keyword.get_position_change()
            if change:
                if change > 0:
                    report['keywords']['improved'] += 1
                    if change > 5:
                        report['top_improvements'].append({
                            'keyword': keyword.keyword,
                            'improvement': change
                        })
                elif change < 0:
                    report['keywords']['declined'] += 1
                    if change < -5:
                        report['needs_attention'].append({
                            'keyword': keyword.keyword,
                            'decline': abs(change)
                        })
                else:
                    report['keywords']['unchanged'] += 1

        # Sort improvements and needs attention lists
        report['top_improvements'].sort(key=lambda x: x['improvement'], reverse=True)
        report['needs_attention'].sort(key=lambda x: x['decline'], reverse=True)

        # Limit to top 5 for each list
        report['top_improvements'] = report['top_improvements'][:5]
        report['needs_attention'] = report['needs_attention'][:5]

        # Render the report template
        report_html = render_to_string(
            'seo_manager/reports/monthly_report.html',
            {'report': report, 'client': client},
            request=request
        )

        return JsonResponse({
            'success': True,
            'report_html': report_html
        })
        
    except Exception as e:
        logger.error(f"Error generating report: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': f"Error generating report: {str(e)}"
        })

================
File: apps/seo_manager/views/search_console_views.py
================
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.core.exceptions import ValidationError
from ..models import Client, SearchConsoleCredentials
from ..google_auth import get_google_auth_flow, get_search_console_properties
from apps.common.tools.user_activity_tool import user_activity_tool
import json
import logging
from django.urls import reverse

logger = logging.getLogger(__name__)

@login_required
def client_search_console(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Check if client has Search Console credentials
    if not hasattr(client, 'sc_credentials'):
        messages.warning(request, {
            'title': 'Search Console Not Connected',
            'text': 'Please connect your Search Console account first.',
            'icon': 'warning',
            'redirect_url': reverse('seo_manager:client_integrations', args=[client_id])
        }, extra_tags='sweetalert')
        return redirect('seo_manager:client_integrations', client_id=client.id)
    
    try:
        # Try to get Search Console data
        service = client.sc_credentials.get_service()
        property_url = client.sc_credentials.property_url
        
        # If we get here, the credentials are valid
        context = {
            'client': client,
            'page_title': 'Search Console',
        }
        return render(request, 'seo_manager/client_search_console.html', context)
        
    except Exception as e:
        error_str = str(e)
        logger.error(f"Error accessing Search Console: {error_str}")
        
        if 'invalid_grant' in error_str.lower():
            # Remove invalid credentials
            client.sc_credentials.delete()
            
            # Log the activity
            user_activity_tool.run(
                None,  # System action
                'delete',
                f"Search Console credentials automatically removed due to invalid grant",
                client=client
            )
            
            messages.error(request, {
                'title': 'Search Console Connection Expired',
                'text': 'Your Search Console connection has expired or been revoked. Please reconnect your account.',
                'icon': 'error',
                'redirect_url': reverse('seo_manager:client_integrations', args=[client_id])
            }, extra_tags='sweetalert')
            return redirect('seo_manager:client_integrations', client_id=client.id)
        else:
            messages.error(request, {
                'title': 'Error',
                'text': 'An error occurred accessing Search Console. Please try again later.',
                'icon': 'error',
                'redirect_url': reverse('seo_manager:client_detail', args=[client_id])
            }, extra_tags='sweetalert')
            return redirect('seo_manager:client_detail', client_id=client.id)

@login_required
def add_sc_credentials(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Check if client already has credentials
    if hasattr(client, 'sc_credentials'):
        messages.warning(request, "Search Console credentials already exist for this client. Remove them first to add new ones.")
        return redirect('seo_manager:client_detail', client_id=client.id)
    
    # Handle POST request for property selection
    if request.method == 'POST':
        selected_property = request.POST.get('selected_property')
        if selected_property:
            try:
                # Extract just the URL
                try:
                    property_data = json.loads(selected_property)
                    logger.info(f"property_data: {property_data}")
                    property_url = property_data['url']
                except (json.JSONDecodeError, KeyError):
                    property_url = selected_property

                logger.info(f"""
                    Storing Search Console credentials for {client.name}:
                    property_url: {property_url}
                    access_token: {bool(request.session.get('access_token'))}
                    refresh_token: {bool(request.session.get('refresh_token'))}
                    token_uri: {bool(request.session.get('token_uri'))}
                    client_id: {bool(request.session.get('client_id'))}
                    client_secret: {bool(request.session.get('client_secret'))}
                """)

                credentials = SearchConsoleCredentials.objects.update_or_create(
                    client=client,
                    defaults={
                        'property_url': property_url,
                        'access_token': request.session.get('access_token'),
                        'refresh_token': request.session.get('refresh_token'),
                        'token_uri': request.session.get('token_uri'),
                        'sc_client_id': request.session.get('client_id'),
                        'client_secret': request.session.get('client_secret'),
                    }
                )[0]
                user_activity_tool.run(request.user, 'create', f"Added Search Console credentials for client: {client.name}", client=client)
                messages.success(request, "Search Console credentials added successfully.")
                
                # Clean up session
                for key in ['properties', 'access_token', 'refresh_token', 'token_uri', 'client_id', 'client_secret']:
                    request.session.pop(key, None)
                
                return redirect('seo_manager:client_detail', client_id=client.id)
            except Exception as e:
                messages.error(request, f"Error saving Search Console credentials: {str(e)}")
        else:
            messages.error(request, "Please select a property.")
    
    # If we have properties in session, show selection page
    if 'properties' in request.session:
        return render(request, 'seo_manager/select_search_console_property.html', {
            'client': client,
            'properties': request.session['properties'],
        })
    
    # Start OAuth flow if no properties in session
    flow = get_google_auth_flow(request)
    authorization_url, state = flow.authorization_url(
        access_type='offline',
        include_granted_scopes='true',
        state=f"{client_id}_sc",
        prompt='consent'
    )
    request.session['oauth_state'] = state
    return redirect(authorization_url)

@login_required
def remove_sc_credentials(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    try:
        if hasattr(client, 'sc_credentials'):
            client.sc_credentials.delete()
            user_activity_tool.run(request.user, 'delete', f"Removed Search Console credentials for client: {client.name}", client=client)
            messages.success(request, "Search Console credentials removed successfully.")
        else:
            messages.warning(request, "No Search Console credentials found for this client.")
    except Exception as e:
        messages.error(request, f"Error removing Search Console credentials: {str(e)}")
    
    for key in ['properties', 'access_token', 'refresh_token', 'token_uri', 'client_id', 'client_secret']:
        request.session.pop(key, None)
    
    return redirect('seo_manager:client_detail', client_id=client.id)

@login_required
def add_sc_credentials_service_account(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Clear any existing session data
    for key in ['properties', 'service_account_json']:
        request.session.pop(key, None)
    
    if request.method == 'POST':
        if 'selected_property' in request.POST:
            selected_property = request.POST.get('selected_property')
            if selected_property:
                properties = request.session.get('properties', [])
                property_data = next((prop for prop in properties if prop['url'] == selected_property), None)
                if property_data:
                    SearchConsoleCredentials.objects.update_or_create(
                        client=client,
                        defaults={
                            'service_account_json': request.session.get('service_account_json', ''),
                            'property_url': property_data['url'],
                        }
                    )
                    user_activity_tool.run(request.user, 'create', f"Added Search Console credentials (Service Account) for client: {client.name}", client=client)
                    messages.success(request, "Search Console credentials (Service Account) added successfully.")
                    return redirect('seo_manager:client_detail', client_id=client.id)
                else:
                    messages.error(request, "Selected property not found. Please try again.")
            else:
                messages.error(request, "Please select a property.")
        elif 'service_account_file' in request.FILES:
            service_account_file = request.FILES['service_account_file']
            try:
                service_account_info = json.load(service_account_file)
                service_account_json = json.dumps(service_account_info)
                properties = get_search_console_properties(service_account_json)
                request.session['properties'] = properties
                request.session['service_account_json'] = service_account_json
                return render(request, 'seo_manager/select_search_console_property.html', {
                    'client': client,
                    'properties': properties,
                })
            except json.JSONDecodeError:
                messages.error(request, "Invalid JSON file. Please upload a valid service account JSON file.")
        else:
            messages.error(request, "No file uploaded. Please select a service account JSON file.")
    
    # If no POST or no properties in session, show the upload form
    return render(request, 'seo_manager/add_sc_credentials_service_account.html', {'client': client})

def get_search_console_data(service, property_url, start_date, end_date):
    try:
        response = service.searchanalytics().query(
            siteUrl=property_url,
            body={
                'startDate': start_date,
                'endDate': end_date,
                'dimensions': ['query'],
                'rowLimit': 1000
            }
        ).execute()
        
        search_console_data = []
        for row in response.get('rows', []):
            search_console_data.append({
                'query': row['keys'][0],
                'clicks': row['clicks'],
                'impressions': row['impressions'],
                'ctr': row['ctr'] * 100,  # Convert to percentage
                'position': row['position']
            })
        
        search_console_data.sort(key=lambda x: x['impressions'], reverse=True)
        
        return search_console_data
    except Exception as e:
        error_str = str(e)
        logger.error(f"An error occurred: {error_str}")
        
        # Check for invalid grant error
        if 'invalid_grant' in error_str.lower():
            # Find the client associated with this property_url
            try:
                sc_credentials = SearchConsoleCredentials.objects.get(property_url=property_url)
                client = sc_credentials.client
                
                # Invalidate the credentials
                sc_credentials.delete()
                
                # Log the event
                user_activity_tool.run(
                    None,  # System action
                    'delete',
                    f"Search Console credentials automatically removed due to invalid grant",
                    client=client
                )
                
                logger.info(f"Removed invalid Search Console credentials for property: {property_url}")
                
            except SearchConsoleCredentials.DoesNotExist:
                logger.error(f"Could not find Search Console credentials for property: {property_url}")
            except Exception as inner_e:
                logger.error(f"Error handling invalid credentials: {str(inner_e)}")
        
        return []

def _get_redirect_url(request, client_id):
    """Helper function to determine redirect URL based on 'next' parameter"""
    next_page = request.GET.get('next')
    if next_page == 'integrations':
        return 'seo_manager:client_integrations'
    return 'seo_manager:client_detail'

__all__ = [
    'client_search_console',
    'add_sc_credentials',
    'add_sc_credentials_service_account',
    'remove_sc_credentials'
]

================
File: apps/seo_manager/admin.py
================
from django.contrib import admin
from .models import ClientGroup, Client, SEOData, AIProvider

@admin.register(ClientGroup)
class ClientGroupAdmin(admin.ModelAdmin):
    list_display = ('name', 'parent')
    search_fields = ('name',)

@admin.register(Client)
class ClientAdmin(admin.ModelAdmin):
    list_display = ('name', 'website_url', 'status', 'group')
    list_filter = ('status', 'group')
    search_fields = ('name', 'website_url')

@admin.register(SEOData)
class SEODataAdmin(admin.ModelAdmin):
    list_display = ('client', 'date', 'traffic', 'keywords')
    list_filter = ('client', 'date')
    date_hierarchy = 'date'

@admin.register(AIProvider)
class AIProviderAdmin(admin.ModelAdmin):
    list_display = ('name', 'model', 'is_active')
    list_filter = ('is_active',)
    search_fields = ('name', 'model')

================
File: apps/seo_manager/apps.py
================
from django.apps import AppConfig

class SeoManagerConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.seo_manager'
    verbose_name = 'SEO Manager'

================
File: apps/seo_manager/consumers.py
================
import json
import logging
from channels.generic.websocket import AsyncWebsocketConsumer
from apps.common.websockets.organization_consumer import OrganizationAwareConsumer
from celery.result import AsyncResult
import asyncio
from asgiref.sync import sync_to_async

logger = logging.getLogger(__name__)

class MetaTagsTaskConsumer(OrganizationAwareConsumer):
    """WebSocket consumer for meta tags extraction task updates with organization context support."""
    
    async def connect(self):
        """Handle WebSocket connection with organization context."""
        # Set organization context first
        await super().connect()
        
        self.task_id = self.scope['url_route']['kwargs']['task_id']
        self.group_name = f"metatags_task_{self.task_id}"
        
        # Join the group for this task
        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        
        await self.accept()
        logger.info(f"WebSocket connection established for meta tags task: {self.task_id}")
        
        # Start the background task to check task status periodically
        self.check_task_status_task = asyncio.create_task(self.check_task_status_periodically())
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        # Leave the group
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )
        
        # Cancel the background task if it's running
        if hasattr(self, 'check_task_status_task'):
            self.check_task_status_task.cancel()
            
        logger.info(f"WebSocket connection closed for meta tags task: {self.task_id}")
        
        # Clear organization context
        await super().disconnect(close_code)
    
    async def receive(self, text_data):
        """Handle incoming WebSocket messages."""
        try:
            data = json.loads(text_data)
            message_type = data.get('type')
            
            if message_type == 'check_status':
                # Client is requesting a status update
                await self.check_task_status()
            
        except Exception as e:
            logger.error(f"Error processing WebSocket message: {str(e)}")
    
    async def check_task_status_periodically(self):
        """Periodically check Celery task status and send updates."""
        try:
            while True:
                await self.check_task_status()
                # Wait for 2 seconds before checking again
                await asyncio.sleep(2)
        except asyncio.CancelledError:
            # Task was cancelled, this is normal during disconnect
            pass
        except Exception as e:
            logger.error(f"Error in periodic task status check: {str(e)}")
    
    @sync_to_async
    def get_task_status(self, task_id):
        """Get Celery task status in a synchronous context."""
        try:
            result = AsyncResult(task_id)
            
            if result.ready():
                if result.successful():
                    task_result = result.get()
                    # Extract file path from result for the client to use
                    file_path = task_result.get('file_path', '')
                    success = task_result.get('success', False)
                    
                    return {
                        'ready': True,
                        'successful': True,
                        'task_result': task_result,
                        'file_path': file_path,
                        'success': success,
                        'url': task_result.get('url', '')
                    }
                else:
                    error = str(result.result) if result.result else "Unknown error"
                    return {
                        'ready': True,
                        'successful': False,
                        'error': error
                    }
            else:
                # Task is still pending
                return {
                    'ready': False,
                    'state': result.state
                }
        except Exception as e:
            logger.error(f"Error in get_task_status: {str(e)}")
            return {
                'ready': True,
                'successful': False,
                'error': str(e)
            }
    
    async def check_task_status(self):
        """Check the status of the Celery task and send an update."""
        try:
            # Get task status in a way safe for async context
            result_info = await self.get_task_status(self.task_id)
            
            # Prepare the status update based on result_info
            if result_info['ready']:
                if result_info['successful']:
                    status_update = {
                        'type': 'status_update',
                        'status': 'complete',
                        'result': {
                            'success': result_info['success'],
                            'file_path': result_info['file_path'],
                            'url': result_info['url']
                        },
                        'message': "Meta tags snapshot completed successfully."
                    }
                    logger.info(f"Task {self.task_id} completed successfully: {result_info['file_path']}")
                else:
                    status_update = {
                        'type': 'status_update',
                        'status': 'failed',
                        'error': result_info['error'],
                        'message': f"Meta tags snapshot failed: {result_info['error']}"
                    }
                    logger.error(f"Task {self.task_id} failed: {result_info['error']}")
            else:
                # Task is still pending
                status_update = {
                    'type': 'status_update',
                    'status': 'pending',
                    'message': "Meta tags snapshot is still processing."
                }
            
            # Send the status update to the group
            await self.channel_layer.group_send(
                self.group_name,
                status_update
            )
        except Exception as e:
            logger.error(f"Error checking task status: {str(e)}")
            
    async def progress_update(self, event):
        """Handle progress updates and send them to the WebSocket."""
        try:
            # Log the incoming progress event
            logger.debug(f"Received progress_update event: {event}")
            
            # Send progress data directly without the type field
            message = {
                'progress': event['progress']
            }
            logger.debug(f"Sending progress message to WebSocket: {message}")
            await self.send(text_data=json.dumps(message))
        except Exception as e:
            logger.error(f"Error sending progress update: {str(e)}")
    
    async def status_update(self, event):
        """Handle status updates and send them to the WebSocket."""
        try:
            # Log the incoming status event
            logger.debug(f"Received status_update event: {event}")
            
            # Remove type field as it's used internally by channels
            data = {k: v for k, v in event.items() if k != 'type'}
            
            logger.debug(f"Sending status message to WebSocket: {data}")
            # Send the status update to the WebSocket - send directly as expected by client
            await self.send(text_data=json.dumps(data))
        except Exception as e:
            logger.error(f"Error sending status update: {str(e)}")

================
File: apps/seo_manager/exceptions.py
================
class AuthError(Exception):
    """Custom exception for authentication errors"""
    pass

================
File: apps/seo_manager/forms.py
================
from django import forms
from django.core.exceptions import ValidationError
from .models import Client, TargetedKeyword, KeywordRankingHistory, SEOProject
import csv
import io
from django.utils import timezone

class ClientForm(forms.ModelForm):
    class Meta:
        model = Client
        fields = ['name', 'website_url', 'status', 'group', 'target_audience']
        widgets = {
            'name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'Enter client name'
            }),
            'website_url': forms.URLInput(attrs={
                'class': 'form-control',
                'placeholder': 'https://example.com'
            }),
            'status': forms.Select(attrs={
                'class': 'form-select'
            }),
            'group': forms.Select(attrs={
                'class': 'form-select'
            }),
            'target_audience': forms.Textarea(attrs={
                'class': 'form-control',
                'rows': 3,
                'placeholder': 'Describe the target audience'
            }),
        }

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # Add any additional field customization here
        for field in self.fields.values():
            if not isinstance(field.widget, forms.CheckboxInput):
                field.widget.attrs.update({
                    'class': field.widget.attrs.get('class', '') + ' form-control'
                })

class BusinessObjectiveForm(forms.Form):
    goal = forms.CharField(required=True)
    metric = forms.CharField(required=True)
    target_date = forms.DateField(required=True)
    status = forms.BooleanField(required=False, initial=True)

    def clean_target_date(self):
        target_date = self.cleaned_data.get('target_date')
        if target_date and target_date < timezone.now().date():
            raise ValidationError("Target date cannot be in the past")
        return target_date

class TargetedKeywordForm(forms.ModelForm):
    class Meta:
        model = TargetedKeyword
        fields = ['keyword', 'priority', 'notes']
        widgets = {
            'keyword': forms.TextInput(attrs={'class': 'form-control'}),
            'priority': forms.Select(attrs={'class': 'form-select'}),
            'notes': forms.Textarea(attrs={'class': 'form-control', 'rows': 3}),
        }

class KeywordBulkUploadForm(forms.Form):
    csv_file = forms.FileField(
        label='CSV File',
        help_text='Upload a CSV file with columns: keyword, priority (1-5), notes (optional)',
        widget=forms.FileInput(attrs={'class': 'form-control'})
    )

    def clean_csv_file(self):
        csv_file = self.cleaned_data['csv_file']
        if not csv_file.name.endswith('.csv'):
            raise ValidationError('File must be a CSV')
        
        # Validate CSV structure
        try:
            decoded_file = csv_file.read().decode('utf-8')
            csv_data = csv.DictReader(io.StringIO(decoded_file))
            required_fields = ['keyword', 'priority']
            
            if not all(field in csv_data.fieldnames for field in required_fields):
                raise ValidationError('CSV must contain keyword and priority columns')
            
            # Reset file pointer
            csv_file.seek(0)
            return csv_file
        except Exception as e:
            raise ValidationError(f'Invalid CSV file: {str(e)}')

class RankingImportForm(forms.Form):
    IMPORT_SOURCE_CHOICES = [
        ('search_console', 'Google Search Console'),
        ('csv', 'CSV Upload'),
        ('manual', 'Manual Entry'),
    ]

    import_source = forms.ChoiceField(
        choices=IMPORT_SOURCE_CHOICES,
        widget=forms.RadioSelect(attrs={'class': 'form-check-input'})
    )
    
    date_from = forms.DateField(
        widget=forms.DateInput(attrs={
            'class': 'form-control flatpickr-date',
            'data-toggle': 'flatpickr'
        })
    )
    
    date_to = forms.DateField(
        widget=forms.DateInput(attrs={
            'class': 'form-control flatpickr-date',
            'data-toggle': 'flatpickr'
        })
    )
    
    csv_file = forms.FileField(
        required=False,
        widget=forms.FileInput(attrs={'class': 'form-control'})
    )

    def clean(self):
        cleaned_data = super().clean()
        import_source = cleaned_data.get('import_source')
        csv_file = cleaned_data.get('csv_file')

        if import_source == 'csv' and not csv_file:
            raise ValidationError('CSV file is required when importing from CSV')

        return cleaned_data

    def process_import(self, user):
        import_source = self.cleaned_data['import_source']
        
        if import_source == 'search_console':
            return self._process_search_console_import()
        elif import_source == 'csv':
            return self._process_csv_import()
        else:
            return self._process_manual_entry()

    def _process_search_console_import(self):
        # Implementation for Search Console import
        pass

    def _process_csv_import(self):
        # Implementation for CSV import
        pass

    def _process_manual_entry(self):
        # Implementation for manual entry
        pass

class SEOProjectForm(forms.ModelForm):
    class Meta:
        model = SEOProject
        fields = ['title', 'description', 'status', 
                 'implementation_date', 'completion_date', 
                 'targeted_keywords']
        widgets = {
            'implementation_date': forms.DateInput(attrs={
                'class': 'form-control datepicker',
                'type': 'date'
            }),
            'completion_date': forms.DateInput(attrs={
                'class': 'form-control datepicker',
                'type': 'date'
            }),
            'description': forms.Textarea(attrs={
                'rows': 3, 
                'class': 'form-control'
            }),
            'title': forms.TextInput(attrs={
                'class': 'form-control'
            }),
            'status': forms.Select(attrs={
                'class': 'form-control'
            }),
            'targeted_keywords': forms.SelectMultiple(attrs={
                'class': 'form-control'
            }),
        }

    def __init__(self, *args, **kwargs):
        client = kwargs.pop('client', None)
        super().__init__(*args, **kwargs)
        
        if client:
            self.fields['targeted_keywords'].queryset = TargetedKeyword.objects.filter(
                client=client
            ).order_by('keyword')

    def clean(self):
        cleaned_data = super().clean()
        implementation_date = cleaned_data.get('implementation_date')
        completion_date = cleaned_data.get('completion_date')

        if completion_date and implementation_date and completion_date < implementation_date:
            raise ValidationError({
                'completion_date': 'Completion date cannot be earlier than implementation date.'
            })

        return cleaned_data

class ClientProfileForm(forms.Form):
    client_profile = forms.CharField(
        widget=forms.Textarea(attrs={
            'class': 'form-control',
            'rows': 10,
            'placeholder': 'Enter a detailed 300-500 word profile of the client\'s business, goals, and SEO strategy'
        }),
        help_text="Provide a comprehensive overview of the client's business, target market, goals, and SEO strategy."
    )

================
File: apps/seo_manager/google_auth.py
================
from google_auth_oauthlib.flow import Flow
from django.conf import settings
from django.urls import reverse
from google.oauth2.credentials import Credentials
from google.oauth2 import service_account
from googleapiclient.discovery import build
import json
import logging

logger = logging.getLogger(__name__)

def get_google_auth_flow(request):
    """
    Creates OAuth2 flow for Google Analytics and Search Console authentication.
    """
    flow = Flow.from_client_secrets_file(
        settings.GOOGLE_CLIENT_SECRETS_FILE,
        scopes=[
            'https://www.googleapis.com/auth/analytics.readonly',  # GA4 scope
            'https://www.googleapis.com/auth/webmasters.readonly',
            'openid',
            'https://www.googleapis.com/auth/userinfo.email',
            'https://www.googleapis.com/auth/userinfo.profile'
        ],
        redirect_uri=request.build_absolute_uri('/google/login/callback/')
    )
    return flow

def get_analytics_accounts_oauth(credentials):
    """Get GA4 accounts using OAuth credentials"""
    try:
        # Create the Analytics Admin API client
        analytics = build('analyticsadmin', 'v1beta', credentials=credentials)
        
        try:
            # First get accounts
            accounts_request = analytics.accounts().list().execute()
            accounts = []
            
            # For each account, get its properties
            for account in accounts_request.get('accounts', []):
                account_id = account['name']  # Format: "accounts/1234567"
                account_name = account.get('displayName', 'Unknown Account')
                #logger.info(f"Fetching properties for account: {account_name}")
                
                try:
                    # Initialize pagination variables
                    page_token = None
                    page_num = 1
                    properties_count = 0
                    
                    while True:
                        # List properties for this account with pagination
                        request_params = {
                            'filter': f'parent:{account_id}',
                            'pageSize': 200  # Maximum allowed page size
                        }
                        if page_token:
                            request_params['pageToken'] = page_token
                            
                        properties_request = analytics.properties().list(**request_params).execute()
                        
                        for property in properties_request.get('properties', []):
                            property_id = property['name']
                            property_name = property.get('displayName', 'Unknown Property')
                            
                            accounts.append({
                                'property_id': property_id,
                                'property_name': property_name,
                                'account_name': account_name
                            })
                            properties_count += 1
                        
                        # Check if there are more pages
                        page_token = properties_request.get('nextPageToken')
                        if not page_token:
                            break
                            
                        page_num += 1
                    
                    # logger.info(f"Found {properties_count} properties in account: {account_name}")
                        
                except Exception as e:
                    logger.error(f"Error listing properties for account {account_id}: {str(e)}", exc_info=True)
                    continue
            
            logger.info(f"Total GA4 properties found across all accounts: {len(accounts)}")
            return accounts
            
        except Exception as e:
            logger.error(f"Error listing GA4 accounts: {str(e)}", exc_info=True)
            return []
            
    except Exception as e:
        logger.error(f"Error building GA4 service: {str(e)}", exc_info=True)
        return []

def get_analytics_accounts_service_account(service_account_json):
    """Get GA4 properties using service account credentials"""
    try:
        credentials = service_account.Credentials.from_service_account_info(
            json.loads(service_account_json),
            scopes=['https://www.googleapis.com/auth/analytics.readonly']
        )
        analytics = build('analyticsadmin', 'v1beta', credentials=credentials)
        return fetch_analytics_accounts(analytics)
    except Exception as e:
        logger.error(f"Error building GA4 service with service account: {str(e)}")
        return []

def fetch_analytics_accounts(analytics):
    """Fetch GA4 properties using the Analytics Admin API"""
    try:
        # List all GA4 properties accessible to the user
        request = analytics.accounts().list()
        response = request.execute()
        
        accounts = []
        for account in response.get('accounts', []):
            account_id = account['name'].split('/')[-1]  # Format: "accounts/123456"
            account_name = account.get('displayName', 'Unknown Account')
            
            # Get properties for this account using the correct API call
            properties_request = analytics.properties().list(
                filter=f"parent:accounts/{account_id}"  # Changed from parent parameter to filter
            )
            properties_response = properties_request.execute()
            
            for property in properties_response.get('properties', []):
                property_id = property['name'].split('/')[-1]  # Format: "properties/123456"
                accounts.append({
                    'account_id': account_id,
                    'account_name': account_name,
                    'property_id': property_id,
                    'property_name': property.get('displayName', 'Unknown Property')
                })
        
        logger.info(f"Found {len(accounts)} GA4 properties")
        if not accounts:
            logger.warning("No GA4 properties found for this account")
            
        return accounts
        
    except Exception as e:
        logger.error(f"Error fetching GA4 properties: {str(e)}")
        return []

def get_search_console_service(credentials):
    return build('searchconsole', 'v1', credentials=credentials)

def get_search_console_properties(credentials_or_json):
    """Get list of Search Console properties"""
    try:
        if isinstance(credentials_or_json, str):
            service_account_info = json.loads(credentials_or_json)
            credentials = service_account.Credentials.from_service_account_info(
                service_account_info,
                scopes=['https://www.googleapis.com/auth/webmasters.readonly']
            )
        else:
            credentials = credentials_or_json

        service = build('searchconsole', 'v1', credentials=credentials)
        sites = service.sites().list().execute()
        
        properties = []
        if 'siteEntry' in sites:
            for site in sites['siteEntry']:
                # logger.info(f"Found Search Console site: {site}")
                properties.append({
                    'url': site['siteUrl'],
                    'permission_level': site.get('permissionLevel', '')
                })
        
        return properties

    except Exception as e:
        logger.error(f"Error getting Search Console properties: {str(e)}")
        raise

================
File: apps/seo_manager/middleware.py
================
from .exceptions import AuthError
from django.shortcuts import redirect
from django.contrib import messages

class GoogleAuthMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        return response

    def process_exception(self, request, exception):
        if isinstance(exception, AuthError):
            messages.error(request, str(exception))
            return redirect('seo_manager:client_list')
        return None

================
File: apps/seo_manager/models.py
================
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone
from django.db.models import Q
from django.db.models import Avg
import logging
from dateutil.relativedelta import relativedelta
import json
from datetime import datetime
from google.oauth2.credentials import Credentials
from google.oauth2 import service_account
from google.analytics.data_v1beta import BetaAnalyticsDataClient
from googleapiclient.discovery import build
import google.auth.transport.requests
from google.auth.transport.requests import Request
from google_auth_oauthlib.flow import Flow
from django.urls import reverse
from django.conf import settings
from .exceptions import AuthError
from django.contrib.auth import get_user_model
from apps.organizations.models.mixins import OrganizationModelMixin
from core.storage import SecureFileStorage

logger = logging.getLogger(__name__)

User = get_user_model()

# Create storage for SEO documentation files
seo_docs_storage = SecureFileStorage(
    private=True,
    collection='seo_projects'
)

class ClientGroup(models.Model):
    name = models.CharField(max_length=100)
    parent = models.ForeignKey('self', on_delete=models.SET_NULL, null=True, blank=True, related_name='children')

    def __str__(self):
        return self.name

class Client(OrganizationModelMixin, models.Model):
    STATUS_CHOICES = [
        ('active', 'Active'),
        ('inactive', 'Inactive'),
        ('on_hold', 'On Hold'),
    ]

    name = models.CharField(max_length=100)
    website_url = models.URLField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='active')
    group = models.ForeignKey(ClientGroup, on_delete=models.SET_NULL, null=True, blank=True, related_name='clients')
    # organization field is inherited from OrganizationModelMixin
    # Track the user who created this client
    created_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        related_name='created_clients',
        null=True,
        blank=True,
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    business_objectives = models.JSONField(default=list, blank=True)
    target_audience = models.TextField(blank=True, null=True)
    # New field
    client_profile = models.TextField(
        help_text="Detailed 300-500 word profile of the client's business, goals, and SEO strategy",
        blank=True
    )
    distilled_website = models.TextField(
        help_text="Distilled version of the client's website content for SEO purposes",
        blank=True
    )
    distilled_website_date = models.DateTimeField(
        null=True,
        blank=True,
        help_text="The last time the distilled website content was modified or created"
    )

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if self.business_objectives is None:
            self.business_objectives = []

    def __str__(self):
        return self.name
    
    def save(self, *args, **kwargs):
        if self.pk:
            old_client = Client.objects.get(pk=self.pk)
            if old_client.distilled_website != self.distilled_website:
                self.distilled_website_date = timezone.now()
        else:
            if self.distilled_website:
                self.distilled_website_date = timezone.now()
        super().save(*args, **kwargs)
        
    def get_keyword_rankings_summary(self):
        """Get summary of current keyword rankings"""
        latest_rankings = KeywordRankingHistory.objects.filter(
            client=self,
            keyword__isnull=False,  # Only targeted keywords
            date=KeywordRankingHistory.objects.filter(
                client=self,
                keyword__isnull=False
            ).values('date').order_by('-date').first()['date']
        ).select_related('keyword')

        return {
            'total_keywords': latest_rankings.count(),
            'avg_position': latest_rankings.aggregate(
                Avg('average_position')
            )['average_position__avg'],
            'rankings': latest_rankings
        }

class SEOData(models.Model):
    client = models.ForeignKey(Client, on_delete=models.CASCADE, related_name='seo_data')
    date = models.DateField()
    traffic = models.IntegerField()
    keywords = models.IntegerField()
    rankings = models.JSONField()  # Store rankings as JSON

    class Meta:
        unique_together = ['client', 'date']

class AIProvider(models.Model):
    name = models.CharField(max_length=100)
    api_key = models.CharField(max_length=255)
    model = models.CharField(max_length=100)
    parameters = models.JSONField(default=dict)
    is_active = models.BooleanField(default=True)

    def __str__(self):
        return self.name

class OAuthManager:
    """Manages OAuth operations for Google services"""
    
    @staticmethod
    def create_oauth_flow(request, state_key=None):
        """Create OAuth flow for Google services"""
        logger.info(f"Creating OAuth flow with state key: {state_key}")
        
        # Get the current domain and scheme
        scheme = request.scheme
        domain = request.get_host()
        
        # Use the same redirect URI that's configured in Google Console
        redirect_uri = f'{scheme}://{domain}/google/login/callback/'
        
        logger.info(f"Using redirect URI: {redirect_uri}")
        
        try:
            flow = Flow.from_client_secrets_file(
                settings.GOOGLE_CLIENT_SECRETS_FILE,
                scopes=[
                    'https://www.googleapis.com/auth/analytics.readonly',
                    'https://www.googleapis.com/auth/webmasters.readonly',
                    'https://www.googleapis.com/auth/adwords',  # Add Google Ads scope
                    'openid',
                    'https://www.googleapis.com/auth/userinfo.email',
                    'https://www.googleapis.com/auth/userinfo.profile'
                ],
                state=state_key,
                redirect_uri=redirect_uri
            )
            
            # Store the redirect URI in session
            request.session['oauth_redirect_uri'] = redirect_uri
            request.session.modified = True  # Ensure session is saved
            
            logger.info(f"OAuth flow created successfully with redirect URI: {redirect_uri}")
            return flow
            
        except Exception as e:
            logger.error(f"Error creating OAuth flow: {str(e)}", exc_info=True)
            raise
    
    @staticmethod
    def handle_oauth_callback(request, code, state):
        """Handle OAuth callback and return credentials"""
        try:
            # Get the stored redirect URI from session
            redirect_uri = request.session.get('oauth_redirect_uri')
            if not redirect_uri:
                raise AuthError("Missing redirect URI in session")
            
            flow = OAuthManager.create_oauth_flow(request, state_key=state)
            
            # Ensure the redirect URI matches
            flow.redirect_uri = redirect_uri
            
            # Fetch token with explicit redirect URI
            credentials = flow.fetch_token(
                code=code,
                redirect_uri=redirect_uri
            )
            
            # Clean up session
            request.session.pop('oauth_redirect_uri', None)
            
            return credentials
            
        except Exception as e:
            logger.error(f"OAuth callback error: {str(e)}")
            raise AuthError("Failed to complete OAuth flow")
    
    @staticmethod
    def credentials_to_dict(credentials):
        """Convert OAuth credentials to dictionary for session storage"""
        if hasattr(credentials, 'token'):
            # Handle Google OAuth2Credentials
            return {
                'token': credentials.token,
                'refresh_token': credentials.refresh_token,
                'token_uri': credentials.token_uri,
                'client_id': credentials.client_id,
                'client_secret': credentials.client_secret,
                'scopes': credentials.scopes
            }
        else:
            # Handle OAuth2Token
            return {
                'token': credentials['access_token'],
                'refresh_token': credentials.get('refresh_token'),
                'token_uri': 'https://oauth2.googleapis.com/token',  # Standard Google OAuth2 token endpoint
                'client_id': credentials.get('client_id'),
                'client_secret': credentials.get('client_secret'),
                'scopes': credentials.get('scope', '').split(' ') if isinstance(credentials.get('scope'), str) else credentials.get('scope', [])
            }

class GoogleAnalyticsCredentials(models.Model):
    client = models.OneToOneField(Client, on_delete=models.CASCADE, related_name='ga_credentials')
    view_id = models.CharField(max_length=100, blank=True, null=True)
    access_token = models.TextField(blank=True, null=True)
    refresh_token = models.TextField(blank=True, null=True)
    token_uri = models.URLField(blank=True, null=True)
    ga_client_id = models.CharField(max_length=100, blank=True, null=True)
    client_secret = models.CharField(max_length=100, blank=True, null=True)
    use_service_account = models.BooleanField(default=False)
    service_account_json = models.TextField(blank=True, null=True)
    user_email = models.EmailField()
    scopes = models.JSONField(default=list)

    def __str__(self):
        return f"GA Credentials for {self.client.name}"

    @property
    def required_scopes(self):
        return ['https://www.googleapis.com/auth/analytics.readonly']

    def get_credentials(self):
        """Returns refreshed Google Analytics credentials"""
        try:
            if self.use_service_account and self.service_account_json:
                service_account_info = json.loads(self.service_account_json)
                return service_account.Credentials.from_service_account_info(
                    service_account_info,
                    scopes=['https://www.googleapis.com/auth/analytics.readonly']
                )

            # For OAuth, create credentials from stored values
            if not all([self.refresh_token, self.token_uri, self.ga_client_id, self.client_secret]):
                logger.error("Missing required OAuth fields")
                return None

            credentials = Credentials(
                token=self.access_token,
                refresh_token=self.refresh_token,
                token_uri=self.token_uri,
                client_id=self.ga_client_id,
                client_secret=self.client_secret,
                scopes=['https://www.googleapis.com/auth/analytics.readonly']
            )

            # Always try to refresh if we have a refresh token
            if credentials.refresh_token:
                request = google.auth.transport.requests.Request()
                credentials.refresh(request)
                self.access_token = credentials.token
                self.save(update_fields=['access_token'])
                logger.info(f"Refreshed access token for {self.client.name}")

            return credentials

        except Exception as e:
            logger.error(f"Error getting credentials: {str(e)}")
            if 'invalid_grant' in str(e):
                self.access_token = None
                self.refresh_token = None
                self.save(update_fields=['access_token', 'refresh_token'])
                raise AuthError("OAuth credentials expired. Please re-authenticate.")
            return None

    def get_property_id(self):
        """Get the clean property ID without 'properties/' prefix"""
        if self.view_id:
            return self.view_id.replace('properties/', '')
        return None

    def get_service(self):
        """Returns an authenticated Analytics service"""
        try:
            credentials = self.get_credentials()
            if not credentials:
                return None

            return BetaAnalyticsDataClient(credentials=credentials)

        except Exception as e:
            logger.error(f"Error creating Analytics service: {str(e)}")
            return None

    def refresh_credentials(self):
        """Handle token refresh according to OAuth 2.0 spec"""
        try:
            if not self.refresh_token:
                raise AuthError("No refresh token available. Re-authorization required.")

            credentials = Credentials(
                token=self.access_token,
                refresh_token=self.refresh_token,
                token_uri=self.token_uri,
                client_id=self.ga_client_id,
                client_secret=self.client_secret,
                scopes=self.required_scopes
            )

            request = google.auth.transport.requests.Request()
            credentials.refresh(request)
            
            # Update stored credentials
            self.access_token = credentials.token
            self.save(update_fields=['access_token'])
            
            return True
            
        except Exception as e:
            if 'invalid_grant' in str(e):
                # Clear credentials if refresh token is invalid
                self.access_token = None
                self.refresh_token = None
                self.save(update_fields=['access_token', 'refresh_token'])
                raise AuthError("Refresh token expired or revoked. Re-authorization required.")
            raise

    def save_oauth_credentials(self, credentials):
        """Save OAuth credentials from flow"""
        try:
            # Log the credentials we're trying to save
            logger.info(f"""
            Attempting to save OAuth credentials for {self.client.name}:
            Token: {'Present' if credentials.token else 'Missing'}
            Refresh Token: {'Present' if credentials.refresh_token else 'Missing'}
            Token URI: {credentials.token_uri if credentials.token_uri else 'Missing'}
            Client ID: {'Present' if credentials.client_id else 'Missing'}
            Client Secret: {'Present' if credentials.client_secret else 'Missing'}
            """)

            # Save all fields
            self.access_token = credentials.token
            self.refresh_token = credentials.refresh_token
            self.token_uri = credentials.token_uri
            self.ga_client_id = credentials.client_id
            self.client_secret = credentials.client_secret
            self.scopes = credentials.scopes
            self.use_service_account = False
            
            self.save()
            
            # Verify saved credentials
            saved_creds = self.get_credentials()
            if not saved_creds:
                raise ValueError("Failed to verify saved credentials")

            logger.info(f"Successfully saved and verified OAuth credentials for {self.client.name}")

        except Exception as e:
            logger.error(f"Error saving OAuth credentials: {str(e)}")
            raise

    def validate_credentials(self):
        """Validate stored credentials"""
        try:
            if not self.access_token and not self.refresh_token and not self.service_account_json:
                raise AuthError("No valid credentials found")
                
            credentials = self.get_credentials()
            if not credentials:
                raise AuthError("Failed to get valid credentials")
                
            return True
            
        except Exception as e:
            logger.error(f"Credential validation error: {str(e)}")
            raise AuthError(f"Credential validation failed: {str(e)}")

    def handle_oauth_response(self, credentials_dict):
        """Handle OAuth response and save credentials"""
        try:
            self.access_token = credentials_dict['token']
            self.refresh_token = credentials_dict['refresh_token']
            self.token_uri = credentials_dict['token_uri']
            self.ga_client_id = credentials_dict['client_id']
            self.client_secret = credentials_dict['client_secret']
            self.use_service_account = False
            self.scopes = credentials_dict['scopes']
            self.save()
            
            logger.info(f"Saved GA OAuth credentials for {self.client.name}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving GA OAuth credentials: {str(e)}", exc_info=True)
            raise AuthError(f"Failed to save credentials: {str(e)}")

    def handle_service_account(self, service_account_json):
        """Handle service account setup"""
        try:
            self.service_account_json = service_account_json
            self.use_service_account = True
            self.access_token = None
            self.refresh_token = None
            self.save()
            
            # Validate the service account works
            credentials = self.get_credentials()
            if not credentials:
                raise AuthError("Invalid service account credentials")
                
            return True
            
        except Exception as e:
            logger.error(f"Service account setup error: {str(e)}")
            raise AuthError(f"Failed to setup service account: {str(e)}")

class SearchConsoleCredentials(models.Model):
    client = models.OneToOneField(Client, on_delete=models.CASCADE, related_name='sc_credentials')
    property_url = models.TextField()
    access_token = models.TextField(blank=True, null=True)
    refresh_token = models.TextField(blank=True, null=True)
    token_uri = models.URLField(blank=True, null=True)
    sc_client_id = models.CharField(max_length=100, blank=True, null=True)
    client_secret = models.CharField(max_length=100, blank=True, null=True)
    service_account_json = models.TextField(blank=True, null=True)
    last_validated = models.DateTimeField(auto_now=True)
    user_email = models.EmailField(blank=True, null=True)

    def __str__(self):
        return f"Search Console Credentials for {self.client.name}"

    def get_credentials(self):
        """Returns refreshed Google OAuth2 credentials"""
        try:
            # Handle service account authentication
            if self.service_account_json:
                service_account_info = json.loads(self.service_account_json)
                return service_account.Credentials.from_service_account_info(
                    service_account_info,
                    scopes=['https://www.googleapis.com/auth/webmasters.readonly']
                )

            # Handle OAuth2 authentication
            if not self.refresh_token:
                raise AuthError("No refresh token available. Reauthorization required.")

            credentials = Credentials(
                token=self.access_token,
                refresh_token=self.refresh_token,
                token_uri=self.token_uri,
                client_id=self.sc_client_id,
                client_secret=self.client_secret,
                scopes=['https://www.googleapis.com/auth/webmasters.readonly']
            )

            # Only refresh if token is expired or missing
            if not self.access_token or not credentials.valid:
                request = google.auth.transport.requests.Request()
                try:
                    credentials.refresh(request)
                    
                    # Update stored credentials
                    self.access_token = credentials.token
                    self.save(update_fields=['access_token'])
                    
                    logger.info(f"Successfully refreshed Search Console OAuth credentials for {self.client.name}")
                except Exception as e:
                    if 'invalid_grant' in str(e):
                        # Clear invalid credentials to force reauthorization
                        self.access_token = None
                        self.refresh_token = None
                        self.save(update_fields=['access_token', 'refresh_token'])
                        raise AuthError("Stored credentials are no longer valid. Please reauthorize Search Console access.")
                    raise

            return credentials

        except Exception as e:
            logger.error(f"Failed to refresh Search Console credentials for {self.client.name}: {str(e)}")
            raise AuthError(f"Failed to get valid Search Console credentials: {str(e)}")

    def get_service(self):
        """Returns an authenticated Search Console service"""
        try:
            credentials = self.get_credentials()
            if not credentials:
                logger.warning(f"No valid credentials available for {self.client.name}")
                return None
                
            return build('searchconsole', 'v1', credentials=credentials)
        except Exception as e:
            logger.error(f"Error creating Search Console service for {self.client.name}: {str(e)}")
            return None

    def get_property_url(self):
        """Parse and return the correct property URL format"""
        try:
            if isinstance(self.property_url, str):
                if '{' in self.property_url:
                    # Parse JSON-like string
                    data = json.loads(self.property_url.replace("'", '"'))
                    return data.get('url')  # Use get() to safely access 'url'
                return self.property_url
            elif isinstance(self.property_url, dict):
                return self.property_url.get('url')
            return self.property_url
        except Exception as e:
            logger.error(f"Error parsing property URL for {self.client.name}: {str(e)}")
            return None

    def save_oauth_credentials(self, credentials):
        """Save OAuth credentials from flow"""
        creds_dict = OAuthManager.credentials_to_dict(credentials)
        self.access_token = creds_dict['token']
        self.refresh_token = creds_dict['refresh_token']
        self.token_uri = creds_dict['token_uri']
        self.sc_client_id = creds_dict['client_id']
        self.client_secret = creds_dict['client_secret']
        self.save()

    def validate_credentials(self):
        """Validate stored credentials"""
        try:
            if not self.access_token and not self.refresh_token and not self.service_account_json:
                raise AuthError("No valid credentials found")
                
            credentials = self.get_credentials()
            if not credentials:
                raise AuthError("Failed to get valid credentials")
                
            return True
            
        except Exception as e:
            logger.error(f"Search Console credential validation error: {str(e)}")
            raise AuthError(f"Credential validation failed: {str(e)}")

    def handle_oauth_response(self, credentials_dict):
        """Handle OAuth response and save credentials"""
        try:
            self.access_token = credentials_dict['token']
            self.refresh_token = credentials_dict['refresh_token']
            self.token_uri = credentials_dict['token_uri']
            self.sc_client_id = credentials_dict['client_id']
            self.client_secret = credentials_dict['client_secret']
            self.save()
            
            logger.info(f"Saved SC OAuth credentials for {self.client.name}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving SC OAuth credentials: {str(e)}", exc_info=True)
            raise AuthError(f"Failed to save credentials: {str(e)}")

class GoogleAdsCredentials(models.Model):
    client = models.OneToOneField(Client, on_delete=models.CASCADE, related_name='ads_credentials')
    customer_id = models.CharField(max_length=100, blank=True, null=True, help_text="The specific Google Ads Customer ID (e.g., 123-456-7890)")
    login_customer_id = models.CharField(max_length=100, blank=True, null=True, help_text="The Manager Account ID (MCC) used for login, if applicable.")
    access_token = models.TextField(blank=True, null=True)
    refresh_token = models.TextField(blank=True, null=True)
    token_uri = models.URLField(blank=True, null=True)
    ads_client_id = models.CharField(max_length=100, blank=True, null=True)  # Use a specific one or reuse the main one
    client_secret = models.CharField(max_length=100, blank=True, null=True)
    scopes = models.JSONField(default=list)
    last_validated = models.DateTimeField(auto_now=True)
    user_email = models.EmailField(blank=True, null=True)

    def __str__(self):
        return f"Google Ads Credentials for {self.client.name}"

    @property
    def required_scopes(self):
        return ['https://www.googleapis.com/auth/adwords']

    def get_credentials(self):
        """Returns a dictionary usable by google-ads library for authentication."""
        # Note: google-ads library often takes a dictionary directly
        # and handles refresh internally if refresh_token is present.
        if not all([self.refresh_token, self.token_uri, self.ads_client_id, self.client_secret]):
            logger.warning(f"Missing required OAuth fields for Ads credentials for client {self.client.id}")
            return None
        
        # The google-ads client library expects specific keys
        return {
            "developer_token": settings.GOOGLE_ADS_DEVELOPER_TOKEN, # Needs to be added to settings
            "client_id": self.ads_client_id,
            "client_secret": self.client_secret,
            "refresh_token": self.refresh_token,
            "login_customer_id": self.login_customer_id, # Required if accessing via manager account
            "use_proto_plus": True # Recommended setting
        }

    def validate_credentials(self):
        """Validate stored Ads credentials (e.g., by making a test API call)."""
        # Placeholder: Implement validation, perhaps by listing accessible customers.
        # This might require initializing the GoogleAdsClient.
        # from google.ads.googleads.client import GoogleAdsClient
        # from google.ads.googleads.errors import GoogleAdsException
        try:
            creds_dict = self.get_credentials()
            if not creds_dict:
                raise AuthError("Missing required credential components.")
            
            # TODO: Optionally, make a lightweight test call to verify connection
            # e.g., client = GoogleAdsClient.load_from_dict(creds_dict)
            # customer_service = client.get_service("CustomerService")
            # accessible_customers = customer_service.list_accessible_customers()
            
            logger.info(f"Google Ads credentials for {self.client.name} appear structurally valid.")
            return True
        except GoogleAdsException as e:
            logger.error(f"Google Ads credential validation failed for {self.client.name}: {e}")
            raise AuthError(f"Credential validation failed: {e}")
        except Exception as e:
            logger.error(f"Unexpected error validating Google Ads credentials for {self.client.name}: {e}")
            raise AuthError(f"Unexpected validation error: {str(e)}")

    def handle_oauth_response(self, credentials_dict, selected_customer_id, selected_login_customer_id=None):
        """Handle OAuth response and save credentials along with selected IDs."""
        try:
            self.access_token = credentials_dict.get('token') # Adjust key if needed based on OAuthManager.credentials_to_dict
            self.refresh_token = credentials_dict.get('refresh_token')
            self.token_uri = credentials_dict.get('token_uri')
            self.ads_client_id = credentials_dict.get('client_id') # Ensure this matches the key used
            self.client_secret = credentials_dict.get('client_secret') # Ensure this matches the key used
            self.scopes = credentials_dict.get('scopes', self.required_scopes)
            self.customer_id = selected_customer_id
            self.login_customer_id = selected_login_customer_id # May be None if not an MCC login
            self.save()
            
            logger.info(f"Saved Google Ads OAuth credentials for {self.client.name} (Customer ID: {self.customer_id})")
            return True
            
        except Exception as e:
            logger.error(f"Error saving Google Ads OAuth credentials for {self.client.name}: {str(e)}", exc_info=True)
            raise AuthError(f"Failed to save Google Ads credentials: {str(e)}")

class UserActivity(models.Model):
    CATEGORY_CHOICES = [
        ('login', 'Login'),
        ('logout', 'Logout'),
        ('view', 'View'),
        ('create', 'Create'),
        ('update', 'Update'),
        ('delete', 'Delete'),
        ('export', 'Export'),
        ('import', 'Import'),
        ('other', 'Other'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE)
    client = models.ForeignKey(Client, on_delete=models.CASCADE, null=True, blank=True)
    category = models.CharField(max_length=20, choices=CATEGORY_CHOICES)
    action = models.CharField(max_length=255)
    timestamp = models.DateTimeField(auto_now_add=True)
    details = models.JSONField(null=True, blank=True)

    def __str__(self):
        return f"{self.user.username} - {self.category} - {self.action}"

class TargetedKeyword(models.Model):
    PRIORITY_CHOICES = [
        (1, 'Highest'),
        (2, 'High'),
        (3, 'Medium'),
        (4, 'Low'),
        (5, 'Lowest'),
    ]

    client = models.ForeignKey(
        Client, 
        on_delete=models.CASCADE,
        related_name='targeted_keywords'
    )
    keyword = models.CharField(max_length=255)
    priority = models.IntegerField(
        choices=PRIORITY_CHOICES,
        default=3,
        help_text="Priority level for this keyword"
    )
    notes = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def get_monthly_rankings(self, months=12):
        """Get monthly ranking history"""
        end_date = timezone.now().date()
        start_date = end_date - relativedelta(months=months)
        
        # logger.debug(
        #     f"Fetching monthly rankings for keyword '{self.keyword}' (ID: {self.id})"
        #     f"\nDate range: {start_date} to {end_date}"
        # )
        
        rankings = self.ranking_history.filter(
            date__gte=start_date,
            date__lte=end_date
        ).order_by('date')
        
        # logger.debug(f"Found {rankings.count()} ranking records")
        
        # Group by month and get the monthly record
        monthly_data = {}
        for ranking in rankings:
            month_key = ranking.date.strftime('%Y-%m')
            if month_key not in monthly_data:
                data = {
                    'date': ranking.date,
                    'position': float(ranking.average_position),
                    'impressions': int(ranking.impressions),
                    'clicks': int(ranking.clicks),
                    'ctr': float(ranking.ctr)
                }
                monthly_data[month_key] = data
                # logger.debug(
                #     f"Added data for {month_key}:"
                #     f"\nPosition: {data['position']}"
                #     f"\nImpressions: {data['impressions']}"
                #     f"\nClicks: {data['clicks']}"
                #     f"\nCTR: {data['ctr']}"
                # )
        
        result = [monthly_data[k] for k in sorted(monthly_data.keys())]
        # logger.debug(
        #     f"Returning {len(result)} months of data for {self.keyword}"
        # )
        return result

    def get_ranking_history(self):
        """Get all ranking history entries for this keyword"""
        return KeywordRankingHistory.objects.filter(
            Q(keyword=self) | 
            Q(keyword_text=self.keyword, client=self.client)
        ).order_by('-date')

    @property
    def current_position(self):
        """Get the most recent average position"""
        latest = self.get_ranking_history().first()
        return round(latest.average_position, 1) if latest else None

    def get_position_change(self, months=1):
        """Calculate position change over specified number of months"""
        history = self.get_ranking_history()[:2]  # Get latest two entries
        if len(history) < 2:
            return None
            
        current = history[0].average_position
        previous = history[1].average_position
        
        return round(previous - current, 1)

    @property
    def position_trend(self):
        """Returns trend indicator based on 30-day change"""
        change = self.get_position_change()
        if change is None:
            return 'neutral'
        if change > 0.5:  # Improved by more than 0.5 positions
            return 'up'
        if change < -0.5:  # Declined by more than 0.5 positions
            return 'down'
        return 'neutral'

    class Meta:
        unique_together = ['client', 'keyword']
        ordering = ['priority', 'keyword']

    def __str__(self):
        return f"{self.keyword} ({self.client.name})"

class KeywordRankingHistory(models.Model):
    client = models.ForeignKey(
        Client,
        on_delete=models.CASCADE,
        related_name='keyword_rankings'
    )
    keyword = models.ForeignKey(
        TargetedKeyword,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='ranking_history'
    )
    keyword_text = models.CharField(
        max_length=255,
        help_text="Actual keyword text, useful when no TargetedKeyword reference exists"
    )
    date = models.DateField()
    impressions = models.IntegerField(default=0)
    clicks = models.IntegerField(default=0)
    ctr = models.FloatField(
        verbose_name="Click-Through Rate",
        help_text="Click-through rate as a decimal (e.g., 0.15 for 15%)"
    )
    average_position = models.FloatField()
    
    class Meta:
        unique_together = ['client', 'keyword_text', 'date']
        ordering = ['-date']
        get_latest_by = 'date'
        indexes = [
            models.Index(fields=['-date']),  # Optimize date-based queries
            models.Index(fields=['client', '-date']),  # Optimize client+date queries
        ]

    @classmethod
    def get_rankings_for_period(cls, client, start_date, end_date, keyword=None):
        """Get rankings for a specific period with optimized querying"""
        query = cls.objects.select_related('keyword').filter(
            client=client,
            date__range=[start_date, end_date]
        )

        if keyword:
            query = query.filter(
                Q(keyword=keyword) | Q(keyword_text=keyword.keyword)
            )

        return query.order_by('date')

    def get_position_change(self):
        """Calculate position change from previous entry"""
        if not hasattr(self, '_position_change'):
            previous = KeywordRankingHistory.objects.filter(
                client=self.client,
                keyword_text=self.keyword_text,
                date__lt=self.date
            ).order_by('-date').values('average_position').first()

            self._position_change = (previous['average_position'] - self.average_position) if previous else 0
        return self._position_change

class SEOProject(models.Model):
    client = models.ForeignKey(
        Client,
        on_delete=models.CASCADE,
        related_name='seo_projects'
    )
    title = models.CharField(max_length=200)
    description = models.TextField()
    implementation_date = models.DateField()
    completion_date = models.DateField(null=True, blank=True)
    targeted_keywords = models.ManyToManyField(
        TargetedKeyword,
        related_name='related_projects'
    )
    documentation_file = models.FileField(
        upload_to='',
        storage=seo_docs_storage,
        null=True,
        blank=True
    )
    initial_rankings = models.JSONField(
        default=dict,
        help_text="Snapshot of keyword rankings before project implementation"
    )
    status = models.CharField(
        max_length=20,
        choices=[
            ('planned', 'Planned'),
            ('in_progress', 'In Progress'),
            ('completed', 'Completed'),
            ('on_hold', 'On Hold'),
        ],
        default='planned'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['-implementation_date']

    def __str__(self):
        return f"{self.title} - {self.client.name}"

    def get_initial_rank(self, keyword):
        """Get initial rank for a keyword, falling back to 3-month pre-implementation average"""
        # First try to get from initial_rankings
        if self.initial_rankings and keyword in self.initial_rankings:
            return self.initial_rankings[keyword]
        
        # Fall back to calculating average from 3 months before implementation
        pre_period = self.implementation_date - relativedelta(months=3)
        pre_rankings = KeywordRankingHistory.objects.filter(
            client=self.client,
            keyword_text=keyword,
            date__range=[pre_period, self.implementation_date]
        )
        pre_avg = pre_rankings.aggregate(Avg('average_position'))['average_position__avg']
        
        return round(pre_avg, 1) if pre_avg else None


    def _calculate_impressions_change(self, rankings):
        """Calculate the percentage change in impressions before and after implementation"""
        try:
            pre_imp = rankings.filter(
                date__lt=self.implementation_date
            ).aggregate(Avg('impressions'))['impressions__avg'] or 0

            post_imp = rankings.filter(
                date__gte=self.implementation_date
            ).aggregate(Avg('impressions'))['impressions__avg'] or 0

            if pre_imp == 0:
                return 100 if post_imp > 0 else 0
                
            return ((post_imp - pre_imp) / pre_imp) * 100
            
        except Exception as e:
            logger.error(f"Error calculating impressions change: {str(e)}")
            return 0

    def _calculate_clicks_change(self, rankings):
        """Calculate the percentage change in clicks before and after implementation"""
        try:
            pre_clicks = rankings.filter(
                date__lt=self.implementation_date
            ).aggregate(Avg('clicks'))['clicks__avg'] or 0

            post_clicks = rankings.filter(
                date__gte=self.implementation_date
            ).aggregate(Avg('clicks'))['clicks__avg'] or 0

            if pre_clicks == 0:
                return 100 if post_clicks > 0 else 0
                
            return ((post_clicks - pre_clicks) / pre_clicks) * 100
            
        except Exception as e:
            logger.error(f"Error calculating clicks change: {str(e)}")
            return 0

    # Add method to analyze project impact
    def analyze_impact(self):
        """Analyze the impact of SEO project implementation on keyword rankings"""
        try:
            implementation_date = self.implementation_date
            pre_period = implementation_date - relativedelta(months=3)
            post_period = implementation_date + relativedelta(months=2)

            logger.info(f"Analyzing impact for project {self.id} - {self.title}")
            logger.info(f"Date range: {pre_period} to {post_period}")
            logger.info(f"Implementation date: {implementation_date}")

            results = {}
            for keyword in self.targeted_keywords.all():
                # Get all rankings in the period by keyword text
                rankings = KeywordRankingHistory.objects.filter(
                    client=self.client,
                    keyword_text=keyword.keyword,
                    date__range=[pre_period, post_period]
                ).order_by('date')

                # Log the number of rankings found
                logger.info(f"Found {rankings.count()} ranking records for keyword: {keyword.keyword}")

                # Get pre-implementation rankings (including implementation date)
                pre_rankings = rankings.filter(date__lte=implementation_date)
                pre_avg = pre_rankings.aggregate(
                    Avg('average_position'))['average_position__avg']
                
                # Log pre-implementation data
                logger.info(f"Pre-implementation rankings for {keyword.keyword}:")
                logger.info(f"Number of records: {pre_rankings.count()}")
                logger.info(f"Average position: {pre_avg}")

                # Get post-implementation rankings (excluding implementation date)
                post_rankings = rankings.filter(date__gt=implementation_date)
                post_avg = post_rankings.aggregate(
                    Avg('average_position'))['average_position__avg']
                
                # Log post-implementation data
                logger.info(f"Post-implementation rankings for {keyword.keyword}:")
                logger.info(f"Number of records: {post_rankings.count()}")
                logger.info(f"Average position: {post_avg}")

                results[keyword.keyword] = {
                    'pre_implementation_avg': pre_avg,
                    'post_implementation_avg': post_avg,
                    'improvement': pre_avg - post_avg if pre_avg and post_avg else None,
                    'impressions_change': self._calculate_impressions_change(rankings),
                    'clicks_change': self._calculate_clicks_change(rankings),
                    'pre_implementation_count': pre_rankings.count(),
                    'post_implementation_count': post_rankings.count()
                }

            return results
        except Exception as e:
            logger.error(f"Error analyzing project impact: {str(e)}", exc_info=True)
            return {}

================
File: apps/seo_manager/routing.py
================
from django.urls import re_path
from . import consumers

websocket_urlpatterns = [
    re_path(r'ws/meta-tags/task/(?P<task_id>[\w-]+)/$', consumers.MetaTagsTaskConsumer.as_asgi()),
]

================
File: apps/seo_manager/services.py
================
from google.oauth2.credentials import Credentials
from googleapiclient.discovery import build
from google.auth.exceptions import RefreshError
from google.auth.transport.requests import Request  # Add this import
from google.analytics.data_v1beta import BetaAnalyticsDataClient
from google.analytics.data_v1beta.types import (
  DateRange,
  Dimension,
  Metric,
  RunReportRequest,
)

def get_analytics_service(ga_credentials, request):
  print("Entering get_analytics_service")
  try:
      print("GA Credentials:", ga_credentials)
      print("User Email:", ga_credentials.user_email)
      credentials = Credentials(
          token=ga_credentials.access_token,
          refresh_token=ga_credentials.refresh_token,
          token_uri=ga_credentials.token_uri,
          client_id=ga_credentials.ga_client_id,
          client_secret=ga_credentials.client_secret,
          scopes=ga_credentials.scopes
      )
      print("Credentials created, refreshing...")
      credentials.refresh(Request())
      print("Credentials refreshed successfully.")
      client = BetaAnalyticsDataClient(credentials=credentials)
      print("Analytics client created successfully, client:", client)
      return client
  except RefreshError as e:
      print(f"Error refreshing credentials: {e}")
      raise e
  finally:
      print("Exiting get_analytics_service")

def get_analytics_data(client, property_id, start_date, end_date):
  print("Entering get_analytics_data")
  print(f"Fetching analytics data for Property ID: {property_id}, Start Date: {start_date}, End Date: {end_date}")
  
  try:
      request = RunReportRequest(
          property=f"properties/{property_id}",
          dimensions=[Dimension(name="date")],
          metrics=[
              Metric(name="sessions"),
              Metric(name="screenPageViews")  # Changed from "pageviews" to "screenPageViews"
          ],
          date_ranges=[DateRange(start_date=start_date, end_date=end_date)],
      )
      response = client.run_report(request)
      print("Analytics data fetched successfully.")
      return response
  except Exception as e:
      print(f"Error fetching analytics data: {e}")
      raise e
  finally:
      print("Exiting get_analytics_data")

================
File: apps/seo_manager/sitemap_extractor.py
================
import os
import csv
import requests
import json
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from django.conf import settings
from core.storage import SecureFileStorage
from django.core.files.base import ContentFile
from datetime import datetime
from apps.common.tools.user_activity_tool import user_activity_tool
from apps.agents.tools.sitemap_retriever_tool.sitemap_retriever_tool import SitemapRetrieverTool
import logging
import io

logger = logging.getLogger(__name__)

# Instantiate SecureFileStorage for meta tags
meta_tag_storage = SecureFileStorage(private=True)

def extract_sitemap_and_meta_tags(client, user, progress_callback=None):
    """
    Extract sitemap and meta tags from a client's website and save to cloud storage.
    
    Args:
        client: The client instance
        user: The user instance
        progress_callback: Optional callback function for progress reporting
        
    Returns:
        str: The relative path to the saved file
    """
    try:
        base_url = client.website_url.rstrip('/')  # Remove trailing slash if present
        fqdn = urlparse(base_url).netloc
        date_str = datetime.now().strftime("%y-%m-%d")
        file_name = f"{fqdn}-{date_str}.csv"
        relative_path = os.path.join(str(user.id), 'meta-tags', file_name)

        # Use SitemapRetrieverTool to get URLs
        sitemap_retriever = SitemapRetrieverTool()
        
        if progress_callback:
            progress_callback("Finding sitemaps and crawling website")
        
        # Set a higher max_pages value for more comprehensive crawling
        # Using CSV output format
        result = sitemap_retriever._run(url=base_url, user_id=user.id, max_pages=10000, output_format="json")
        result_data = json.loads(result)
        
        urls_to_visit = set()
        
        # Extract URLs from the sitemap result
        if result_data.get("success", False):
            urls = result_data.get("urls", [])
            for url_data in urls:
                if "loc" in url_data:
                    urls_to_visit.add(url_data["loc"])
        
        # If no URLs found, start with the base URL
        if not urls_to_visit:
            logger.warning(f"No URLs found in sitemap for {base_url}, using base URL")
            urls_to_visit.add(base_url)
        
        total_urls = len(urls_to_visit)
        logger.info(f"Found {total_urls} URLs to process for {base_url}")
        
        if progress_callback:
            progress_callback("Processing URLs", urls_found=total_urls, total_urls=total_urls)
        
        visited_urls = set()
        urls_processed = 0

        # Create a CSV in memory
        output = io.StringIO()
        fieldnames = ['url', 'title', 'meta_description', 'meta_charset', 'viewport', 
                     'robots', 'canonical', 'og_title', 'og_description', 'og_image', 
                     'twitter_card', 'twitter_title', 'twitter_description', 
                     'twitter_image', 'author', 'language']
        writer = csv.DictWriter(output, fieldnames=fieldnames)
        writer.writeheader()

        while urls_to_visit:
            url = urls_to_visit.pop()

            if url in visited_urls:
                continue

            # Step 4: Exclude URLs with specific words, anchor links, and query strings
            if any(word in url for word in ['blog', 'product-id', 'search', 'page', 'wp-content']) or '#' in url or '?' in url:
                continue

            try:
                logger.debug(f"Visiting URL: {url}")
                
                if progress_callback:
                    urls_processed += 1
                    progress_callback(f"Processing URL: {url}", 
                                    urls_processed=urls_processed, 
                                    total_urls=total_urls)
                
                response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
                logger.debug(f"Response: {response.status_code}")
                if response.status_code == 200:
                    soup = BeautifulSoup(response.content, 'html.parser')
                    # Step 3: Extract meta tags
                    meta_tags = {
                        'url': url,
                        'title': soup.title.string if soup.title else '',
                        'meta_description': soup.find('meta', attrs={'name': 'description'})['content'] if soup.find('meta', attrs={'name': 'description'}) else '',
                        'meta_charset': soup.find('meta', attrs={'charset': True})['charset'] if soup.find('meta', attrs={'charset': True}) else '',
                        'viewport': soup.find('meta', attrs={'name': 'viewport'})['content'] if soup.find('meta', attrs={'name': 'viewport'}) else '',
                        'robots': soup.find('meta', attrs={'name': 'robots'})['content'] if soup.find('meta', attrs={'name': 'robots'}) else '',
                        'canonical': soup.find('link', attrs={'rel': 'canonical'})['href'] if soup.find('link', attrs={'rel': 'canonical'}) else '',
                        'og_title': soup.find('meta', attrs={'property': 'og:title'})['content'] if soup.find('meta', attrs={'property': 'og:title'}) else '',
                        'og_description': soup.find('meta', attrs={'property': 'og:description'})['content'] if soup.find('meta', attrs={'property': 'og:description'}) else '',
                        'og_image': soup.find('meta', attrs={'property': 'og:image'})['content'] if soup.find('meta', attrs={'property': 'og:image'}) else '',
                        'twitter_card': soup.find('meta', attrs={'name': 'twitter:card'})['content'] if soup.find('meta', attrs={'name': 'twitter:card'}) else '',
                        'twitter_title': soup.find('meta', attrs={'name': 'twitter:title'})['content'] if soup.find('meta', attrs={'name': 'twitter:title'}) else '',
                        'twitter_description': soup.find('meta', attrs={'name': 'twitter:description'})['content'] if soup.find('meta', attrs={'name': 'twitter:description'}) else '',
                        'twitter_image': soup.find('meta', attrs={'name': 'twitter:image'})['content'] if soup.find('meta', attrs={'name': 'twitter:image'}) else '',
                        'author': soup.find('meta', attrs={'name': 'author'})['content'] if soup.find('meta', attrs={'name': 'author'}) else '',
                        'language': soup.find('html').get('lang', '') if soup.find('html') else '',
                    }

                    writer.writerow(meta_tags)

                    # Also extract links for additional crawling if needed
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        if '#' in href or '?' in href:
                            continue
                        full_url = urljoin(url, href)
                        full_url = full_url.split('#')[0]
                        if full_url.startswith(base_url) and full_url not in visited_urls and full_url not in urls_to_visit:
                            urls_to_visit.add(full_url)

                    visited_urls.add(url)

            except requests.RequestException as e:
                logger.error(f"Error processing URL {url}: {str(e)}")

        if progress_callback:
            progress_callback("Saving results to file")
            
        # Get the full content as a string first
        content_str = output.getvalue()
        output.close()
        
        # Save using SecureFileStorage with explicit Content-Length
        content = ContentFile(content_str.encode('utf-8'))
        saved_path = meta_tag_storage._save(relative_path, content)

        # Log the activity
        user_activity_tool.run(user, 'create', f"Created meta tags snapshot for client: {client.name}", 
                             client=client, details={'file_name': file_name})

        return relative_path

    except Exception as e:
        logger.error(f"Error in extract_sitemap_and_meta_tags: {str(e)}", exc_info=True)
        raise

def extract_sitemap_and_meta_tags_from_url(url, user, output_file=None, progress_callback=None):
    """
    Extract sitemap and meta tags from a URL and save to cloud storage.
    
    Args:
        url: The URL to extract from
        user: The user instance
        output_file: Optional specific output file path to use
        progress_callback: Optional callback function for progress reporting
        
    Returns:
        str: The relative path to the saved file
    """
    try:
        base_url = url.rstrip('/')
        fqdn = urlparse(base_url).netloc
        
        # Use provided output_file or generate one
        if not output_file:
            date_str = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            filename = f"{fqdn.replace('.', '_')}_{date_str}.csv"
            relative_path = f"{user.id}/meta-tags/{filename}"
        else:
            # If output_file is provided, use it as is (assumes it's a relative path)
            relative_path = output_file

        # Use SitemapRetrieverTool to get URLs
        sitemap_retriever = SitemapRetrieverTool()
        
        if progress_callback:
            progress_callback("Finding sitemaps and crawling website")
            
        # Set a higher max_pages value for more comprehensive crawling
        # Using JSON output format for the tool (we'll convert to CSV)
        result = sitemap_retriever._run(url=base_url, user_id=user.id, max_pages=10000, output_format="json")
        result_data = json.loads(result)
        
        urls_to_visit = set()
        
        # Extract URLs from the sitemap result
        if result_data.get("success", False):
            urls = result_data.get("urls", [])
            for url_data in urls:
                if "loc" in url_data:
                    urls_to_visit.add(url_data["loc"])
        
        # If no URLs found, start with the base URL
        if not urls_to_visit:
            logger.warning(f"No URLs found in sitemap for {base_url}, using base URL")
            urls_to_visit.add(base_url)
        
        total_urls = len(urls_to_visit)
        logger.info(f"Found {total_urls} URLs to process for {base_url}")
        
        if progress_callback:
            progress_callback("Processing URLs", urls_found=total_urls, total_urls=total_urls)
            
        visited_urls = set()
        urls_processed = 0

        # Create a CSV in memory
        output = io.StringIO()
        fieldnames = ['url', 'title', 'meta_description', 'meta_charset', 'viewport', 
                     'robots', 'canonical', 'og_title', 'og_description', 'og_image', 
                     'twitter_card', 'twitter_title', 'twitter_description', 
                     'twitter_image', 'author', 'language']
        writer = csv.DictWriter(output, fieldnames=fieldnames)
        writer.writeheader()

        while urls_to_visit:
            url = urls_to_visit.pop()

            if url in visited_urls:
                continue

            # Step 4: Exclude URLs with specific words, anchor links, and query strings
            if any(word in url for word in ['blog', 'product-id', 'search', 'page', 'wp-content']) or '#' in url or '?' in url:
                continue

            try:
                logger.debug(f"Visiting URL: {url}")
                
                if progress_callback:
                    urls_processed += 1
                    progress_callback(f"Processing URL: {url}", 
                                    urls_processed=urls_processed, 
                                    total_urls=total_urls)
                
                response = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'})
                logger.debug(f"Response: {response.status_code}")
                if response.status_code == 200:
                    soup = BeautifulSoup(response.content, 'html.parser')
                    # Step 3: Extract meta tags
                    meta_tags = {
                        'url': url,
                        'title': soup.title.string if soup.title else '',
                        'meta_description': soup.find('meta', attrs={'name': 'description'})['content'] if soup.find('meta', attrs={'name': 'description'}) else '',
                        'meta_charset': soup.find('meta', attrs={'charset': True})['charset'] if soup.find('meta', attrs={'charset': True}) else '',
                        'viewport': soup.find('meta', attrs={'name': 'viewport'})['content'] if soup.find('meta', attrs={'name': 'viewport'}) else '',
                        'robots': soup.find('meta', attrs={'name': 'robots'})['content'] if soup.find('meta', attrs={'name': 'robots'}) else '',
                        'canonical': soup.find('link', attrs={'rel': 'canonical'})['href'] if soup.find('link', attrs={'rel': 'canonical'}) else '',
                        'og_title': soup.find('meta', attrs={'property': 'og:title'})['content'] if soup.find('meta', attrs={'property': 'og:title'}) else '',
                        'og_description': soup.find('meta', attrs={'property': 'og:description'})['content'] if soup.find('meta', attrs={'property': 'og:description'}) else '',
                        'og_image': soup.find('meta', attrs={'property': 'og:image'})['content'] if soup.find('meta', attrs={'property': 'og:image'}) else '',
                        'twitter_card': soup.find('meta', attrs={'name': 'twitter:card'})['content'] if soup.find('meta', attrs={'name': 'twitter:card'}) else '',
                        'twitter_title': soup.find('meta', attrs={'name': 'twitter:title'})['content'] if soup.find('meta', attrs={'name': 'twitter:title'}) else '',
                        'twitter_description': soup.find('meta', attrs={'name': 'twitter:description'})['content'] if soup.find('meta', attrs={'name': 'twitter:description'}) else '',
                        'twitter_image': soup.find('meta', attrs={'name': 'twitter:image'})['content'] if soup.find('meta', attrs={'name': 'twitter:image'}) else '',
                        'author': soup.find('meta', attrs={'name': 'author'})['content'] if soup.find('meta', attrs={'name': 'author'}) else '',
                        'language': soup.find('html').get('lang', '') if soup.find('html') else '',
                    }

                    # Write to CSV
                    writer.writerow(meta_tags)

                    # Also extract links for additional crawling if needed
                    for link in soup.find_all('a', href=True):
                        href = link['href']
                        if '#' in href or '?' in href:
                            continue
                        full_url = urljoin(url, href)
                        full_url = full_url.split('#')[0]
                        if full_url.startswith(base_url) and full_url not in visited_urls and full_url not in urls_to_visit:
                            urls_to_visit.add(full_url)

                    visited_urls.add(url)

            except requests.RequestException as e:
                logger.error(f"Error processing URL {url}: {str(e)}")
        
        if progress_callback:
            progress_callback("Saving results to file")
        
        # Get the full content as a string first
        content_str = output.getvalue()
        output.close()
        
        # Save using SecureFileStorage with explicit Content-Length
        content = ContentFile(content_str.encode('utf-8'))
        saved_path = meta_tag_storage._save(relative_path, content)
        
        # Log the activity without a client
        user_activity_tool.run(user, 'create', f"Created meta tags snapshot for URL: {url}", 
                             details={'file_name': os.path.basename(relative_path)})

        return saved_path

    except Exception as e:
        logger.error(f"Error in extract_sitemap_and_meta_tags_from_url: {str(e)}", exc_info=True)
        raise

================
File: apps/seo_manager/tasks.py
================
import logging
from celery import shared_task
from django.contrib.auth import get_user_model
from .models import Client
from .sitemap_extractor import extract_sitemap_and_meta_tags, extract_sitemap_and_meta_tags_from_url
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
import json
from celery.exceptions import SoftTimeLimitExceeded

logger = logging.getLogger(__name__)

User = get_user_model()
channel_layer = get_channel_layer()

def send_progress_update(task_id, progress_data):
    """
    Send a progress update via WebSocket.
    
    Args:
        task_id: The Celery task ID
        progress_data: Dict containing progress information
    """
    try:
        group_name = f"metatags_task_{task_id}"
        logger.debug(f"Sending progress update to group {group_name}: {progress_data}")
        async_to_sync(channel_layer.group_send)(
            group_name,
            {
                'type': 'progress_update',
                'progress': progress_data
            }
        )
        logger.debug(f"Progress update sent successfully to group {group_name}")
    except Exception as e:
        logger.error(f"Error sending progress update: {str(e)}")

class ProgressTracker:
    """Helper class to track and report progress during extraction."""
    
    def __init__(self, task_id, total_steps=4):
        self.task_id = task_id
        self.total_steps = total_steps
        self.current_step = 0
        self.current_action = "Starting"
        self.urls_found = 0
        self.urls_processed = 0
        self.total_urls = 0
    
    def update(self, step=None, action=None, urls_found=None, 
              urls_processed=None, total_urls=None):
        """Update progress and send via WebSocket."""
        if step is not None:
            self.current_step = step
        if action is not None:
            self.current_action = action
        if urls_found is not None:
            self.urls_found = urls_found
        if urls_processed is not None:
            self.urls_processed = urls_processed
        if total_urls is not None:
            self.total_urls = total_urls
        
        # Calculate overall progress percentage
        step_weight = 100 / self.total_steps
        base_progress = (self.current_step - 1) * step_weight if self.current_step > 0 else 0
        
        # Add progress within current step
        if self.current_step == 2 and self.total_urls > 0:  # URL processing step
            step_progress = (self.urls_processed / self.total_urls) * step_weight
        else:
            step_progress = 0
        
        overall_progress = min(base_progress + step_progress, 100)
        
        # Send progress update
        progress_data = {
            'percent': overall_progress,
            'step': self.current_step,
            'action': self.current_action,
            'urls_found': self.urls_found,
            'urls_processed': self.urls_processed,
            'total_urls': self.total_urls
        }
        
        send_progress_update(self.task_id, progress_data)
        return progress_data

@shared_task(bind=True, max_retries=1, default_retry_delay=30, time_limit=6*60*60, soft_time_limit=5*60*60)
def extract_sitemap_task(self, website_url, output_file, user_id):
    """
    Background task to extract sitemap and meta tags from a website URL.
    
    Args:
        website_url: The URL of the website to extract from
        output_file: The path where the output should be saved
        user_id: The id of the user initiating the task
        
    Returns:
        dict: Results of the extraction process
    """
    try:
        logger.info(f"Starting sitemap extraction task for URL {website_url}")
        
        # Create progress tracker
        progress = ProgressTracker(self.request.id)
        progress.update(step=1, action="Initializing extraction")
        
        # Get the user object
        user = User.objects.get(id=user_id)  # Note: User model typically doesn't have organization_objects
        
        # Set up a callback for the extraction process to report progress
        def progress_callback(action, urls_found=None, urls_processed=None, total_urls=None):
            nonlocal progress
            # Update step based on action
            if "Finding sitemaps" in action:
                step = 1
            elif "Processing URLs" in action:
                step = 2
            elif "Saving results" in action:
                step = 3
            else:
                step = progress.current_step
                
            progress.update(
                step=step,
                action=action,
                urls_found=urls_found,
                urls_processed=urls_processed,
                total_urls=total_urls
            )
        
        # Run the extraction with progress callback
        from .sitemap_extractor import extract_sitemap_and_meta_tags_from_url
        
        file_path = extract_sitemap_and_meta_tags_from_url(
            website_url, 
            user, 
            output_file=output_file,
            progress_callback=progress_callback
        )
        
        # Final progress update
        progress.update(step=4, action="Completed")
        
        logger.info(f"Sitemap extraction completed for URL {website_url}. File path: {file_path}")
        
        # Return the file path for reference
        return {
            'success': True,
            'file_path': file_path,
            'url': website_url
        }
        
    except SoftTimeLimitExceeded:
        logger.error(f"Soft time limit exceeded for sitemap extraction from URL {website_url}")
        # Send a timeout message via WebSocket
        send_progress_update(self.request.id, {
            'status': 'error',
            'message': 'Task timed out. The website may have too many pages to process in the allowed time.',
            'progress': 100,
            'step': 4,
            'complete': True
        })
        return {
            'success': False,
            'error': 'Extraction timed out. The website may have too many pages to process.',
            'website_url': website_url,
            'file_path': output_file
        }
    except Exception as e:
        logger.error(f"Error in sitemap extraction task: {str(e)}")
        # Send error via WebSocket
        send_progress_update(self.request.id, {
            'error': str(e),
            'action': 'Error occurred'
        })
        
        # Retry once after 30 seconds
        try:
            self.retry(exc=e)
        except Exception as retry_exc:
            logger.error(f"Task retry failed: {str(retry_exc)}")
            return {
                'success': False,
                'error': str(e),
                'url': website_url
            }

@shared_task(bind=True, max_retries=1, default_retry_delay=30, time_limit=6*60*60, soft_time_limit=5*60*60)
def extract_sitemap_from_url_task(self, website_url, output_file, user_id):
    """
    Background task to extract sitemap and meta tags from a URL.
    
    Args:
        website_url: The URL to extract from
        output_file: The path where the output should be saved
        user_id: The id of the user initiating the task
        
    Returns:
        dict: Results of the extraction process
    """
    try:
        logger.info(f"Starting sitemap extraction task for URL {website_url}")
        
        # Create progress tracker
        progress = ProgressTracker(self.request.id)
        progress.update(step=1, action="Initializing extraction")
        
        # Get the user object
        user = User.objects.get(id=user_id)  # Note: User model typically doesn't have organization_objects
        
        # Set up a callback for the extraction process to report progress
        def progress_callback(action, urls_found=None, urls_processed=None, total_urls=None):
            nonlocal progress
            # Update step based on action
            if "Finding sitemaps" in action:
                step = 1
            elif "Processing URLs" in action:
                step = 2
            elif "Saving results" in action:
                step = 3
            else:
                step = progress.current_step
                
            progress.update(
                step=step,
                action=action,
                urls_found=urls_found,
                urls_processed=urls_processed,
                total_urls=total_urls
            )
        
        # Run the extraction with progress callback
        from .sitemap_extractor import extract_sitemap_and_meta_tags_from_url
        
        file_path = extract_sitemap_and_meta_tags_from_url(
            website_url, 
            user, 
            output_file=output_file,
            progress_callback=progress_callback
        )
        
        # Final progress update
        progress.update(step=4, action="Completed")
        
        logger.info(f"Sitemap extraction completed for URL {website_url}. File path: {file_path}")
        
        # Return the file path for reference
        return {
            'success': True,
            'file_path': file_path,
            'url': website_url
        }
        
    except SoftTimeLimitExceeded:
        logger.error(f"Soft time limit exceeded for sitemap extraction from URL {website_url}")
        # Send a timeout message via WebSocket
        send_progress_update(self.request.id, {
            'status': 'error',
            'message': 'Task timed out. The website may have too many pages to process in the allowed time.',
            'progress': 100,
            'step': 4,
            'complete': True
        })
        return {
            'success': False,
            'error': 'Extraction timed out. The website may have too many pages to process.',
            'website_url': website_url,
            'file_path': output_file
        }
    except Exception as e:
        logger.error(f"Error in sitemap extraction from URL task: {str(e)}")
        # Send error via WebSocket
        send_progress_update(self.request.id, {
            'error': str(e),
            'action': 'Error occurred'
        })
        
        # Retry once after 30 seconds
        try:
            self.retry(exc=e)
        except Exception as retry_exc:
            logger.error(f"Task retry failed: {str(retry_exc)}")
            return {
                'success': False,
                'error': str(e),
                'url': website_url
            }

================
File: apps/seo_manager/urls.py
================
from django.urls import path, include
from . import views_analytics
from django.shortcuts import redirect
from .views import (
    KeywordListView, KeywordCreateView, KeywordUpdateView,
    ProjectListView, ProjectCreateView, ProjectDetailView
)
from .views import client_views, activity_views, analytics_views, business_objective_views, keyword_views, project_views, meta_tags_views, ranking_views, report_views, project_views, search_console_views, ads_views

app_name = 'seo_manager'

# Redirect function for backward compatibility
def redirect_to_summarizer(request):
    return redirect('summarizer:summarize_view')

urlpatterns = [
    # Main URLs
    path('', client_views.dashboard, name='dashboard'),
    path('summarize/', redirect_to_summarizer, name='summarize_redirect'),
    
    # Client URLs
    path('clients/', include([
        path('', client_views.client_list, name='client_list'),
        path('add/', client_views.add_client, name='add_client'),
        path('<int:client_id>/', include([
            path('', client_views.client_detail, name='client_detail'),
            path('edit/', client_views.edit_client, name='edit_client'),
            path('delete/', client_views.delete_client, name='delete_client'),
            path('analytics/', views_analytics.client_analytics, name='client_analytics'),
            path('search-console/', search_console_views.client_search_console, name='client_search_console'),
            path('ads/', analytics_views.client_ads, name='client_ads'),
            path('dataforseo/', analytics_views.client_dataforseo, name='client_dataforseo'),   
            path('load-more-activities/', client_views.load_more_activities, name='load_more_activities'),
            path('export-activities/', client_views.export_activities, name='export_activities'),
            # Keyword Management URLs
            path('keywords/', include([
                path('', KeywordListView.as_view(), name='keyword_list'),
                path('add/', KeywordCreateView.as_view(), name='keyword_create'),
                path('import/', keyword_views.keyword_import, name='keyword_import'),
                path('<int:pk>/edit/', KeywordUpdateView.as_view(), name='keyword_update'),
                path('<int:pk>/rankings/', ranking_views.ranking_import, name='ranking_import'),
                path('search-console/', 
                     keyword_views.search_console_keywords, 
                     name='search_console_keywords'),
            ])),
            
            # SEO Project URLs
            path('projects/', include([
                path('', ProjectListView.as_view(), name='project_list'),
                path('add/', ProjectCreateView.as_view(), name='project_create'),
                path('<int:pk>/', ProjectDetailView.as_view(), name='project_detail'),
                path('<int:project_id>/edit/', project_views.edit_project, name='edit_project'),
                path('<int:project_id>/delete/', project_views.delete_project, name='delete_project'),
            ])),
            
            # Credentials URLs
            path('credentials/', include([
                # Google Analytics URLs
                path('ga/', include([
                    path('oauth/add/', 
                         analytics_views.add_ga_credentials_oauth, 
                         name='add_ga_credentials_oauth'),
                    path('service-account/add/', 
                         analytics_views.add_ga_credentials_service_account, 
                         name='add_ga_credentials_service_account'),
                    path('select-account/', 
                         analytics_views.select_analytics_account, 
                         name='select_analytics_account'),
                    path('remove/', 
                         analytics_views.remove_ga_credentials, 
                         name='remove_ga_credentials'),
                ])),
                
                # Search Console URLs
                path('sc/add/', 
                     search_console_views.add_sc_credentials, 
                     name='add_sc_credentials'),
                path('sc/remove/', 
                     search_console_views.remove_sc_credentials, 
                     name='remove_sc_credentials'),
                     
                # Google Ads URLs
                path('ads/', include([
                    path('oauth/', 
                         ads_views.initiate_google_ads_oauth, 
                         name='initiate_ads_oauth'),
                    path('select-account/', 
                         ads_views.select_ads_account, 
                         name='select_ads_account'),
                    path('remove/', 
                         ads_views.remove_ads_credentials, 
                         name='remove_ads_credentials'),
                ])),
            ])),
            
            # Business Objective URLs
            path('objectives/', include([
                path('add/', business_objective_views.add_business_objective, name='add_business_objective'),
                path('edit/<int:objective_index>/', business_objective_views.edit_business_objective, name='edit_business_objective'),
                path('delete/<int:objective_index>/', business_objective_views.delete_business_objective, name='delete_business_objective'),
                path('update-status/<int:objective_index>/', business_objective_views.update_objective_status, name='update_objective_status'),
            ])),
            
            # Profile URLs
            path('profile/', include([
                path('update/', client_views.update_client_profile, name='update_client_profile'),
                path('generate-magic/', client_views.generate_magic_profile, name='generate_magic_profile'),
                path('generation-complete/', client_views.profile_generation_complete, name='profile_generation_complete'),
            ])),
            
            # Meta Tags URLs
            path('meta-tags/', include([
                path('snapshot/', meta_tags_views.create_snapshot, name='create_meta_tags_snapshot'),
                path('task-status/<str:task_id>/', meta_tags_views.check_task_status, name='check_meta_tags_task_status'),
                path('report/<path:file_path>/', meta_tags_views.view_meta_tags_report, name='view_meta_tags_report'),
                path('', meta_tags_views.meta_tags, name='meta_tags_dashboard'),
            ])),
            
            # Rankings URLs
            path('rankings/', include([
                path('collect/', ranking_views.collect_rankings, name='collect_rankings'),
                path('report/', report_views.generate_report, name='generate_report'),
                path('backfill/', ranking_views.backfill_rankings, name='backfill_rankings'),
                path('manage/', ranking_views.ranking_data_management, name='ranking_data_management'),
                path('export-csv/', ranking_views.export_rankings_csv, name='export_rankings_csv'),
            ])),
            
            # Search Console URLs
            path('select-property/', 
                 analytics_views.select_search_console_property, 
                 name='select_search_console_property'),
            path('add-service-account/', 
                 analytics_views.add_sc_credentials_service_account, 
                 name='add_sc_credentials_service_account'),
            path('integrations/', client_views.client_integrations, name='client_integrations'),
            path('import-from-search-console/', 
                 keyword_views.import_from_search_console, 
                 name='import_from_search_console'),
            path('meta-tags/', meta_tags_views.meta_tags, name='meta_tags_dashboard'),
        ])),
    ])),
    
    # Other URLs
    path('activity-log/', activity_views.activity_log, name='activity_log'),
    path('create-meta-tags-snapshot-url/', meta_tags_views.create_snapshot_from_url, name='create_meta_tags_snapshot_url'),
    
    # OAuth URLs
    path('google/', include([
        path('login/callback/', 
             analytics_views.google_oauth_callback, 
             name='google_oauth_callback'),
        path('oauth/', include([
            path('init/<int:client_id>/<str:service_type>/', 
                 analytics_views.initiate_google_oauth, 
                 name='initiate_google_oauth'),
        ])),
    ])),
    path('clients/<int:client_id>/objectives/<int:objective_index>/update-status/',
         business_objective_views.update_objective_status, name='update_objective_status'),
]

================
File: apps/seo_manager/utils.py
================
from datetime import datetime, date, timedelta
from dateutil.relativedelta import relativedelta
from typing import List, Tuple

def get_monthly_date_ranges(months_back: int = 12) -> List[Tuple[date, date]]:
    """
    Generate a list of (start_date, end_date) tuples for each month
    going back X months from today.
    """
    today = date.today()
    ranges = []
    
    for i in range(months_back):
        # Get first day of the month
        end_date = today - relativedelta(months=i)
        start_date = end_date.replace(day=1)
        
        # For current month, use today as end_date
        if i == 0:
            ranges.append((start_date, today))
        else:
            # Get last day of the month
            end_date = (start_date + relativedelta(months=1) - timedelta(days=1))
            ranges.append((start_date, end_date))
    
    return ranges

================
File: apps/seo_manager/views_analytics.py
================
import json
import logging
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import Client, GoogleAnalyticsCredentials, SearchConsoleCredentials
from .google_auth import get_search_console_properties
from datetime import datetime, timedelta
from google.auth.exceptions import RefreshError
from googleapiclient.errors import HttpError
from apps.agents.tools.google_analytics_tool.google_analytics_tool import GoogleAnalyticsTool
from django.core.serializers.json import DjangoJSONEncoder
from apps.common.tools.user_activity_tool import user_activity_tool
from django.urls import reverse

logger = logging.getLogger(__name__)

def get_analytics_data(client_id, start_date, end_date):
    """Get Google Analytics data with proper error handling"""
    try:
        # Get the client and its analytics credentials
        client = get_object_or_404(Client, id=client_id)
        
        try:
            ga_credentials = GoogleAnalyticsCredentials.objects.get(client=client)
        except GoogleAnalyticsCredentials.DoesNotExist:
            logger.warning(f"No Google Analytics credentials found for client: {client.name}")
            return None
            
        # Get the credentials as a dictionary
        credentials_dict = {
            'access_token': ga_credentials.access_token,
            'refresh_token': ga_credentials.refresh_token,
            'token_uri': ga_credentials.token_uri or 'https://oauth2.googleapis.com/token',
            'ga_client_id': ga_credentials.ga_client_id,
            'client_secret': ga_credentials.client_secret,
            'scopes': ga_credentials.scopes
        }
        
        # Get the property ID using the method from the model
        analytics_property_id = ga_credentials.get_property_id()
        
        if not analytics_property_id:
            logger.warning(f"No Analytics property ID found for client: {client.name}")
            return None
        
        # Initialize the tool and run it with proper parameters
        ga_tool = GoogleAnalyticsTool()
        analytics_data = ga_tool._run(
            start_date=start_date,
            end_date=end_date,
            analytics_property_id=analytics_property_id,
            analytics_credentials=credentials_dict
        )
        
        if analytics_data['success']:
            return analytics_data
        else:
            logger.warning(f"Failed to fetch GA data: {analytics_data.get('error')}")
            return None
            
    except Exception as e:
        error_str = str(e)
        logger.error(f"Error fetching GA data: {error_str}")
        
        # Check for invalid grant error
        if 'invalid_grant' in error_str.lower():
            try:
                # Find the client and remove invalid credentials
                client = Client.objects.get(id=client_id)
                if hasattr(client, 'ga_credentials'):
                    client.ga_credentials.delete()
                    
                    # Log the removal
                    logger.info(f"Removed invalid Google Analytics credentials for client: {client.name}")
                    
                    # Log the activity
                    user_activity_tool.run(
                        None,  # System action
                        'delete',
                        f"Google Analytics credentials automatically removed due to invalid grant",
                        client=client
                    )
            except Client.DoesNotExist:
                logger.error(f"Could not find client with ID: {client_id}")
            except Exception as inner_e:
                logger.error(f"Error handling invalid credentials: {str(inner_e)}")
        
        return None

@login_required
def client_analytics(request, client_id):
    client = get_object_or_404(Client, id=client_id)
    
    # Get credentials without forcing 404
    try:
        ga_credentials = GoogleAnalyticsCredentials.objects.get(client=client)
    except GoogleAnalyticsCredentials.DoesNotExist:
        ga_credentials = None
        
    try:
        sc_credentials = SearchConsoleCredentials.objects.get(client=client)
    except SearchConsoleCredentials.DoesNotExist:
        sc_credentials = None

    context = {
        'page_title': 'Client Analytics',
        'client': client,
        'analytics_data': None,
        'search_console_data': None,
    }

    # Only process GA data if credentials exist
    if ga_credentials:
        ga_range = request.GET.get('ga_range', '30')
        ga_end_date = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        
        if ga_range == 'custom':
            ga_start_date = request.GET.get('ga_start_date')
            ga_end_date = request.GET.get('ga_end_date')
            if not ga_start_date or not ga_end_date:
                messages.error(request, "Invalid GA date range provided")
                return redirect('seo_manager:client_analytics', client_id=client_id)
        else:
            try:
                days = int(ga_range)
                ga_start_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
            except ValueError:
                messages.error(request, "Invalid GA date range")
                return redirect('seo_manager:client_analytics', client_id=client_id)

        context.update({
            'ga_start_date': ga_start_date,
            'ga_end_date': ga_end_date,
            'selected_ga_range': ga_range,
        })

        analytics_data = get_analytics_data(client_id, ga_start_date, ga_end_date)
        
        if analytics_data:
            context['analytics_data'] = json.dumps(analytics_data['analytics_data'])
            context['start_date'] = analytics_data['start_date']
            context['end_date'] = analytics_data['end_date']
        else:
            # Check if credentials were removed due to invalid grant
            try:
                ga_credentials.refresh_from_db()
            except GoogleAnalyticsCredentials.DoesNotExist:
                messages.error(request, {
                    'title': 'Google Analytics Connection Expired',
                    'text': 'Your Google Analytics connection has expired or been revoked. Please reconnect your account.',
                    'icon': 'error',
                    'redirect_url': reverse('seo_manager:client_integrations', args=[client_id])
                }, extra_tags='sweetalert')
                return redirect('seo_manager:client_integrations', client_id=client.id)
            else:
                messages.error(request, {
                    'title': 'Error',
                    'text': 'An error occurred accessing Google Analytics. Please try again later.',
                    'icon': 'error',
                    'redirect_url': reverse('seo_manager:client_detail', args=[client_id])
                }, extra_tags='sweetalert')

    # Only process SC data if credentials exist
    if sc_credentials:
        sc_range = request.GET.get('sc_range', '30')
        sc_end_date = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        
        if sc_range == 'custom':
            sc_start_date = request.GET.get('sc_start_date')
            sc_end_date = request.GET.get('sc_end_date')
            if not sc_start_date or not sc_end_date:
                messages.error(request, "Invalid SC date range provided")
                return redirect('seo_manager:client_analytics', client_id=client_id)
        else:
            try:
                days = int(sc_range)
                sc_start_date = (datetime.now() - timedelta(days=days)).strftime('%Y-%m-%d')
            except ValueError:
                messages.error(request, "Invalid SC date range")
                return redirect('seo_manager:client_analytics', client_id=client_id)

        context.update({
            'sc_start_date': sc_start_date,
            'sc_end_date': sc_end_date,
            'selected_sc_range': sc_range,
        })

        try:
            search_console_service = sc_credentials.get_service()
            if search_console_service:
                property_url = sc_credentials.get_property_url()
                if property_url:
                    search_console_data = get_search_console_data(
                        search_console_service, 
                        property_url,
                        sc_start_date,
                        sc_end_date
                    )
                    context['search_console_data'] = search_console_data
                else:
                    messages.warning(request, "Invalid Search Console property URL format.")
            else:
                messages.warning(request, "Search Console credentials are incomplete.")
        except Exception as e:
            logger.error(f"Error fetching Search Console data: {str(e)}")
            messages.warning(request, "Unable to fetch Search Console data.")

    return render(request, 'seo_manager/client_analytics.html', context)

def get_search_console_service(credentials, request):
    from googleapiclient.discovery import build
    from google.oauth2.credentials import Credentials
    
    creds = Credentials(
        token=credentials.access_token,
        refresh_token=credentials.refresh_token,
        token_uri=credentials.token_uri,
        client_id=credentials.sc_client_id,
        client_secret=credentials.client_secret
    )
    
    return build('searchconsole', 'v1', credentials=creds)

def get_search_console_data(service, property_url, start_date, end_date):
    try:
        response = service.searchanalytics().query(
            siteUrl=property_url,
            body={
                'startDate': start_date,
                'endDate': end_date,
                'dimensions': ['query'],
                'rowLimit': 1000
            }
        ).execute()
        
        search_console_data = []
        for row in response.get('rows', []):
            search_console_data.append({
                'query': row['keys'][0],
                'clicks': row['clicks'],
                'impressions': row['impressions'],
                'ctr': row['ctr'] * 100,  # Convert to percentage
                'position': row['position']
            })
        
        search_console_data.sort(key=lambda x: x['impressions'], reverse=True)
        
        return search_console_data
    except HttpError as error:
        print(f"An error occurred: {error}")
        return []

================
File: apps/seo_manager/views.py
================
from .views.client_views import *
from .views.keyword_views import *
from .views.project_views import *
from .views.analytics_views import *
from .views.search_console_views import *
from .views.business_objective_views import *
from .views.ranking_views import *
from .views.report_views import *
from .views.activity_views import *
from .views.meta_tags_views import *

# This file now serves as a compatibility layer, importing all views from their respective modules.
# All views are now organized in separate files in the views/ directory for better maintainability.

================
File: apps/summarizer/templates/summarizer/summarize.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block extrastyle %}
<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    #task-status .spinner {
        animation: spin 2s linear infinite;
        display: none;
    }
</style>
{% endblock extrastyle %}

{% block content %}
{% load replace_value %}
<div id='modelSelectedContext' data-model-selected-value="{{ model_selected }}">
    <div class="container-fluid py-4">
        <div class="row">
            <!-- Main Summarize Area -->
            <div class="col-md-9 order-1 order-md-2">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Summarize Something</h5>
                        <form id="summarize-form" data-model-selected-value="{{ model_selected_value }}" method="post" action="{% url 'summarizer:summarize_view' %}" enctype="multipart/form-data">
                            {% csrf_token %}
                            <div class="mb-3">
                                <label for="text" class="form-label">This will summarize any content you put in here. Copy paste any text, or enter the url of a web page, or enter the share link of a YouTube video:</label>
                                <textarea class="form-control" id="query-text" name="text" rows="5" required></textarea>
                            </div>
                            <div class="mb-3">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="crawl-website" name="crawl-website">
                                    <label class="form-check-label" for="crawl-website">
                                        Crawl entire website (for URLs only)
                                    </label>
                                </div>
                                <div id="max-pages-container" class="mt-2" style="display: none;">
                                    <label for="max-pages" class="form-label">Maximum pages to crawl (1-100):</label>
                                    <input type="number" class="form-control" id="max-pages" name="max-pages" min="1" max="100" value="10" style="width: 150px;">
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary">Summarize</button>
                            <button type="submit" class="btn btn-danger" style="float:right; padding-left:30px;" id="cancel-btn" title="Cancel this task">
                                Cancel 
                            </button>
                        </form>
                    </div>
                </div>

                <div class="card p-3">
                    <div id="task-status" class="mt-3" style="display: none;">
                        <div class="d-flex align-items-center">
                            <div class="spinner me-3">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                            <p class="mb-0">Getting source... <span id="perc-complete"></span> <span id="task-timer">0</span> seconds</p>
                        </div>
                        <div class="progress mt-2">
                            <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                    </div>
                    
                    <div class="card-body p-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <h5 class="card-title">Summary</h5>
                            <button class="btn btn-icon-only shadow-none data-bs-toggle="tooltip" data-bs-placement="top" title data-bs-original-title="Copy to Clipboard" btn-link" id="copy-btn" title="Copy to clipboard" style="display: none;">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>                
                        <div id="task-result" class="card-body border rounded-3 mt-3" style="display: none;"></div>
                    </div>
                </div>
            </div>

            <!-- Previous Summarizations Sidebar -->
            <div class="col-md-3 order-2 order-md-1">
                {% if request.user.is_superuser %}
                <div class="card mb-4">
                    <div class="card-body">
                        <label>Models:</label>
                        <select id="model-selected" name="models_selected" class="form-select" size="21" style="width: 100%;">
                            {% for model in models %}
                                <option value="{{ model }}" {% if model == model_selected %}selected="selected"{% endif %}>{{ model }}</option>
                            {% endfor %}
                        </select>
                    </div>
                </div>
                {% endif %}

                <div class="card mb-4">
                    <div class="card-body">
                        <h6 class="card-title">Previous Summarizations</h6>
                        <ul id="summarization-list" style="list-style: none; padding: 0;">
                            {% for summarization in summarizations %}
                            <a href="#" style="display: block; padding-left: 0;margin-left: 0;" class="text-xs mb-2" data-query="{{ summarization.query }}" data-response="{{ summarization.html_result }}">
                                {{ summarization.response|clean_title |truncatewords:20 }}
                            </a>
                            <hr class="horizontal dark">
                            {% empty %}
                            <li>No previous summarizations</li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
      const summarizationList = document.getElementById('summarization-list');
      summarizationList.addEventListener('click', function(event) {
        if (event.target.tagName === 'A') {
          const query = event.target.getAttribute('data-query');
          const response = event.target.getAttribute('data-response')
          var queryText=document.getElementById('query-text');
          var taskResult=document.getElementById('task-result');
          var copyBtn = document.getElementById('copy-btn');
          queryText.value = query;  
          taskResult.innerHTML = response;
          taskResult.style.display = 'block';
          copyBtn.style.display = 'inline-block';
        }
      });
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        var form = document.getElementById('summarize-form');
        var taskStatus = document.getElementById('task-status');
        var taskResult = document.getElementById('task-result');
        var csrfToken = '{{ csrf_token }}'; // Get the CSRF token from Django
        var taskTimer = document.getElementById('task-timer');
        var percComplete = document.getElementById('perc-complete');
        var taskTimerInterval;
        var taskStartTime;
        var copyBtn = document.getElementById('copy-btn');

        // Add this at the beginning of your DOMContentLoaded handler
        const crawlWebsiteCheckbox = document.getElementById('crawl-website');
        const maxPagesContainer = document.getElementById('max-pages-container');

        crawlWebsiteCheckbox.addEventListener('change', function() {
            maxPagesContainer.style.display = this.checked ? 'block' : 'none';
        });

        form.addEventListener('submit', function(event) {
            event.preventDefault();
            taskStatus.style.display = 'block';
            taskResult.style.display = 'none';
            taskResult.innerHTML = ''; // Clear the task result
            taskTimer.textContent = 0; // Reset the task timer
            clearInterval(taskTimerInterval); // Clear any existing interval
            copyBtn.style.display = 'none'; // Hide the copy button

            var modelSelectedElement = document.getElementById('model-selected');
            var modelSelected = modelSelectedElement ? modelSelectedElement.value : '';
            var modelSelectedFromContext = document.getElementById('modelSelectedContext');
            var modelSelectedValue = modelSelectedFromContext.dataset.modelSelectedValue;

            if (!modelSelected) {
                modelSelected = modelSelectedValue;
            }
            var formData = new FormData(form);
            
            // Add crawl website and max pages data if checkbox is checked
            if (crawlWebsiteCheckbox.checked) {
                formData.append('crawl_website', true);
                formData.append('max_pages', document.getElementById('max-pages').value);
            }

            formData.append('model_selected_value', modelSelected);            
            formData.append('query_text_value', document.getElementById('query-text').value);

            var xhr = new XMLHttpRequest();
            xhr.open('POST', '{% url "summarizer:summarize_view" %}');
            xhr.onload = function() {
                if (xhr.status === 200) {
                    var response = JSON.parse(xhr.responseText);
                    console.log(response)
                    if (response.task_id) {
                        taskStartTime = new Date().getTime();
                        taskTimerInterval = setInterval(updateTaskTimer, 5000);
                        checkTaskStatus(response.task_id);
                    } else {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = 'Error: ' + response.error;
                        taskResult.style.display = 'block';
                    }
                }
            };
            xhr.send(formData);
        });

        function updateTaskTimer() {
            var currentTime = new Date().getTime();
            var elapsedTime = Math.floor((currentTime - taskStartTime) / 1000);
            taskTimer.textContent = elapsedTime;
        }

        // Store the current task ID
        let currentTaskId = null;
        
        function handleCancelClick(event) {
            event.preventDefault();
            if (currentTaskId) {
                clearInterval(taskTimerInterval);
                checkTaskStatus(currentTaskId, 'cancel');
            }
        }
        
        function checkTaskStatus(taskId, action = null) {
            currentTaskId = taskId; // Store the task ID
            var xhr = new XMLHttpRequest();
            
            var taskStatusUrl = '{% url "summarizer:task_status" task_id="TASK_ID" %}'.replace('TASK_ID', encodeURIComponent(taskId));
            if (action === 'cancel') {
                taskStatusUrl += '?action=cancel';
            }
            xhr.open('GET', taskStatusUrl);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    var response = JSON.parse(xhr.responseText);
                    console.log(response); // Log the response for debugging
        
                    if (response.status === 'SUCCESS') {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = response.result;
                        taskResult.style.display = 'block';
                        copyBtn.style.display = 'inline-block'; // Show the copy button
                        clearInterval(taskTimerInterval); // Stop the timer interval
                            // Reset progress bar
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.width = '0%';
                        progressBar.setAttribute('aria-valuenow', 0);
                        percComplete.textContent = '0'; // Reset percentage text
                    } else if (response.status === 'FAILURE') {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = 'Error: ' + response.result;
                        taskResult.style.display = 'block';
                        clearInterval(taskTimerInterval); // Stop the timer interval
                    } else if (response.status === 'processing') {
                        var progress = (response.current / response.total) * 100;
                        // Update progress percentage element
                        percComplete.textContent = response.status + '... ' + Math.round(progress) + '%';
                        // Update progress bar width
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.width = progress + '%';
                        progressBar.setAttribute('aria-valuenow', progress);
                        setTimeout(function () {
                            checkTaskStatus(taskId);
                        }, 5000);
                    } else if (response.satus ==='summarizing') {
                        percComplete.textContent = response.status + '... ';
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.display = 'block';
                    } else {
                        percComplete.textContent = response.status + '... '
                        setTimeout(function() {
                            checkTaskStatus(taskId);
                        }, 5000);
                    }
                } else {
                    // Handle other response status codes
                    console.error('Error checking task status:', xhr.status, xhr.statusText);
                }
            };
            xhr.send();
        }
        
        // Add an event listener to the cancel button
        document.getElementById('cancel-btn').addEventListener('click', handleCancelClick);
        
        // Copy to clipboard functionality
        copyBtn.addEventListener('click', function() {
            var resultText = taskResult.textContent.trim();
            if (resultText) {
                navigator.clipboard.writeText(resultText)
                    .then(() => {
                        alert('Summary copied to clipboard!');
                    })
                    .catch((err) => {
                        console.error('Failed to copy summary: ', err);
                    });
            }
        });
    });
</script>
{% endblock extra_js %}

================
File: apps/summarizer/templatetags/__init__.py
================
# This file is intentionally left empty to mark this directory as a Python package.

================
File: apps/summarizer/templatetags/replace_value.py
================
from django import template
import json
from django.utils.safestring import mark_safe

register = template.Library()

@register.filter(name='replace_value')
def replace_value(value, arg):
    """Removes all values of arg from the given string"""
    return value.replace(arg, ' ').title()

@register.filter(name='clean_title')
def clean_title(text):
    return text.replace('#','').strip().replace('\n','').replace('\r,','')

@register.filter(name='dict2json')
def dict_to_json(dictionary):
    return json.dumps(dictionary)

@register.simple_tag
def client_data(client):
    client_json = json.dumps(client)
    return mark_safe(client_json)

================
File: apps/summarizer/__init__.py
================


================
File: apps/summarizer/admin.py
================
from django.contrib import admin
from .models import SummarizerUsage


@admin.register(SummarizerUsage)
class SummarizerUsageAdmin(admin.ModelAdmin):
    list_display = ('user', 'query', 'created_at', 'model_used')
    list_filter = ('model_used', 'created_at')
    search_fields = ('query', 'response')
    date_hierarchy = 'created_at'

================
File: apps/summarizer/apps.py
================
from django.apps import AppConfig


class SummarizerConfig(AppConfig):
    name = 'apps.summarizer'
    verbose_name = 'Summarizer'

================
File: apps/summarizer/models.py
================
from django.db import models
from django.contrib.auth.models import User
from django.utils import timezone


class SummarizerUsage(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='summarizer_usage')
    query = models.TextField()
    compressed_content = models.TextField()
    response = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    duration = models.DurationField()
    content_token_size = models.IntegerField()
    content_character_count = models.IntegerField()
    total_input_tokens = models.IntegerField()
    total_output_tokens = models.IntegerField()
    model_used = models.CharField(max_length=100)

================
File: apps/summarizer/urls.py
================
from django.urls import path
from . import views

app_name = 'summarizer'

urlpatterns = [
    path('', views.summarize_view, name='summarize_view'),
    path('task_status/<str:task_id>/', views.task_status, name='task_status'),
]

================
File: apps/summarizer/views.py
================
from django.contrib.auth.models import User
from django.conf import settings

from apps.tasks.tasks import summarize_content
import mistune

from django.http import JsonResponse
from celery.result import AsyncResult
import logging
from apps.common.utils import get_models
from apps.common.tools.user_activity_tool import user_activity_tool

import json
from django.shortcuts import render
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from .models import SummarizerUsage


@login_required
def summarize_view(request):
    models = get_models()
    logging.info(f'request.user.id: {request.user.id}')
    model_selected = settings.SUMMARIZER
    
    if request.method == 'POST':
        text_to_summarize = request.POST.get('query_text_value')
        model_selected = request.POST.get('model_selected_value')
        crawl_website = request.POST.get('crawl_website') == 'true'
        max_pages = int(request.POST.get('max_pages', 10))
        
        # Log the actual values for debugging
        logging.info(f"Summarize request params: crawl_website={crawl_website}, max_pages={max_pages}")
        
        # Ensure max_pages is within bounds
        max_pages = min(max(1, max_pages), 100)
        
        task = summarize_content.delay(
            text_to_summarize, 
            request.user.id, 
            model_selected,
            crawl_website=crawl_website,
            max_pages=max_pages
        )
        
        # Log user activity
        user_activity_tool.run(
            user=request.user,
            category='summarize',
            action=f"Used summarizer with model: {model_selected}",
            details={
                "text_length": len(text_to_summarize),
                "crawl_website": crawl_website,
                "max_pages": max_pages if crawl_website else None
            }
        )
        
        return JsonResponse({'task_id': task.id})
    
    user = User.objects.get(id=request.user.id)
    summarizations = SummarizerUsage.objects.filter(user=user).order_by('-created_at')
    
    for summ in summarizations:
        summ.html_result = mistune.html(summ.response)
        
    task_result = None
    task_status = None
    model_selected = settings.SUMMARIZER
    context = {
        'page_title': 'Summarize',
        'task_result': task_result,
        'task_status': task_status,
        'summarizations': summarizations,
        'models': models,
        'model_selected': model_selected
    }
    
    # Log user activity for viewing summarize page
    user_activity_tool.run(
        user=request.user,
        category='view',
        action="Viewed summarize page"
    )
    
    return render(request, 'summarizer/summarize.html', context)


def task_status(request, task_id):
    current_chunk = 0
    total_chunks = 1
    task_result = AsyncResult(task_id)
    if task_result.info is not None:
        if task_result.state == 'SUCCESS':
            result = task_result.result
            html_result = mistune.html(result)
            return JsonResponse({'status': 'SUCCESS', 'result': html_result})
        elif task_result.state == 'FAILURE':
            error = str(task_result.result)
            return JsonResponse({'status': 'FAILURE', 'result': error})
        elif task_result.status == 'processing':
            progress = task_result.info
            current_chunk = progress.get('current_chunk', 0)
            total_chunks = progress.get('total_chunks', 0)
            return JsonResponse({'status': task_result.status, 'current': current_chunk, 'total': total_chunks})
        else:
            if task_result.status:
                return JsonResponse({'status': task_result.status})
            else:
                return JsonResponse({'status': 'PENDING'})
    else:
        return JsonResponse({'status': 'PENDING'})

================
File: apps/tasks/templatetags/formats.py
================
# -*- encoding: utf-8 -*-
"""
Copyright (c) 2019 - present AppSeed.us
"""

import json
import os

from django import template
from django.conf import settings

register = template.Library()

def date_format(date):
    """
    Returns a formatted date string
    Format:  `Year-Month-Day-Hour-Minute-Second`
    Example: `2022-10-10-00-20-33`
    :param date datetime: Date object to be formatted
    :rtype: str
    """
    try:
        return date.strftime(r'%Y-%m-%d-%H-%M-%S')
    except:
        return date

register.filter("date_format", date_format)

def get_result_field(result, field: str):
    """
    Returns a field from the content of the result attibute in result 
    Example: `result.result['field']`
    :param result AbortableAsyncResult: Result object to get field from
    :param field str: Field to return from result object
    :rtype: str
    """
    result = json.loads(result.result)
    if result:
        return result.get(field)

register.filter("get_result_field", get_result_field)



def log_file_path(path):
    file_path = path.split("tasks_logs")[1]
    return file_path

register.filter("log_file_path", log_file_path)


def log_to_text(path):
    path = path.lstrip('/')

    full_path = os.path.join(settings.CELERY_LOGS_DIR, path)

    try:
        with open(full_path, 'r') as file:
            text = file.read()
        
        return text
    except:
        return 'NO LOGS'

register.filter("log_to_text", log_to_text)

================
File: apps/tasks/admin.py
================
from django.contrib import admin

# Register your models here.

================
File: apps/tasks/apps.py
================
from django.apps import AppConfig


class TasksConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.tasks'

================
File: apps/tasks/celery.py
================
import os
from celery import Celery
from django.conf import settings

# Set the default Django settings module for the 'celery' program.
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

app = Celery('core')

# Using a string here means the worker doesn't have to serialize
# the configuration object to child processes.
app.config_from_object('django.conf:settings', namespace='CELERY')

# Load task modules from all registered Django apps.
app.autodiscover_tasks()

@app.task(bind=True)
def debug_task(self):
    print(f'Request: {self.request!r}')

================
File: apps/tasks/decorators.py
================
import functools
import logging
from celery import shared_task

from apps.organizations.utils import OrganizationContext

logger = logging.getLogger(__name__)

def organization_aware_task(**task_kwargs):
    """
    Decorator for Celery tasks that preserves organization context.
    
    This decorator wraps Celery's shared_task decorator to automatically
    handle organization context propagation. It ensures that tasks
    executed in the background maintain the correct organization context.
    
    Example usage:
    
    @organization_aware_task()
    def my_task(arg1, arg2, organization_id=None):
        # This task will have the correct organization context set
        # based on the organization_id parameter
        ...
    
    # Call the task with organization context
    my_task.delay(arg1, arg2, organization_id=org.id)
    """
    def decorator(func):
        @shared_task(**task_kwargs)
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Extract organization_id from kwargs
            organization_id = kwargs.pop('organization_id', None)
            
            if not organization_id:
                logger.warning(
                    f"Task {func.__name__} called without organization_id. "
                    "Organization context will not be set."
                )
                # Execute task without organization context
                return func(*args, **kwargs)
            
            # Execute task with organization context
            try:
                with OrganizationContext.organization_context(organization_id):
                    logger.debug(f"Running task {func.__name__} with organization_id: {organization_id}")
                    return func(*args, **kwargs)
            except Exception as e:
                logger.exception(
                    f"Error in organization_aware_task {func.__name__} "
                    f"with organization_id {organization_id}: {str(e)}"
                )
                raise
        
        return wrapper
    
    return decorator

================
File: apps/tasks/models.py
================
from django.db import models

# Create your models here.

================
File: apps/tasks/tasks.py
================
import os, time, subprocess
import datetime
import json
from os import listdir
from os.path import isfile, join
from .celery import app
from celery.contrib.abortable import AbortableTask
from django.utils import timezone
from django.contrib.auth.models import User
from django.conf import settings
import logging
import tiktoken
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile

from apps.common.content_loader import ContentLoader
from apps.agents.tools.compression_tool.compression_tool import CompressionTool
from apps.summarizer.models import SummarizerUsage

def get_scripts():
    """
    Returns all scripts from 'ROOT_DIR/celery_scripts'
    """
    raw_scripts = []
    scripts     = []
    ignored_ext = ['db', 'txt']

    try:
        raw_scripts = [f for f in listdir(settings.CELERY_SCRIPTS_DIR) if isfile(join(settings.CELERY_SCRIPTS_DIR, f))]
    except Exception as e:
        return None, 'Error CELERY_SCRIPTS_DIR: ' + str( e ) 

    for filename in raw_scripts:

        ext = filename.split(".")[-1]
        if ext not in ignored_ext:
           scripts.append( filename )

    return scripts, None           

def write_to_log_file(logs, script_name):
    """
    Writes logs to a log file with formatted name in the CELERY_LOGS_DIR directory.
    """
    script_base_name = os.path.splitext(script_name)[0]  # Remove the .py extension
    current_time = datetime.datetime.now().strftime("%y%m%d-%H%M%S")
    log_file_name = f"{script_base_name}-{current_time}.log"
    log_file_path = os.path.join(settings.CELERY_LOGS_DIR, log_file_name)
    
    with default_storage.open(log_file_path, 'w') as log_file:
        log_file.write(logs)
    
    return log_file_path

@app.task(bind=True, base=AbortableTask)
def execute_script(self, data: dict):
    """
    This task executes scripts found in settings.CELERY_SCRIPTS_DIR and logs are later generated and stored in settings.CELERY_LOGS_DIR
    :param data dict: contains data needed for task execution. Example `input` which is the script to be executed.
    :rtype: None
    """
    script = data.get("script")
    args   = data.get("args")

    print( '> EXEC [' + script + '] -> ('+args+')' ) 

    scripts, ErrInfo = get_scripts()

    if script and script in scripts:
        # Executing related script
        script_path = os.path.join(settings.CELERY_SCRIPTS_DIR, script)
        process = subprocess.Popen(
            f"python {script_path} {args}", shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        time.sleep(8)

        exit_code = process.wait()
        error = False
        status = "STARTED"
        if exit_code == 0:  # If script execution successfull
            logs = process.stdout.read().decode()
            status = "SUCCESS"
        else:
            logs = process.stderr.read().decode()
            error = True
            status = "FAILURE"


        log_file = write_to_log_file(logs, script)

        return {"logs": logs, "input": script, "error": error, "output": "", "status": status, "log_file": log_file}
    
@app.task(bind=True, time_limit=3600)
def summarize_content(self_task, query, user_id, model_name=settings.SUMMARIZER, crawl_website=False, max_pages=10):
    """
    Summarize the given content 
    :param self: Celery task instance
    :param query: str, the text/url to be summarized
    :param user_id: int, the user ID
    :param model_name: str, the model to use for summarization
    :param crawl_website: bool, whether to crawl the entire website
    :param max_pages: int, maximum number of pages to crawl
    :return: str, the summary of the input text
    """
    start_time = timezone.now()
    max_tokens = int(settings.SUMMARIZER_MAX_TOKENS)
    
    try:
        user = User.objects.get(id=user_id)
    except Exception as e:
        user_id = 3
        user = User.objects.get(id=user_id)
    
    content_loader = ContentLoader()
    content = content_loader.load_content(
        query, 
        user_id=user_id,
        crawl_website=crawl_website, 
        max_pages=max_pages
    )

    input_tokens = 0
    output_tokens = 0


    # Use CompressionTool for compression with 'comprehensive' setting
    compression_tool = CompressionTool(modelname=model_name)
    compression_result_json = compression_tool.run(
        content=content,
        max_tokens=max_tokens,
        detail_level="comprehensive"
    )
    
    # Parse the result
    compression_result = json.loads(compression_result_json)
    
    if "error" in compression_result:
        logging.error(f"Error compressing content: {compression_result.get('message', 'Unknown error')}")
        return f"Error: {compression_result.get('message', 'Failed to compress content')}"
    
    compressed_content = compression_result.get("processed_content", "")
    comp_input_tokens = compression_result.get("llm_input_tokens", 0)
    comp_output_tokens = compression_result.get("llm_output_tokens", 0)



    input_tokens += comp_input_tokens
    output_tokens += comp_output_tokens
    
    # Use CompressionTool for summarization with 'focused' setting to create a summary
    summarization_tool = CompressionTool(modelname=model_name)
    summarization_result_json = summarization_tool.run(
        content=compressed_content,
        detail_level="focused"  # Using focused for summarization
    )
    
    # Parse the result
    summarization_result = json.loads(summarization_result_json)
    
    if "error" in summarization_result:
        logging.error(f"Error summarizing content: {summarization_result.get('message', 'Unknown error')}")
        return f"Error: {summarization_result.get('message', 'Failed to summarize content')}"
    
    summary = summarization_result.get("processed_content", "")
    sum_input_tokens = summarization_result.get("llm_input_tokens", 0)
    sum_output_tokens = summarization_result.get("llm_output_tokens", 0)
    
    logging.info("finished compressing content")

    logging.info("finished summarizing content")
    input_tokens += sum_input_tokens
    output_tokens += sum_output_tokens

    result = summary + "\n\n--Detail-------------------\n\n" + compressed_content

    # save summarizationusage
    end_time = timezone.now()
    duration = end_time - start_time

    tokenizer = tiktoken.get_encoding("cl100k_base")
    content_tokens = tokenizer.encode(content)

    usage = SummarizerUsage.objects.create(
        user=user,
        query=query,
        compressed_content=compressed_content,
        response=summary,
        duration=duration,
        content_token_size=len(content_tokens),
        content_character_count=len(content),
        total_input_tokens=input_tokens,
        total_output_tokens=output_tokens,
        model_used=model_name
    )
    usage.save()
    logging.info(f"task summarize_content, user_id: {user_id}, model_name: {model_name}, max_tokens: {max_tokens}, content_tokens: {len(content_tokens)}, input_tokens: {input_tokens}, output_tokens: {output_tokens}, total_tokens: {input_tokens+output_tokens}, duration: {duration}")

    return result

================
File: apps/tasks/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/tasks/urls.py
================
from django.urls import path

from apps.tasks import views

urlpatterns = [
    # Celery
    path('', views.tasks, name="tasks"),
    path('tasks/run/<str:task_name>'  , views.run_task,    name="run-task"    ),
    path('tasks/cancel/<str:task_id>' , views.cancel_task, name="cancel-task" ),
    path('tasks/output/'              , views.task_output, name="task-output" ),
    path('tasks/log/'                 , views.task_log,    name="task-log"    ), 
    path('download-log-file/<str:file_path>/', views.download_log_file, name='download_log_file'),
]

================
File: apps/tasks/views.py
================
import os
import time
import json

from django.http import HttpResponse
from django.shortcuts import render, redirect

from celery import current_app
from apps.tasks.tasks import execute_script, get_scripts
from django_celery_results.models import TaskResult
from celery.contrib.abortable import AbortableAsyncResult
from apps.tasks.celery import app
from django.http import HttpResponse, Http404
from os import listdir
from os.path import isfile, join
from django.conf import settings

from django.template  import loader

# Create your views here.

def index(request):
    return HttpResponse("INDEX Tasks")



# @login_required(login_url="/login/")
def tasks(request):

    scripts, ErrInfo = get_scripts()
 
    context = {
        'page_title': 'Tasks',
        'cfgError' : ErrInfo,
        'tasks'    : get_celery_all_tasks(),
        'scripts'  : scripts,
        'segment'  : 'tasks',
        'parent'   : 'apps',
    }

    # django_celery_results_task_result
    task_results = TaskResult.objects.all()
    context["task_results"] = task_results

    html_template = loader.get_template('pages/apps/tasks.html')
    return HttpResponse(html_template.render(context, request)) 

def run_task(request, task_name):
    '''
    Runs a celery task
    :param request HttpRequest: Request
    :param task_name str: Name of task to execute
    :rtype: (HttpResponseRedirect | HttpResponsePermanentRedirect)
    '''
    tasks = [execute_script]
    _script = request.POST.get("script")
    _args   = request.POST.get("args")
    for task in tasks:
        if task.__name__ == task_name:
            task.delay({"script": _script, "args": _args})
    time.sleep(1)  # Waiting for task status to update in db

    return redirect("tasks") 

def cancel_task(request, task_id):
    '''
    Cancels a celery task using its task id
    :param request HttpRequest: Request
    :param task_id str: task_id of result to cancel execution
    :rtype: (HttpResponseRedirect | HttpResponsePermanentRedirect)
    '''
    result = TaskResult.objects.get(task_id=task_id)
    abortable_result = AbortableAsyncResult(
        result.task_id, task_name=result.task_name, app=app)
    if not abortable_result.is_aborted():
        abortable_result.revoke(terminate=True)
    time.sleep(1)
    return redirect("tasks")

def get_celery_all_tasks():
    current_app.loader.import_default_modules()
    tasks = list(sorted(name for name in current_app.tasks
                        if not name.startswith('celery.')))
    tasks = [{"name": name.split(".")[-1], "script":name} for name in tasks]
    for task in tasks:
        last_task = TaskResult.objects.filter(
            task_name=task["script"]).order_by("date_created").last()
        if last_task:
            task["id"] = last_task.task_id
            task["has_result"] = True
            task["status"] = last_task.status
            task["successfull"] = last_task.status == "SUCCESS" or last_task.status == "STARTED"
            task["date_created"] = last_task.date_created
            task["date_done"] = last_task.date_done
            task["result"] = last_task.result

            try:
                task["input"] = json.loads(last_task.result).get("input")
            except:
                task["input"] = ''
                
    return tasks

def task_output(request):
    '''
    Returns a task output 
    '''

    task_id = request.GET.get('task_id')
    task    = TaskResult.objects.get(id=task_id)

    if not task:
        return ''

    # task.result -> JSON Format
    return HttpResponse( task.result )

def task_log(request):
    '''
    Returns a task LOG file (if located on disk) 
    '''

    task_id  = request.GET.get('task_id')
    task     = TaskResult.objects.get(id=task_id)
    task_log = 'NOT FOUND'

    if not task: 
        return ''

    try: 
        # Get logs file
        all_logs = [f for f in listdir(settings.CELERY_LOGS_DIR) if isfile(join(settings.CELERY_LOGS_DIR, f))]
        
        for log in all_logs:

            # Task HASH name is saved in the log name
            if task.task_id in log:
                
                with open( os.path.join( settings.CELERY_LOGS_DIR, log) ) as f:
                    
                    # task_log -> JSON Format
                    task_log = f.readlines() 

                break    
    
    except Exception as e:
        task_log = json.dumps( { 'Error CELERY_LOGS_DIR: ' : str( e) } )

    return HttpResponse(task_log)

def download_log_file(request, file_path):
    path = file_path.replace('%slash%', '/')
    if os.path.exists(path):
        with open(path, 'rb') as fh:
            response = HttpResponse(fh.read(), content_type="application/vnd.ms-excel")
            response['Content-Disposition'] = 'inline; filename=' + os.path.basename(path)
            return response
    raise Http404

================
File: apps/users/admin.py
================
from django.contrib import admin

# Register your models here.

================
File: apps/users/apps.py
================
from django.apps import AppConfig


class UsersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.users'

    def ready(self):
        import apps.users.signals

================
File: apps/users/forms.py
================
from django import forms
from django.utils.translation import gettext_lazy as _
from apps.users.models import Profile


class ProfileForm(forms.ModelForm):
    class Meta:
        model = Profile
        exclude = ('user', 'role', 'avatar',)

    def __init__(self, *args, **kwargs):
        super(ProfileForm, self).__init__(*args, **kwargs)

        for field_name, field in self.fields.items():
            self.fields[field_name].widget.attrs['placeholder'] = field.label
            self.fields[field_name].widget.attrs['class'] = 'form-control'
            self.fields[field_name].widget.attrs['required'] = False


class QuillFieldForm(forms.ModelForm):
    class Meta:
        model = Profile
        fields = ('bio',)

================
File: apps/users/models.py
================
import json
from django.db import models
from django.contrib.auth.models import User
from django_quill.fields import QuillField
from rest_framework.authtoken.models import Token
from core.storage import SecureFileStorage

# Create avatar storage
avatar_storage = SecureFileStorage(
    private=True,
    collection='user_avatars'
)

# Create your models here.

ROLE_CHOICES = (
    ('admin'  , 'Admin'),
    ('user'  , 'User'),
)

def avatar_with_id(instance, filename):
    # Return a path that includes the user ID to ensure uniqueness
    # but still keep it within the user_avatars collection
    return f"{instance.user.id}/{filename}"

def convert_to_quill():
    converted_data = {
        "delta": "",
        "html": "Write something #cool about you.",
    }
    return json.dumps(converted_data)


class Profile(models.Model):
    user      = models.OneToOneField(User, on_delete=models.CASCADE)
    role      = models.CharField(max_length=20, choices=ROLE_CHOICES, default='user')
    full_name = models.CharField(max_length=255, null=True, blank=True)
    country   = models.CharField(max_length=255, null=True, blank=True)
    city      = models.CharField(max_length=255, null=True, blank=True)
    zip_code  = models.CharField(max_length=255, null=True, blank=True)
    address   = models.CharField(max_length=255, null=True, blank=True)
    phone     = models.CharField(max_length=255, null=True, blank=True)
    avatar    = models.ImageField(upload_to=avatar_with_id, storage=avatar_storage, null=True, blank=True)
    bio       = QuillField(default=convert_to_quill())
    dark_mode = models.BooleanField(default=False)


    def __str__(self):
        return self.user.username
        
    def get_token(self):
        """Get the user's current token"""
        return Token.objects.get_or_create(user=self.user)[0]
        
    def regenerate_token(self):
        """Delete existing token and create a new one"""
        Token.objects.filter(user=self.user).delete()
        return Token.objects.create(user=self.user)

================
File: apps/users/signals.py
================
from django.contrib.auth.models import User
from apps.users.models import Profile
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token

@receiver(post_save, sender=User)
def create_profile(sender, instance, created, **kwargs):
    if created:
        profile = Profile.objects.create(user=instance)
        if instance.is_superuser:
            profile.role = "admin"
            profile.save()
        
        Token.objects.create(user=instance)

================
File: apps/users/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/users/urls.py
================
from django.urls import path
from apps.users import views


urlpatterns = [
    path('profile/', views.profile, name='profile'),
    path('upload-avatar/', views.upload_avatar, name='upload_avatar'),
    path('change-password/', views.change_password, name='change_password'),
    path('change-mode/', views.change_mode, name='change_mode'),
    path('regenerate-token/', views.regenerate_token, name='regenerate_token'),
]

================
File: apps/users/views.py
================
from django.shortcuts import render, redirect, get_object_or_404
from apps.users.models import Profile
from apps.users.forms import ProfileForm, QuillFieldForm
from django.contrib.auth.decorators import login_required
from django.contrib.auth.hashers import check_password
from django.contrib import messages
from django.http import JsonResponse
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
import logging

logger = logging.getLogger(__name__)

# Create your views here.


@login_required
def profile(request):
    profile = get_object_or_404(Profile, user=request.user)
    form = QuillFieldForm(instance=profile)
    if request.method == 'POST':

        if request.POST.get('email'):
            request.user.email = request.POST.get('email')
            request.user.save()

        for attribute, value in request.POST.items():
            if attribute == 'csrfmiddlewaretoken':
                continue

            setattr(profile, attribute, value)
            profile.save()

        messages.success(request, 'Profile updated successfully')
        return redirect(request.META.get('HTTP_REFERER'))

    context = {
        'page_title': 'Profile',
        'segment': 'profile',
        'parent': 'apps',
        'form': form
    }
    return render(request, 'pages/apps/user-profile.html', context)


@login_required
def upload_avatar(request):
    profile = get_object_or_404(Profile, user=request.user)
    if request.method == 'POST':
        profile.avatar = request.FILES.get('avatar')
        profile.save()
        messages.success(request, 'Avatar uploaded successfully')
    return redirect(request.META.get('HTTP_REFERER'))


@login_required
def change_password(request):
    user = request.user
    if request.method == 'POST':
        new_password = request.POST.get('new_password')
        confirm_new_password = request.POST.get('confirm_new_password')

        if new_password == confirm_new_password:
            if check_password(request.POST.get('current_password'), user.password):
                user.set_password(new_password)
                user.save()
                messages.success(request, 'Password changed successfully')
            else:
                messages.error(request, "Old password doesn't match!")
        else:
            messages.error(request, "Password doesn't match!")

    return redirect(request.META.get('HTTP_REFERER'))


@login_required
def change_mode(request):
    profile = get_object_or_404(Profile, user=request.user)
    if profile.dark_mode:
        profile.dark_mode = False
    else:
        profile.dark_mode = True
    
    profile.save()

    return redirect(request.META.get('HTTP_REFERER'))


@login_required
def regenerate_token(request):
    """View to regenerate a user's API token"""
    if request.method != 'POST':
        return JsonResponse({
            'error': 'Only POST method is allowed',
            'success': False
        }, status=405)
    
    try:
        profile = request.user.profile
        token = profile.regenerate_token()
        
        return JsonResponse({
            'token': token.key,
            'message': 'API token regenerated successfully',
            'success': True
        })
    except Exception as e:
        logger.error(f"Error regenerating token for user {request.user.id}: {str(e)}")
        return JsonResponse({
            'error': 'Failed to regenerate token',
            'message': str(e),
            'success': False
        }, status=500)

================
File: apps/utilities/templates/utilities/test_endpoint.html
================
{% extends "layouts/base.html" %}

{% block title %} Test Endpoint {% endblock %}

{% block extrastyle %}
<style>
    .response-container {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        margin-top: 20px;
    }
    .json-response {
        white-space: pre-wrap;
        word-wrap: break-word;
    }
    .status-badge {
        font-size: 1rem;
    }
</style>
{% endblock extrastyle %}

{% block content %}

<div class="container-fluid py-4">
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header pb-0">
                    <h6>Test API Endpoint</h6>
                </div>
                <div class="card-body">
                    <form id="endpoint-form" class="row g-3">
                        {% csrf_token %}
                        <div class="col-12">
                            <label for="saved_endpoint" class="form-label">Saved Endpoints</label>
                            <select class="form-control" id="saved_endpoint">
                                <option value="">-- Select an endpoint --</option>
                                {% for endpoint in saved_endpoints %}
                                <option value="{{ endpoint.id }}" 
                                        data-url="{{ endpoint.url }}"
                                        data-method="{{ endpoint.method }}"
                                        data-token="{{ endpoint.auth_token }}"
                                        data-body="{{ endpoint.default_body }}">
                                    {{ endpoint.name }}
                                </option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="col-md-8">
                            <label for="endpoint" class="form-label">Endpoint URL</label>
                            <input type="url" class="form-control" id="endpoint" name="endpoint" required>
                        </div>
                        <div class="col-md-4">
                            <label for="method" class="form-label">Method</label>
                            <select class="form-control" id="method" name="method">
                                <option value="GET">GET</option>
                                <option value="POST">POST</option>
                                <option value="PUT">PUT</option>
                                <option value="DELETE">DELETE</option>
                                <option value="PATCH">PATCH</option>
                            </select>
                        </div>
                        <div class="col-12">
                            <label for="auth_token" class="form-label">Bearer Token (Optional)</label>
                            <input type="text" class="form-control" id="auth_token" name="auth_token">
                        </div>
                        <div class="col-12">
                            <label for="request_body" class="form-label">Request Body (JSON)</label>
                            <textarea class="form-control" id="request_body" name="request_body" rows="5"></textarea>
                        </div>
                        <div class="col-12">
                            <button type="submit" class="btn btn-primary">Send Request</button>
                        </div>
                    </form>

                    <div id="response-section" class="response-container mt-4" style="display: none;">
                        <h6>Response</h6>
                        <div class="mb-2">
                            Status: <span id="status-code" class="badge bg-success status-badge">200</span>
                        </div>
                        <div class="mb-2">
                            <button class="btn btn-sm btn-outline-primary" type="button" data-bs-toggle="collapse" data-bs-target="#headersCollapse">
                                Show Headers
                            </button>
                            <div class="collapse mt-2" id="headersCollapse">
                                <div id="response-headers" class="json-response"></div>
                            </div>
                        </div>
                        <div class="mt-3">
                            <strong>Response Body:</strong>
                            <div id="response-body" class="json-response mt-2"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
<script>
// Handle saved endpoint selection
document.getElementById('saved_endpoint').addEventListener('change', function(e) {
    const option = e.target.selectedOptions[0];
    if (option.value) {
        document.getElementById('endpoint').value = option.dataset.url;
        document.getElementById('method').value = option.dataset.method;
        document.getElementById('auth_token').value = option.dataset.token;
        document.getElementById('request_body').value = option.dataset.body;
        
        // Trigger method change to show/hide request body
        document.getElementById('method').dispatchEvent(new Event('change'));
    }
});

document.getElementById('endpoint-form').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const form = e.target;
    const submitBtn = form.querySelector('button[type="submit"]');
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Sending...';
    
    try {
        const formData = new FormData(form);
        const response = await fetch(window.location.href, {
            method: 'POST',
            body: formData,
            headers: {
                'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value
            }
        });
        
        const data = await response.json();
        
        if (data.success) {
            // Show response section
            document.getElementById('response-section').style.display = 'block';
            
            // Update status code
            const statusElement = document.getElementById('status-code');
            statusElement.textContent = data.status_code;
            statusElement.className = `badge status-badge ${data.status_code < 400 ? 'bg-success' : 'bg-danger'}`;
            
            // Update headers
            document.getElementById('response-headers').textContent = 
                JSON.stringify(data.headers, null, 2);
            
            // Update response body
            const responseBody = document.getElementById('response-body');
            if (data.is_json) {
                responseBody.textContent = JSON.stringify(data.response, null, 2);
            } else {
                responseBody.textContent = data.response;
            }
        } else {
            Swal.fire({
                icon: 'error',
                title: 'Error',
                text: data.error
            });
        }
    } catch (error) {
        Swal.fire({
            icon: 'error',
            title: 'Error',
            text: 'An error occurred while processing your request.'
        });
    } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Send Request';
    }
});

// Add event listener to method select to toggle request body
document.getElementById('method').addEventListener('change', function(e) {
    const method = e.target.value;
    const requestBodyContainer = document.getElementById('request_body').parentElement;
    requestBodyContainer.style.display = method === 'GET' ? 'none' : 'block';
});

// Initial toggle of request body based on method
document.getElementById('method').dispatchEvent(new Event('change'));
</script>
{% endblock extra_js %}

================
File: apps/utilities/admin.py
================
from django.contrib import admin
from .models import APIEndpoint

@admin.register(APIEndpoint)
class APIEndpointAdmin(admin.ModelAdmin):
    list_display = ('name', 'method', 'url', 'created_by', 'created_at')
    list_filter = ('method', 'created_by')
    search_fields = ('name', 'url')
    readonly_fields = ('created_at', 'updated_at')
    
    def save_model(self, request, obj, form, change):
        if not change:  # If creating new object
            obj.created_by = request.user
        super().save_model(request, obj, form, change)

================
File: apps/utilities/apps.py
================
from django.apps import AppConfig


class UtilitiesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'apps.utilities'
    verbose_name = 'Utilities'

================
File: apps/utilities/models.py
================
from django.db import models
from django.conf import settings

# Create your models here.

class APIEndpoint(models.Model):
    name = models.CharField(max_length=100, help_text="Name/description of the endpoint")
    url = models.URLField(help_text="Full URL of the endpoint")
    method = models.CharField(
        max_length=10,
        choices=[
            ('GET', 'GET'),
            ('POST', 'POST'),
            ('PUT', 'PUT'),
            ('DELETE', 'DELETE'),
            ('PATCH', 'PATCH')
        ],
        default='GET'
    )
    auth_token = models.CharField(
        max_length=500, 
        blank=True, 
        help_text="Bearer token for authentication"
    )
    default_body = models.TextField(
        blank=True, 
        help_text="Default JSON body for the request"
    )
    created_by = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='api_endpoints'
    )
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ['name']
        verbose_name = "API Endpoint"
        verbose_name_plural = "API Endpoints"

    def __str__(self):
        return f"{self.name} ({self.method} {self.url})"

================
File: apps/utilities/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: apps/utilities/urls.py
================
from django.urls import path
from . import views

app_name = 'utilities'

urlpatterns = [
    path('test-endpoint/', views.test_endpoint, name='test_endpoint'),
]

================
File: apps/utilities/views.py
================
from django.shortcuts import render
import json
import requests
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import APIEndpoint

# Create your views here.

@login_required
def test_endpoint(request):
    """View for testing API endpoints"""
    if request.method == 'POST':
        try:
            endpoint = request.POST.get('endpoint')
            method = request.POST.get('method', 'GET')
            auth_token = request.POST.get('auth_token')
            request_body = request.POST.get('request_body')
            
            headers = {}
            if auth_token:
                headers['Authorization'] = f'Bearer {auth_token}'
            
            # Add JSON content type header if body is present
            if request_body:
                headers['Content-Type'] = 'application/json'
                try:
                    # Validate JSON body
                    json_body = json.loads(request_body)
                except json.JSONDecodeError:
                    return JsonResponse({
                        'success': False,
                        'error': 'Invalid JSON in request body'
                    })
            else:
                json_body = None
            
            # Make the request
            response = requests.request(
                method=method,
                url=endpoint,
                headers=headers,
                json=json_body if json_body else None,
                timeout=30
            )
            
            # Try to parse response as JSON
            try:
                response_data = response.json()
                is_json = True
            except:
                response_data = response.text
                is_json = False
            
            return JsonResponse({
                'success': True,
                'status_code': response.status_code,
                'headers': dict(response.headers),
                'is_json': is_json,
                'response': response_data
            })
            
        except requests.RequestException as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            })
    
    # Get saved endpoints for the current user
    saved_endpoints = APIEndpoint.objects.filter(created_by=request.user).order_by('name')
    return render(request, 'utilities/test_endpoint.html', {'saved_endpoints': saved_endpoints})

================
File: config/asgi.py
================
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from channels.security.websocket import AllowedHostsOriginValidator

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

django_asgi_app = get_asgi_application()

from apps.image_optimizer.routing import websocket_urlpatterns as image_optimizer_websocket_urlpatterns
from apps.agents.routing import websocket_urlpatterns as agents_websocket_urlpatterns

application = ProtocolTypeRouter({
    'http': django_asgi_app,
    'websocket': AllowedHostsOriginValidator(
        AuthMiddlewareStack(
            URLRouter(
                image_optimizer_websocket_urlpatterns + agents_websocket_urlpatterns
            )
        )
    ),
})

================
File: config/routing.py
================
from django.urls import path, re_path
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from channels.security.websocket import AllowedHostsOriginValidator

from apps.image_optimizer.routing import websocket_urlpatterns as image_optimizer_websocket_urlpatterns

application = ProtocolTypeRouter({
    'websocket': AllowedHostsOriginValidator(
        AuthMiddlewareStack(
            URLRouter(
                image_optimizer_websocket_urlpatterns
            )
        )
    ),
})

================
File: config/settings.py
================
# Channels Configuration
ASGI_APPLICATION = 'config.asgi.application'

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [('127.0.0.1', 6379)],
        },
    },
}

================
File: config/urls.py
================
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # ... your other URL patterns ...
]

# Add static files handling for development only
if settings.DEBUG:
    urlpatterns += static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

================
File: core/__init__.py
================
from apps.tasks.celery import app as celery_app

__all__ = ('celery_app',)

================
File: core/apps.py
================
from django.apps import AppConfig
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.utils.module_loading import import_string
import logging
import time
import sys

logger = logging.getLogger('core.apps')

class StorageConfigError(RuntimeError):
    """Raised when storage configuration is invalid"""
    pass

class CoreConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'core'

    def _cleanup_test_files(self):
        """Clean up any leftover test files"""
        try:
            # List all files in storage
            _, files = default_storage.listdir('')
            
            # Find and delete any test files
            test_files = [f for f in files if f.startswith('_test_storage_')]
            for test_file in test_files:
                try:
                    default_storage.delete(test_file)
                    #logger.info(f"Cleaned up test file: {test_file}")
                except Exception as e:
                    logger.warning(f"Failed to delete test file {test_file}: {str(e)}")
                    
        except Exception as e:
            logger.warning(f"Error during test file cleanup: {str(e)}")

    def ready(self):
        """Verify storage configuration on startup"""
        from django.conf import settings
        
        # Skip storage verification if running migrations or collecting static
        if len(sys.argv) > 1:
            cmd = sys.argv[1]
            if cmd in ['migrate', 'collectstatic', 'makemigrations']:
                #logger.info(f"Skipping storage verification during {cmd}")
                return
        
        # Clean up any leftover test files from previous runs
        self._cleanup_test_files()
        
        # Verify storage settings are configured
        if not hasattr(settings, 'DEFAULT_FILE_STORAGE'):
            raise StorageConfigError("DEFAULT_FILE_STORAGE not configured in settings!")
            
        if not hasattr(settings, 'STORAGE_BACKEND'):
            raise StorageConfigError("STORAGE_BACKEND not configured in settings!")
            
        #logger.info("Verifying storage configuration...")
        #logger.info(f"Using storage backend: {settings.STORAGE_BACKEND}")
        #logger.info(f"DEFAULT_FILE_STORAGE: {settings.DEFAULT_FILE_STORAGE}")
        
        # Import and verify storage class
        try:
            storage_class = import_string(settings.DEFAULT_FILE_STORAGE)
            storage = storage_class()
            default_storage._wrapped = storage
        except Exception as e:
            logger.error(f"Storage initialization error: {str(e)}")
            raise StorageConfigError(f"Failed to initialize storage backend: {str(e)}")
        
        #logger.info(f"Storage class initialized: {storage.__class__.__name__}")
        
        # Verify storage is working with a test file
        test_path = f"_test_storage_{int(time.time())}.txt"
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                # Test write
                default_storage.save(test_path, ContentFile("test content"))
                #logger.info("Test file save successful")
                
                # Small delay to allow for eventual consistency
                time.sleep(1)
                
                # Verify file exists
                if not default_storage.exists(test_path):
                    raise StorageConfigError("Test file not found after save!")
                
                # Test read
                content = default_storage.open(test_path).read()
                if b"test content" not in content:
                    raise StorageConfigError("Test file content verification failed!")
                
                # Test delete and verify deletion
                default_storage.delete(test_path)
                time.sleep(1)  # Wait for deletion to propagate
                
                if default_storage.exists(test_path):
                    raise StorageConfigError("Test file still exists after deletion!")
                    
                #logger.info("Storage verification complete")
                
                # Success - exit the retry loop
                break
                
            except Exception as e:
                retry_count += 1
                if retry_count >= max_retries:
                    logger.error(f"Storage verification failed after {max_retries} attempts")
                    # Try to clean up before raising the error
                    try:
                        if default_storage.exists(test_path):
                            default_storage.delete(test_path)
                    except:
                        pass
                    raise StorageConfigError(f"Storage verification failed: {str(e)}")
                    
                logger.warning(f"Retry {retry_count}/{max_retries}: {str(e)}")
                # Try to clean up before retrying
                try:
                    if default_storage.exists(test_path):
                        default_storage.delete(test_path)
                except:
                    pass
                time.sleep(2)  # Wait before retrying
                
        # Final cleanup check
        self._cleanup_test_files()

================
File: core/asgi.py
================
import os
import django

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from core.routing import websocket_urlpatterns
from apps.organizations.middleware import OrganizationMiddlewareAsync

# Apply standard middleware chaining for WebSockets:
# 1. Auth middleware for authentication
# 2. Organization middleware for setting organization context
# 3. URL router for routing to appropriate consumer

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": AuthMiddlewareStack(
        OrganizationMiddlewareAsync(
            URLRouter(
                websocket_urlpatterns
            )
        )
    ),
})

================
File: core/b2_storage.py
================
from django.core.files.storage import Storage, default_storage
from django.conf import settings
from django.utils.deconstruct import deconstructible
from b2sdk.v2 import B2Api, InMemoryAccountInfo
from django.core.files.utils import validate_file_name
import logging
import os
from django.core.files.base import ContentFile
from io import BytesIO

logger = logging.getLogger('core.storage')

class B2ObjectsCollection:
    """Mimics S3's objects collection interface"""
    def __init__(self, bucket):
        self.bucket = bucket

    def filter(self, Prefix=''):
        """Mimics S3's filter method"""
        try:
            for file_version, _ in self.bucket.ls(folder_to_list=Prefix):
                yield B2Object(file_version)
        except Exception as e:
            logger.error(f"Error listing objects with prefix {Prefix}: {str(e)}")
            raise

class B2Object:
    """Mimics S3's Object interface"""
    def __init__(self, file_version):
        self.file_version = file_version
        self.key = file_version.file_name
        self.size = file_version.size

    def delete(self):
        """Mimics S3's delete method"""
        try:
            self.file_version.bucket.delete_file_version(
                self.file_version.id_,
                self.file_version.file_name
            )
        except Exception as e:
            logger.error(f"Error deleting object {self.key}: {str(e)}")
            raise

@deconstructible
class B2Storage(Storage):
    """
    Backblaze B2 Storage backend for Django with S3-compatible interface
    """
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            logger.info("Creating new B2Storage instance")
            cls._instance = super().__new__(cls)
            # Initialize here to ensure it happens only once
            cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if not getattr(self, '_initialized', False):
            logger.info("Initializing B2Storage backend")
            super().__init__()
            self._b2_api = None
            self._bucket = None
            self._objects = None
            self._initialize_b2()
            self._initialized = True
            logger.info("B2Storage backend initialization complete")
        else:
            logger.debug("Reusing existing B2Storage instance")

    def _initialize_b2(self):
        """Initialize B2 connection and bucket"""
        try:
            logger.debug("Starting B2 API initialization")
            logger.debug(f"Using credentials - Key ID: {settings.B2_APPLICATION_KEY_ID[:4]}..., Bucket: {settings.B2_BUCKET_NAME}")
            
            # Create API client
            self._b2_api = B2Api(InMemoryAccountInfo())
            
            # Authorize
            logger.debug("Authorizing with B2...")
            self._b2_api.authorize_account(
                "production",
                settings.B2_APPLICATION_KEY_ID,
                settings.B2_APPLICATION_KEY
            )
            logger.debug("B2 authorization successful")
            
            # Get bucket and verify access
            self._bucket = self._b2_api.get_bucket_by_name(settings.B2_BUCKET_NAME)
            logger.debug(f"Got bucket: {self._bucket.name}")
            
            # Test bucket access
            logger.debug("Testing bucket access...")
            test_file = "test_access.txt"
            test_data = b"Testing bucket access"
            try:
                # Try to upload
                self._bucket.upload_bytes(
                    data_bytes=test_data,
                    file_name=test_file
                )
                logger.debug("Test upload successful")
                
                # Try to download
                download = self._bucket.download_file_by_name(test_file)
                logger.debug("Test download successful")
                
                # Clean up
                file_version = self._bucket.get_file_info_by_name(test_file)
                self._bucket.delete_file_version(file_version.id_, test_file)
                logger.debug("Test cleanup successful")
                
            except Exception as e:
                logger.error(f"Bucket access test failed: {str(e)}", exc_info=True)
                raise
                
            self._objects = B2ObjectsCollection(self._bucket)
            logger.debug("B2 Storage initialization complete")
            
        except Exception as e:
            logger.error(f"B2 Storage initialization failed: {str(e)}", exc_info=True)
            raise RuntimeError(f"Failed to initialize B2 storage backend: {str(e)}") from e

    @property
    def bucket(self):
        """Accessor for B2 bucket with S3-compatible interface"""
        if not self._bucket:
            logger.warning("B2 bucket not initialized, reinitializing...")
            self._initialize_b2()
        return self

    @property
    def objects(self):
        """S3-compatible objects collection"""
        if not self._objects:
            self._initialize_b2()
        return self._objects

    def _save(self, name, content):
        """Save a file to B2"""
        try:
            logger.info(f"B2Storage._save called with name: {name}")
            if not self._bucket:
                logger.error("No bucket available!")
                self._initialize_b2()
                
            # Reset file pointer
            content.seek(0)
            
            # Read the content
            data = content.read()
            logger.info(f"Content type: {type(data)}, length: {len(data) if data else 0}")
            
            # If it's a string, encode it
            if isinstance(data, str):
                data = data.encode('utf-8')
                logger.info("Encoded string content to bytes")
            
            logger.info(f"Uploading to B2 with name: {name}")
            try:
                # Get upload URL and auth token
                upload_url = self._bucket.get_upload_url()
                logger.info(f"Got upload URL: {upload_url.upload_url}")
                
                # Upload the file
                file_info = self._bucket.upload_bytes(
                    data_bytes=data,
                    file_name=name,
                )
                
                # Verify the upload
                try:
                    verification = self._bucket.get_file_info_by_name(name)
                    logger.info(f"Verified file upload - ID: {verification.id_}, Size: {verification.size}")
                    if verification.size != len(data):
                        raise Exception(f"Upload size mismatch - Expected: {len(data)}, Got: {verification.size}")
                except Exception as e:
                    logger.error(f"Failed to verify upload: {str(e)}", exc_info=True)
                    raise
                    
                logger.info(f"B2 upload_bytes completed and verified successfully")
                return name
                
            except Exception as e:
                logger.error(f"B2 upload_bytes failed: {str(e)}", exc_info=True)
                # Try to get more details about the error
                if hasattr(e, 'response'):
                    logger.error(f"B2 API Response: {e.response.text if hasattr(e.response, 'text') else str(e.response)}")
                raise
            
        except Exception as e:
            logger.error(f"Failed to save file to B2: {str(e)}", exc_info=True)
            raise

    def _open(self, name, mode='rb'):
        """Retrieve a file from B2"""
        try:
            output = BytesIO()
            self._bucket.download_file_by_name(name).save(output)
            output.seek(0)
            content = output.getvalue()
            
            # If in text mode and content is bytes, decode it
            if 'b' not in mode and isinstance(content, bytes):
                content = content.decode('utf-8')
            
            return ContentFile(content)
        except Exception as e:
            logger.error(f"Failed to retrieve file from B2: {str(e)}", exc_info=True)
            raise

    def exists(self, name):
        """Check if a file exists in B2"""
        try:
            # Force a fresh check from B2
            self._bucket.get_file_info_by_name(name, force_fresh=True)
            return True
        except:
            return False

    def delete(self, name):
        """Delete a file from B2"""
        try:
            file_version = self._bucket.get_file_info_by_name(name)
            self._bucket.delete_file_version(file_version.id_, name)
        except Exception as e:
            logger.error(f"Failed to delete file from B2: {str(e)}")
            raise

    def url(self, name):
        """Get the URL for a file"""
        try:
            return self._bucket.get_download_url(name)
        except Exception as e:
            logger.error(f"Failed to get URL for file: {str(e)}")
            raise

    def size(self, name):
        """Get the size of a file"""
        try:
            file_info = self._bucket.get_file_info_by_name(name)
            return file_info.size
        except Exception as e:
            logger.error(f"Failed to get file size: {str(e)}")
            raise

    def __str__(self):
        return f"B2Storage(bucket={settings.B2_BUCKET_NAME})"

    def __repr__(self):
        return self.__str__()

    def get_modified_time(self, name):
        """
        Get the last modified time of a file
        """
        try:
            file_info = self._bucket.get_file_info_by_name(name)
            return file_info.upload_timestamp
        except Exception as e:
            logger.error(f"Failed to get modified time: {str(e)}")
            raise

    def get_accessed_time(self, name):
        """
        Get the last accessed time of a file
        """
        return self.get_modified_time(name)

    def get_created_time(self, name):
        """
        Get the creation time of a file
        """
        return self.get_modified_time(name)

    def listdir(self, path):
        """
        List the contents of a directory
        """
        try:
            directories = set()
            files = []
            
            for file_version, _ in self._bucket.ls(folder_to_list=path):
                name = file_version.file_name
                relative_name = name[len(path):].lstrip('/')
                
                if not relative_name:
                    continue
                    
                parts = relative_name.split('/', 1)
                
                if len(parts) > 1:
                    # This is a file in a subdirectory
                    directories.add(parts[0])
                else:
                    # This is a file in the current directory
                    files.append(parts[0])
                    
            return list(sorted(directories)), sorted(files)
        except Exception as e:
            logger.error(f"Failed to list directory: {str(e)}")
            raise

    def get_valid_name(self, name):
        """
        Returns a filename suitable for use with the underlying storage system.
        """
        return validate_file_name(name)

    def get_available_name(self, name, max_length=None):
        """
        Returns a filename that's free on the target storage system.
        """
        dir_name, file_name = os.path.split(name)
        file_root, file_ext = os.path.splitext(file_name)
        
        while self.exists(name):
            # If the filename already exists, add an underscore and a random character
            file_root = f"{file_root}_{os.urandom(2).hex()}"
            name = os.path.join(dir_name, f"{file_root}{file_ext}")
            if max_length and len(name) > max_length:
                raise ValueError("Max length exceeded")
        
        return name

def initialize_storage():
    """Initialize the default storage with B2Storage"""
    logger.info("Initializing default storage with B2Storage")
    try:
        if not isinstance(default_storage._wrapped, B2Storage):
            storage = B2Storage()
            default_storage._wrapped = storage
            logger.info("Successfully initialized default storage with B2Storage")
        else:
            logger.info("Default storage is already B2Storage")
    except Exception as e:
        logger.error(f"Failed to initialize default storage: {str(e)}", exc_info=True)
        raise

================
File: core/context_processors.py
================
from django.conf import settings

def version_context(request):
    return {'VERSION': settings.VERSION}

================
File: core/minio_storage.py
================
"""
Custom MinIO storage backend that addresses 403 errors with head_object operations.

This module provides a storage class that fixes issues with MinIO rejecting
head_object operations for certain file types while still allowing get_object
and list_objects operations.
"""

import logging
from storages.backends.s3boto3 import S3Boto3Storage
from botocore.exceptions import ClientError
from django.core.files.base import ContentFile

logger = logging.getLogger('core.storage')

class MinIOStorage(S3Boto3Storage):
    """
    MinIO-specific S3Boto3Storage backend that properly handles 403 errors
    with head_object operations on certain file types.
    """
    
    def exists(self, name):
        """
        Override the exists method to handle 403 Forbidden errors when checking
        file existence by trying alternative approaches (list_objects).
        
        Args:
            name: The file path to check
            
        Returns:
            Boolean indicating if file exists
        """
        try:
            # Try standard approach first (uses head_object)
            return super().exists(name)
        except ClientError as e:
            # Check if this is a 403 error
            if getattr(e, 'response', {}).get('Error', {}).get('Code') == '403':
                logger.warning(f"Got 403 when checking if file exists, trying list_objects: {name}")
                
                try:
                    # Use list_objects_v2 to check if file exists
                    # This works because our test showed list_objects succeeds even for image files
                    paginator = self.connection.meta.client.get_paginator('list_objects_v2')
                    
                    # Handle directory structure in the path
                    prefix = name
                    for page in paginator.paginate(Bucket=self.bucket_name, Prefix=prefix):
                        for obj in page.get('Contents', []):
                            if obj['Key'] == name:
                                logger.info(f"File exists (confirmed via list_objects): {name}")
                                return True
                    
                    return False
                except Exception as alt_error:
                    logger.error(f"Alternative file existence check failed: {str(alt_error)}")
                    return False
            
            # For any other error, log it and assume file doesn't exist
            logger.error(f"Error checking if file exists: {name}, error: {str(e)}")
            return False
            
    def _open(self, name, mode='rb'):
        """
        Override the _open method to handle 403 Forbidden errors by using get_object
        directly instead of S3File which uses head_object that can fail with 403.
        
        Args:
            name: The file path to open
            mode: File open mode (ignored for S3)
            
        Returns:
            A Django file-like object
        """
        try:
            # Try standard approach first
            return super()._open(name, mode)
        except ClientError as e:
            # Check if this is a 403 error
            if getattr(e, 'response', {}).get('Error', {}).get('Code') == '403':
                logger.warning(f"Got 403 when opening file, trying direct get_object: {name}")
                
                try:
                    # Use get_object directly instead of the boto3 resource
                    response = self.connection.meta.client.get_object(
                        Bucket=self.bucket_name, 
                        Key=name
                    )
                    
                    content = response['Body'].read()
                    file_obj = ContentFile(content)
                    file_obj.name = name
                    
                    logger.info(f"Successfully opened file using direct get_object: {name}")
                    return file_obj
                except Exception as alt_error:
                    logger.error(f"Alternative open method failed: {str(alt_error)}")
                    raise
            
            # Re-raise the original error
            raise

    def size(self, name):
        """
        Override the size method to handle 403 Forbidden errors by attempting
        to get object metadata directly if head_object fails.

        Args:
            name: The file path to check size for

        Returns:
            Integer file size in bytes
        """
        try:
            # Try standard approach first (uses head_object via resource)
            return super().size(name)
        except ClientError as e:
            # Check if this is a 403 error
            if getattr(e, 'response', {}).get('Error', {}).get('Code') == '403':
                logger.warning(f"Got 403 when getting size (head_object), trying direct get_object metadata: {name}")
                
                try:
                    # Use head_object directly via client, which might have different permissions or behavior
                    # Or alternatively, use get_object and check ContentLength, though less efficient
                    metadata = self.connection.meta.client.head_object(
                        Bucket=self.bucket_name,
                        Key=name
                    )
                    size = metadata.get('ContentLength', 0)
                    if size > 0:
                         logger.info(f"Successfully got size using direct head_object: {name}, size: {size}")
                         return size
                    else:
                         # Fallback if direct head_object doesn't work or returns 0 size incorrectly
                         logger.warning(f"Direct head_object did not return size for {name}, trying get_object (less efficient).")
                         response = self.connection.meta.client.get_object(
                            Bucket=self.bucket_name,
                            Key=name
                         )
                         size = response.get('ContentLength', 0)
                         logger.info(f"Successfully got size using direct get_object: {name}, size: {size}")
                         return size

                except Exception as alt_error:
                    logger.error(f"Alternative size check method failed for {name}: {str(alt_error)}")
                    # If fallback fails, raise the original error or return 0/raise specific exception
                    raise alt_error # Or return 0, depending on desired behavior for size check failure
            
            # Re-raise the original error if it's not 403
            raise

================
File: core/routing.py
================
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.auth import AuthMiddlewareStack
from django.urls import re_path
from apps.agents.kanban_consumers import CrewKanbanConsumer
from apps.agents.consumers import ConnectionTestConsumer, CrewExecutionConsumer
from apps.agents.websockets import ChatConsumer
from apps.seo_audit.consumers import SEOAuditConsumer
from apps.image_optimizer.consumers import OptimizationConsumer
from apps.research.websockets.research_consumer import ResearchConsumer
from apps.seo_manager.consumers import MetaTagsTaskConsumer
# Import crawl website routes
from apps.crawl_website.routing import websocket_urlpatterns as crawl_websocket_urlpatterns

websocket_urlpatterns = [
    re_path(r'ws/connection_test/$', ConnectionTestConsumer.as_asgi()),
    re_path(r'ws/crew_execution/(?P<execution_id>\w+)/$', CrewExecutionConsumer.as_asgi()),
    re_path(r'ws/chat/(?P<session>[^/]+)?/?$', ChatConsumer.as_asgi()),
    re_path(r'ws/crew/(?P<crew_id>\w+)/kanban/$', CrewKanbanConsumer.as_asgi()),
    re_path(r'ws/seo_audit/(?P<audit_id>\d+)/$', SEOAuditConsumer.as_asgi()),
    re_path(r'ws/image-optimizer/(?P<optimization_id>\d+)/$', OptimizationConsumer.as_asgi()),
    re_path(r'ws/research/(?P<research_id>\d+)/$', ResearchConsumer.as_asgi()),
    re_path(r'ws/meta-tags/task/(?P<task_id>[\w-]+)/$', MetaTagsTaskConsumer.as_asgi()),
]

# Append crawl website routes
websocket_urlpatterns += crawl_websocket_urlpatterns

application = ProtocolTypeRouter({
    "websocket": AuthMiddlewareStack(
        URLRouter(websocket_urlpatterns)
    ),
})

================
File: core/settings.py
================
"""
Django settings for core project.

Generated by 'django-admin startproject' using Django 4.2.9.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.2/ref/settings/
"""

from pathlib import Path
from django.utils.translation import gettext_lazy as _
from django.contrib import messages
from dotenv import load_dotenv
from str2bool       import str2bool
import os, random, string, sys
import logging
from botocore.config import Config
import mimetypes
import json
import warnings
import colorlog

# Suppress specific Django warning about StreamingHttpResponse
warnings.filterwarnings(
    "ignore",
    message="StreamingHttpResponse must consume synchronous iterators in order to serve them asynchronously.",
    module="django.http.response"
)

# Add this near the top of the file, after the imports
mimetypes.add_type("application/javascript", ".js", True)
mimetypes.add_type("text/javascript", ".js", True)

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
ENV_FILE = BASE_DIR / '.env'
load_dotenv(dotenv_path=ENV_FILE)

# Detect if running in Docker
IS_DOCKER = str2bool(os.getenv('IS_DOCKER', 'False'))
LOG_DIR = os.path.join(BASE_DIR, 'logs') if not IS_DOCKER else None

# Create logs directory if we're not in Docker
if not IS_DOCKER and not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv('SECRET_KEY')
if not SECRET_KEY:
    SECRET_KEY = ''.join(random.choice( string.ascii_lowercase  ) for i in range( 32 ))

# Enable/Disable DEBUG Mode
DEBUG = str2bool(os.getenv('DEBUG'))

# Add localhost to ALLOWED_HOSTS for Docker health checks
APP_DOMAIN = os.getenv('APP_DOMAIN', '')
ALLOWED_HOSTS =  [domain.strip() for domain in APP_DOMAIN.split(',') if domain.strip()]
ALLOWED_HOSTS.extend(['localhost', '127.0.0.1','localhost:3010'])

# Used by DEBUG-Toolbar
INTERNAL_IPS = [
    "127.0.0.1",
]

# Add here your deployment HOSTS
CSRF_TRUSTED_ORIGINS = [f'https://{domain}' for domain in os.getenv('APP_DOMAIN', '').split(',')]
CSRF_TRUSTED_ORIGINS.extend([f'http://{domain}' for domain in os.getenv('APP_DOMAIN', '').split(',')])


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'core.apps.CoreConfig',
    'django_celery_results',
    'debug_toolbar',
    'django_quill',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.github',

    'rest_framework',
    'rest_framework.authtoken',
    'drf_spectacular',
    'django_api_gen',
    'channels',

    'home',
    'apps.api',
    'apps.common.apps.CommonConfig',
    'apps.file_manager',
    'apps.tasks',
    'apps.users',
    'apps.seo_manager.apps.SeoManagerConfig',
    'apps.crawl_website.apps.CrawlWebsiteConfig',
    'apps.agents.apps.AgentsConfig',
    'apps.seo_audit.apps.SEOAuditConfig',
    'apps.image_optimizer.apps.ImageOptimizerConfig',
    'storages',
    'apps.research.apps.ResearchConfig',
    'apps.utilities.apps.UtilitiesConfig',
    'apps.organizations.apps.OrganizationsConfig',
    'apps.summarizer.apps.SummarizerConfig',
]

SITE_ID = 1

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    "whitenoise.middleware.WhiteNoiseMiddleware",
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.locale.LocaleMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'apps.organizations.middleware.OrganizationMiddleware',
    'apps.organizations.middleware.OrganizationSecurityMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    # Required for allauth
    'allauth.account.middleware.AccountMiddleware',
    # Required for debug toolbar
    'debug_toolbar.middleware.DebugToolbarMiddleware',
    'apps.seo_manager.middleware.GoogleAuthMiddleware',
]

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'templates',
            BASE_DIR / 'apps' / 'seo_manager' / 'templates',
            BASE_DIR / 'apps' / 'seo_audit' / 'templates',
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'core.context_processors.version_context',
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'
ASGI_APPLICATION = 'core.asgi.application'

CHANNEL_LAYERS = {
    'default': {
        'BACKEND': 'channels_redis.core.RedisChannelLayer',
        'CONFIG': {
            "hosts": [(os.getenv('REDIS_HOST', 'redis'), 6379)],
            # Increased expiry to handle long crawl operations with 10s delays
            "capacity": 1000,  # Channel capacity
            "expiry": 600,  # Set to 10 minutes - sufficient for most crawls
            # Cloudflare has 100s timeout, but we need longer for crawl operations
            "group_expiry": 600,  # Should match expiry
            # Channel specific configuration
            "channel_capacity": {
                # Default channel capacity
                "http.request": 100,
                "http.response!*": 100,
                "websocket.send!*": 100,
            },
        },
    },
}


# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/#databases

DB_ENGINE   = os.getenv('DB_ENGINE')
DB_USERNAME = os.getenv('DB_USERNAME')
DB_PASS     = os.getenv('DB_PASS')
DB_HOST     = os.getenv('DB_HOST')
DB_PORT     = os.getenv('DB_PORT')
DB_NAME     = os.getenv('DB_NAME')

if DB_ENGINE and DB_NAME and DB_USERNAME:
    DATABASES = {
      'default': {
        'ENGINE'  : 'django.db.backends.' + DB_ENGINE,
        'NAME'    : DB_NAME,
        'USER'    : DB_USERNAME,
        'PASSWORD': DB_PASS,
        'HOST'    : DB_HOST,
        'PORT'    : DB_PORT,
        },
    }
else:
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': 'db.sqlite3',
        }
    }
# LiteLLM Logs Database
LITELLM_DB_ENGINE   = os.getenv('LITELLM_DB_ENGINE')
LITELLM_DB_NAME     = os.getenv('LITELLM_DB_NAME')
LITELLM_DB_USERNAME = os.getenv('LITELLM_DB_USERNAME')
LITELLM_DB_PASS     = os.getenv('LITELLM_DB_PASS')
LITELLM_DB_HOST     = os.getenv('LITELLM_DB_HOST')
LITELLM_DB_PORT     = os.getenv('LITELLM_DB_PORT')

# Add litellm_logs database if credentials are provided
if LITELLM_DB_NAME and LITELLM_DB_USERNAME:
    DATABASES['litellm_logs'] = {
        'ENGINE'  : 'django.db.backends.' + LITELLM_DB_ENGINE,
        'NAME'    : LITELLM_DB_NAME,
        'USER'    : LITELLM_DB_USERNAME,
        'PASSWORD': LITELLM_DB_PASS,
        'HOST'    : LITELLM_DB_HOST,
        'PORT'    : LITELLM_DB_PORT,
    }
STAGING_DB_ENGINE = os.getenv('STAGING_DB_ENGINE', 'postgresql')
STAGING_DB_NAME = os.getenv('STAGING_DB_NAME')
STAGING_DB_USERNAME = os.getenv('STAGING_DB_USERNAME')
STAGING_DB_PASS = os.getenv('STAGING_DB_PASS')
STAGING_DB_HOST = os.getenv('STAGING_DB_HOST')
STAGING_DB_PORT = os.getenv('STAGING_DB_PORT', '5432')

if STAGING_DB_NAME and STAGING_DB_USERNAME:
  DATABASES['staging'] = {
      'ENGINE'  : 'django.db.backends.' + STAGING_DB_ENGINE,
      'NAME'    : STAGING_DB_NAME,
      'USER'    : STAGING_DB_USERNAME,
      'PASSWORD': STAGING_DB_PASS,
      'HOST'    : STAGING_DB_HOST,
      'PORT'    : STAGING_DB_PORT,
  }
# Password validation
# https://docs.djangoproject.com/en/4.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.2/topics/i18n/

LANGUAGES = [
    ('en', _('English (US)')),
    ('de', _('Deutsch')),
    ('it', _('Italiano')),
]

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'America/New_York'

USE_I18N = True

USE_TZ = True

LOCALE_PATHS = [
    os.path.join(BASE_DIR, 'locale'),
]

# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

STATICFILES_DIRS = [
    os.path.join(BASE_DIR,'static'),
    os.path.join(BASE_DIR, "apps/agents/static"),
    os.path.join(BASE_DIR, "apps/seo_manager/static"),
    os.path.join(BASE_DIR, "apps/seo_audit/static"),
    os.path.join(BASE_DIR, "apps/common/static"),
    os.path.join(BASE_DIR, "apps/image_optimizer/static"),
]

# Determine log level and handlers based on IS_DOCKER
APP_LOG_LEVEL = 'DEBUG' if not IS_DOCKER else 'INFO'
APP_LOG_HANDLERS = ['console', 'file'] if not IS_DOCKER else ['console']

# Logging configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'exclude_get_requests': {
            '()': 'django.utils.log.CallbackFilter',
            'callback': lambda record: not (hasattr(record, 'request') and getattr(record, 'request').method == 'GET')
        },
    },
    'formatters': {
        'colored': {
            '()': 'colorlog.ColoredFormatter',
            'format': '%(log_color)s[%(asctime)s] %(name)s [%(levelname)s] %(module)s.%(funcName)s: %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S',
            'log_colors': {
                'DEBUG': 'cyan',
                'INFO': 'green',
                'WARNING': 'yellow',
                'ERROR': 'red',
                'CRITICAL': 'red,bg_white',
            },
            'reset': True,  # Ensure color codes are properly reset
        },
        'verbose': {
            'format': '[%(asctime)s] %(name)s [%(levelname)s] %(module)s.%(funcName)s: %(message)s',
            'datefmt': '%Y-%m-%d %H:%M:%S'
        }
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'colored',
            'filters': ['exclude_get_requests'],
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(LOG_DIR, 'django.log') if not IS_DOCKER else '/dev/null',
            'formatter': 'verbose',
            'filters': ['exclude_get_requests'],
        }
    },
    'loggers': {
        'django': {
            'handlers': APP_LOG_HANDLERS,
            'level': 'INFO', # Keep Django logs at INFO generally
            'propagate': False,
        },
        'django.server': {
            'handlers': APP_LOG_HANDLERS,
            'level': 'INFO',
            'propagate': False,
            'filters': ['exclude_get_requests'],
        },
        'apps': { # Logger for your applications
            'handlers': APP_LOG_HANDLERS,
            'level': APP_LOG_LEVEL, # Use conditional level
            'propagate': False,
        },
        'core': { # Added logger for core
            'handlers': APP_LOG_HANDLERS,
            'level': APP_LOG_LEVEL,
            'propagate': False,
        },
        'home': { # Added logger for home
            'handlers': APP_LOG_HANDLERS,
            'level': APP_LOG_LEVEL,
            'propagate': False,
        },
        'celery': {
            'handlers': APP_LOG_HANDLERS,
            'level': 'INFO', # Keep Celery logs at INFO generally
            'propagate': False,
        },
        '': { # Root logger
            'handlers': APP_LOG_HANDLERS,
            'level': 'INFO', # Root logger level remains INFO
            'propagate': True,
        }
    }
}

logger = logging.getLogger(__name__)

logger.warning(f"ENV_FILE: {ENV_FILE}")

# Storage Configuration
STORAGE_BACKEND = os.getenv('STORAGE_BACKEND', '')  # Options: 'B2', 'GCS', 'S3', 'AZURE', 'MINIO'

if STORAGE_BACKEND == 'B2':
    DEFAULT_FILE_STORAGE = 'core.storage.B2Storage'
    B2_APPLICATION_KEY_ID = os.environ['B2_APPLICATION_KEY_ID']
    B2_APPLICATION_KEY = os.environ['B2_APPLICATION_KEY']
    B2_BUCKET_NAME = os.environ['B2_BUCKET_NAME']
    logger.info(f"Using B2 Storage with bucket: {B2_BUCKET_NAME}")

elif STORAGE_BACKEND == 'GCS':
    DEFAULT_FILE_STORAGE = 'storages.backends.gcloud.GoogleCloudStorage'
    GS_BUCKET_NAME = os.environ['GS_BUCKET_NAME']
    GS_CREDENTIALS = os.environ.get('GOOGLE_APPLICATION_CREDENTIALS')
    GS_PROJECT_ID = os.environ.get('GS_PROJECT_ID')
    logger.info(f"Using Google Cloud Storage with bucket: {GS_BUCKET_NAME}")

elif STORAGE_BACKEND == 'S3':
    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
    AWS_ACCESS_KEY_ID = os.environ['AWS_ACCESS_KEY_ID']
    AWS_SECRET_ACCESS_KEY = os.environ['AWS_SECRET_ACCESS_KEY']
    AWS_STORAGE_BUCKET_NAME = os.environ['AWS_STORAGE_BUCKET_NAME']
    AWS_S3_REGION_NAME = os.environ.get('AWS_S3_REGION_NAME', 'us-east-1')
    AWS_S3_CUSTOM_DOMAIN = os.environ.get('AWS_S3_CUSTOM_DOMAIN')
    AWS_S3_OBJECT_PARAMETERS = {'CacheControl': 'max-age=86400'}
    logger.info(f"Using AWS S3 Storage with bucket: {AWS_STORAGE_BUCKET_NAME}")

elif STORAGE_BACKEND == 'AZURE':
    DEFAULT_FILE_STORAGE = 'storages.backends.azure_storage.AzureStorage'
    AZURE_ACCOUNT_NAME = os.environ['AZURE_ACCOUNT_NAME']
    AZURE_ACCOUNT_KEY = os.environ['AZURE_ACCOUNT_KEY']
    AZURE_CONTAINER = os.environ['AZURE_CONTAINER']
    AZURE_SSL = True
    logger.info(f"Using Azure Storage with container: {AZURE_CONTAINER}")

elif STORAGE_BACKEND == 'MINIO':
    DEFAULT_FILE_STORAGE = 'core.minio_storage.MinIOStorage'
    AWS_ACCESS_KEY_ID = os.environ['MINIO_ACCESS_KEY']
    AWS_SECRET_ACCESS_KEY = os.environ['MINIO_SECRET_KEY']
    AWS_STORAGE_BUCKET_NAME = os.environ['MINIO_BUCKET_NAME']
    AWS_S3_ENDPOINT_URL = os.environ['MINIO_ENDPOINT']
    AWS_S3_USE_SSL = str2bool(os.getenv('MINIO_USE_SSL', 'True'))
    AWS_S3_VERIFY = str2bool(os.getenv('MINIO_VERIFY_SSL', 'True'))
    AWS_S3_MAX_POOL_CONNECTIONS = int(os.getenv('MINIO_MAX_CONNECTIONS', '30'))

    # Add these settings for MinIO compatibility
    AWS_S3_ADDRESSING_STYLE = 'path'
    AWS_S3_SIGNATURE_VERSION = 's3v4'
    AWS_S3_FILE_OVERWRITE = False
    AWS_QUERYSTRING_AUTH = False
    AWS_DEFAULT_ACL = None

    # Configure boto3 to use these settings
    AWS_S3_CONFIG = Config(
        s3={'addressing_style': 'path'},
        signature_version='s3v4',
        retries={'max_attempts': 3},
        max_pool_connections=AWS_S3_MAX_POOL_CONNECTIONS
    )

    logger.info(f"Using MinIO Storage with bucket: {AWS_STORAGE_BUCKET_NAME} at {AWS_S3_ENDPOINT_URL}")

else:
    raise ValueError(f"Invalid STORAGE_BACKEND: {STORAGE_BACKEND}")

STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'

# Media Configuration
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
# https://docs.djangoproject.com/en/4.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


LOGIN_REDIRECT_URL = '/'
LOGIN_URL = '/accounts/login/illustration-login/'

# AllAuth
ACCOUNT_EMAIL_VERIFICATION =  os.getenv('ACCOUNT_EMAIL_VERIFICATION', 'none')
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_AUTHENTICATION_METHOD = 'email'
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_CONFIRM_EMAIL_ON_GET = True
ACCOUNT_LOGIN_ON_EMAIL_CONFIRMATION = True
ACCOUNT_UNIQUE_EMAIL = True

AUTHENTICATION_BACKENDS = [
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
]

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'APP':{
            'client_id': os.getenv('GOOGLE_CLIENT_ID', default=""),
            'secret': os.getenv('GOOGLE_SECRET_KEY', default=""),
        },
        'SCOPE': [
            'profile',
            'email',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        }
    },
    'github': {
        'APP':{
            'client_id': os.getenv('GITHUB_CLINET_ID', default=""),
            'secret': os.getenv('GITHUB_SECRET_KEY', default=""),
        }
    }
}

GOOGLE_CLIENT_SECRETS_FILE = os.getenv('GOOGLE_CLIENT_SECRETS_FILE')
GOOGLE_OAUTH_REDIRECT_URI = os.getenv('GOOGLE_OAUTH_REDIRECT_URI', 'http://localhost:8000/seo/google/oauth/callback/')
SERVICE_ACCOUNT_FILE = os.getenv('SERVICE_ACCOUNT_FILE', default="/secrets/service-account.json")
# ### Async Tasks (Celery) Settings ###

CELERY_SCRIPTS_DIR        = os.path.join(BASE_DIR, "tasks_scripts" )

CELERY_LOGS_URL           = "/tasks_logs/"
CELERY_LOGS_DIR           = os.path.join(BASE_DIR, "tasks_logs"    )

CELERY_BROKER_URL         = os.getenv('CELERY_BROKER', 'redis://redis:6379')
#CELERY_RESULT_BACKEND     = os.environ.get("CELERY_BROKER", "redis://redis:6379")

CELERY_TASK_TRACK_STARTED = True
CELERY_TASK_TIME_LIMIT    = 8 * 60 * 60  # 8 hours
CELERY_TASK_SOFT_TIME_LIMIT = 7 * 60 * 60  # 7 hours - gives time for graceful shutdown
CELERY_CACHE_BACKEND      = "django-cache"
CELERY_RESULT_BACKEND     = "django-db"
CELERY_RESULT_EXTENDED    = True
CELERY_RESULT_EXPIRES     = 60*60*24*30 # Results expire after 1 month
CELERY_ACCEPT_CONTENT     = ["json"]
CELERY_TASK_SERIALIZER    = 'json'
CELERY_RESULT_SERIALIZER  = 'json'
########################################

X_FRAME_OPTIONS = 'SAMEORIGIN'

# ### API-GENERATOR Settings ###
API_GENERATOR = {
    'agents'   : "apps.agents.models.Agent",
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
    'DEFAULT_THROTTLE_RATES': {
        'user': '10000/day',    # Default user rate
        'anon': '10/day',     # Default anonymous rate
    },
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ],
}
########################################

MESSAGE_TAGS = {
    messages.DEBUG: 'alert-info',
    messages.INFO: 'alert-info',
    messages.SUCCESS: 'alert-success',
    messages.WARNING: 'alert-warning',
    messages.ERROR: 'alert-danger',
}

ACCOUNT_DEFAULT_HTTP_PROTOCOL = 'https'
DEFAULT_HTTP_PROTOCOL='https'
HTTPS=True
USE_X_FORWARDED_HOST = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
NEURALAMI_API_TOKEN = os.getenv('NEURALAMI_API_TOKEN')
API_BASE_URL = os.getenv('API_BASE_URL')
LITELLM_MASTER_KEY= os.getenv('LITELLM_MASTER_KEY')
SERPAPI_API_KEY=os.getenv('SERPAPI_API_KEY')
OPENAI_BASE_URL=os.getenv('API_BASE_URL')
ALPHA_VANTAGE_API_KEY=os.getenv('ALPHA_VANTAGE_API_KEY')
DATAFORSEO_EMAIL = os.getenv('DATAFORSEO_EMAIL')
DATAFORSEO_PASSWORD = os.getenv('DATAFORSEO_PASSWORD')
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
GOOGLE_ADS_DEVELOPER_TOKEN=os.getenv('GOOGLE_ADS_DEVELOPER_TOKEN')
PERPLEXITYAI_API_KEY = os.getenv('PERPLEXITYAI_API_KEY')
OPENAI_API_KEY = os.getenv('LITELLM_MASTER_KEY')

GENERAL_MODEL=os.getenv('GENERAL_MODEL')
TEXT_MODEL=os.getenv('TEXT_MODEL')
CODING_MODEL=os.getenv('CODING_MODEL')
SUMMARIZER=os.getenv('SUMMARIZER')
SUMMARIZER_MAX_TOKENS=(os.getenv('SUMMARIZER_MAX_TOKENS'))
BUSINESS_CREDIBILITY_MODEL=os.getenv('BUSINESS_CREDIBILITY_MODEL')

CRAWL4AI_URL=os.getenv('CRAWL4AI_URL')
CRAWL4AI_API_KEY=os.getenv('CRAWL4AI_API_KEY')
CRAWL4AI_TIMEOUT = 300  # 5 minutes
CRAWL4AI_CRAWLER_PARAMS = json.loads(os.getenv('CRAWL4AI_CRAWLER_PARAMS', '{}'))
CRAWL4AI_EXTRA_PARAMS = {
    "word_count_threshold": 10,
    "only_text": True,
    "bypass_cache": False,
    "process_iframes": True,
    "excluded_tags": ['nav', 'aside', 'footer'],
    "exclude_external_links": True,
    "exclude_social_media_links": True
}


PLAYWRIGHT_API_URL=os.getenv('PLAYWRIGHT_API_URL')
PLAYWRIGHT_API_KEY=os.getenv('PLAYWRIGHT_API_KEY')
FIRECRAWL_URL=os.getenv('FIRECRAWL_URL')
FIRECRAWL_API_KEY=os.getenv('FIRECRAWL_API_KEY')
EMAIL_ADDRESS = os.getenv('EMAIL_ADDRESS')
COMPANY_NAME = os.getenv('COMPANY_NAME')

BROWSERLESS_API_KEY=os.getenv('BROWSERLESS_API_KEY')
BROWSERLESS_BASE_URL=os.getenv('BROWSERLESS_BASE_URL')
DOWNLOAD_FOLDER = os.getenv('DOWNLOAD_FOLDER')
CREWAI_DISABLE_LITELLM=os.getenv('CREWAI_DISABLE_LITELLM')

# Slack Integration Settings
DSLACK_BOT_TOKEN = os.getenv('DSLACK_BOT_TOKEN')
DSLACK_APP_TOKEN = os.getenv('DSLACK_APP_TOKEN')
DSLACK_CLIENT_ID = os.getenv('DSLACK_CLIENT_ID')
DSLACK_CLIENT_SECRET = os.getenv('DSLACK_CLIENT_SECRET')
SLACK_NOTIFICATION_CHANNEL = os.getenv('SLACK_NOTIFICATION_CHANNEL', '#bot-notifications')
PAGESPEED_API_KEY = os.getenv('PAGESPEED_API_KEY')
SCRAPPER_HOST=os.getenv('SCRAPPER_HOST')


# Make sure storages is in INSTALLED_APPS
if 'storages' not in INSTALLED_APPS:
    INSTALLED_APPS.append('storages')

# File storage settings
STORAGES = {
    "default": {
        "BACKEND": DEFAULT_FILE_STORAGE,
        "OPTIONS": {
            "bucket_name": os.getenv('AWS_STORAGE_BUCKET_NAME') or os.getenv('GS_BUCKET_NAME') or os.getenv('AZURE_CONTAINER') or os.getenv('MINIO_BUCKET_NAME'),
            "default_acl": None,
            "file_overwrite": False,
        },
    },
    "staticfiles": {
        "BACKEND": "django.contrib.staticfiles.storage.StaticFilesStorage",  # Use local storage for static files
    },
}

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': os.environ.get("CELERY_BROKER", "redis://redis:6379/0"),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    }
}

# Add this to silence the URLField warning and use https as default scheme
FORMS_URLFIELD_ASSUME_HTTPS = True

# Add this to your settings.py
#VERSION = '1.0.0'  # You'd update this manually when releasing

try:
    from core.version import VERSION, COMMIT
except ImportError:
    VERSION = '0.0.0'
    COMMIT = 'dev'

================
File: core/storage.py
================
import os
from django.core.files.storage import Storage, default_storage
from django.utils.deconstruct import deconstructible
from django.conf import settings
from django.urls import reverse
from django.utils.module_loading import import_string
import logging

logger = logging.getLogger('core.storage')

# Only import B2 if it's being used
if settings.STORAGE_BACKEND == 'B2':
    from b2sdk.v2 import B2Api, InMemoryAccountInfo

# Import django-storages backends
if settings.STORAGE_BACKEND in ['S3', 'MINIO']:
    from storages.backends.s3boto3 import S3Boto3Storage
elif settings.STORAGE_BACKEND == 'GCS':
    from storages.backends.gcloud import GoogleCloudStorage
elif settings.STORAGE_BACKEND == 'AZURE':
    from storages.backends.azure_storage import AzureStorage

@deconstructible
class BaseStorage(Storage):
    """Base storage class with common functionality"""
    def get_valid_name(self, name):
        """Returns a filename suitable for use with the storage system."""
        return name.replace('\\', '/')

    def get_available_name(self, name, max_length=None):
        """Returns a filename that's free on the target storage system."""
        dir_name, file_name = os.path.split(name)
        file_root, file_ext = os.path.splitext(file_name)
        
        counter = 0
        while self.exists(name):
            counter += 1
            name = os.path.join(dir_name, f"{file_root}_{counter}{file_ext}")
            if max_length and len(name) > max_length:
                raise ValueError("Max length exceeded")
        
        return name

@deconstructible
class B2Storage(Storage):
    """Backblaze B2 Storage backend"""
    def __init__(self):
        super().__init__()
        self._api = B2Api(InMemoryAccountInfo())
        self._api.authorize_account("production", 
                                  settings.B2_APPLICATION_KEY_ID,
                                  settings.B2_APPLICATION_KEY)
        self._bucket = self._api.get_bucket_by_name(settings.B2_BUCKET_NAME)

    def _save(self, name, content):
        content.seek(0)
        self._bucket.upload_bytes(content.read(), name)
        return name

    def _open(self, name, mode='rb'):
        file_data = self._bucket.download_file_by_name(name)
        return file_data.get_content()

@deconstructible
class SecureFileStorage(Storage):
    """
    A secure file storage implementation that handles private files by routing 
    access through Django views with permission checks.
    
    This class provides a wrapping interface that can use any of the supported 
    storage backends while ensuring secure access to files.
    """
    def __init__(self, private=True, collection='default'):
        """
        Initialize the secure storage.
        
        Args:
            private (bool): Whether files should be served via Django views (True) or 
                          direct from storage (False)
            collection (str): A logical grouping for the files (e.g., 'logos', 'avatars')
        """
        self.private = private
        self.collection = collection
        
        # Get the actual storage backend from Django's default_storage
        self.storage = default_storage
        #logger.debug(f"SecureFileStorage initialized with backend: {self.storage.__class__.__name__}")
        
    def _get_path(self, name):
        """
        Get the normalized path, prefixed with collection if provided.
        """
        if self.collection and self.collection != 'default':
            # Check if the name already starts with the collection prefix to avoid duplication
            if name.startswith(f"{self.collection}/"):
                return name
            return f"{self.collection}/{name}"
        return name
        
    def _save(self, name, content):
        """Save the file using the underlying storage"""
        path = self._get_path(name)
        return self.storage._save(path, content)
        
    def _open(self, name, mode='rb'):
        """Open the file using the underlying storage"""
        path = self._get_path(name)
        return self.storage._open(path, mode)
        
    def delete(self, name):
        """Delete the file using the underlying storage"""
        path = self._get_path(name)
        return self.storage.delete(path)
        
    def exists(self, name):
        """Check if the file exists using the underlying storage"""
        path = self._get_path(name)
        return self.storage.exists(path)
        
    def size(self, name):
        """Get the file size using the underlying storage"""
        path = self._get_path(name)
        return self.storage.size(path)
        
    def url(self, name):
        """
        Return a URL for the file.
        
        For private files, return a URL to the Django view that will serve the file
        with permission checks.
        For public files, return a direct URL to the storage backend.
        """
        path = self._get_path(name)
        
        if self.private:
            # Return URL to Django view for secure file access
            return reverse('serve_protected_file', kwargs={
                'path': path
            })
        else:
            # Return direct URL from storage backend
            return self.storage.url(path)
            
    def path(self, name):
        """
        Return the file's path on the underlying storage if available
        """
        if hasattr(self.storage, 'path'):
            path = self._get_path(name)
            return self.storage.path(path)
        raise NotImplementedError("This storage doesn't support absolute paths")

    def get_accessed_time(self, name):
        """Get the last accessed time using the underlying storage if available"""
        if hasattr(self.storage, 'get_accessed_time'):
            path = self._get_path(name)
            return self.storage.get_accessed_time(path)
        raise NotImplementedError("This storage doesn't support accessed time")
        
    def get_created_time(self, name):
        """Get the creation time using the underlying storage if available"""
        if hasattr(self.storage, 'get_created_time'):
            path = self._get_path(name)
            return self.storage.get_created_time(path)
        raise NotImplementedError("This storage doesn't support created time")
        
    def get_modified_time(self, name):
        """Get the last modified time using the underlying storage if available"""
        if hasattr(self.storage, 'get_modified_time'):
            path = self._get_path(name)
            return self.storage.get_modified_time(path)
        raise NotImplementedError("This storage doesn't support modified time")

# No need for get_storage() function since Django handles this through DEFAULT_FILE_STORAGE setting

================
File: core/urls.py
================
"""
URL configuration for core project.
"""
import logging
import mimetypes
logger = logging.getLogger(__name__)
#logger.info("==== CORE URLS LOADED ====")

from django.contrib import admin
from django.urls import path, include, re_path
from django.conf import settings
from django.conf.urls.static import static
from django.conf.urls.i18n import i18n_patterns
from django.http import HttpResponse, Http404, FileResponse
from home import views
from django.views.static import serve
from apps.seo_manager import views as seo_views
import logging
from core.views import serve_protected_file

logger = logging.getLogger(__name__)

#logger.info("Starting admin module imports")

# Import admin modules to ensure they are registered
try:
    from apps.agents import admin as agents_admin
    #logger.info("Successfully imported agents admin")
except Exception as e:
    logger.error(f"Failed to import agents admin: {str(e)}")

try:
    from apps.seo_manager import admin as seo_manager_admin
    #logger.info("Successfully imported seo_manager admin")
except Exception as e:
    logger.error(f"Failed to import seo_manager admin: {str(e)}")

try:
    from apps.seo_audit import admin as seo_audit_admin
    #logger.info("Successfully imported seo_audit admin")
except Exception as e:
    logger.error(f"Failed to import seo_audit admin: {str(e)}")

try:
    from apps.common import admin as common_admin
    #logger.info("Successfully imported common admin")
except Exception as e:
    logger.error(f"Failed to import common admin: {str(e)}")

#logger.info(f"Admin site registry after imports: {list(admin.site._registry.keys())}")

handler404 = 'home.views.error_404'
handler500 = 'home.views.error_500'

# Configure admin site
admin.site.site_header = 'NeuralAMI Control'
admin.site.site_title = 'NeuralAMI Control'
admin.site.index_title = 'Administration'

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('home.urls')),
    path("api/", include("apps.api.urls")),
    path('tasks/', include('apps.tasks.urls')),
    path('file-manager/', include('apps.file_manager.urls')),
    path("users/", include("apps.users.urls")),
    path('accounts/', include('allauth.urls')),
    path('', include('apps.common.urls', namespace='common')),

    # Serve media files from cloud storage
    re_path(r'^static/(?P<path>.*)$', serve,{'document_root': settings.STATIC_ROOT}), 
    
    # Serve protected storage files with authentication/authorization
    path('media/secure/<path:path>', serve_protected_file, name='serve_protected_file'),

    path('crawl_website/', include('apps.crawl_website.urls')),

    path("__debug__/", include("debug_toolbar.urls")),
    
    # Add Google OAuth callback at root level
    path('google/login/callback/', seo_views.analytics_views.google_oauth_callback, name='root_google_oauth_callback'),
]

urlpatterns += [
    path('seo/', include('apps.seo_manager.urls', namespace='seo_manager')),
    path('agents/', include('apps.agents.urls', namespace='agents')),
    path('seo-audit/', include('apps.seo_audit.urls', namespace='seo_audit')),
    path('image-optimizer/', include('apps.image_optimizer.urls', namespace='image_optimizer')),
    path('research/', include('apps.research.urls', namespace='research')),
    path('utilities/', include('apps.utilities.urls', namespace='utilities')),
    path('organization/', include('apps.organizations.urls', namespace='organizations')),
    path('summarize/', include('apps.summarizer.urls', namespace='summarizer')),
]

from django.http import HttpResponse

def health_check(request):
    return HttpResponse("OK")

urlpatterns += [
    path('health/', health_check, name='health_check'),
]

================
File: core/version.py
================
import os
import subprocess
import datetime

def get_version():
    """Get the current version based on build-time version or git state"""
    # First try to get version from environment (set during Docker build)
    build_version = os.getenv('VERSION')
    if build_version:
        # Get commit date from environment
        commit_date = os.getenv('COMMIT_DATE')
        if commit_date:
            # Convert Unix timestamp to datetime
            dt = datetime.datetime.fromtimestamp(int(commit_date))
            # Format as YYYYMMDD-HHMMSS
            date_str = dt.strftime('%Y%m%d-%H%M%S')
            return f"{build_version}-{date_str}"
        return build_version
        
    # If not in Docker (development), try git
    try:
        # Get the current commit hash (works with uncommitted changes)
        commit = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode().strip()
        
        # Get the current working tree state hash (includes uncommitted changes)
        tree_hash = subprocess.check_output(['git', 'write-tree']).decode().strip()
        
        # Get commit timestamp
        commit_date = subprocess.check_output(['git', 'show', '-s', '--format=%ct', 'HEAD']).decode().strip()
        dt = datetime.datetime.fromtimestamp(int(commit_date))
        date_str = dt.strftime('%Y%m%d-%H%M%S')
        
        # Create a unique version based on the current state
        version = f"{commit}-{tree_hash[:8]}-{date_str}"
        return version
    except Exception:
        # Fallback to current timestamp if git commands fail
        return datetime.datetime.now().strftime('%Y%m%d-%H%M%S')

# Generate version on import
VERSION = get_version()
COMMIT = os.getenv('COMMIT', 'unknown')  # Use build-time commit if available

================
File: core/views.py
================
import mimetypes
import os
import re
from django.http import HttpResponse, Http404
from django.core.files.storage import default_storage
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
import logging

logger = logging.getLogger(__name__)

@login_required
def serve_protected_file(request, path):
    """
    Serve a file from storage with access control.
    
    This view provides authenticated access to files stored in Django's storage backend.
    It can be extended to include specific permission checks based on the file path.
    
    Args:
        request: The HTTP request
        path: The path to the file in storage
        
    Returns:
        HttpResponse with the file content
    """
    logger.debug(f"Serving protected file: {path}")
    
    # Default permission to True for authenticated users
    has_permission = True
    
    # Example permission check for organization logos
    if path.startswith('organization_logos/'):
        # Organization logos can be viewed by any authenticated user
        # Additional permissions could be added here if needed
        pass
    
    # Permission check for user avatars
    elif path.startswith('user_avatars/'):
        # Extract user ID from path (format: user_avatars/user_id/filename)
        user_id_match = re.match(r'user_avatars/(\d+)/.*', path)
        
        if user_id_match:
            avatar_user_id = user_id_match.group(1)
            # Only allow access if it's the user's own avatar or they're an admin
            if str(request.user.id) != avatar_user_id and not request.user.is_staff:
                logger.warning(f"User {request.user.id} tried to access avatar of user {avatar_user_id}")
                has_permission = False
        else:
            # If we can't extract a user ID, default to allowed for backward compatibility
            # But log it as a potential issue
            logger.warning(f"Couldn't extract user ID from avatar path: {path}")
    
    if not has_permission:
        logger.warning(f"User {request.user.id} denied access to {path}")
        raise Http404("File not found")
    
    # Check if file exists
    if not default_storage.exists(path):
        logger.error(f"File not found in storage: {path}")
        raise Http404("File not found")
    
    try:
        # Open the file and read content
        file_content = default_storage.open(path, 'rb').read()
        
        # Guess content type
        content_type, encoding = mimetypes.guess_type(path)
        if content_type is None:
            content_type = 'application/octet-stream'
        
        # Create response with file content
        response = HttpResponse(file_content, content_type=content_type)
        
        # Add Content-Disposition header for browser handling
        filename = os.path.basename(path)
        response['Content-Disposition'] = f'inline; filename="{filename}"'
        
        return response
    except Exception as e:
        logger.error(f"Error serving file {path}: {str(e)}", exc_info=True)
        raise Http404("Error serving file")

================
File: core/wsgi.py
================
"""
WSGI config for core project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')

application = get_wsgi_application()

================
File: file_manager/file-manager.html
================
<a href="{% url 'file_manager:delete' file_path=item.path %}">Delete</a>

================
File: tasks_scripts/check-db-health.py
================
#!/usr/bin/env python
"""
Copyright (c) 2019 - present AppSeed.us
"""

import os, sys

def main(argv):

    try:
        
        print(' EXEC -> ' + os.path.basename(__file__)) 

        for i in range(1, len(argv)):
            print('argument:', i, 'value:', argv[i])        

        # Unix ErrCode
        exit(0)

    except Exception as e:

        print( 'Err: ' + str( e ) )
        exit(1)

if __name__ == '__main__':
    main(sys.argv)

================
File: tasks_scripts/check-disk-free.py
================
#!/usr/bin/env python
"""
Copyright (c) 2019 - present AppSeed.us
"""

import os, sys

def main(argv):

    try:
        
        print(' EXEC -> ' + os.path.basename(__file__)) 
        
        # Unix ErrCode
        exit(0)

    except Exception as e:

        print( 'Err: ' + str( e ) )
        exit(1)

if __name__ == '__main__':
    main(sys.argv)

================
File: tasks_scripts/clean-database.py
================
#!/usr/bin/env python
"""
Copyright (c) 2019 - present AppSeed.us
"""

import os, sys

def main(argv):
        
    try:
        
        print(' EXEC -> ' + os.path.basename(__file__)) 

        # Unix ErrCode
        exit(0)

    except Exception as e:

        print( 'Err: ' + str( e ) )
        exit(1)

if __name__ == '__main__':
    main(sys.argv)

================
File: templates/authentication/change/basic.html
================
{% extends 'layouts/base-full.html' %}
{% load static %}

{% block body %}bg-gray-200{% endblock body %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-90 m-3 border-radius-xl" style="background-image: url('https://images.unsplash.com/photo-1627850991511-fd5640f0b472?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1951&q=80');">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-4 col-md-7 mx-auto">
            <div class="card z-index-0 my-auto">
              <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
                <div class="bg-gradient-success shadow-success border-radius-lg py-3 text-center">
                  <h4 class="font-weight-bolder text-white mb-0 mt-1">Change password</h4>
                  {% comment %} <p class="text-white mb-1">You will receive an e-mail in maximum 60 seconds</p> {% endcomment %}
                </div>
              </div>
              <div class="card-body">
                <form role="form" method="post">
                  {% csrf_token %}


                  {% for field in form %}
                    <label>{{ field.label }}</label>
                    <div class="mb-3">
                      {{ field }}
                    </div>

                    <small class="text-danger">{{ field.errors }}</small>
                  {% endfor %}

                  <div class="text-center">
                    <button type="submit" class="btn bg-gradient-dark btn-lg w-100 my-4 mb-2">Change</button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}
{% block fixed_plugin %}{% endblock fixed_plugin %}

{% block extra_js %}

  <script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>

{% endblock extra_js %}

================
File: templates/authentication/complete/basic.html
================
{% extends 'layouts/base-full.html' %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-90 m-3 border-radius-xl" style="background-image: url('https://images.unsplash.com/photo-1627850991511-fd5640f0b472?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1951&q=80');">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-4 col-md-7 mx-auto">
            <div class="card z-index-0 my-auto">
              <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
                <div class="bg-gradient-success shadow-success border-radius-lg py-3 text-center">
                  <h4 class="font-weight-bolder text-white mb-0 mt-1">Password Changed</h4>
                  <p class="text-white mb-1">Your password has been changed successfully, You can login again</p>
                </div>
              </div>
              <div class="card-body">
                <div class="text-center">
                  <a href="{% url 'basic_login' %}" class="btn bg-gradient-dark w-100 mt-2 mb-4">Login</a>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>


  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}
{% block fixed_plugin %}{% endblock fixed_plugin %}


{% block extra_js %}

  <script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>

{% endblock extra_js %}

================
File: templates/authentication/done/basic.html
================
{% extends 'layouts/base-full.html' %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-90 m-3 border-radius-xl" style="background-image: url('https://images.unsplash.com/photo-1627850991511-fd5640f0b472?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1951&q=80');">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-4 col-md-7 mx-auto">
            <div class="card z-index-0 my-auto">
              <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
                <div class="bg-gradient-success shadow-success border-radius-lg py-3 text-center">
                  <h4 class="font-weight-bolder text-white mb-0 mt-1">Email Sent</h4>
                  <p class="text-white mb-1">An email has been sent to your email address. Please click the link and reset your password.</p>
                </div>
              </div>
              <div class="card-body">
                
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}
{% block fixed_plugin %}{% endblock fixed_plugin %}

{% block extra_js %}

  <script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>

{% endblock extra_js %}

================
File: templates/authentication/done/change-done.html
================
{% extends 'layouts/base-full.html' %}
{% load static %}

{% block body %}bg-gray-200{% endblock body %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-90 m-3 border-radius-xl" style="background-image: url('https://images.unsplash.com/photo-1627850991511-fd5640f0b472?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1951&q=80');">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-4 col-md-7 mx-auto">
            <div class="card z-index-0 my-auto">
              <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
                <div class="bg-gradient-success shadow-success border-radius-lg py-3 text-center">
                  <h4 class="font-weight-bolder text-white mb-0 mt-1">Password Changed</h4>
                  <p class="text-white mb-1">Your password has been changed successfully.</p>
                </div>
              </div>
              <div class="card-body">
                
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}
{% block fixed_plugin %}{% endblock fixed_plugin %}


{% block extra_js %}

  <script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>

{% endblock extra_js %}

================
File: templates/authentication/error/404.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <section class="my-10">
      <div class="container">
        <div class="row">
          <div class="col-lg-6 my-auto">
            <h1 class="display-1 text-bolder text-gradient text-danger">Error 404</h1>
            <h2>Erm. Page not found</h2>
            <p class="lead">We suggest you to go to the homepage while we solve this issue.</p>
            <button type="button" class="btn bg-gradient-dark mt-4">Go to Homepage</button>
          </div>
          <div class="col-lg-6 my-auto position-relative">
            <img class="w-100 position-relative" src="{% static "assets/img/illustrations/error-404.png" %}" alt="404-error">
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/error/500.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <div>
      <section class="min-vh-100 d-flex align-items-center">
        <div class="container">
          <div class="row mt-lg-0 mt-8">
            <div class="col-lg-5 my-auto">
              <h1 class="display-1 text-bolder text-gradient text-warning fadeIn1 fadeInBottom mt-5">Error 500</h1>
              <h2 class="fadeIn3 fadeInBottom opacity-8">Something went wrong</h2>
              <p class="lead opacity-6 fadeIn2 fadeInBottom">We suggest you to go to the homepage while we solve this issue.</p>
              <button type="button" class="btn bg-gradient-warning mt-4 fadeIn2 fadeInBottom">Go to Homepage</button>
            </div>
            <div class="col-lg-7 my-auto">
              <img class="w-100 fadeIn1 fadeInBottom" src="{% static "assets/img/illustrations/error-500.png" %}" alt="500-error">
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

{% endblock content %}

================
File: templates/authentication/lock/basic.html
================
{% extends "layouts/base-full.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-50 pt-5 pb-11 m-3 border-radius-lg" style="background-image: url('{% static "assets/img/curved-images/curved8.jpg" %}');">
      <span class="mask bg-gradient-dark opacity-6"></span>
    </div>
    <div class="container">
      <div class="row mt-lg-n10 mt-md-n11 mt-n10 justify-content-center">
        <div class="col-xl-4 col-lg-5 col-md-7 mx-auto">
          <div class="card py-lg-3">
            <div class="card-body text-center">
              <div class="info mb-4">
                <img class="avatar avatar-xxl" alt="Image placeholder" src="{% static "assets/img/team-4.jpg" %}">
              </div>
              <h4 class="mb-0 font-weight-bolder">Mike Priesler</h4>
              <p class="mb-4">Enter password to unlock your account.</p>
              <form role="form">
                <div class="mb-3">
                  <input type="password" class="form-control" placeholder="Password" aria-label="password">
                </div>
                <div class="text-center">
                  <button type="button" class="btn btn-lg bg-gradient-dark mt-3 mb-0">Unlock</button>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

================
File: templates/authentication/lock/cover.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section>
      <div class="page-header min-vh-75">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-6 d-flex flex-column mx-auto">
              <div class="card card-plain py-lg-3">
                <div class="card-body text-center">
                  <h4 class="mb-0 font-weight-bolder">Mike Priesler</h4>
                  <p class="mb-4">Enter password to unlock your account.</p>
                  <form role="form">
                    <div class="mb-3">
                      <input type="password" class="form-control" placeholder="Password" aria-label="password">
                    </div>
                    <div class="text-center">
                      <button type="button" class="btn btn-lg w-100 bg-gradient-dark mb-0">Unlock</button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="oblique position-absolute top-0 h-100 d-md-block d-none me-n8">
                <div class="oblique-image bg-cover position-absolute fixed-top ms-auto h-100 z-index-0 ms-n6" style="background-image:url('{% static "assets/img/curved-images/curved7.jpg" %}')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/lock/illustration.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <section>
      <div class="page-header min-vh-100">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-7 d-flex flex-column mx-lg-0 mx-auto">
              <div class="card card-plain py-lg-3">
                <div class="card-body text-center">
                  <h4 class="mb-0 font-weight-bolder">Mike Priesler</h4>
                  <p class="mb-4">Enter password to unlock your account.</p>
                  <form role="form">
                    <div class="mb-3">
                      <input type="password" class="form-control" placeholder="Password" aria-label="password">
                    </div>
                    <div class="text-center">
                      <button type="button" class="btn btn-lg w-100 bg-gradient-dark mb-0">Unlock</button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
            <div class="col-6 d-lg-flex d-none h-100 my-auto pe-0 position-absolute top-0 end-0 text-center justify-content-center flex-column">
              <div class="position-relative bg-gradient-dark h-100 m-3 px-7 border-radius-lg d-flex flex-column justify-content-center">
                <img src="{% static "assets/img/shapes/pattern-lines.svg" %}" alt="pattern-lines" class="position-absolute opacity-4 start-0">
                <div class="position-relative">
                  <img class="max-width-500 w-100 position-relative z-index-2" src="{% static "assets/img/illustrations/dark-lock-ill.png" %}" alt="dark-lock">
                </div>
                <h4 class="mt-5 text-white font-weight-bolder">"Attention is the new currency"</h4>
                <p class="text-white">The more effortless the writing looks, the more effort the writer actually put into the process.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}

================
File: templates/authentication/reset/basic.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section class="min-vh-75">
      <div class="container">
        <div class="row">
          <div class="col-lg-5 col-md-7 mx-auto">
            <div class="card z-index-0 mt-sm-12 mt-9 mb-4">
              <div class="card-header text-center pt-4 pb-1">
                <h4 class="font-weight-bolder mb-1">Reset password</h4>
                <p class="mb-0">You will receive an e-mail in maximum 60 seconds</p>
              </div>
              <div class="card-body">
                <form role="form" method="post">
                  {% csrf_token %}

                  {% for field in form %}
                    <div class="mb-3">
                      {{ field }}
                    </div>
                  {% endfor %}

                  <div class="text-center">
                    <button type="submit" class="btn bg-gradient-dark btn-lg w-100 my-4 mb-2">Send</button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/reset/cover.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section>
      <div class="page-header min-vh-75">
        <div class="container">
          <div class="row">
            <div class="col-xl-5 col-lg-6 col-md-8 col-12 px-5 d-flex flex-column">
              <div class="card card-plain mt-8">
                <div class="card-header pb-0 text-left">
                  <h3 class="text-info text-gradient">Reset Password</h3>
                  <p class="mb-0">You will receive an e-mail in maximum 60 seconds</p>
                </div>
                <div class="card-body pb-3">
                  <form role="form">
                    <label>Email</label>
                    <div class="mb-3">
                      <input type="email" class="form-control" placeholder="Enter your e-mail" aria-label="Email">
                    </div>
                    <div class="text-center">
                      <button type="button" class="btn bg-gradient-info w-100 mt-4 mb-0">Reset</button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="oblique position-absolute top-0 h-100 d-md-block d-none me-n8">
                <div class="oblique-image bg-cover position-absolute fixed-top ms-auto h-100 z-index-0 ms-n6" style="background-image:url('{% static "assets/img/curved-images/curved6.jpg" %}')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/reset/illustration.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <section>
      <div class="page-header min-vh-100">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-7 d-flex flex-column mx-lg-0 mx-auto">
              <div class="card card-plain">
                <div class="card-header pb-0 text-left">
                  <h4 class="font-weight-bolder">Reset password</h4>
                  <p class="mb-0">You will receive an e-mail in maximum 60 seconds</p>
                </div>
                <div class="card-body">
                  <form role="form">
                    <div class="mb-3">
                      <input type="email" class="form-control form-control-lg" placeholder="Email" aria-label="Email">
                    </div>
                    <div class="mb-3">
                      <input type="text" class="form-control form-control-lg" placeholder="Verification Code" aria-label="code">
                    </div>
                    <div class="text-center">
                      <button type="button" class="btn btn-primary btn-lg w-100 my-4">Send</button>
                    </div>
                  </form>
                </div>
              </div>
            </div>
            <div class="col-6 d-lg-flex d-none h-100 my-auto pe-0 position-absolute top-0 end-0 text-center justify-content-center flex-column">
              <div class="position-relative bg-primary h-100 m-3 px-7 border-radius-lg d-flex flex-column justify-content-center">
                <img src="{% static "assets/img/shapes/pattern-lines.svg" %}" alt="pattern-lines" class="position-absolute opacity-4 start-0">
                <div class="position-relative">
                  <img class="max-width-500 w-100 position-relative z-index-2" src="{% static "assets/img/illustrations/lock.png" %}" alt="lock-svg">
                </div>
                <h4 class="mt-5 text-white font-weight-bolder">Soft UI Design</h4>
                <p class="text-white">Just as it takes a company to sustain a product, it takes a community to sustain a protocol.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}

================
File: templates/authentication/reset-confirm/basic.html
================
{% extends 'layouts/base-full.html' %}
{% load static %}

{% block body %}bg-gray-200{% endblock body %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-90 m-3 border-radius-xl" style="background-image: url('https://images.unsplash.com/photo-1627850991511-fd5640f0b472?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1951&q=80');">
      <div class="container my-auto">
        <div class="row">
          <div class="col-lg-4 col-md-7 mx-auto">
            <div class="card z-index-0 my-auto">
              <div class="card-header p-0 position-relative mt-n4 mx-3 z-index-2">
                <div class="bg-gradient-success shadow-success border-radius-lg py-3 text-center">
                  <h4 class="font-weight-bolder text-white mb-0 mt-1">Reset password</h4>
                  {% comment %} <p class="text-white mb-1">You will receive an e-mail in maximum 60 seconds</p> {% endcomment %}
                </div>
              </div>
              <div class="card-body">
                <form role="form" method="post">
                  {% csrf_token %}

                  {% for field in form %}
                    <label>{{ field.label }}</label>
                    <div class="mb-3">
                      {{ field }}
                    </div>

                    <small class="text-danger">{{ field.errors }}</small>
                  {% endfor %}
                  <div class="text-center">
                    <button type="submit" class="btn bg-gradient-dark btn-lg w-100 my-4 mb-2">Reset</button>
                  </div>
                </form>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}
{% block fixed_plugin %}{% endblock fixed_plugin %}

{% block extra_js %}

  <script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>

{% endblock extra_js %}

================
File: templates/authentication/signin/basic.html
================
{% extends "layouts/base-full.html" %}
{% load static socialaccount %}
{% get_providers as socialaccount_providers %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-50 pt-5 pb-11 m-3 border-radius-lg" style="background-image: url('{% static "assets/img/curved-images/curved9.jpg" %}');">
      <span class="mask bg-gradient-dark opacity-6"></span>
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-5 text-center mx-auto">
            <h1 class="text-white mb-2 mt-5">Welcome!</h1>
            <p class="text-lead text-white">Use these awesome forms to login or create new account in your project for free.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row mt-lg-n10 mt-md-n11 mt-n10 justify-content-center">
        <div class="col-xl-4 col-lg-5 col-md-7 mx-auto">
          <div class="card z-index-0">
            <div class="card-header text-center pt-4">
              <h5>Sign in</h5>
            </div>
            <!--
            <div class="row px-xl-5 px-sm-4 px-3">
              <form method="post" action="{% provider_login_url 'github' %}" class="col-3 ms-auto px-1">
                {% csrf_token %}

                <button class="btn btn-outline-light w-100" type="submit">
                  <svg aria-hidden="true" class="octicon octicon-mark-github" width="24px" height="32px" version="1.1" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                  </svg>
                </button>
              </form>
              <div class="col-3 me-auto px-1">
                <a class="btn btn-outline-light w-100" href="javascript:;">
                  <svg width="24px" height="32px" viewBox="0 0 64 64" version="1.1">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                      <g transform="translate(3.000000, 2.000000)" fill-rule="nonzero">
                        <path d="M57.8123233,30.1515267 C57.8123233,27.7263183 57.6155321,25.9565533 57.1896408,24.1212666 L29.4960833,24.1212666 L29.4960833,35.0674653 L45.7515771,35.0674653 C45.4239683,37.7877475 43.6542033,41.8844383 39.7213169,44.6372555 L39.6661883,45.0037254 L48.4223791,51.7870338 L49.0290201,51.8475849 C54.6004021,46.7020943 57.8123233,39.1313952 57.8123233,30.1515267" fill="#4285F4"></path>
                        <path d="M29.4960833,58.9921667 C37.4599129,58.9921667 44.1456164,56.3701671 49.0290201,51.8475849 L39.7213169,44.6372555 C37.2305867,46.3742596 33.887622,47.5868638 29.4960833,47.5868638 C21.6960582,47.5868638 15.0758763,42.4415991 12.7159637,35.3297782 L12.3700541,35.3591501 L3.26524241,42.4054492 L3.14617358,42.736447 C7.9965904,52.3717589 17.959737,58.9921667 29.4960833,58.9921667" fill="#34A853"></path>
                        <path d="M12.7159637,35.3297782 C12.0932812,33.4944915 11.7329116,31.5279353 11.7329116,29.4960833 C11.7329116,27.4640054 12.0932812,25.4976752 12.6832029,23.6623884 L12.6667095,23.2715173 L3.44779955,16.1120237 L3.14617358,16.2554937 C1.14708246,20.2539019 0,24.7439491 0,29.4960833 C0,34.2482175 1.14708246,38.7380388 3.14617358,42.736447 L12.7159637,35.3297782" fill="#FBBC05"></path>
                        <path d="M29.4960833,11.4050769 C35.0347044,11.4050769 38.7707997,13.7975244 40.9011602,15.7968415 L49.2255853,7.66898166 C44.1130815,2.91684746 37.4599129,0 29.4960833,0 C17.959737,0 7.9965904,6.62018183 3.14617358,16.2554937 L12.6832029,23.6623884 C15.0758763,16.5505675 21.6960582,11.4050769 29.4960833,11.4050769" fill="#EB4335"></path>
                      </g>
                    </g>
                  </svg>
                </a>
              </div>
            </div>
            -->
            <div class="card-body">
              <form role="form" class="text-start" method="post">
                {% csrf_token %}

                {% if form.non_field_errors %}
                  {% for error in form.non_field_errors %}
                    <p class="text-danger">{{ error }}</p>
                  {% endfor %}
                {% endif %}

                {% for field in form %}
                <div class="mb-3">
                  {{ field }}
                </div>
                {% endfor %}

                <div class="d-flex justify-content-between align-items-center">
                  <div class="form-check form-switch">
                    <input class="form-check-input" type="checkbox" id="rememberMe">
                    <label class="form-check-label" for="rememberMe">Remember me</label>
                  </div>
                  <p class="text-sm">
                    <a href="{% url 'basic_reset' %}" class="text-primary text-gradient font-weight-bold">Forgot Password?</a>
                  </p>
                </div>

                <div class="text-center">
                  <button type="submit" class="btn bg-gradient-info w-100 my-4 mb-2">Sign in</button>
                </div>
                <div class="mb-2 position-relative text-center">
                  <p class="text-sm font-weight-bold mb-2 text-secondary text-border d-inline z-index-2 bg-white px-3">
                    or
                  </p>
                </div>
                <div class="text-center">
                  <a href="{% url "basic_register" %}" class="btn bg-gradient-dark w-100 mt-2 mb-4">Sign up</a>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

================
File: templates/authentication/signin/cover.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section>
      <div class="page-header min-vh-75">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-6 d-flex flex-column mx-auto">
              <div class="card card-plain mt-8">
                <div class="card-header pb-0 text-start">
                  <h3 class="font-weight-bolder text-info text-gradient">Welcome back</h3>
                  <p class="mb-0">Enter your email and password to sign in</p>
                </div>
                <div class="card-body">
                  <form role="form" class="text-start" method="post">
                    {% csrf_token %}

                    {% if form.non_field_errors %}
                      {% for error in form.non_field_errors %}
                        <p class="text-danger">{{ error }}</p>
                      {% endfor %}
                    {% endif %}

                    {% for field in form %}
                      <label>{{ field.label }}</label>
                      <div class="mb-3">
                        {{ field }}
                      </div>
                    {% endfor %}

                    <div class="d-flex justify-content-between align-items-center">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="rememberMe" checked="">
                        <label class="form-check-label" for="rememberMe">Remember me</label>
                      </div>
                      <p class="text-sm">
                        <a href="{% url 'basic_reset' %}" class="text-primary text-gradient font-weight-bold">Forgot Password?</a>
                      </p>
                    </div>
                    
                    <div class="text-center">
                      <button type="submit" class="btn bg-gradient-info w-100 mt-4 mb-0">Sign in</button>
                    </div>
                  </form>
                </div>
                <div class="card-footer text-center pt-0 px-lg-2 px-1">
                  <p class="mb-4 text-sm mx-auto">
                    Don't have an account?
                    <a href="{% url "cover_register" %}" class="text-info text-gradient font-weight-bold">Sign up</a>
                  </p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="oblique position-absolute top-0 h-100 d-md-block d-none me-n8">
                <div class="oblique-image bg-cover position-absolute fixed-top ms-auto h-100 z-index-0 ms-n6" style="background-image:url('{% static "assets/img/curved-images/curved9.jpg" %}')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/signin/illustration.html
================
{% extends 'layouts/base-shadow.html' %}
{% load static %}
{% load static socialaccount %}
{% get_providers as socialaccount_providers %}

{% block content %}

  <main class="main-content  mt-0">
    <section>
      <div class="page-header min-vh-100">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-7 d-flex flex-column mx-lg-0 mx-auto">
              <div class="card card-plain">
                <div class="card-header pb-4 text-start text-center">
                  <h4 class="font-weight-bolder">Sign In</h4>
                  {% comment %} <p class="mb-0">Enter your email and password to sign in</p> {% endcomment %}
                </div>

            <div class="row px-xl-5 px-sm-4 px-3">
              
              
              <form method="post" action="{% provider_login_url 'github' %}" class="col-3 ms-auto px-1">
                {% csrf_token %}

                <button type="submit" class="btn btn-outline-light w-100 social-login-btn">
                  <svg width="24px" height="32px" fill="currentColor" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github"
                    role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512">
                    <path
                      d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z">
                    </path>
                  </svg>
                </button>
              </form>

              <form method="post" action="{% provider_login_url 'google' %}" class="col-3 me-auto px-1">
                {% csrf_token %}

                <button class="btn btn-outline-light w-100 social-login-btn">
                  <svg width="24px" height="32px" fill="currentColor" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
                  viewBox="0 0 210 210" xml:space="preserve">
                    <path d="M0,105C0,47.103,47.103,0,105,0c23.383,0,45.515,7.523,64.004,21.756l-24.4,31.696C133.172,44.652,119.477,40,105,40
                      c-35.841,0-65,29.159-65,65s29.159,65,65,65c28.867,0,53.398-18.913,61.852-45H105V85h105v20c0,57.897-47.103,105-105,105
                      S0,162.897,0,105z"/>
                  </svg>
                </button>
              </form>
              

            </div>


                <div class="card-body">
                  <form method="post" role="form">
                    {% csrf_token %}
                    {% if form.non_field_errors %}
                      {% for error in form.non_field_errors %}
                        <div class="text-danger mb-3">{{ error }}</div>
                      {% endfor %}
                    {% endif %}

                    {% for field in form %}
                    <div class="mb-3">
                      {{ field }}
                    </div>
                    {% endfor %}

                    <div class="d-flex justify-content-between align-items-center">
                      <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="rememberMe">
                        <label class="form-check-label" for="rememberMe">Remember me</label>
                      </div>
                      <p class="text-sm mt-3">
                        <a href="{% url 'illustration_reset' %}" class="text-primary text-gradient font-weight-bold">Forgot Password?</a>
                      </p>
                    </div>

                    <div class="text-center">
                      <button type="submit" class="btn bg-gradient-primary w-100 mt-4 mb-0">Sign in</button>
                    </div>
                  </form>
                </div>
                <div class="card-footer text-center pt-0 px-lg-2 px-1">
                  <p class="mb-4 text-sm mx-auto">
                    Don't have an account?
                    <a href="{% url 'illustration_register' %}" class="text-primary text-gradient font-weight-bold">Sign up</a>
                  </p>
                </div>
              </div>
            </div>
            <div class="col-6 d-lg-flex d-none h-100 my-auto pe-0 position-absolute top-0 end-0 text-center justify-content-center flex-column">
              <div class="position-relative bg-gradient-primary h-100 m-3 px-7 border-radius-lg d-flex flex-column justify-content-center">
                <img src="{% static 'assets/img/shapes/pattern-lines.svg' %}" alt="pattern-lines" class="position-absolute opacity-4 start-0">
                <div class="position-relative">
                  <img class="max-width-500 w-100 position-relative z-index-2" src="{% static 'assets/neuralami/logos/NeuralamiLogo480x480SD.png' %}" alt="chat-img">
                </div>
                <h4 class="mt-5 text-white font-weight-bolder">"Simplicity is the new currency!"</h4>
                <p class="text-white">The more effortless the service looks, the more effort the company actually put into the process.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

{% block footer %}    {% include "includes/footer-full.html" %} {% endblock footer %}

{% block extra_js %}
<style>
  /* Additional styles for social login buttons */
  .social-login-btn {
    transition: all 0.3s ease;
    border-radius: 0.5rem;
  }
  
  .social-login-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }
  
  /* Light mode specific styles */
  .social-login-btn svg {
    transition: fill 0.3s ease;
  }
  
  /* Ensure the social login buttons are visible in any theme */
  @media (prefers-color-scheme: dark) {
    .social-login-btn svg {
      fill: white;
    }
  }
</style>
{% endblock extra_js %}

================
File: templates/authentication/signup/basic.html
================
{% extends "layouts/base-full.html" %}
{% load static socialaccount %}
{% get_providers as socialaccount_providers %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header align-items-start min-vh-50 pt-5 pb-11 m-3 border-radius-lg" style="background-image: url('{% static "assets/img/curved-images/curved6.jpg" %}');">
      <span class="mask bg-gradient-dark opacity-6"></span>
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-5 text-center mx-auto">
            <h1 class="text-white mb-2 mt-5">Welcome!</h1>
            <p class="text-lead text-white">Use these awesome forms to login or create new account in your project for free.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div class="row mt-lg-n10 mt-md-n11 mt-n10 justify-content-center">
        <div class="col-xl-4 col-lg-5 col-md-7 mx-auto">
          <div class="card z-index-0">
            <div class="card-header text-center pt-4">
              <h5>Register</h5>
            </div>
            <!--
            <div class="row px-xl-5 px-sm-4 px-3">
              <form method="post" action="{% provider_login_url 'github' %}" class="col-3 ms-auto px-1">
                {% csrf_token %}

                <button class="btn btn-outline-light w-100" type="submit">
                  <svg aria-hidden="true" class="octicon octicon-mark-github" width="24px" height="32px" version="1.1" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                  </svg>
                </button>
              </form>
              <div class="col-3 me-auto px-1">
                <a class="btn btn-outline-light w-100" href="javascript:;">
                  <svg width="24px" height="32px" viewBox="0 0 64 64" version="1.1">
                    <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                      <g transform="translate(3.000000, 2.000000)" fill-rule="nonzero">
                        <path d="M57.8123233,30.1515267 C57.8123233,27.7263183 57.6155321,25.9565533 57.1896408,24.1212666 L29.4960833,24.1212666 L29.4960833,35.0674653 L45.7515771,35.0674653 C45.4239683,37.7877475 43.6542033,41.8844383 39.7213169,44.6372555 L39.6661883,45.0037254 L48.4223791,51.7870338 L49.0290201,51.8475849 C54.6004021,46.7020943 57.8123233,39.1313952 57.8123233,30.1515267" fill="#4285F4"></path>
                        <path d="M29.4960833,58.9921667 C37.4599129,58.9921667 44.1456164,56.3701671 49.0290201,51.8475849 L39.7213169,44.6372555 C37.2305867,46.3742596 33.887622,47.5868638 29.4960833,47.5868638 C21.6960582,47.5868638 15.0758763,42.4415991 12.7159637,35.3297782 L12.3700541,35.3591501 L3.26524241,42.4054492 L3.14617358,42.736447 C7.9965904,52.3717589 17.959737,58.9921667 29.4960833,58.9921667" fill="#34A853"></path>
                        <path d="M12.7159637,35.3297782 C12.0932812,33.4944915 11.7329116,31.5279353 11.7329116,29.4960833 C11.7329116,27.4640054 12.0932812,25.4976752 12.6832029,23.6623884 L12.6667095,23.2715173 L3.44779955,16.1120237 L3.14617358,16.2554937 C1.14708246,20.2539019 0,24.7439491 0,29.4960833 C0,34.2482175 1.14708246,38.7380388 3.14617358,42.736447 L12.7159637,35.3297782" fill="#FBBC05"></path>
                        <path d="M29.4960833,11.4050769 C35.0347044,11.4050769 38.7707997,13.7975244 40.9011602,15.7968415 L49.2255853,7.66898166 C44.1130815,2.91684746 37.4599129,0 29.4960833,0 C17.959737,0 7.9965904,6.62018183 3.14617358,16.2554937 L12.6832029,23.6623884 C15.0758763,16.5505675 21.6960582,11.4050769 29.4960833,11.4050769" fill="#EB4335"></path>
                      </g>
                    </g>
                  </svg>
                </a>
              </div>
              <div class="mt-2 position-relative text-center">
                <p class="text-sm font-weight-bold mb-2 text-secondary text-border d-inline z-index-2 bg-white px-3">
                  or
                </p>
              </div>
            </div>
            -->
            <div class="card-body">
              <form role="form" method="post">
                {% csrf_token %}

                {% for field in form %}
                <div class="mb-3">
                  {{ field }}
                  <span class="d-block mt-1 text-danger">{{ field.errors }}</span>
                </div>
                {% endfor %}
                <div class="form-check form-check-info text-start">
                  <input class="form-check-input" type="checkbox" value="" id="flexCheckDefault" checked>
                  <label class="form-check-label" for="flexCheckDefault">
                    I agree the <a href="javascript:;" class="text-dark font-weight-bolder">Terms and Conditions</a>
                  </label>
                </div>
                <div class="text-center">
                  <button type="submit" class="btn bg-gradient-dark w-100 my-4 mb-2">Sign up</button>
                </div>
                <div class="mb-2 position-relative text-center">
                  <p class="text-sm font-weight-bold mb-2 text-secondary text-border d-inline z-index-2 bg-white px-3">
                    or
                  </p>
                </div>                
                <div class="text-center">
                  <a href="{% url "basic_login" %}" class="btn bg-gradient-info w-100 mt-2 mb-4">Sign In</a>
                </div>
              </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

================
File: templates/authentication/signup/cover.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section>
      <div class="page-header min-vh-75">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-6 d-flex flex-column mx-auto">
              <div class="card card-plain mt-sm-8 mt-7 mt-md-5">
                <div class="card-header pb-0 text-left">
                  <h3 class="font-weight-bolder text-primary text-gradient">Join us today</h3>
                  <p class="mb-0">Enter your email and password to register</p>
                </div>
                <div class="card-body pb-3">
                  <form method="post" role="form">
                    {% csrf_token %}

                    {% for field in form %}
                    <label>{{ field.label }}</label>
                    <div class="mb-3">
                      {{ field }}
                      <span class="d-block mt-1 text-danger">{{ field.errors }}</span>
                    </div>
                    {% endfor %}

                    <div class="form-check form-check-info text-left">
                      <input class="form-check-input" type="checkbox" value="" id="flexCheckDefault" checked>
                      <label class="form-check-label" for="flexCheckDefault">
                        I agree the <a href="#" class="text-dark font-weight-bolder">Terms and Conditions</a>
                      </label>
                    </div>
                    <div class="text-center">
                      <button type="submit" class="btn btn-primary w-100 mt-4 mb-0">Sign up</button>
                    </div>
                  </form>
                </div>
                <div class="card-footer text-center pt-0 px-sm-4 px-1">
                  <p class="mb-4 mx-auto">
                    Already have an account?
                    <a href="{% url "cover_login" %}" class="text-primary text-gradient font-weight-bold">Sign in</a>
                  </p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="oblique position-absolute top-0 h-100 d-md-block d-none me-n8">
                <div class="oblique-image bg-cover position-absolute fixed-top ms-auto h-100 z-index-0 ms-n6" style="background-image:url('{% static "assets/img/curved-images/curved11.jpg" %}')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/signup/illustration.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <section>
      <div class="page-header min-vh-100">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-7 d-flex flex-column mx-lg-0 mx-auto">
              <div class="card card-plain">
                <div class="card-header pb-0 text-left">
                  <h4 class="font-weight-bolder">Sign Up</h4>
                  <p class="mb-0">Enter your email and password to register</p>
                </div>
                <div class="card-body pb-3">
                  <form role="form" method="post">
                    {% csrf_token %}

                    {% for field in form %}
                    <label>{{ field.label }}</label>
                    <div class="mb-3">
                      {{ field }}
                      <span class="d-block mt-1 text-danger">{{ field.errors }}</span>
                    </div>
                    {% endfor %}
                    <div class="form-check form-check-info text-left">
                      <input class="form-check-input" type="checkbox" value="" id="flexCheckDefault" checked>
                      <label class="form-check-label" for="flexCheckDefault">
                        I agree the <a href="#" class="text-dark font-weight-bolder">Terms and Conditions</a>
                      </label>
                    </div>
                    <div class="text-center">
                      <button type="submit" class="btn btn-primary w-100 mt-4 mb-0">Sign up</button>
                    </div>
                  </form>
                </div>
                <div class="card-footer text-center pt-0 px-sm-4 px-1">
                  <p class="mb-4 mx-auto">
                    Already have an account?
                    <a href="{% url "illustration_login" %}" class="text-primary text-gradient font-weight-bold">Sign in</a>
                  </p>
                </div>
              </div>
            </div>
            <div class="col-6 d-lg-flex d-none h-100 my-auto pe-0 position-absolute top-0 end-0 text-center justify-content-center flex-column">
              <div class="position-relative bg-primary h-100 m-3 px-7 border-radius-lg d-flex flex-column justify-content-center">
                <img src="{% static "assets/img/shapes/pattern-lines.svg" %}" alt="pattern-lines" class="position-absolute opacity-4 start-0">
                <div class="position-relative">
                  <img class="max-width-500 w-100 position-relative z-index-2" src="{% static "assets/img/illustrations/rocket-white.png" %}" alt="rocket">
                </div>
                <h4 class="mt-5 text-white font-weight-bolder">Your journey starts here</h4>
                <p class="text-white">Just as it takes a company to sustain a product, it takes a community to sustain a protocol.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}

================
File: templates/authentication/verification/basic.html
================
{% extends "layouts/base-full.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <div class="page-header min-vh-100" style="background-image: url('{% static "assets/img/curved-images/curved9.jpg" %}');">
      <span class="mask bg-gradient-dark opacity-6"></span>
      <div class="container">
        <div class="row justify-content-center">
          <div class="col-lg-4 col-md-7">
            <div class="card">
              <div class="card-body px-lg-5 py-lg-5 text-center">
                <div class="info mb-4">
                  <div class="icon icon-shape icon-xl rounded-circle bg-gradient-warning shadow text-center py-3 mx-auto">
                    <svg class="mt-3" width="40px" height="35px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>spaceship</title>
                      <g id="Basic-Elements" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g id="Rounded-Icons" transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g id="Icons-with-opacity" transform="translate(1716.000000, 291.000000)">
                            <g id="spaceship" transform="translate(4.000000, 301.000000)">
                              <path d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z" id="Shape"></path>
                              <path d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z" id="Path"></path>
                              <path d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" id="color-2" opacity="0.598539807"></path>
                              <path d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" id="color-3" opacity="0.598539807"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                </div>
                <div class="text-center text-muted mb-4">
                  <h2>2-Step Verification</h2>
                </div>
                <div class="row gx-2 gx-sm-3">
                  <div class="col">
                    <div class="form-group">
                      <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                    </div>
                  </div>
                  <div class="col">
                    <div class="form-group">
                      <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                    </div>
                  </div>
                  <div class="col">
                    <div class="form-group">
                      <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                    </div>
                  </div>
                  <div class="col">
                    <div class="form-group">
                      <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                    </div>
                  </div>
                </div>
                <div class="text-center">
                  <button type="button" class="btn bg-gradient-warning w-100">Send code</button>
                  <span class="text-muted text-sm">Haven't received it?<a href="javascript:;"> Resend a new code</a>.</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}

================
File: templates/authentication/verification/cover.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content main-content-bg mt-0">
    <section>
      <div class="page-header min-vh-75">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-6 d-flex flex-column mx-auto">
              <div class="card card-plain">
                <div class="card-body px-lg-5 py-lg-5 text-center">
                  <div class="text-center text-muted mb-4">
                    <h2>2-Step Verification</h2>
                  </div>
                  <div class="row gx-2 gx-sm-3">
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                  </div>
                  <div class="text-center">
                    <button type="button" class="btn bg-gradient-warning w-100">Send code</button>
                    <span class="text-muted text-sm">Haven't received it?<a href="javascript:;"> Resend a new code</a>.</span>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="oblique position-absolute top-0 h-100 d-md-block d-none me-n8">
                <div class="oblique-image bg-cover position-absolute fixed-top ms-auto h-100 z-index-0 ms-n6" style="background-image:url('{% static "assets/img/curved-images/curved9.jpg" %}')"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

================
File: templates/authentication/verification/illustration.html
================
{% extends "layouts/base-shadow.html" %}
{% load static %}

{% block content %}

  <main class="main-content  mt-0">
    <section>
      <div class="page-header min-vh-100">
        <div class="container">
          <div class="row">
            <div class="col-xl-4 col-lg-5 col-md-7 d-flex flex-column mx-lg-0 mx-auto">
              <div class="card card-plain">
                <div class="card-body px-lg-5 py-lg-5 text-center">
                  <div class="text-center text-muted mb-4">
                    <h2>2-Step Verification</h2>
                  </div>
                  <div class="row gx-2 gx-sm-3">
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                    <div class="col">
                      <div class="form-group">
                        <input type="text" class="form-control form-control-lg" maxlength="1" autocomplete="off" autocapitalize="off">
                      </div>
                    </div>
                  </div>
                  <div class="text-center">
                    <button type="button" class="btn bg-gradient-warning w-100">Send code</button>
                    <span class="text-muted text-sm">Haven't received it?<a href="javascript:;"> Resend a new code</a>.</span>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-6 d-lg-flex d-none h-100 my-auto pe-0 position-absolute top-0 end-0 text-center justify-content-center flex-column">
              <div class="position-relative bg-gradient-warning h-100 m-3 px-7 border-radius-lg d-flex flex-column justify-content-center">
                <img src="{% static "assets/img/shapes/pattern-lines.svg" %}" alt="pattern-lines" class="position-absolute opacity-4 start-0">
                <div class="position-relative">
                  <img class="max-width-500 w-100 position-relative z-index-2" src="{% static "assets/img/illustrations/danger-chat-ill.png" %}" alt="chart-ill">
                </div>
                <h4 class="mt-5 text-white font-weight-bolder">"Attention is the new currency"</h4>
                <p class="text-white">The more effortless the writing looks, the more effort the writer actually put into the process.</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

{% endblock content %}

{% block footer %}{% endblock footer %}

================
File: templates/includes/configurator.html
================
{% load static %}

<div class="fixed-plugin">
    <!-- <a class="fixed-plugin-button text-dark position-fixed px-3 py-2">
      <i class="fa fa-cog py-2"> </i>
    </a> -->
    <div class="card shadow-lg blur">
      <div class="card-header pb-0 pt-3  bg-transparent ">
        <div class="float-start">
          <h5 class="mt-3 mb-0">Neuralami Configurator</h5>
          <p>See our dashboard options.</p>
        </div>
        <div class="float-end mt-4">
          <button class="btn btn-link text-dark p-0 fixed-plugin-close-button">
            <i class="fa fa-close"></i>
          </button>
        </div>
        <!-- End Toggle Button -->
      </div>
      <hr class="horizontal dark my-1">
      <div class="card-body pt-sm-3 pt-0">
        <!-- Sidebar Backgrounds -->
        <div>
          <h6 class="mb-0">Sidebar Colors</h6>
        </div>
        <a href="javascript:void(0)" class="switch-trigger background-color">
          <div class="badge-colors my-2 text-start">
            <span class="badge filter bg-primary active" data-color="primary" onclick="sidebarColor(this)"></span>
            <span class="badge filter bg-gradient-dark" data-color="dark" onclick="sidebarColor(this)"></span>
            <span class="badge filter bg-gradient-info" data-color="info" onclick="sidebarColor(this)"></span>
            <span class="badge filter bg-gradient-success" data-color="success" onclick="sidebarColor(this)"></span>
            <span class="badge filter bg-gradient-warning" data-color="warning" onclick="sidebarColor(this)"></span>
            <span class="badge filter bg-gradient-danger" data-color="danger" onclick="sidebarColor(this)"></span>
          </div>
        </a>
        <!-- Sidenav Type -->
        <div class="mt-3">
          <h6 class="mb-0">Sidenav Type</h6>
          <p class="text-sm">Choose between 2 different sidenav types.</p>
        </div>
        <div class="d-flex">
          <button class="btn btn-primary w-100 px-3 mb-2 active" data-class="bg-transparent" onclick="sidebarType(this)">Transparent</button>
          <button class="btn btn-primary w-100 px-3 mb-2 ms-2" data-class="bg-white" onclick="sidebarType(this)">White</button>
        </div>
        <p class="text-sm d-xl-none d-block mt-2">You can change the sidenav type just on desktop view.</p>
        <!-- Navbar Fixed -->
        <div class="mt-3">
          <h6 class="mb-0">Navbar Fixed</h6>
        </div>
        <div class="form-check form-switch ps-0">
          <input class="form-check-input mt-1 ms-auto" type="checkbox" id="navbarFixed" onclick="navbarFixed(this)">
        </div>
        <hr class="horizontal dark mb-1 d-xl-block d-none">
        <div class="mt-2 d-xl-block d-none">
          <h6 class="mb-0">Sidenav Mini</h6>
        </div>
        <div class="form-check form-switch ps-0 d-xl-block d-none">
          <input class="form-check-input mt-1 ms-auto" type="checkbox" id="navbarMinimize" onclick="navbarMinimize(this)">
        </div>
        <hr class="horizontal dark mb-1 d-xl-block d-none">
        <div class="mt-2 d-xl-block d-none">
          <h6 class="mb-0">Light/Dark</h6>
        </div>
        <div class="form-check form-switch ps-0 d-xl-block d-none">
          <input class="form-check-input mt-1 ms-auto" type="checkbox" id="dark-version" onclick="darkMode(this)">
        </div>
        <hr class="horizontal dark my-sm-4">

      </div>
    </div>
</div>

<!-- Added script for theme persistence -->
<script>
  // Direct script to handle theme persistence
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded - initializing theme persistence');
    
    // Modify the original functions to save to localStorage
    const originalDarkMode = window.darkMode;
    window.darkMode = function(el) {
      // Call the original function first
      originalDarkMode(el);
      
      // After calling the original function, check if dark mode is actually enabled
      // by checking the body class, which is more reliable than the checkbox attribute
      const isDarkMode = document.body.classList.contains('dark-version');
      
      // Save to localStorage based on the actual state
      localStorage.setItem('darkMode', isDarkMode ? 'true' : 'false');
      console.log('Dark mode saved:', isDarkMode ? 'true' : 'false');
    };
    
    const originalSidebarColor = window.sidebarColor;
    window.sidebarColor = function(a) {
      // Call the original function
      originalSidebarColor(a);
      
      // Save to localStorage
      const color = a.getAttribute("data-color");
      localStorage.setItem('sidebarColor', color);
      console.log('Sidebar color saved:', color);
    };
    
    const originalSidebarType = window.sidebarType;
    window.sidebarType = function(a) {
      // Call the original function
      originalSidebarType(a);
      
      // Save to localStorage
      const type = a.getAttribute("data-class");
      localStorage.setItem('sidebarType', type);
      console.log('Sidebar type saved:', type);
    };
    
    const originalNavbarFixed = window.navbarFixed;
    window.navbarFixed = function(el) {
      // Call the original function
      originalNavbarFixed(el);
      
      // After calling original function, determine fixed state directly
      const navbar = document.getElementById('navbarBlur');
      const isFixed = navbar && navbar.classList.contains('position-sticky');
      
      // Save to localStorage
      localStorage.setItem('navbarFixed', isFixed ? 'true' : 'false');
      console.log('Navbar fixed saved:', isFixed ? 'true' : 'false');
    };
    
    const originalNavbarMinimize = window.navbarMinimize;
    window.navbarMinimize = function(el) {
      // Call the original function
      originalNavbarMinimize(el);
      
      // After calling original function, determine minimized state directly
      const sidenavShow = document.getElementsByClassName('g-sidenav-show')[0];
      const isMinimized = sidenavShow && sidenavShow.classList.contains('g-sidenav-hidden');
      
      // Save to localStorage
      localStorage.setItem('navbarMinimized', isMinimized ? 'true' : 'false');
      console.log('Navbar minimized saved:', isMinimized ? 'true' : 'false');
    };
    
    // Load saved preferences
    try {
      console.log('Loading saved preferences...');
      
      // Dark mode
      const darkModeToggle = document.getElementById('dark-version');
      if (darkModeToggle) {
        const isDarkMode = localStorage.getItem('darkMode') === 'true';
        const currentlyDark = document.body.classList.contains('dark-version');
        
        console.log('Dark mode preference:', isDarkMode, 'Current state:', currentlyDark);
        
        if (isDarkMode !== currentlyDark) {
          console.log('Applying dark mode preference');
          darkModeToggle.click();
        }
      }
      
      // Sidebar color
      const sidebarColor = localStorage.getItem('sidebarColor');
      if (sidebarColor) {
        console.log('Sidebar color preference:', sidebarColor);
        const colorButton = document.querySelector(`.badge-colors .badge[data-color="${sidebarColor}"]`);
        if (colorButton && !colorButton.classList.contains('active')) {
          console.log('Applying sidebar color');
          colorButton.click();
        }
      }
      
      // Sidebar type
      const sidebarType = localStorage.getItem('sidebarType');
      if (sidebarType) {
        console.log('Sidebar type preference:', sidebarType);
        const typeButton = document.querySelector(`.d-flex .btn[data-class="${sidebarType}"]`);
        if (typeButton && !typeButton.classList.contains('active')) {
          console.log('Applying sidebar type');
          typeButton.click();
        }
      }
      
      // Navbar fixed
      const navbarFixedToggle = document.getElementById('navbarFixed');
      if (navbarFixedToggle) {
        const isFixed = localStorage.getItem('navbarFixed') === 'true';
        const navbar = document.getElementById('navbarBlur');
        const currentlyFixed = navbar && navbar.classList.contains('position-sticky');
        
        console.log('Navbar fixed preference:', isFixed, 'Current state:', currentlyFixed);
        
        if (isFixed !== currentlyFixed) {
          console.log('Applying navbar fixed preference');
          navbarFixedToggle.click();
        }
      }
      
      // Navbar minimized
      const navbarMinimizeToggle = document.getElementById('navbarMinimize');
      if (navbarMinimizeToggle) {
        const isMinimized = localStorage.getItem('navbarMinimized') === 'true';
        const sidenavShow = document.getElementsByClassName('g-sidenav-show')[0];
        const currentlyMinimized = sidenavShow && sidenavShow.classList.contains('g-sidenav-hidden');
        
        console.log('Navbar minimized preference:', isMinimized, 'Current state:', currentlyMinimized);
        
        if (isMinimized !== currentlyMinimized) {
          console.log('Applying navbar minimized preference');
          navbarMinimizeToggle.click();
        }
      }
    } catch (error) {
      console.error('Error initializing theme:', error);
    }
  });
</script>

================
File: templates/includes/footer-full.html
================
{% load static %}

<footer class="footer pt-3">
  <div class="container-fluid">
    <div class="row align-items-center justify-content-lg-between">
      <div class="col-lg-6 mb-lg-0 mb-4">
        <div class="copyright text-center text-sm text-muted text-lg-start">
          &copy; 2025 | SEO Manager v{{ VERSION }} | coded by <a href="https://www.neuralami.com" class="font-weight-bold">Neuralami LLC</a>  
          <a href="https://www.neuralami.com/privacy-policy" class="text-muted">| Privacy Policy</a> | 
          <a href="https://www.neuralami.com/terms-and-conditions" class="text-muted">Terms of Service</a>
        </div>
      </div>
      <div class="col-lg-6 mb-lg-0 mb-4 text-center text-lg-end">
        <a href="mailto:support@neuralami.com" class="text-muted">Contact Us</a> | 
        <a href="https://www.facebook.com/neuralamillc" class="text-muted">Facebook</a> | 
        <a href="https://x.com/neuralami" class="text-muted">Twitter</a> | 
        <a href="https://www.linkedin.com/company/neuralami" class="text-muted">LinkedIn</a>
      </div>
    </div>
  </div>
</footer>

================
File: templates/includes/footer.html
================
{% load static %}

<footer class="footer pt-3  ">
  <div class="container-fluid">
    <div class="row align-items-center justify-content-lg-between">
      <div class="col-lg-6 mb-lg-0 mb-4">
        <div class="copyright text-center text-sm text-muted text-lg-start">
          &copy; SEO Manager v{{ VERSION }} | coded by <a href="https://www.neuralami.com" class="font-weight-bold">Neuralami</a>.
          <a href="https://www.neuralami.com/privacy-policy" class="text-muted">| Privacy Policy</a> | 
          <a href="https://www.neuralami.com/terms-and-conditions" class="text-muted">Terms of Service</a>
        </div>
      </div>
      <div class="col-lg-6 mb-lg-0 mb-4 text-center text-lg-end">
        <a href="mailto:support@neuralami.com" class="text-muted">Contact Us</a> | 
        <a href="https://www.facebook.com/neuralamillc" class="text-muted">Facebook</a> | 
        <a href="https://x.com/neuralami" class="text-muted">Twitter</a> | 
        <a href="https://www.linkedin.com/company/neuralami" class="text-muted">LinkedIn</a>
      </div>
    </div>
  </div>
</footer>

================
File: templates/includes/head.html
================
{% load static %}

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<!-- Theme initialization script - Must be at the top of head -->
<script>
  // Apply saved theme immediately to prevent flickering
  (function() {
    try {
      // Check for dark mode preference
      var isDarkMode = localStorage.getItem('darkMode') === 'true';
      if (isDarkMode) {
        // Apply dark mode class immediately to html element
        document.documentElement.classList.add('dark-mode-preload');

        // Add a style block to ensure correct theme during initial page load
        var style = document.createElement('style');
        style.innerHTML = `
          /* Dark mode preload styles */
          html.dark-mode-preload,
          html.dark-mode-preload body,
          html.dark-mode-preload .g-sidenav-show,
          html.dark-mode-preload .sidenav,
          html.dark-mode-preload .card,
          html.dark-mode-preload .bg-gray-100,
          html.dark-mode-preload .bg-gray-200 {
            background-color: #141727 !important;
            color: #fff !important;
            transition: none !important;
          }

          /* Prevent white flash on load */
          html.dark-mode-preload .navbar,
          html.dark-mode-preload .main-content,
          html.dark-mode-preload .fixed-plugin .card,
          html.dark-mode-preload .card-body,
          html.dark-mode-preload .card-header {
            background-color: #1a2035 !important;
            color: #fff !important;
          }

          /* Ensure text is visible */
          html.dark-mode-preload h1,
          html.dark-mode-preload h2,
          html.dark-mode-preload h3,
          html.dark-mode-preload h4,
          html.dark-mode-preload h5,
          html.dark-mode-preload h6,
          html.dark-mode-preload p,
          html.dark-mode-preload span:not(.badge) {
            color: rgba(255, 255, 255, 0.8) !important;
          }

          /* Fix text-dark elements in dark mode preload */
          html.dark-mode-preload .text-dark,
          html.dark-mode-preload .btn-link.text-dark,
          html.dark-mode-preload i.text-dark,
          html.dark-mode-preload .fas.text-dark {
            color: rgba(255, 255, 255, 0.9) !important;
          }

          /* Fix social login buttons in dark mode preload */
          html.dark-mode-preload .btn-outline-light svg {
            fill: #fff !important;
          }
        `;
        document.head.appendChild(style);

        // Add class to body as soon as it's available
        document.addEventListener('DOMContentLoaded', function() {
          document.body.classList.add('dark-version');
        });
      }
    } catch (e) {
      console.error('Error in theme preload script:', e);
    }
  })();
</script>

<!-- Additional dark mode styles for better text contrast -->
<style>
  /* Improve text contrast in dark mode */
  body.dark-version .navbar-nav .nav-link,
  body.dark-version a.nav-link,
  body.dark-version .navbar a,
  body.dark-version header a {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  /* Ensure header action links are visible */
  body.dark-version .navbar-nav a:hover,
  body.dark-version header a:hover,
  body.dark-version .nav-link:hover {
    color: #fff !important;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  }

  /* Make row details text more readable */
  body.dark-version td,
  body.dark-version .table-responsive td,
  body.dark-version .dataTables_wrapper td {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  /* Improve readability of small text and details */
  body.dark-version .text-xs,
  body.dark-version .text-sm,
  body.dark-version small,
  body.dark-version .small {
    color: rgba(255, 255, 255, 0.85) !important;
  }

  /* Fix for "Change Password" and header links */
  body.dark-version .navbar-nav .nav-item .nav-link.text-body,
  body.dark-version .text-body {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  /* Fix for buttons and icons with text-dark class */
  body.dark-version .btn-link.text-dark,
  body.dark-version a.text-dark,
  body.dark-version .text-dark {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  body.dark-version i.text-dark,
  body.dark-version .fas.text-dark,
  body.dark-version .far.text-dark,
  body.dark-version .fal.text-dark,
  body.dark-version .fad.text-dark,
  body.dark-version .fab.text-dark {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  /* Fix Details buttons specifically */
  body.dark-version a.btn-link.text-dark {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  body.dark-version a.btn-link.text-dark:hover {
    color: #ffffff !important;
    text-decoration: underline;
  }

  /* Additional dropdown menu fixes */
  body.dark-version .dropdown-menu {
    background-color: #1a2035 !important;
  }

  body.dark-version .dropdown-item {
    color: rgba(255, 255, 255, 0.9) !important;
  }

  body.dark-version .dropdown-item:hover {
    background-color: #252f4a !important;
  }

  /* Fix social login buttons in dark mode */
  body.dark-version .btn-outline-light {
    border-color: rgba(255, 255, 255, 0.8);
    color: #fff;
  }

  body.dark-version .btn-outline-light:hover {
    background-color: rgba(255, 255, 255, 0.1);
  }

  body.dark-version .btn-outline-light svg {
    fill: #fff !important;
  }
</style>

<link rel="apple-touch-icon" sizes="76x76" href="{% static "assets/img/apple-icon.png" %}">
<link rel="icon" type="image/png" href="{% static "assets/img/favicon.png" %}">
<title>
  {% if page_title %}{{ page_title }} | Neuralami{% else %}Neuralami{% endif %}
</title>
<!--     Fonts and icons     -->
<link href="https://fonts.googleapis.com/css?family=Inter:300,400,500,600,700,800" rel="stylesheet" />
<!-- Nucleo Icons -->
<link href="https://demos.creative-tim.com/argon-dashboard-pro/assets/css/nucleo-icons.css" rel="stylesheet" />
<link href="https://demos.creative-tim.com/argon-dashboard-pro/assets/css/nucleo-svg.css" rel="stylesheet" />
<!-- Font Awesome Icons -->
<script src="{% static "assets/js/plugins/font-awesome6.4.0.min.js" %}" crossorigin="anonymous"></script>
<!-- CSS Files -->
<link id="pagestyle" href="{% static "assets/css/soft-ui-dashboard.css" %}?v={% now 'U' %}" rel="stylesheet" />
<!-- Custom fixes for theme issues -->
<link href="{% static "assets/css/custom-fixes.css" %}?v={% now 'U' %}" rel="stylesheet" />

================
File: templates/includes/items-table.html
================
{% load get_attribute %}

<div class="dt-responsive table-responsive">
    <table class="table">
        <thead>
          <tr>
            {% for field in db_field_names %}
                <th id="th_{{ field }}_export" scope="col">{{ field }}</th>
            {% endfor %}
          </tr>
        </thead>
        <tbody>
            {% for item in items %}
            <tr>
                {% for field_name in db_field_names %}
                    <td class="td_{{ field_name }}">{{ item|getattribute:field_name }}</td>
                {% endfor %}
            </tr>
             {% endfor %}
        </tbody>
    </table>
</div>

================
File: templates/includes/navigation-full.html
================
{% load static replace_value %}

<nav class="navbar navbar-main navbar-expand-lg position-sticky mt-4 top-1 px-0 mx-4 shadow-none border-radius-xl z-index-sticky" id="navbarBlur" data-scroll="true">
  <div class="container-fluid py-1 px-3">
    <!-- Sidenav toggler -->
    <div class="sidenav-toggler sidenav-toggler-inner d-xl-block d-none me-2">
      <a href="javascript:;" class="nav-link text-body p-0">
        <div class="sidenav-toggler-inner">
          <i class="sidenav-toggler-line"></i>
          <i class="sidenav-toggler-line"></i>
          <i class="sidenav-toggler-line"></i>
        </div>
      </a>
    </div>

    <!-- Breadcrumb -->
    <nav aria-label="breadcrumb">
      <ol class="breadcrumb bg-transparent mb-0 pb-0 pt-1 px-0 me-sm-6 me-5">
        <li class="breadcrumb-item text-sm"><a class="opacity-5 text-dark" href="javascript:;">Pages</a></li>
        <li class="breadcrumb-item text-sm text-dark active" aria-current="page">{{ segment|replace_value:"_" }}</li>
      </ol>
    </nav>

    <!-- Search and Navigation Items -->
    <div class="collapse navbar-collapse mt-sm-0 mt-2 me-md-0 me-sm-4" id="navbar">
      <!-- Search -->
      <div class="ms-md-auto pe-md-3 d-flex align-items-center">
        <div class="input-group">
          <span class="input-group-text text-body"><i class="fas fa-search" aria-hidden="true"></i></span>
          <input type="text" class="form-control" placeholder="Type here...">
        </div>
      </div>

      <!-- Navigation Items -->
      <ul class="navbar-nav justify-content-end">
        {% if request.user.is_authenticated %}
        <li class="nav-item d-flex align-items-center me-3">
          <a href="{% url 'password_change' %}" class="nav-link text-body font-weight-bold px-0">
            <i class="fa fa-edit me-sm-1"></i>
            <span class="d-sm-inline d-none">Change Password</span>
          </a>
        </li>
        {% endif %}
        
        <!-- Authentication -->
        <li class="nav-item d-flex align-items-center">
          {% if request.user.is_authenticated %}
          <a href="{% url 'logout' %}" class="nav-link text-body font-weight-bold px-0">
            <i class="fa fa-user me-sm-1"></i>
            <span class="d-sm-inline d-none">Logout</span>
          </a>
          {% else %}
          <a href="{% url 'basic_login' %}" class="nav-link text-body font-weight-bold px-0">
            <i class="fa fa-user me-sm-1"></i>
            <span class="d-sm-inline d-none">Sign In</span>
          </a>
          {% endif %}
        </li>

        <!-- Mobile Sidenav Toggle -->
        <li class="nav-item d-xl-none ps-3 d-flex align-items-center">
          <a href="javascript:;" class="nav-link text-body p-0" id="iconNavbarSidenav">
            <div class="sidenav-toggler-inner">
              <i class="sidenav-toggler-line"></i>
              <i class="sidenav-toggler-line"></i>
              <i class="sidenav-toggler-line"></i>
            </div>
          </a>
        </li>

        <!-- Settings -->
        <li class="nav-item px-3 d-flex align-items-center">
          <a href="javascript:;" class="nav-link text-body p-0">
            <i class="fa fa-cog fixed-plugin-button-nav cursor-pointer"></i>
          </a>
        </li>
      </ul>
    </div>
  </div>
</nav>

================
File: templates/includes/navigation-shadow.html
================
{% load static %}

<nav class="navbar navbar-expand-lg  blur blur-rounded top-0  z-index-3 shadow position-absolute my-3 py-2 start-0 end-0 mx-4">
    <div class="container-fluid">
      <a class="navbar-brand font-weight-bolder ms-lg-0 ms-3 " href="{% url "index" %}">
        Neuralami
      </a>
      <button class="navbar-toggler shadow-none ms-2" type="button" data-bs-toggle="collapse" data-bs-target="#navigation" aria-controls="navigation" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon mt-2">
          <span class="navbar-toggler-bar bar1"></span>
          <span class="navbar-toggler-bar bar2"></span>
          <span class="navbar-toggler-bar bar3"></span>
        </span>
      </button>
      <div class="collapse navbar-collapse w-100 pt-3 pb-2 py-lg-0" id="navigation">
        <ul class="navbar-nav navbar-nav-hover mx-auto">
          <li class="nav-item dropdown dropdown-hover mx-2">
            <a role="button" class="nav-link ps-2 d-flex justify-content-between cursor-pointer align-items-center " id="dropdownMenuPages" data-bs-toggle="dropdown" aria-expanded="false">
              Pages
              <img src=" {% static "assets/img/down-arrow-dark.svg" %}  " alt="down-arrow" class="arrow ms-1 d-lg-block d-none">
              <img src="{% static "assets/img/down-arrow-dark.svg" %}" alt="down-arrow" class="arrow ms-1 d-lg-none d-block">
            </a>
            <div class="dropdown-menu dropdown-menu-animation dropdown-xl p-3 border-radius-xl mt-0 mt-lg-3" aria-labelledby="dropdownMenuPages">
              <div class="row d-none d-lg-block">
                <div class="col-12 px-4 py-2">
                  <div class="row">
                    <div class="col-4 position-relative">
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                            <svg width="12px" height="12px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>spaceship</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(4.000000, 301.000000)">
                                      <path class="color-background" d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                                      <path class="color-background" d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                                      <path class="color-background" d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                                      <path class="color-background" d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Dashboards
                      </div>
                      <a href="{% url "index" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Default</span>
                      </a>
                      <a href="{% url "automotive" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Automotive</span>
                      </a>
                      <a href="{% url "smart_home" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Smart Home</span>
                      </a>
                      <a href="{% url "vr_default" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Virtual Reality</span>
                      </a>
                      <a href="{% url "crm" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">CRM</span>
                      </a>
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                            <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>office</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1869.000000, -293.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(153.000000, 2.000000)">
                                      <path d="M12.25,17.5 L8.75,17.5 L8.75,1.75 C8.75,0.78225 9.53225,0 10.5,0 L31.5,0 C32.46775,0 33.25,0.78225 33.25,1.75 L33.25,12.25 L29.75,12.25 L29.75,3.5 L12.25,3.5 L12.25,17.5 Z" opacity="0.6"></path>
                                      <path d="M40.25,14 L24.5,14 C23.53225,14 22.75,14.78225 22.75,15.75 L22.75,38.5 L19.25,38.5 L19.25,22.75 C19.25,21.78225 18.46775,21 17.5,21 L1.75,21 C0.78225,21 0,21.78225 0,22.75 L0,40.25 C0,41.21775 0.78225,42 1.75,42 L40.25,42 C41.21775,42 42,41.21775 42,40.25 L42,15.75 C42,14.78225 41.21775,14 40.25,14 Z M12.25,36.75 L7,36.75 L7,33.25 L12.25,33.25 L12.25,36.75 Z M12.25,29.75 L7,29.75 L7,26.25 L12.25,26.25 L12.25,29.75 Z M35,36.75 L29.75,36.75 L29.75,33.25 L35,33.25 L35,36.75 Z M35,29.75 L29.75,29.75 L29.75,26.25 L35,26.25 L35,29.75 Z M35,22.75 L29.75,22.75 L29.75,19.25 L35,19.25 L35,22.75 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Users
                      </div>
                      <a href="{% url "reports" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Reports</span>
                      </a>
                      <a href="{% url "new_user" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">New User</span>
                      </a>
                      <hr class="vertical dark">
                    </div>
                    <div class="col-4 position-relative">
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                            <svg width="12px" height="12px" viewBox="0 0 45 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>shop </title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1716.000000, -439.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(0.000000, 148.000000)">
                                      <path d="M46.7199583,10.7414583 L40.8449583,0.949791667 C40.4909749,0.360605034 39.8540131,0 39.1666667,0 L7.83333333,0 C7.1459869,0 6.50902508,0.360605034 6.15504167,0.949791667 L0.280041667,10.7414583 C0.0969176761,11.0460037 -1.23209662e-05,11.3946378 -1.23209662e-05,11.75 C-0.00758042603,16.0663731 3.48367543,19.5725301 7.80004167,19.5833333 L7.81570833,19.5833333 C9.75003686,19.5882688 11.6168794,18.8726691 13.0522917,17.5760417 C16.0171492,20.2556967 20.5292675,20.2556967 23.494125,17.5760417 C26.4604562,20.2616016 30.9794188,20.2616016 33.94575,17.5760417 C36.2421905,19.6477597 39.5441143,20.1708521 42.3684437,18.9103691 C45.1927731,17.649886 47.0084685,14.8428276 47.0000295,11.75 C47.0000295,11.3946378 46.9030823,11.0460037 46.7199583,10.7414583 Z" opacity="0.598981585"></path>
                                      <path d="M39.198,22.4912623 C37.3776246,22.4928106 35.5817531,22.0149171 33.951625,21.0951667 L33.92225,21.1107282 C31.1430221,22.6838032 27.9255001,22.9318916 24.9844167,21.7998837 C24.4750389,21.605469 23.9777983,21.3722567 23.4960833,21.1018359 L23.4745417,21.1129513 C20.6961809,22.6871153 17.4786145,22.9344611 14.5386667,21.7998837 C14.029926,21.6054643 13.533337,21.3722507 13.0522917,21.1018359 C11.4250962,22.0190609 9.63246555,22.4947009 7.81570833,22.4912623 C7.16510551,22.4842162 6.51607673,22.4173045 5.875,22.2911849 L5.875,44.7220845 C5.875,45.9498589 6.7517757,46.9451667 7.83333333,46.9451667 L19.5833333,46.9451667 L19.5833333,33.6066734 L27.4166667,33.6066734 L27.4166667,46.9451667 L39.1666667,46.9451667 C40.2482243,46.9451667 41.125,45.9498589 41.125,44.7220845 L41.125,22.2822926 C40.4887822,22.4116582 39.8442868,22.4815492 39.198,22.4912623 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Profile
                      </div>
                      <a href="{% url "profile_overview" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Overview</span>
                      </a>
                      <a href="{% url "teams" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Teams</span>
                      </a>
                      <a href="{% url "projects" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Projects</span>
                      </a>
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                            <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>box-3d-50</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(603.000000, 0.000000)">
                                      <path d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                      <path d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                      <path d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Projects
                      </div>
                      <a href="{% url "general" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">General</span>
                      </a>
                      <a href="{% url "timeline" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Timeline</span>
                      </a>
                      <a href="{% url "new_project" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">New Project</span>
                      </a>
                      <hr class="vertical dark">
                    </div>
                    <div class="col-4">
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                            <svg width="12px" height="12px" viewBox="0 0 46 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>customer-support</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1717.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(1.000000, 0.000000)">
                                      <path class="color-background" d="M45,0 L26,0 C25.447,0 25,0.447 25,1 L25,20 C25,20.379 25.214,20.725 25.553,20.895 C25.694,20.965 25.848,21 26,21 C26.212,21 26.424,20.933 26.6,20.8 L34.333,15 L45,15 C45.553,15 46,14.553 46,14 L46,1 C46,0.447 45.553,0 45,0 Z" opacity="0.59858631"></path>
                                      <path class="color-foreground" d="M22.883,32.86 C20.761,32.012 17.324,31 13,31 C8.676,31 5.239,32.012 3.116,32.86 C1.224,33.619 0,35.438 0,37.494 L0,41 C0,41.553 0.447,42 1,42 L25,42 C25.553,42 26,41.553 26,41 L26,37.494 C26,35.438 24.776,33.619 22.883,32.86 Z"></path>
                                      <path class="color-foreground" d="M13,28 C17.432,28 21,22.529 21,18 C21,13.589 17.411,10 13,10 C8.589,10 5,13.589 5,18 C5,22.529 8.568,28 13,28 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Account
                      </div>
                      <a href="{% url "settings" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Settings</span>
                      </a>
                      <a href="{% url "billing" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Billing</span>
                      </a>
                      <a href="{% url "invoice" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Invoice</span>
                      </a>
                      <a href="{% url "security" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Security</span>
                      </a>
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                            <svg width="12px" height="12px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>document</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(154.000000, 300.000000)">
                                      <path d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                      <path d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Extra
                      </div>
                      <a href="{% url "pricing" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Pricing Page</span>
                      </a>
                      <a href="{% url "messages" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Messages</span>
                      </a>
                      <a href="{% url "rtl" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">RTL Page</span>
                      </a>
                      <a href="{% url "widgets" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Widgets</span>
                      </a>
                    </div>
                  </div>
                </div>
              </div>
              <!-- responsive -->
              <div class="d-lg-none">
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                      <svg width="12px" height="12px" viewBox="0 0 45 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>shop </title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1716.000000, -439.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(0.000000, 148.000000)">
                                <path d="M46.7199583,10.7414583 L40.8449583,0.949791667 C40.4909749,0.360605034 39.8540131,0 39.1666667,0 L7.83333333,0 C7.1459869,0 6.50902508,0.360605034 6.15504167,0.949791667 L0.280041667,10.7414583 C0.0969176761,11.0460037 -1.23209662e-05,11.3946378 -1.23209662e-05,11.75 C-0.00758042603,16.0663731 3.48367543,19.5725301 7.80004167,19.5833333 L7.81570833,19.5833333 C9.75003686,19.5882688 11.6168794,18.8726691 13.0522917,17.5760417 C16.0171492,20.2556967 20.5292675,20.2556967 23.494125,17.5760417 C26.4604562,20.2616016 30.9794188,20.2616016 33.94575,17.5760417 C36.2421905,19.6477597 39.5441143,20.1708521 42.3684437,18.9103691 C45.1927731,17.649886 47.0084685,14.8428276 47.0000295,11.75 C47.0000295,11.3946378 46.9030823,11.0460037 46.7199583,10.7414583 Z" opacity="0.598981585"></path>
                                <path d="M39.198,22.4912623 C37.3776246,22.4928106 35.5817531,22.0149171 33.951625,21.0951667 L33.92225,21.1107282 C31.1430221,22.6838032 27.9255001,22.9318916 24.9844167,21.7998837 C24.4750389,21.605469 23.9777983,21.3722567 23.4960833,21.1018359 L23.4745417,21.1129513 C20.6961809,22.6871153 17.4786145,22.9344611 14.5386667,21.7998837 C14.029926,21.6054643 13.533337,21.3722507 13.0522917,21.1018359 C11.4250962,22.0190609 9.63246555,22.4947009 7.81570833,22.4912623 C7.16510551,22.4842162 6.51607673,22.4173045 5.875,22.2911849 L5.875,44.7220845 C5.875,45.9498589 6.7517757,46.9451667 7.83333333,46.9451667 L19.5833333,46.9451667 L19.5833333,33.6066734 L27.4166667,33.6066734 L27.4166667,46.9451667 L39.1666667,46.9451667 C40.2482243,46.9451667 41.125,45.9498589 41.125,44.7220845 L41.125,22.2822926 C40.4887822,22.4116582 39.8442868,22.4815492 39.198,22.4912623 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Dashboards
                </div>
                <a href="{% url "index" %}" class="dropdown-item border-radius-md">
                  Default
                </a>
                <a href="{% url "automotive" %}" class="dropdown-item border-radius-md">
                  Automotive
                </a>
                <a href="{% url "smart_home" %}" class="dropdown-item border-radius-md">
                  Smart Home
                </a>
                <a href="{% url "vr_default" %}" class="dropdown-item border-radius-md">
                  Virtual Reality
                </a>
                <a href="{% url "crm" %}" class="dropdown-item border-radius-md">
                  CRM
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>office</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1869.000000, -293.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(153.000000, 2.000000)">
                                <path d="M12.25,17.5 L8.75,17.5 L8.75,1.75 C8.75,0.78225 9.53225,0 10.5,0 L31.5,0 C32.46775,0 33.25,0.78225 33.25,1.75 L33.25,12.25 L29.75,12.25 L29.75,3.5 L12.25,3.5 L12.25,17.5 Z" opacity="0.6"></path>
                                <path d="M40.25,14 L24.5,14 C23.53225,14 22.75,14.78225 22.75,15.75 L22.75,38.5 L19.25,38.5 L19.25,22.75 C19.25,21.78225 18.46775,21 17.5,21 L1.75,21 C0.78225,21 0,21.78225 0,22.75 L0,40.25 C0,41.21775 0.78225,42 1.75,42 L40.25,42 C41.21775,42 42,41.21775 42,40.25 L42,15.75 C42,14.78225 41.21775,14 40.25,14 Z M12.25,36.75 L7,36.75 L7,33.25 L12.25,33.25 L12.25,36.75 Z M12.25,29.75 L7,29.75 L7,26.25 L12.25,26.25 L12.25,29.75 Z M35,36.75 L29.75,36.75 L29.75,33.25 L35,33.25 L35,36.75 Z M35,29.75 L29.75,29.75 L29.75,26.25 L35,26.25 L35,29.75 Z M35,22.75 L29.75,22.75 L29.75,19.25 L35,19.25 L35,22.75 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Users
                </div>
                <a href="{% url "reports" %}" class="dropdown-item border-radius-md">
                  Reports
                </a>
                <a href="{% url "new_user" %}" class="dropdown-item border-radius-md">
                  New user
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 46 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>customer-support</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1717.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(1.000000, 0.000000)">
                                <path class="color-background" d="M45,0 L26,0 C25.447,0 25,0.447 25,1 L25,20 C25,20.379 25.214,20.725 25.553,20.895 C25.694,20.965 25.848,21 26,21 C26.212,21 26.424,20.933 26.6,20.8 L34.333,15 L45,15 C45.553,15 46,14.553 46,14 L46,1 C46,0.447 45.553,0 45,0 Z" opacity="0.59858631"></path>
                                <path class="color-foreground" d="M22.883,32.86 C20.761,32.012 17.324,31 13,31 C8.676,31 5.239,32.012 3.116,32.86 C1.224,33.619 0,35.438 0,37.494 L0,41 C0,41.553 0.447,42 1,42 L25,42 C25.553,42 26,41.553 26,41 L26,37.494 C26,35.438 24.776,33.619 22.883,32.86 Z"></path>
                                <path class="color-foreground" d="M13,28 C17.432,28 21,22.529 21,18 C21,13.589 17.411,10 13,10 C8.589,10 5,13.589 5,18 C5,22.529 8.568,28 13,28 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Profile
                </div>
                <a href="{% url "profile_overview" %}" class="dropdown-item border-radius-md">
                  Overview
                </a>
                <a href="{% url "teams" %}" class="dropdown-item border-radius-md">
                  Teams
                </a>
                <a href="{% url "projects" %}" class="dropdown-item border-radius-md">
                  Projects
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>box-3d-50</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(603.000000, 0.000000)">
                                <path d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                <path d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                <path d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Projects
                </div>
                <a href="{% url "general" %}" class="dropdown-item border-radius-md">
                  General
                </a>
                <a href="{% url "timeline" %}" class="dropdown-item border-radius-md">
                  Timeline
                </a>
                <a href="{% url "new_project" %}" class="dropdown-item border-radius-md">
                  New Project
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>document</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(154.000000, 300.000000)">
                                <path d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                <path d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Account
                </div>
                <a href="{% url "settings" %}" class="dropdown-item border-radius-md">
                  Settings
                </a>
                <a href="{% url "billing" %}" class="dropdown-item border-radius-md">
                  Billing
                </a>
                <a href="{% url "invoice" %}" class="dropdown-item border-radius-md">
                  Invoice
                </a>
                <a href="{% url "security" %}" class="dropdown-item border-radius-md">
                  Security
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg class="" width="12px" height="20px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>spaceship</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(4.000000, 301.000000)">
                                <path d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                                <path d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                                <path d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                                <path d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Extra
                </div>
                <a href="{% url "pricing" %}" class="dropdown-item border-radius-md">
                  Pricing Page
                </a>
                <a href="{% url "messages" %}" class="dropdown-item border-radius-md">
                  Messages
                </a>
                <a href="{% url "rtl" %}" class="dropdown-item border-radius-md">
                  RTL Page
                </a>
                <a href="{% url "widgets" %}" class="dropdown-item border-radius-md">
                  Widgets
                </a>
              </div>
            </div>
          </li>
          <li class="nav-item dropdown dropdown-hover mx-2">
            <a role="button" class="nav-link ps-2 d-flex justify-content-between cursor-pointer align-items-center " id="dropdownMenuAccount" data-bs-toggle="dropdown" aria-expanded="false">
              Authentication
              <img src=" {% static "assets/img/down-arrow-dark.svg" %} " alt="down-arrow" class="arrow ms-1 d-lg-block d-none">
              <img src="{% static "assets/img/down-arrow-dark.svg" %}" alt="down-arrow" class="arrow ms-1 d-lg-none d-block">
            </a>
            <div class="dropdown-menu dropdown-menu-animation dropdown-lg border-radius-xl p-3 mt-0 mt-lg-3" aria-labelledby="dropdownMenuAccount">
              <div class="row d-none d-lg-flex">
                <div class="col-6">
                  <div class="py-6 h-100 w-100 d-flex border-radius-lg position-relative dropdown-image" style="background-image:url('{% static "assets/img/curved-images/curved8.jpg" %}')">
                    <div class="mask bg-primary border-radius-lg"></div>
                    <div class="d-flex justify-content-center align-items-center text-center text-white font-weight-bold w-100 z-index-1 flex-column">
                      <div class="icon icon-shape rounded-circle bg-white shadow text-center">
                        <i class="ni ni-diamond text-primary text-gradient text-lg" aria-hidden="true"></i>
                      </div>
                      <span class="text-lg mt-2">Explore our<br>utilities pages</span>
                    </div>
                  </div>
                </div>
                <div class="col-6 ps-0 d-flex justify-content-center flex-column">
                  <ul class="list-group">
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdownSignIn">
                        <span>Sign In</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdownSignIn">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "basic_login" %}">
                          <span>Basic</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "cover_login" %}">
                          <span>Cover</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "illustration_login" %}">
                          <span>Illustration</span>
                        </a>
                      </div>
                    </li>
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdownSignUp">
                        <span>Sign Up</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdownSignUp">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "basic_register" %}">
                          <span>Basic</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "cover_register" %}">
                          <span>Cover</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "illustration_register" %}">
                          <span>Illustration</span>
                        </a>
                      </div>
                    </li>
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdownPasswordReset">
                        <span>Reset Password</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdownPasswordReset">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "basic_reset" %}">
                          <span>Basic</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "cover_reset" %}">
                          <span>Cover</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "illustration_reset" %}">
                          <span>Illustration</span>
                        </a>
                      </div>
                    </li>
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdownLock">
                        <span>Lock</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdownLock">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "basic_lock" %}">
                          <span>Basic</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "cover_lock" %}">
                          <span>Cover</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "illustration_lock" %}">
                          <span>Illustration</span>
                        </a>
                      </div>
                    </li>
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdown2fa">
                        <span>2-Step Verification</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdown2fa">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="basic_verification">
                          <span>Basic</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "cover_verification" %}">
                          <span>Cover</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "illustration_verification" %}">
                          <span>Illustration</span>
                        </a>
                      </div>
                    </li>
                    <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                      <a class="dropdown-item border-radius-md ps-3 d-flex align-items-center justify-content-between mb-1" id="dropdownError">
                        <span>Error</span>
                        <img src="{% static "assets/img/down-arrow.svg" %}" alt="down-arrow" class="arrow">
                      </a>
                      <div class="dropdown-menu mt-0 py-3 px-2" aria-labelledby="dropdownError">
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "error_404" %}">
                          <span>404</span>
                        </a>
                        <a class="dropdown-item ps-3 border-radius-md mb-1" href="{% url "error_500" %}">
                          <span>500</span>
                        </a>
                      </div>
                    </li>
                  </ul>
                </div>
              </div>
              <div class="row d-lg-none">
                <div class="col-12 d-flex justify-content-center flex-column">
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                    Sign In
                  </h6>
                  <a href="{% url "basic_login" %}" class="dropdown-item border-radius-md">
                    Basic
                  </a>
                  <a href="{% url "cover_login" %}" class="dropdown-item border-radius-md">
                    Cover
                  </a>
                  <a href="{% url "illustration_login" %}" class="dropdown-item border-radius-md">
                    Illustration
                  </a>
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                    Sign Up
                  </h6>
                  <a href="{% url "basic_register" %}" class="dropdown-item border-radius-md">
                    Basic
                  </a>
                  <a href="{% url "cover_register" %}" class="dropdown-item border-radius-md">
                    Cover
                  </a>
                  <a href="{% url "illustration_register" %}" class="dropdown-item border-radius-md">
                    Illustration
                  </a>
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                    Reset Password
                  </h6>
                  <a href="{% url "basic_reset" %}" class="dropdown-item border-radius-md">
                    Basic
                  </a>
                  <a href="{% url "cover_reset" %}" class="dropdown-item border-radius-md">
                    Cover
                  </a>
                  <a href="{% url "illustration_reset" %}" class="dropdown-item border-radius-md">
                    Illustation
                  </a>
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                    Lock
                  </h6>
                  <a href="{% url "basic_lock" %}" class="dropdown-item border-radius-md">
                    Basic
                  </a>
                  <a href="{% url "cover_lock" %}" class="dropdown-item border-radius-md">
                    Cover
                  </a>
                  <a href="{% url "illustration_lock" %}" class="dropdown-item border-radius-md">
                    Illustration
                  </a>
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                    2-Step Verification
                  </h6>
                  <a href="basic_verification" class="dropdown-item border-radius-md">
                    Basic
                  </a>
                  <a href="{% url "cover_verification" %}" class="dropdown-item border-radius-md">
                    Cover
                  </a>
                  <a href="{% url "illustration_verification" %}" class="dropdown-item border-radius-md">
                    Illustration
                  </a>
                  <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center mt-3 px-0">
                    Error
                  </h6>
                  <a href="{% url "error_404" %}" class="dropdown-item border-radius-md">
                    404
                  </a>
                  <a href="{% url "error_500" %}" class="dropdown-item border-radius-md">
                    500
                  </a>
                </div>
              </div>
            </div>
          </li>
          <li class="nav-item dropdown dropdown-hover mx-2">
            <a role="button" class="nav-link ps-2 d-flex justify-content-between cursor-pointer align-items-center " id="dropdownMenuBlocks" data-bs-toggle="dropdown" aria-expanded="false">
              Applications
              <img src=" {% static "assets/img/down-arrow-dark.svg" %} " alt="down-arrow" class="arrow ms-1 d-lg-block d-none">
              <img src="{% static "assets/img/down-arrow-dark.svg" %}" alt="down-arrow" class="arrow ms-1 d-lg-none d-block">
            </a>
            <div class="dropdown-menu dropdown-menu-animation dropdown-md dropdown-md-responsive p-3 border-radius-lg mt-0 mt-lg-3" aria-labelledby="dropdownMenuBlocks">
              <div class="d-none d-lg-block">
                <ul class="list-group">
                  <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="{% url "kanban" %}">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <i class="ni ni-single-copy-04 text-gradient text-primary"></i>
                        </div>
                        <div class="w-100 d-flex align-items-center justify-content-between">
                          <div>
                            <p class="dropdown-header text-dark p-0">Kanban</p>
                          </div>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="{% url "wizard" %}">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <i class="ni ni-laptop text-gradient text-primary"></i>
                        </div>
                        <div class="w-100 d-flex align-items-center justify-content-between">
                          <div>
                            <p class="dropdown-header text-dark p-0">Wizard</p>
                          </div>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="{% url "datatables" %}">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <i class="ni ni-badge text-gradient text-primary"></i>
                        </div>
                        <div class="w-100 d-flex align-items-center justify-content-between">
                          <div>
                            <p class="dropdown-header text-dark p-0">DataTables</p>
                          </div>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item dropdown dropdown-hover dropdown-subitem list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="{% url "calendar" %}">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <i class="ni ni-notification-70 text-gradient text-primary"></i>
                        </div>
                        <div class="w-100 d-flex align-items-center justify-content-between">
                          <div>
                            <p class="dropdown-header text-dark p-0">Calendar</p>
                          </div>
                        </div>
                      </div>
                    </a>
                  </li>
                </ul>
              </div>
              <!-- responsive -->
              <div class="row d-lg-none">
                <div class="col-md-12">
                  <a class="py-2 ps-3 border-radius-md" href="{% url "kanban" %}">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <i class="ni ni-single-copy-04 text-gradient text-primary"></i>
                      </div>
                      <div class="w-100 d-flex align-items-center justify-content-between">
                        <div>
                          <p class="dropdown-header text-dark p-0">Kanban</p>
                        </div>
                      </div>
                    </div>
                  </a>
                  <a class="py-2 ps-3 border-radius-md" href="{% url "wizard" %}">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <i class="ni ni-laptop text-gradient text-primary"></i>
                      </div>
                      <div class="w-100 d-flex align-items-center justify-content-between">
                        <div>
                          <p class="dropdown-header text-dark p-0">Wizard</p>
                        </div>
                      </div>
                    </div>
                  </a>
                  <a class="py-2 ps-3 border-radius-md" href="{% url "datatables" %}">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <i class="ni ni-badge text-gradient text-primary"></i>
                      </div>
                      <div class="w-100 d-flex align-items-center justify-content-between">
                        <div>
                          <p class="dropdown-header text-dark p-0">DataTables</p>
                        </div>
                      </div>
                    </div>
                  </a>
                  <a class="py-2 ps-3 border-radius-md" href="{% url "calendar" %}">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <i class="ni ni-notification-70 text-gradient text-primary"></i>
                      </div>
                      <div class="w-100 d-flex align-items-center justify-content-between">
                        <div>
                          <p class="dropdown-header text-dark p-0">Calendar</p>
                        </div>
                      </div>
                    </div>
                  </a>
                </div>
              </div>
            </div>
          </li>
          <li class="nav-item dropdown dropdown-hover mx-2">
            <a role="button" class="nav-link ps-2 d-flex justify-content-between cursor-pointer align-items-center " id="dropdownMenuEcommerce" data-bs-toggle="dropdown" aria-expanded="false">
              Ecommerce
              <img src=" {% static "assets/img/down-arrow-dark.svg" %}  " alt="down-arrow" class="arrow ms-1 d-lg-block d-none">
              <img src="{% static "assets/img/down-arrow-dark.svg" %}" alt="down-arrow" class="arrow ms-1 d-lg-none d-block">
            </a>
            <div class="dropdown-menu dropdown-menu-animation dropdown-lg p-3 border-radius-xl mt-0 mt-lg-3" aria-labelledby="dropdownMenuEcommerce">
              <div class="row d-none d-lg-block">
                <div class="col-12 px-4 py-2">
                  <div class="row">
                    <div class="col-6 position-relative">
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                            <svg width="12px" height="12px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>document</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(154.000000, 300.000000)">
                                      <path d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                      <path d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Orders
                      </div>
                      <a href="{% url "order_list" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Order List</span>
                      </a>
                      <a href="{% url "order_details" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Order Details</span>
                      </a>
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                            <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>box-3d-50</title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(603.000000, 0.000000)">
                                      <path d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                      <path d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                      <path d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        General
                      </div>
                      <a href="{% url "overview" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Overview</span>
                      </a>
                      <a href="{% url "referral" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Referral</span>
                      </a>
                      <hr class="vertical dark">
                    </div>
                    <div class="col-6 position-relative">
                      <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                        <div class="d-inline-block">
                          <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                            <svg width="12px" height="12px" viewBox="0 0 45 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                              <title>shop </title>
                              <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                                <g transform="translate(-1716.000000, -439.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                  <g transform="translate(1716.000000, 291.000000)">
                                    <g transform="translate(0.000000, 148.000000)">
                                      <path d="M46.7199583,10.7414583 L40.8449583,0.949791667 C40.4909749,0.360605034 39.8540131,0 39.1666667,0 L7.83333333,0 C7.1459869,0 6.50902508,0.360605034 6.15504167,0.949791667 L0.280041667,10.7414583 C0.0969176761,11.0460037 -1.23209662e-05,11.3946378 -1.23209662e-05,11.75 C-0.00758042603,16.0663731 3.48367543,19.5725301 7.80004167,19.5833333 L7.81570833,19.5833333 C9.75003686,19.5882688 11.6168794,18.8726691 13.0522917,17.5760417 C16.0171492,20.2556967 20.5292675,20.2556967 23.494125,17.5760417 C26.4604562,20.2616016 30.9794188,20.2616016 33.94575,17.5760417 C36.2421905,19.6477597 39.5441143,20.1708521 42.3684437,18.9103691 C45.1927731,17.649886 47.0084685,14.8428276 47.0000295,11.75 C47.0000295,11.3946378 46.9030823,11.0460037 46.7199583,10.7414583 Z" opacity="0.598981585"></path>
                                      <path d="M39.198,22.4912623 C37.3776246,22.4928106 35.5817531,22.0149171 33.951625,21.0951667 L33.92225,21.1107282 C31.1430221,22.6838032 27.9255001,22.9318916 24.9844167,21.7998837 C24.4750389,21.605469 23.9777983,21.3722567 23.4960833,21.1018359 L23.4745417,21.1129513 C20.6961809,22.6871153 17.4786145,22.9344611 14.5386667,21.7998837 C14.029926,21.6054643 13.533337,21.3722507 13.0522917,21.1018359 C11.4250962,22.0190609 9.63246555,22.4947009 7.81570833,22.4912623 C7.16510551,22.4842162 6.51607673,22.4173045 5.875,22.2911849 L5.875,44.7220845 C5.875,45.9498589 6.7517757,46.9451667 7.83333333,46.9451667 L19.5833333,46.9451667 L19.5833333,33.6066734 L27.4166667,33.6066734 L27.4166667,46.9451667 L39.1666667,46.9451667 C40.2482243,46.9451667 41.125,45.9498589 41.125,44.7220845 L41.125,22.2822926 C40.4887822,22.4116582 39.8442868,22.4815492 39.198,22.4912623 Z"></path>
                                    </g>
                                  </g>
                                </g>
                              </g>
                            </svg>
                          </div>
                        </div>
                        Products
                      </div>
                      <a href="{% url "new_product" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">New Product</span>
                      </a>
                      <a href="{% url "edit_product" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Edit Product</span>
                      </a>
                      <a href="{% url "product_page" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Product Page</span>
                      </a>
                      <a href="{% url "products_list" %}" class="dropdown-item border-radius-md">
                        <span class="ps-3">Products List</span>
                      </a>
                    </div>
                  </div>
                </div>
              </div>
              <!-- responsive -->
              <div class="d-lg-none">
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                      <svg width="12px" height="12px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>document</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(154.000000, 300.000000)">
                                <path d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                <path d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Orders
                </div>
                <a href="{% url "order_list" %}" class="dropdown-item border-radius-md">
                  Order List
                </a>
                <a href="{% url "order_details" %}" class="dropdown-item border-radius-md">
                  Order Details
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>box-3d-50</title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(603.000000, 0.000000)">
                                <path d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                <path d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                <path d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  General
                </div>
                <a href="{% url "overview" %}" class="dropdown-item border-radius-md">
                  Overview
                </a>
                <a href="{% url "referral" %}" class="dropdown-item border-radius-md">
                  Referral
                </a>
                <div class="dropdown-header text-dark font-weight-bolder d-flex align-items-center px-0 mt-3">
                  <div class="d-inline-block">
                    <div class="icon icon-shape icon-xs border-radius-md bg-primary text-center me-2 d-flex align-items-center justify-content-center ps-0">
                      <svg width="12px" height="12px" viewBox="0 0 45 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                        <title>shop </title>
                        <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                          <g transform="translate(-1716.000000, -439.000000)" fill="#FFFFFF" fill-rule="nonzero">
                            <g transform="translate(1716.000000, 291.000000)">
                              <g transform="translate(0.000000, 148.000000)">
                                <path d="M46.7199583,10.7414583 L40.8449583,0.949791667 C40.4909749,0.360605034 39.8540131,0 39.1666667,0 L7.83333333,0 C7.1459869,0 6.50902508,0.360605034 6.15504167,0.949791667 L0.280041667,10.7414583 C0.0969176761,11.0460037 -1.23209662e-05,11.3946378 -1.23209662e-05,11.75 C-0.00758042603,16.0663731 3.48367543,19.5725301 7.80004167,19.5833333 L7.81570833,19.5833333 C9.75003686,19.5882688 11.6168794,18.8726691 13.0522917,17.5760417 C16.0171492,20.2556967 20.5292675,20.2556967 23.494125,17.5760417 C26.4604562,20.2616016 30.9794188,20.2616016 33.94575,17.5760417 C36.2421905,19.6477597 39.5441143,20.1708521 42.3684437,18.9103691 C45.1927731,17.649886 47.0084685,14.8428276 47.0000295,11.75 C47.0000295,11.3946378 46.9030823,11.0460037 46.7199583,10.7414583 Z" opacity="0.598981585"></path>
                                <path d="M39.198,22.4912623 C37.3776246,22.4928106 35.5817531,22.0149171 33.951625,21.0951667 L33.92225,21.1107282 C31.1430221,22.6838032 27.9255001,22.9318916 24.9844167,21.7998837 C24.4750389,21.605469 23.9777983,21.3722567 23.4960833,21.1018359 L23.4745417,21.1129513 C20.6961809,22.6871153 17.4786145,22.9344611 14.5386667,21.7998837 C14.029926,21.6054643 13.533337,21.3722507 13.0522917,21.1018359 C11.4250962,22.0190609 9.63246555,22.4947009 7.81570833,22.4912623 C7.16510551,22.4842162 6.51607673,22.4173045 5.875,22.2911849 L5.875,44.7220845 C5.875,45.9498589 6.7517757,46.9451667 7.83333333,46.9451667 L19.5833333,46.9451667 L19.5833333,33.6066734 L27.4166667,33.6066734 L27.4166667,46.9451667 L39.1666667,46.9451667 C40.2482243,46.9451667 41.125,45.9498589 41.125,44.7220845 L41.125,22.2822926 C40.4887822,22.4116582 39.8442868,22.4815492 39.198,22.4912623 Z"></path>
                              </g>
                            </g>
                          </g>
                        </g>
                      </svg>
                    </div>
                  </div>
                  Products
                </div>
                <a href="{% url "new_product" %}" class="dropdown-item border-radius-md">
                  New Product
                </a>
                <a href="{% url "edit_product" %}" class="dropdown-item border-radius-md">
                  Edit Product
                </a>
                <a href="{% url "product_page" %}" class="dropdown-item border-radius-md">
                  Product Page
                </a>
                <a href="{% url "products_list" %}" class="dropdown-item border-radius-md">
                  Products List
                </a>
              </div>
            </div>
          </li>
          <li class="nav-item dropdown dropdown-hover mx-2">
            <a role="button" class="nav-link ps-2 d-flex justify-content-between cursor-pointer align-items-center " id="dropdownMenuDocs" data-bs-toggle="dropdown" aria-expanded="false">
              Docs
              <img src=" {% static "assets/img/down-arrow-dark.svg" %} " alt="down-arrow" class="arrow ms-1 d-lg-block d-none">
              <img src="{% static "assets/img/down-arrow-dark.svg" %}" alt="down-arrow" class="arrow ms-1 d-lg-none d-block">
            </a>
            <div class="dropdown-menu dropdown-menu-animation dropdown-lg mt-0 mt-lg-3 p-3 border-radius-lg" aria-labelledby="dropdownMenuDocs">
              <div class="d-none d-lg-block">
                <ul class="list-group">
                  <li class="nav-item list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="https://app-generator.dev/docs/products/django/soft-ui-dashboard-pro/index.html">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                            <title>spaceship</title>
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                <g transform="translate(1716.000000, 291.000000)">
                                  <g transform="translate(4.000000, 301.000000)">
                                    <path class="color-background" d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                                    <path class="color-background" d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                                    <path class="color-background" d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                                    <path class="color-background" d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                                  </g>
                                </g>
                              </g>
                            </g>
                          </svg>
                        </div>
                        <div>
                          <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Getting Started</h6>
                          <span class="text-sm">All about overview, quick start, license and contents</span>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="https://www.creative-tim.com/learning-lab/bootstrap/colors/soft-ui-dashboard">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                            <title>document</title>
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                <g transform="translate(1716.000000, 291.000000)">
                                  <g transform="translate(154.000000, 300.000000)">
                                    <path class="color-background" d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                    <path class="color-background" d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                                  </g>
                                </g>
                              </g>
                            </g>
                          </svg>
                        </div>
                        <div>
                          <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Foundation</h6>
                          <span class="text-sm">See our colors, icons and typography</span>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="https://www.creative-tim.com/learning-lab/bootstrap/alerts/soft-ui-dashboard">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                            <title>box-3d-50</title>
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                <g transform="translate(1716.000000, 291.000000)">
                                  <g transform="translate(603.000000, 0.000000)">
                                    <path class="color-background" d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                    <path class="color-background" d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                    <path class="color-background" d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                                  </g>
                                </g>
                              </g>
                            </g>
                          </svg>
                        </div>
                        <div>
                          <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Components</h6>
                          <span class="text-sm">Explore our collection of fully designed components</span>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="https://www.creative-tim.com/learning-lab/bootstrap/datepicker/soft-ui-dashboard">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                            <title>switches</title>
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g transform="translate(-1870.000000, -440.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                <g transform="translate(1716.000000, 291.000000)">
                                  <g transform="translate(154.000000, 149.000000)">
                                    <path class="color-background" d="M10,20 L30,20 C35.4545455,20 40,15.4545455 40,10 C40,4.54545455 35.4545455,0 30,0 L10,0 C4.54545455,0 0,4.54545455 0,10 C0,15.4545455 4.54545455,20 10,20 Z M10,3.63636364 C13.4545455,3.63636364 16.3636364,6.54545455 16.3636364,10 C16.3636364,13.4545455 13.4545455,16.3636364 10,16.3636364 C6.54545455,16.3636364 3.63636364,13.4545455 3.63636364,10 C3.63636364,6.54545455 6.54545455,3.63636364 10,3.63636364 Z" opacity="0.6"></path>
                                    <path class="color-background" d="M30,23.6363636 L10,23.6363636 C4.54545455,23.6363636 0,28.1818182 0,33.6363636 C0,39.0909091 4.54545455,43.6363636 10,43.6363636 L30,43.6363636 C35.4545455,43.6363636 40,39.0909091 40,33.6363636 C40,28.1818182 35.4545455,23.6363636 30,23.6363636 Z M30,40 C26.5454545,40 23.6363636,37.0909091 23.6363636,33.6363636 C23.6363636,30.1818182 26.5454545,27.2727273 30,27.2727273 C33.4545455,27.2727273 36.3636364,30.1818182 36.3636364,33.6363636 C36.3636364,37.0909091 33.4545455,40 30,40 Z"></path>
                                  </g>
                                </g>
                              </g>
                            </g>
                          </svg>
                        </div>
                        <div>
                          <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Plugins</h6>
                          <span class="text-sm">Check how you can integrate our plugins</span>
                        </div>
                      </div>
                    </a>
                  </li>
                  <li class="nav-item list-group-item border-0 p-0">
                    <a class="dropdown-item py-2 ps-3 border-radius-md" href="https://www.creative-tim.com/learning-lab/bootstrap/utilities/soft-ui-dashboard">
                      <div class="d-flex">
                        <div class="icon h-10 me-3 d-flex mt-1">
                          <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                            <title>settings</title>
                            <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                              <g transform="translate(-2020.000000, -442.000000)" fill="#FFFFFF" fill-rule="nonzero">
                                <g transform="translate(1716.000000, 291.000000)">
                                  <g transform="translate(304.000000, 151.000000)">
                                    <polygon class="color-background" opacity="0.596981957" points="18.0883333 15.7316667 11.1783333 8.82166667 13.3333333 6.66666667 6.66666667 0 0 6.66666667 6.66666667 13.3333333 8.82166667 11.1783333 15.315 17.6716667"></polygon>
                                    <path class="color-background" d="M31.5666667,23.2333333 C31.0516667,23.2933333 30.53,23.3333333 30,23.3333333 C29.4916667,23.3333333 28.9866667,23.3033333 28.48,23.245 L22.4116667,30.7433333 L29.9416667,38.2733333 C32.2433333,40.575 35.9733333,40.575 38.275,38.2733333 L38.275,38.2733333 C40.5766667,35.9716667 40.5766667,32.2416667 38.275,29.94 L31.5666667,23.2333333 Z" opacity="0.596981957"></path>
                                    <path class="color-background" d="M33.785,11.285 L28.715,6.215 L34.0616667,0.868333333 C32.82,0.315 31.4483333,0 30,0 C24.4766667,0 20,4.47666667 20,10 C20,10.99 20.1483333,11.9433333 20.4166667,12.8466667 L2.435,27.3966667 C0.95,28.7083333 0.0633333333,30.595 0.00333333333,32.5733333 C-0.0583333333,34.5533333 0.71,36.4916667 2.11,37.89 C3.47,39.2516667 5.27833333,40 7.20166667,40 C9.26666667,40 11.2366667,39.1133333 12.6033333,37.565 L27.1533333,19.5833333 C28.0566667,19.8516667 29.01,20 30,20 C35.5233333,20 40,15.5233333 40,10 C40,8.55166667 39.685,7.18 39.1316667,5.93666667 L33.785,11.285 Z"></path>
                                  </g>
                                </g>
                              </g>
                            </g>
                          </svg>
                        </div>
                        <div>
                          <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Utility Classes</h6>
                          <span class="text-sm">For those who want flexibility, use our utility classes</span>
                        </div>
                      </div>
                    </a>
                  </li>
                </ul>
              </div>
              <div class="row d-lg-none">
                <div class="col-md-12 g-0">
                  <a class="dropdown-item py-2 ps-3 border-radius-md" href="#">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>spaceship</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(4.000000, 301.000000)">
                                  <path class="color-background" d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                                  <path class="color-background" d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                                  <path class="color-background" d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                                  <path class="color-background" d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <div>
                        <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Getting Started</h6>
                        <span class="text-sm">All about overview, quick start, license and contents</span>
                      </div>
                    </div>
                  </a>
                  <a class="dropdown-item py-2 ps-3 border-radius-md" href="#">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>document</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(154.000000, 300.000000)">
                                  <path class="color-background" d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                  <path class="color-background" d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <div>
                        <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Foundation</h6>
                        <span class="text-sm">See our colors, icons and typography</span>
                      </div>
                    </div>
                  </a>
                  <a class="dropdown-item py-2 ps-3 border-radius-md" href="#">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>box-3d-50</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(603.000000, 0.000000)">
                                  <path class="color-background" d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                                  <path class="color-background" d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                                  <path class="color-background" d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <div>
                        <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Components</h6>
                        <span class="text-sm">Explore our collection of fully designed components</span>
                      </div>
                    </div>
                  </a>
                  <a class="dropdown-item py-2 ps-3 border-radius-md" href="#">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>switches</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-1870.000000, -440.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(154.000000, 149.000000)">
                                  <path class="color-background" d="M10,20 L30,20 C35.4545455,20 40,15.4545455 40,10 C40,4.54545455 35.4545455,0 30,0 L10,0 C4.54545455,0 0,4.54545455 0,10 C0,15.4545455 4.54545455,20 10,20 Z M10,3.63636364 C13.4545455,3.63636364 16.3636364,6.54545455 16.3636364,10 C16.3636364,13.4545455 13.4545455,16.3636364 10,16.3636364 C6.54545455,16.3636364 3.63636364,13.4545455 3.63636364,10 C3.63636364,6.54545455 6.54545455,3.63636364 10,3.63636364 Z" opacity="0.6"></path>
                                  <path class="color-background" d="M30,23.6363636 L10,23.6363636 C4.54545455,23.6363636 0,28.1818182 0,33.6363636 C0,39.0909091 4.54545455,43.6363636 10,43.6363636 L30,43.6363636 C35.4545455,43.6363636 40,39.0909091 40,33.6363636 C40,28.1818182 35.4545455,23.6363636 30,23.6363636 Z M30,40 C26.5454545,40 23.6363636,37.0909091 23.6363636,33.6363636 C23.6363636,30.1818182 26.5454545,27.2727273 30,27.2727273 C33.4545455,27.2727273 36.3636364,30.1818182 36.3636364,33.6363636 C36.3636364,37.0909091 33.4545455,40 30,40 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <div>
                        <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Plugins</h6>
                        <span class="text-sm">Check how you can integrate our plugins</span>
                      </div>
                    </div>
                  </a>
                  <a class="dropdown-item py-2 ps-3 border-radius-md" href="#">
                    <div class="d-flex">
                      <div class="icon h-10 me-3 d-flex mt-1">
                        <svg class="text-secondary" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>settings</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-2020.000000, -442.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(304.000000, 151.000000)">
                                  <polygon class="color-background" opacity="0.596981957" points="18.0883333 15.7316667 11.1783333 8.82166667 13.3333333 6.66666667 6.66666667 0 0 6.66666667 6.66666667 13.3333333 8.82166667 11.1783333 15.315 17.6716667"></polygon>
                                  <path class="color-background" d="M31.5666667,23.2333333 C31.0516667,23.2933333 30.53,23.3333333 30,23.3333333 C29.4916667,23.3333333 28.9866667,23.3033333 28.48,23.245 L22.4116667,30.7433333 L29.9416667,38.2733333 C32.2433333,40.575 35.9733333,40.575 38.275,38.2733333 L38.275,38.2733333 C40.5766667,35.9716667 40.5766667,32.2416667 38.275,29.94 L31.5666667,23.2333333 Z" opacity="0.596981957"></path>
                                  <path class="color-background" d="M33.785,11.285 L28.715,6.215 L34.0616667,0.868333333 C32.82,0.315 31.4483333,0 30,0 C24.4766667,0 20,4.47666667 20,10 C20,10.99 20.1483333,11.9433333 20.4166667,12.8466667 L2.435,27.3966667 C0.95,28.7083333 0.0633333333,30.595 0.00333333333,32.5733333 C-0.0583333333,34.5533333 0.71,36.4916667 2.11,37.89 C3.47,39.2516667 5.27833333,40 7.20166667,40 C9.26666667,40 11.2366667,39.1133333 12.6033333,37.565 L27.1533333,19.5833333 C28.0566667,19.8516667 29.01,20 30,20 C35.5233333,20 40,15.5233333 40,10 C40,8.55166667 39.685,7.18 39.1316667,5.93666667 L33.785,11.285 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <div>
                        <h6 class="dropdown-header text-dark font-weight-bolder d-flex align-items-center p-0">Utility Classes</h6>
                        <span class="text-sm">All about overview, quick start, license and contents</span>
                      </div>
                    </div>
                  </a>
                </div>
              </div>
            </div>
          </li>
        </ul>
        <ul class="navbar-nav d-lg-block d-none">
          <li class="nav-item">
            <a href="https://app-generator.dev/product/soft-ui-dashboard-pro/django/" 
               class="btn btn-sm  bg-primary  btn-round mb-0 me-1">Download</a>
          </li>
        </ul>
      </div>
    </div>
</nav>

================
File: templates/includes/navigation.html
================
{% load static replace_value %}
{% load organization_tags %}

<nav class="navbar navbar-main navbar-expand-lg position-sticky mt-4 top-1 px-0 mx-4 shadow-none border-radius-xl z-index-sticky" id="navbarBlur" data-scroll="true">
    <div class="container-fluid py-1 px-3">
      <div class="sidenav-toggler sidenav-toggler-inner d-xl-block d-none me-2 ">
        <a href="javascript:;" class="nav-link text-body p-0">
          <div class="sidenav-toggler-inner">
            <i class="sidenav-toggler-line"></i>
            <i class="sidenav-toggler-line"></i>
            <i class="sidenav-toggler-line"></i>
          </div>
        </a>
      </div>
      <nav aria-label="breadcrumb">
        <ol class="breadcrumb bg-transparent mb-0 pb-0 pt-1 px-0 me-sm-6 me-5">
          <li class="breadcrumb-item text-sm"><a class="opacity-5 text-dark" href="javascript:;">Pages</a></li>
          <li class="breadcrumb-item text-sm text-dark active" aria-current="page">{{ segment|replace_value:"_" }}</li>
        </ol>
      </nav>
      <div class="collapse navbar-collapse mt-sm-0 mt-2 me-md-0 me-sm-4" id="navbar">

        <ul class="navbar-nav ms-auto justify-content-end">
          {% if request.user.is_authenticated %}
          <!-- Combined Organization Context and Switcher -->
          <li class="nav-item d-flex align-items-center me-3">
            <div class="d-flex align-items-center">
              <!-- Organization Badge -->
              <!-- <div class="organization-badge bg-primary bg-gradient rounded-pill px-3 py-1 d-flex align-items-center me-2">
                <i class="fas fa-building text-white me-1"></i>
                <span class="text-white">{% organization_name %}</span>
              </div> -->
              
              <!-- Organization Switcher -->
              <div id="organization-switcher-container">
                {% include "organizations/components/organization_switcher.html" %}
              </div>
            </div>
            <script>
              document.addEventListener('DOMContentLoaded', function() {
                fetch('{% url "organizations:switcher" %}')
                  .then(response => response.text())
                  .then(html => {
                    document.getElementById('organization-switcher-container').innerHTML = html;
                  })
                  .catch(error => {
                    console.error('Error loading organization switcher:', error);
                  });
              });
            </script>
          </li>
          
          <li class="nav-item d-flex align-items-center me-3">
            <a href="{% url 'password_change' %}" class="nav-link text-body font-weight-bold px-0">
              <i class="fa fa-edit me-sm-1"></i>
              <span class="d-sm-inline d-none">Change Password</span>
            </a>
          </li>
          {% endif %}
          <li class="nav-item d-flex align-items-center">
            {% if request.user.is_authenticated %}
            <a href="{% url "logout" %}" class="nav-link text-body font-weight-bold px-0">
              <i class="fa fa-user me-sm-1"></i>
              <span class="d-sm-inline d-none">Logout</span>
            </a>
            {% else %}
            <a href="{% url "basic_login" %}" class="nav-link text-body font-weight-bold px-0">
              <i class="fa fa-user me-sm-1"></i>
              <span class="d-sm-inline d-none">Sign In</span>
            </a>
            {% endif %}
          </li>
          <li class="nav-item d-xl-none ps-3 d-flex align-items-center">
            <a href="javascript:;" class="nav-link text-body p-0" id="iconNavbarSidenav">
              <div class="sidenav-toggler-inner">
                <i class="sidenav-toggler-line"></i>
                <i class="sidenav-toggler-line"></i>
                <i class="sidenav-toggler-line"></i>
              </div>
            </a>
          </li>
          <li class="nav-item px-3 d-flex align-items-center">
            <a href="javascript:;" class="nav-link text-body p-0">
              <i class="fa fa-cog fixed-plugin-button-nav cursor-pointer"></i>
            </a>
          </li>
        </ul>
      </div>
    </div>
</nav>

================
File: templates/includes/scripts.html
================
{% load static %}

<script src="{% static "assets/js/core/popper.min.js" %}"></script>
<script src="{% static "assets/js/core/bootstrap.min.js" %}"></script>
<script src="{% static "assets/js/plugins/perfect-scrollbar.min.js" %}"></script>
<script src="{% static "assets/js/plugins/smooth-scrollbar.min.js" %}"></script>

<script src="{% static "assets/js/plugins/dragula/dragula.min.js" %}"></script>
<script src="{% static "assets/js/plugins/jkanban/jkanban.js" %}"></script>
<script src="{% static "assets/js/plugins/flatpickr.min.js" %}"></script>

<script>
    var win = navigator.platform.indexOf('Win') > -1;
    if (win && document.querySelector('#sidenav-scrollbar')) {
      var options = {
        damping: '0.5'
      }
      Scrollbar.init(document.querySelector('#sidenav-scrollbar'), options);
    }
  </script>
  <!-- Github buttons -->
  <script async defer src="https://buttons.github.io/buttons.js"></script>
  <!-- Control Center for Soft Dashboard: parallax effects, scripts for the example pages etc -->
  <script src="{% static "assets/js/soft-ui-dashboard.min.js" %}?v=1.2.0"></script>
  <!-- HTMX -->
  <script src="{% static 'assets/js/plugins/htmx.min.js' %}"></script>
  <!-- Hyperscript for declarative scripting -->
  <script src="https://unpkg.com/hyperscript.org@0.9.12"></script>

  <!-- HTMX CSRF Configuration -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Add CSRF token to all HTMX requests
      document.body.addEventListener('htmx:configRequest', function(evt) {
        if (evt.detail.headers) {
          // Get the CSRF token from the cookie
          const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
          if (csrftoken) {
            evt.detail.headers['X-CSRFToken'] = csrftoken;
          }
        }
      });
    });
  </script>

================
File: templates/includes/sidebar.html
================
{% load static %}

<aside class="sidenav navbar navbar-vertical navbar-expand-xs border-0 border-radius-xl my-3 fixed-start ms-3 " id="sidenav-main">
  <div class="sidenav-header">
    <i class="fas fa-times p-3 cursor-pointer text-secondary opacity-5 position-absolute end-0 top-0 d-none d-xl-none" aria-hidden="true" id="iconSidenav"></i>
    <a class="navbar-brand m-0" href="/">
      <img src="{% static 'assets/neuralami/logos/NeuralamiLogo51x51.png' %}" class="navbar-brand-img h-100" alt="main_logo">
      <span class="ms-1 font-weight-bold">Neuralami Control Center</span>
    </a>
  </div>
  <hr class="horizontal dark mt-0">
  <div class="collapse navbar-collapse w-auto h-100" id="sidenav-collapse-main" style="max-height: calc(100vh - 150px); overflow-y: auto;">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#dashboardSubmenu" class="nav-link {% if request.resolver_match.url_name == 'dashboard' or request.resolver_match.url_name == 'llm-dashboard' %}active{% endif %}" aria-controls="dashboardSubmenu" role="button" aria-expanded="{% if request.resolver_match.url_name == 'dashboard' or request.resolver_match.url_name == 'llm-dashboard' %}true{% else %}false{% endif %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-tv-2 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Dashboard</span>
        </a>
        <div class="collapse {% if request.resolver_match.url_name == 'dashboard' or request.resolver_match.url_name == 'llm-dashboard' %}show{% endif %}" id="dashboardSubmenu">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'dashboard' %}active{% endif %}" href="{% url 'seo_manager:dashboard' %}">
                <span class="sidenav-mini-icon"> O </span>
                <span class="sidenav-normal"> Overview </span>
              </a>
            </li>
            {% if request.user.is_staff %}
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'llm-dashboard' %}active{% endif %}" href="{% url 'llm-dashboard' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-chart-bar-32 text-info"></i> </span>
                <span class="sidenav-normal"> LLM Analytics </span>
              </a>
            </li>
            {% endif %}
          </ul>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'client_list' %}active{% endif %}" href="{% url 'seo_manager:client_list' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-briefcase-24 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Clients</span>
        </a>
      </li>
      <!-- Agent Crews section with submenu -->
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#agentCrewsSubmenu" class="nav-link {% if 'agents' in request.resolver_match.app_name %}active{% endif %}" aria-controls="agentCrewsSubmenu" role="button" aria-expanded="{% if 'agents' in request.resolver_match.app_name %}true{% else %}false{% endif %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-spaceship text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Agent Crews</span>
        </a>
        <div class="collapse {% if 'agents' in request.resolver_match.app_name %}show{% endif %}" id="agentCrewsSubmenu">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'crewai_home' %}active{% endif %}" href="{% url 'agents:crewai_home' %}">
                <span class="sidenav-mini-icon"> O </span>
                <span class="sidenav-normal"> Overview </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'manage_agents' %}active{% endif %}" href="{% url 'agents:manage_agents_card_view' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-single-02 text-info"></i> </span>
                <span class="sidenav-normal"> Manage Agents </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'manage_tasks' %}active{% endif %}" href="{% url 'agents:manage_tasks' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-bullet-list-67 text-primary"></i> </span>
                <span class="sidenav-normal"> Manage Tasks </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'manage_tools' %}active{% endif %}" href="{% url 'agents:manage_tools' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-settings text-warning"></i> </span>
                <span class="sidenav-normal"> Manage Tools </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'manage_crews' %}active{% endif %}" href="{% url 'agents:manage_crews_card_view' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-circle-08 text-success"></i> </span>
                <span class="sidenav-normal"> Manage Crews </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'chat' %}active{% endif %}" href="{% url 'agents:chat' %}">
                <span class="sidenav-mini-icon"> <i class="ni ni-chat-round text-info"></i> </span>
                <span class="sidenav-normal"> Agent Chat </span>
              </a>
            </li>
          </ul>
        </div>
      </li>
      <!-- Image Optimizer -->
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#imageOptimizerSubmenu" class="nav-link {% if 'image_optimizer' in request.resolver_match.namespace %}active{% endif %}" aria-controls="imageOptimizerSubmenu" role="button" aria-expanded="{% if 'image_optimizer' in request.resolver_match.namespace %}true{% else %}false{% endif %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-image text-success text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Image Optimizer</span>
        </a>
        <div class="collapse {% if 'image_optimizer' in request.resolver_match.namespace %}show{% endif %}" id="imageOptimizerSubmenu">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'dashboard' and 'image_optimizer' in request.resolver_match.namespace %}active{% endif %}" href="{% url 'image_optimizer:dashboard' %}">
                <span class="sidenav-mini-icon"> D </span>
                <span class="sidenav-normal"> Dashboard </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'optimize' %}active{% endif %}" href="{% url 'image_optimizer:optimize' %}">
                <span class="sidenav-mini-icon"> O </span>
                <span class="sidenav-normal"> Optimize Images </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'history' %}active{% endif %}" href="{% url 'image_optimizer:history' %}">
                <span class="sidenav-mini-icon"> H </span>
                <span class="sidenav-normal"> History </span>
              </a>
            </li>
          </ul>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'activity_log' %}active{% endif %}" href="{% url 'seo_manager:activity_log' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-calendar-grid-58 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Activity Log</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'crawl_website' %}active{% endif %}" href="{% url 'crawl_website:index' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-world-2 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Crawl Website</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.app_name == 'seo_audit' %}active{% endif %}" href="{% url 'seo_audit:audit' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-check-bold text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">SEO Audit</span>
        </a>
      </li>
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#researchSubmenu" class="nav-link {% if 'research' in request.resolver_match.app_name %}active{% endif %}" aria-controls="researchSubmenu" role="button" aria-expanded="{% if 'research' in request.resolver_match.app_name %}true{% else %}false{% endif %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-books text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Research</span>
        </a>
        <div class="collapse {% if 'research' in request.resolver_match.app_name %}show{% endif %}" id="researchSubmenu">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'research_list' %}active{% endif %}" href="{% url 'research:list' %}">
                <span class="sidenav-mini-icon"> H </span>
                <span class="sidenav-normal"> History </span>
              </a>
            </li>
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'research_create' %}active{% endif %}" href="{% url 'research:create' %}">
                <span class="sidenav-mini-icon"> N </span>
                <span class="sidenav-normal"> New Research </span>
              </a>
            </li>
          </ul>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'summarize_view' %}active{% endif %}" href="{% url 'summarizer:summarize_view' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-scissors text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Summarize</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.namespace == 'file_manager' %}active{% endif %}" href="{% url 'file_manager:index' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-folder-17 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">File Manager</span>
        </a>
      </li>
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#utilitiesSubmenu" class="nav-link {% if 'utilities' in request.resolver_match.app_name %}active{% endif %}" aria-controls="utilitiesSubmenu" role="button" aria-expanded="{% if 'utilities' in request.resolver_match.app_name %}true{% else %}false{% endif %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-settings text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Utilities</span>
        </a>
        <div class="collapse {% if 'utilities' in request.resolver_match.app_name %}show{% endif %}" id="utilitiesSubmenu">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'test_endpoint' %}active{% endif %}" href="{% url 'utilities:test_endpoint' %}">
                <span class="sidenav-mini-icon"> T </span>
                <span class="sidenav-normal"> Test Endpoint </span>
              </a>
            </li>
          </ul>
        </div>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'profile' %}active{% endif %}" href="{% url 'profile' %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-single-02 text-primary text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Profile</span>
        </a>
      </li>
      
      {% if 'clients/' in request.path and client %}
      <li class="nav-item mt-3">
        <h6 class="ps-4 ms-2 text-uppercase text-xs font-weight-bolder opacity-6">Client: {{ client.name }}</h6>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'client_detail' %}active{% endif %}" href="{% url 'seo_manager:client_detail' client.id %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-single-02 text-dark text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Overview</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'client_analytics' %}active{% endif %}" href="{% url 'seo_manager:client_analytics' client.id %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-chart-bar-32 text-info text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Analytics</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'ranking_data_management' %}active{% endif %}" href="{% url 'seo_manager:ranking_data_management' client.id %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="ni ni-chart-line-72 text-success text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Rankings</span>
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link {% if request.resolver_match.url_name == 'meta_tags_dashboard' %}active{% endif %}" href="{% url 'seo_manager:meta_tags_dashboard' client.id %}">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="fas fa-code text-info text-sm opacity-10"></i>
          </div>
          <span class="nav-link-text ms-1">Meta Tags</span>
        </a>
      </li>
      <li class="nav-item">
        <a data-bs-toggle="collapse" href="#clientPages" class="nav-link" aria-controls="clientPages" role="button" aria-expanded="false">
          <div class="icon icon-shape icon-sm shadow border-radius-md bg-white text-center me-2 d-flex align-items-center justify-content-center">
            <i class="fas fa-users text-dark"></i>
          </div>
          <span class="nav-link-text ms-1">Client Management</span>
        </a>
        <div class="collapse" id="clientPages">
          <ul class="nav ms-4 ps-3">
            <li class="nav-item">
              <a class="nav-link {% if request.resolver_match.url_name == 'client_integrations' %}active{% endif %}" 
                 href="{% url 'seo_manager:client_integrations' client.id %}">
                <span class="sidenav-mini-icon"> I </span>
                <span class="sidenav-normal"> Integrations </span>
              </a>
            </li>
          </ul>
        </div>
      </li>
      {% endif %} 
    </ul>
  </div>
</aside>

================
File: templates/includes/subdirectories.html
================
{% load static file_extension %}

{% for item in directories %}
    {% if item.type == 'directory' %}
    <li class="folder-item" data-path="{{ item.path }}">
        <div class="folder-content d-flex align-items-center">
            <i class="fas fa-chevron-down me-2"></i>
            <i class="fas fa-folder text-warning me-2"></i>
            <a href="{% url 'file_manager' item.path|urlencode %}">{{ item.name }}</a>
        </div>
        <ul class="folder-contents ps-4">
            {% with directory=item.path %}
                {% include 'includes/subdirectories.html' %}
            {% endwith %}
        </ul>
    </li>
    {% endif %}
{% endfor %}

================
File: templates/layouts/base-full.html
================
{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    {% include "includes/head.html" %}
    {% block extrastyle %}{% endblock extrastyle %}
</head>

<body class="g-sidenav-show bg-gray-100" id="main-body-full">

    {% block navigation %}
        {% include "includes/navigation-full.html" %}
    {% endblock navigation %}

    {% block content %}{% endblock content %}

    {% block footer %}
        {% include "includes/footer-full.html" %}
    {% endblock footer %}

    {% block configurator %}
        {% include "includes/configurator.html" %}
    {% endblock configurator %}

    {% include "includes/scripts.html" %}
    {% block extra_js %}{% endblock extra_js %}
    
    <!-- Apply dark mode class to body immediately if needed -->
    <script>
      (function() {
        try {
          // Check for dark mode preference and apply immediately
          if (localStorage.getItem('darkMode') === 'true') {
            document.body.classList.add('dark-version');
          }
          
          // Clean up preload class
          document.addEventListener('DOMContentLoaded', function() {
            setTimeout(function() {
              document.documentElement.classList.remove('dark-mode-preload');
            }, 300);
          });
        } catch (e) {
          console.error('Error applying theme to body:', e);
        }
      })();
    </script>

</body>

</html>

================
File: templates/layouts/base-shadow.html
================
{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    {% include "includes/head.html" %}
</head>

<body class="">
  <div class="container position-sticky z-index-sticky top-0">
    <div class="row">
      <div class="col-12">
        {% block navigation %}
            {% comment %} {% include "includes/navigation-shadow.html" %} {% endcomment %}
        {% endblock navigation %}
      </div>
    </div>
  </div>
  {% block content %}{% endblock content %}

  {% block footer %}
    {% include "includes/footer-full.html" %}
  {% endblock footer %}

  {% include "includes/scripts.html" %}

</body>

</html>

================
File: templates/layouts/base.html
================
<!DOCTYPE html>
<html lang="en">

<head>
  {% include "includes/head.html" %}
  {% block extrastyle %}{% endblock extrastyle %}
</head>

<body class="g-sidenav-show bg-gray-100 soft-ui-dashboard" id="main-body">
    {% block sidebar %}
        {% include "includes/sidebar.html" %}
    {% endblock sidebar %}

  <main class="main-content position-relative max-height-vh-100 h-100 border-radius-lg ">
    {% block navigation %}
        {% include "includes/navigation.html" %}
    {% endblock navigation %}
    {% block content %}{% endblock content %}

    {% include "includes/footer.html" %}
  </main>

  {% block configurator %}
    {% include "includes/configurator.html" %}
  {% endblock configurator %}

  {% include "includes/scripts.html" %}
  {% block extra_js %}{% endblock extra_js %}

  <!-- Apply dark mode class to body immediately if needed -->
  <script>
    (function() {
      try {
        // Check for dark mode preference and apply immediately
        if (localStorage.getItem('darkMode') === 'true') {
          document.body.classList.add('dark-version');
        }

        // Clean up preload class
        document.addEventListener('DOMContentLoaded', function() {
          setTimeout(function() {
            document.documentElement.classList.remove('dark-mode-preload');
          }, 300);
        });
      } catch (e) {
        console.error('Error applying theme to body:', e);
      }
    })();
  </script>

</body>

</html>

================
File: templates/pages/account/billing.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block content %}

    <div class="container-fluid mt-4">
      <div class="row align-items-center">
        <div class="col-lg-4 col-sm-8">
          <div class="nav-wrapper position-relative end-0">
            <ul class="nav nav-pills nav-fill p-1" role="tablist">
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 active " data-bs-toggle="tab" href="../../examples/pages/account/settings.html" role="tab" aria-selected="true">
                  Messages
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1  active " data-bs-toggle="tab" href="../../examples/pages/account/billing.html" role="tab" aria-selected="false">
                  Social
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/invoice.html" role="tab" aria-selected="false">
                  Notifications
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/security.html" role="tab" aria-selected="false">
                  Backup
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid my-3 py-3">
      <div class="row">
        <div class="col-lg-8">
          <div class="row">
            <div class="col-xl-6 mb-xl-0 mb-4">
              <div class="card bg-transparent shadow-xl">
                <div class="overflow-hidden position-relative border-radius-xl" style="background-image: url('{% static "assets/img/curved-images/curved14.jpg" %}');">
                  <span class="mask bg-gradient-dark"></span>
                  <div class="card-body position-relative z-index-1 p-3">
                    <i class="fas fa-wifi text-white p-2"></i>
                    <h5 class="text-white mt-4 mb-5 pb-2">4562&nbsp;&nbsp;&nbsp;1122&nbsp;&nbsp;&nbsp;4594&nbsp;&nbsp;&nbsp;7852</h5>
                    <div class="d-flex">
                      <div class="d-flex">
                        <div class="me-4">
                          <p class="text-white text-sm opacity-8 mb-0">Card Holder</p>
                          <h6 class="text-white mb-0">Jack Peterson</h6>
                        </div>
                        <div>
                          <p class="text-white text-sm opacity-8 mb-0">Expires</p>
                          <h6 class="text-white mb-0">11/22</h6>
                        </div>
                      </div>
                      <div class="ms-auto w-20 d-flex align-items-end justify-content-end">
                        <img class="w-60 mt-2" src="{% static "assets/img/logos/mastercard.png" %}" alt="logo">
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-xl-6">
              <div class="row">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-header mx-4 p-3 text-center">
                      <div class="icon icon-shape icon-lg bg-primary shadow text-center border-radius-lg">
                        <i class="fas fa-landmark opacity-10"></i>
                      </div>
                    </div>
                    <div class="card-body pt-0 p-3 text-center">
                      <h6 class="text-center mb-0">Salary</h6>
                      <span class="text-xs">Belong Interactive</span>
                      <hr class="horizontal dark my-3">
                      <h5 class="mb-0">+$2000</h5>
                    </div>
                  </div>
                </div>
                <div class="col-md-6 mt-md-0 mt-4">
                  <div class="card">
                    <div class="card-header mx-4 p-3 text-center">
                      <div class="icon icon-shape icon-lg bg-primary shadow text-center border-radius-lg">
                        <i class="fab fa-paypal opacity-10"></i>
                      </div>
                    </div>
                    <div class="card-body pt-0 p-3 text-center">
                      <h6 class="text-center mb-0">Paypal</h6>
                      <span class="text-xs">Freelance Payment</span>
                      <hr class="horizontal dark my-3">
                      <h5 class="mb-0">$455.00</h5>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-12 mb-lg-0 mb-4">
              <div class="card mt-4">
                <div class="card-header pb-0 p-3">
                  <div class="row">
                    <div class="col-6 d-flex align-items-center">
                      <h6 class="mb-0">Payment Method</h6>
                    </div>
                    <div class="col-6 text-end">
                      <a class="btn bg-gradient-dark mb-0" href="javascript:;"><i class="fas fa-plus"></i>&nbsp;&nbsp;Add New Card</a>
                    </div>
                  </div>
                </div>
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-md-6 mb-md-0 mb-4">
                      <div class="card card-body border card-plain border-radius-lg d-flex align-items-center flex-row">
                        <img class="w-10 me-3 mb-0" src="{% static "assets/img/logos/mastercard.png" %}" alt="logo">
                        <h6 class="mb-0">****&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;7852</h6>
                        <i class="fas fa-pencil-alt ms-auto text-dark cursor-pointer" data-bs-toggle="tooltip" data-bs-placement="top" title="Edit Card"></i>
                      </div>
                    </div>
                    <div class="col-md-6">
                      <div class="card card-body border card-plain border-radius-lg d-flex align-items-center flex-row">
                        <img class="w-10 me-3 mb-0" src="{% static "assets/img/logos/visa.png" %}" alt="logo">
                        <h6 class="mb-0">****&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;****&nbsp;&nbsp;&nbsp;5248</h6>
                        <i class="fas fa-pencil-alt ms-auto text-dark cursor-pointer" data-bs-toggle="tooltip" data-bs-placement="top" title="Edit Card"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-4">
          <div class="card h-100">
            <div class="card-header pb-0 p-3">
              <div class="row">
                <div class="col-6 d-flex align-items-center">
                  <h6 class="mb-0">Invoices</h6>
                </div>
                <div class="col-6 text-end">
                  <button class="btn btn-outline-primary btn-sm mb-0">View All</button>
                </div>
              </div>
            </div>
            <div class="card-body p-3 pb-0">
              <ul class="list-group">
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="mb-1 text-dark font-weight-bold text-sm">March, 01, 2020</h6>
                    <span class="text-xs">#MS-415646</span>
                  </div>
                  <div class="d-flex align-items-center text-sm">
                    $180
                    <button class="btn btn-link text-dark text-sm mb-0 px-0 ms-4"><i class="fas fa-file-pdf text-lg me-1"></i> PDF</button>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="text-dark mb-1 font-weight-bold text-sm">February, 10, 2021</h6>
                    <span class="text-xs">#RV-126749</span>
                  </div>
                  <div class="d-flex align-items-center text-sm">
                    $250
                    <button class="btn btn-link text-dark text-sm mb-0 px-0 ms-4"><i class="fas fa-file-pdf text-lg me-1"></i> PDF</button>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="text-dark mb-1 font-weight-bold text-sm">April, 05, 2020</h6>
                    <span class="text-xs">#FB-212562</span>
                  </div>
                  <div class="d-flex align-items-center text-sm">
                    $560
                    <button class="btn btn-link text-dark text-sm mb-0 px-0 ms-4"><i class="fas fa-file-pdf text-lg me-1"></i> PDF</button>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="text-dark mb-1 font-weight-bold text-sm">June, 25, 2019</h6>
                    <span class="text-xs">#QW-103578</span>
                  </div>
                  <div class="d-flex align-items-center text-sm">
                    $120
                    <button class="btn btn-link text-dark text-sm mb-0 px-0 ms-4"><i class="fas fa-file-pdf text-lg me-1"></i> PDF</button>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="text-dark mb-1 font-weight-bold text-sm">March, 01, 2019</h6>
                    <span class="text-xs">#AR-803481</span>
                  </div>
                  <div class="d-flex align-items-center text-sm">
                    $300
                    <button class="btn btn-link text-dark text-sm mb-0 px-0 ms-4"><i class="fas fa-file-pdf text-lg me-1"></i> PDF</button>
                  </div>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <div class="row mt-4">
        <div class="col-md-7">
          <div class="card">
            <div class="card-header pb-0 px-3">
              <h6 class="mb-0">Billing Information</h6>
            </div>
            <div class="card-body pt-4 p-3">
              <ul class="list-group">
                <li class="list-group-item border-0 d-flex p-4 mb-2 bg-gray-100 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="mb-3 text-sm">Oliver Liam</h6>
                    <span class="mb-2 text-xs">Company Name: <span class="text-dark font-weight-bold ms-sm-2">Viking Burrito</span></span>
                    <span class="mb-2 text-xs">Email Address: <span class="text-dark ms-sm-2 font-weight-bold">oliver@burrito.com</span></span>
                    <span class="text-xs">VAT Number: <span class="text-dark ms-sm-2 font-weight-bold">FRB1235476</span></span>
                  </div>
                  <div class="ms-auto text-end">
                    <a class="btn btn-link text-danger text-gradient px-3 mb-0" href="javascript:;"><i class="far fa-trash-alt me-2"></i>Delete</a>
                    <a class="btn btn-link text-dark px-3 mb-0" href="javascript:;"><i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit</a>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex p-4 mb-2 mt-3 bg-gray-100 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="mb-3 text-sm">Lucas Harper</h6>
                    <span class="mb-2 text-xs">Company Name: <span class="text-dark font-weight-bold ms-sm-2">Stone Tech Zone</span></span>
                    <span class="mb-2 text-xs">Email Address: <span class="text-dark ms-sm-2 font-weight-bold">lucas@stone-tech.com</span></span>
                    <span class="text-xs">VAT Number: <span class="text-dark ms-sm-2 font-weight-bold">FRB1235476</span></span>
                  </div>
                  <div class="ms-auto text-end">
                    <a class="btn btn-link text-danger text-gradient px-3 mb-0" href="javascript:;"><i class="far fa-trash-alt me-2"></i>Delete</a>
                    <a class="btn btn-link text-dark px-3 mb-0" href="javascript:;"><i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit</a>
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex p-4 mb-2 mt-3 bg-gray-100 border-radius-lg">
                  <div class="d-flex flex-column">
                    <h6 class="mb-3 text-sm">Ethan James</h6>
                    <span class="mb-2 text-xs">Company Name: <span class="text-dark font-weight-bold ms-sm-2">Fiber Notion</span></span>
                    <span class="mb-2 text-xs">Email Address: <span class="text-dark ms-sm-2 font-weight-bold">ethan@fiber.com</span></span>
                    <span class="text-xs">VAT Number: <span class="text-dark ms-sm-2 font-weight-bold">FRB1235476</span></span>
                  </div>
                  <div class="ms-auto text-end">
                    <a class="btn btn-link text-danger text-gradient px-3 mb-0" href="javascript:;"><i class="far fa-trash-alt me-2"></i>Delete</a>
                    <a class="btn btn-link text-dark px-3 mb-0" href="javascript:;"><i class="fas fa-pencil-alt text-dark me-2" aria-hidden="true"></i>Edit</a>
                  </div>
                </li>
              </ul>
            </div>
          </div>
        </div>
        <div class="col-md-5 mt-md-0 mt-4">
          <div class="card h-100 mb-4">
            <div class="card-header pb-0 px-3">
              <div class="row">
                <div class="col-md-6">
                  <h6 class="mb-0">Your Transaction's</h6>
                </div>
                <div class="col-md-6 d-flex justify-content-end align-items-center">
                  <i class="far fa-calendar-alt me-2"></i>
                  <small>23 - 30 March 2020</small>
                </div>
              </div>
            </div>
            <div class="card-body pt-4 p-3">
              <h6 class="text-uppercase text-body text-xs font-weight-bolder mb-3">Newest</h6>
              <ul class="list-group">
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-danger mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-arrow-down"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">Netflix</h6>
                      <span class="text-xs">27 March 2020, at 12:30 PM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-danger text-gradient text-sm font-weight-bold">
                    - $ 2,500
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-success mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-arrow-up"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">Apple</h6>
                      <span class="text-xs">27 March 2020, at 04:30 AM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-success text-gradient text-sm font-weight-bold">
                    + $ 2,000
                  </div>
                </li>
              </ul>
              <h6 class="text-uppercase text-body text-xs font-weight-bolder my-3">Yesterday</h6>
              <ul class="list-group">
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-success mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-arrow-up"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">Stripe</h6>
                      <span class="text-xs">26 March 2020, at 13:45 PM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-success text-gradient text-sm font-weight-bold">
                    + $ 750
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-success mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-arrow-up"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">HubSpot</h6>
                      <span class="text-xs">26 March 2020, at 12:30 PM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-success text-gradient text-sm font-weight-bold">
                    + $ 1,000
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-success mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-arrow-up"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">Creative Tim</h6>
                      <span class="text-xs">26 March 2020, at 08:30 AM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-success text-gradient text-sm font-weight-bold">
                    + $ 2,500
                  </div>
                </li>
                <li class="list-group-item border-0 d-flex justify-content-between ps-0 mb-2 border-radius-lg">
                  <div class="d-flex align-items-center">
                    <button class="btn btn-icon-only btn-rounded btn-outline-dark mb-0 me-3 btn-sm d-flex align-items-center justify-content-center"><i class="fas fa-exclamation"></i></button>
                    <div class="d-flex flex-column">
                      <h6 class="mb-1 text-dark text-sm">Webflow</h6>
                      <span class="text-xs">26 March 2020, at 05:00 AM</span>
                    </div>
                  </div>
                  <div class="d-flex align-items-center text-dark text-sm font-weight-bold">
                    Pending
                  </div>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <footer class="footer pt-3  ">
        <div class="container-fluid">
          <div class="row align-items-center justify-content-lg-between">
            <div class="col-lg-6 mb-lg-0 mb-4">
              <div class="copyright text-center text-sm text-muted text-lg-start">
                &copy; Creative-Tim coded by <a href="https://app-generator.dev" class="font-weight-bold">App Generator</a>.
              </div>
            </div>
            <div class="col-lg-6">
              <ul class="nav nav-footer justify-content-center justify-content-lg-end">
                <li class="nav-item">
                  <a href="https://app-generator.dev/product/soft-ui-dashboard-pro/django/" class="nav-link text-muted">Download</a>
                </li>
                <li class="nav-item">
                  <a href="https://app-generator.dev/docs/products/django/soft-ui-dashboard-pro/index.html" class="nav-link text-muted">Documentation</a>
                </li>
                <li class="nav-item">
                  <a href="https://app-generator.dev/product/soft-ui-dashboard/django/" class="nav-link text-muted">Free Version</a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </footer>
    </div>

{% endblock content %}

================
File: templates/pages/account/invoice.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block content %}

    <div class="container-fluid mt-4">
      <div class="row align-items-center">
        <div class="col-lg-4 col-sm-8">
          <div class="nav-wrapper position-relative end-0">
            <ul class="nav nav-pills nav-fill p-1" role="tablist">
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 active " data-bs-toggle="tab" href="../../examples/pages/account/settings.html" role="tab" aria-selected="true">
                  Messages
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/billing.html" role="tab" aria-selected="false">
                  Social
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1  active " data-bs-toggle="tab" href="../../examples/pages/account/invoice.html" role="tab" aria-selected="false">
                  Notifications
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/security.html" role="tab" aria-selected="false">
                  Backup
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid my-3 py-3">
      <div class="row">
        <div class="col-md-8 col-sm-10 mx-auto">
          <form class="" action="index.html" method="post">
            <div class="card my-sm-5">
              <div class="card-header text-center">
                <div class="row justify-content-between">
                  <div class="col-md-4 text-start">
                    <img class="mb-2 w-25 p-2" src="{% static "assets/img/logo-ct.png" %}" alt="Logo">
                    <h6>
                      St. Independence Embankment, 050105 Bucharest, Romania
                    </h6>
                    <p class="d-block text-secondary">tel: +4 (074) 1090873</p>
                  </div>
                  <div class="col-lg-3 col-md-7 text-md-end text-start mt-5">
                    <h6 class="d-block mt-2 mb-0">Billed to: John Doe</h6>
                    <p class="text-secondary">4006 Locust View Drive<br>
                      San Francisco CA<br>
                      California
                    </p>
                  </div>
                </div>
                <br>
                <div class="row justify-content-md-between">
                  <div class="col-md-4 mt-auto">
                    <h6 class="mb-0 text-start text-secondary">
                      Invoice no
                    </h6>
                    <h5 class="text-start mb-0">
                      #0453119
                    </h5>
                  </div>
                  <div class="col-lg-5 col-md-7 mt-auto">
                    <div class="row mt-md-5 mt-4 text-md-end text-start">
                      <div class="col-md-6">
                        <h6 class="text-secondary mb-0">Invoice date:</h6>
                      </div>
                      <div class="col-md-6">
                        <h6 class="text-dark mb-0">06/03/2019</h6>
                      </div>
                    </div>
                    <div class="row text-md-end text-start">
                      <div class="col-md-6">
                        <h6 class="text-secondary mb-0">Due date:</h6>
                      </div>
                      <div class="col-md-6">
                        <h6 class="text-dark mb-0">11/03/2019</h6>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-body">
                <div class="row">
                  <div class="col-12">
                    <div class="table-responsive">
                      <table class="table text-right">
                        <thead class="bg-default">
                          <tr>
                            <th scope="col" class="pe-2 text-start ps-2">Item</th>
                            <th scope="col" class="pe-2">Qty</th>
                            <th scope="col" class="pe-2" colspan="2">Rate</th>
                            <th scope="col" class="pe-2">Amount</th>
                          </tr>
                        </thead>
                        <tbody>
                          <tr>
                            <td class="text-start">Premium Support</td>
                            <td class="ps-4">1</td>
                            <td class="ps-4" colspan="2">$ 9.00</td>
                            <td class="ps-4">$ 9.00</td>
                          </tr>
                          <tr>
                            <td class="text-start">Soft UI Design System PRO</td>
                            <td class="ps-4">3</td>
                            <td class="ps-4" colspan="2">$ 100.00</td>
                            <td class="ps-4">$ 300.00</td>
                          </tr>
                          <tr>
                            <td class="text-start">Parts for service</td>
                            <td class="ps-4">1</td>
                            <td class="ps-4" colspan="2">$ 89.00</td>
                            <td class="ps-4">$ 89.00</td>
                          </tr>
                        </tbody>
                        <tfoot>
                          <tr>
                            <th></th>
                            <th></th>
                            <th class="h5 ps-4" colspan="2">Total</th>
                            <th colspan="1" class="text-right h5 ps-4">$ 698</th>
                          </tr>
                        </tfoot>
                      </table>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card-footer mt-md-5 mt-4">
                <div class="row">
                  <div class="col-lg-5 text-left">
                    <h5>Thank you!</h5>
                    <p class="text-secondary text-sm">If you encounter any issues related to the invoice you can contact us at:</p>
                    <h6 class="text-secondary mb-0">
                      email:
                      <span class="text-dark">support@creative-tim.com</span>
                    </h6>
                  </div>
                  <div class="col-lg-7 text-md-end mt-md-0 mt-3">
                    <button class="btn bg-gradient-info mt-lg-7 mb-0" onClick="window.print()" type="button" name="button">Print</button>
                  </div>
                </div>
              </div>
            </div>
          </form>
        </div>
      </div>
      <footer class="footer pt-3  ">
        <div class="container-fluid">
          <div class="row align-items-center justify-content-lg-between">
            <div class="col-lg-6 mb-lg-0 mb-4">
              <div class="copyright text-center text-sm text-muted text-lg-start">
                &copy; Creative-Tim coded by <a href="https://app-generator.dev" class="font-weight-bold">App Generator</a>.
              </div>
            </div>
            <div class="col-lg-6">
              <ul class="nav nav-footer justify-content-center justify-content-lg-end">
                <li class="nav-item">
                  <a href="https://app-generator.dev/product/soft-ui-dashboard-pro/django/" class="nav-link text-muted">Download</a>
                </li>
                <li class="nav-item">
                  <a href="https://app-generator.dev/docs/products/django/soft-ui-dashboard-pro/index.html" class="nav-link text-muted">Documentation</a>
                </li>
                <li class="nav-item">
                  <a href="https://app-generator.dev/product/soft-ui-dashboard/django/" class="nav-link text-muted">Free Version</a>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </footer>
    </div>

{% endblock content %}

================
File: templates/pages/account/security.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block content %}

    <div class="container-fluid mt-4">
      <div class="row align-items-center">
        <div class="col-lg-4 col-sm-8">
          <div class="nav-wrapper position-relative end-0">
            <ul class="nav nav-pills nav-fill p-1" role="tablist">
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 active " data-bs-toggle="tab" href="../../examples/pages/account/settings.html" role="tab" aria-selected="true">
                  Messages
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/billing.html" role="tab" aria-selected="false">
                  Social
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/invoice.html" role="tab" aria-selected="false">
                  Notifications
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1  active " data-bs-toggle="tab" href="../../examples/pages/account/security.html" role="tab" aria-selected="false">
                  Backup
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid my-3 py-3">
      <div class="row">
        <div class="col-sm-6">
          <label class="form-label">Security Question</label>
          <select class="form-control" name="choices-questions" id="choices-questions">
            <option value="Question 1">Question 1</option>
            <option value="Question 2">Question 2</option>
            <option value="Question 3">Question 3</option>
            <option value="Your Question" disabled>Your Question</option>
          </select>
        </div>
        <div class="col-sm-6">
          <label class="form-label">Your Answer</label>
          <div class="form-group">
            <input class="form-control" type="text" placeholder="Enter your answer">
          </div>
        </div>
        <hr class="horizontal dark mt-1 mb-3">
        <div class="col-md-6">
          <div class="card">
            <div class="card-header pb-0 p-3">
              <h6 class="mb-0">Security Settings</h6>
            </div>
            <div class="card-body p-3">
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Notify me via email when logging in</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault30" checked="" onchange="visible()">
                </div>
              </div>
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Send SMS confirmation for all online payments</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault31" onchange="visible()">
                </div>
              </div>
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Check which devices accessed your account</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault32" checked="" onchange="visible()">
                </div>
              </div>
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Find My Device, make sure your device can be found if it gets lost</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault33" onchange="visible()">
                </div>
              </div>
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Lock your device with a PIN, pattern, or password</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault34" onchange="visible()">
                </div>
              </div>
              <div class="form-group d-flex align-items-center justify-content-between">
                <span class="text-sm">Manage what apps have access to app-usage data on your device</span>
                <div class="form-check form-switch ms-3">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault35" checked="" onchange="visible()">
                </div>
              </div>
              <div class="row mt-5">
                <div class="col-lg-8 col-12 actions text-end ms-auto">
                  <button class="btn btn-outline-primary btn-sm mb-0" type="reset">Cancel</button>
                  <button class="btn btn-primary btn-sm mb-0" type="button">Save Changes</button>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-md-6 mt-md-0 mt-4">
          <div class="card">
            <div class="card-header p-3 pb-0">
              <div class="d-flex align-items-center">
                <h6 class="mb-0">
                  Two factor authentication
                </h6>
                <button class="btn btn-sm bg-gradient-dark ms-auto mb-0">
                  Enable
                </button>
              </div>
            </div>
            <div class="card-body p-3">
              <p class="text-muted text-sm mb-4 mt-sm-5 mt-3">
                Two-factor authentication adds an additional
                layer of security to your account by requiring more
                than just a password to log in.
              </p>
              <div class="card">
                <div class="card-body border-radius-lg bg-gradient-dark p-3">
                  <h6 class="mb-0 text-white">
                    Questions about security?
                  </h6>
                  <p class="text-white text-sm mb-4">
                    Have a question, concern, or comment
                    about security? Please contact us.
                  </p>
                  <button class="btn bg-gradient-light mb-0">Contact Us</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="row gx-4 mt-4">
        <div class="col-md-6">
          <div class="card">
            <div class="card-header p-3 pb-0">
              <h6 class="mb-1">Change password</h6>
              <p class="text-sm mb-0">
                We will send you an email with the verification code.
              </p>
            </div>
            <div class="card-body p-3">
              <label class="form-label">Current password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="Current password">
              </div>
              <label class="form-label">New password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="New password">
              </div>
              <label class="form-label">Confirm new password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="Confirm password">
              </div>
              <button class="btn bg-gradient-dark w-100 mb-0">Update password</button>
            </div>
          </div>
        </div>
        <div class="col-md-6 mt-md-0 mt-4">
          <div class="card">
            <div class="card-header p-3 pb-0">
              <h6 class="mb-1">
                Password requirements
              </h6>
              <p class="text-sm mb-0">
                Please follow this guide for a strong password:
              </p>
            </div>
            <div class="card-body p-3">
              <ul class="text-muted ps-4 mb-0">
                <li>
                  <span class="text-sm">One special characters</span>
                </li>
                <li>
                  <span class="text-sm">Min 6 characters</span>
                </li>
                <li>
                  <span class="text-sm">One number (2 are recommended)</span>
                </li>
                <li>
                  <span class="text-sm">Change it often</span>
                </li>
              </ul>
            </div>
          </div>
        </div>
      </div>
      <footer class="footer pt-3  ">
        <div class="container-fluid">
          <div class="row align-items-center justify-content-lg-between">
            <div class="col-lg-6 mb-lg-0 mb-4">
              <div class="copyright text-center text-sm text-muted text-lg-start">
                &copy; SEO Manager coded by <a href="https://www.neuralami.com" class="font-weight-bold">Neuralami</a>.
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>
    
{% endblock content %}

================
File: templates/pages/account/settings.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block content %}

    <div class="container-fluid mt-4">
      <div class="row align-items-center">
        <div class="col-lg-4 col-sm-8">
          <div class="nav-wrapper position-relative end-0">
            <ul class="nav nav-pills nav-fill p-1" role="tablist">
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 active  active " data-bs-toggle="tab" href="../../examples/pages/account/settings.html" role="tab" aria-selected="true">
                  Messages
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/billing.html" role="tab" aria-selected="false">
                  Social
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/invoice.html" role="tab" aria-selected="false">
                  Notifications
                </a>
              </li>
              <li class="nav-item">
                <a class="nav-link mb-0 px-0 py-1 " data-bs-toggle="tab" href="../../examples/pages/account/security.html" role="tab" aria-selected="false">
                  Backup
                </a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container-fluid my-3 py-3">
      <div class="row mb-5">
        <div class="col-lg-3">
          <div class="card position-sticky top-1">
            <ul class="nav flex-column bg-white border-radius-lg p-3">
              <li class="nav-item">
                <a class="nav-link text-body" data-scroll="" href="#profile">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>spaceship</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(4.000000, 301.000000)">
                              <path class="color-background" d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                              <path class="color-background" d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                              <path class="color-background" d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                              <path class="color-background" d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Profile</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#basic-info">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>document</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(154.000000, 300.000000)">
                              <path class="color-background" d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                              <path class="color-background" d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Basic Info</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#password">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 42 42" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>box-3d-50</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-2319.000000, -291.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(603.000000, 0.000000)">
                              <path class="color-background" d="M22.7597136,19.3090182 L38.8987031,11.2395234 C39.3926816,10.9925342 39.592906,10.3918611 39.3459167,9.89788265 C39.249157,9.70436312 39.0922432,9.5474453 38.8987261,9.45068056 L20.2741875,0.1378125 L20.2741875,0.1378125 C19.905375,-0.04725 19.469625,-0.04725 19.0995,0.1378125 L3.1011696,8.13815822 C2.60720568,8.38517662 2.40701679,8.98586148 2.6540352,9.4798254 C2.75080129,9.67332903 2.90771305,9.83023153 3.10122239,9.9269862 L21.8652864,19.3090182 C22.1468139,19.4497819 22.4781861,19.4497819 22.7597136,19.3090182 Z"></path>
                              <path class="color-background" d="M23.625,22.429159 L23.625,39.8805372 C23.625,40.4328219 24.0727153,40.8805372 24.625,40.8805372 C24.7802551,40.8805372 24.9333778,40.8443874 25.0722402,40.7749511 L41.2741875,32.673375 L41.2741875,32.673375 C41.719125,32.4515625 42,31.9974375 42,31.5 L42,14.241659 C42,13.6893742 41.5522847,13.241659 41,13.241659 C40.8447549,13.241659 40.6916418,13.2778041 40.5527864,13.3472318 L24.1777864,21.5347318 C23.8390024,21.7041238 23.625,22.0503869 23.625,22.429159 Z" opacity="0.7"></path>
                              <path class="color-background" d="M20.4472136,21.5347318 L1.4472136,12.0347318 C0.953235098,11.7877425 0.352562058,11.9879669 0.105572809,12.4819454 C0.0361450918,12.6208008 6.47121774e-16,12.7739139 0,12.929159 L0,30.1875 L0,30.1875 C0,30.6849375 0.280875,31.1390625 0.7258125,31.3621875 L19.5528096,40.7750766 C20.0467945,41.0220531 20.6474623,40.8218132 20.8944388,40.3278283 C20.963859,40.1889789 21,40.0358742 21,39.8806379 L21,22.429159 C21,22.0503869 20.7859976,21.7041238 20.4472136,21.5347318 Z" opacity="0.7"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Change Password</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#2fa">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>switches</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-1870.000000, -440.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(154.000000, 149.000000)">
                              <path class="color-background" d="M10,20 L30,20 C35.4545455,20 40,15.4545455 40,10 C40,4.54545455 35.4545455,0 30,0 L10,0 C4.54545455,0 0,4.54545455 0,10 C0,15.4545455 4.54545455,20 10,20 Z M10,3.63636364 C13.4545455,3.63636364 16.3636364,6.54545455 16.3636364,10 C16.3636364,13.4545455 13.4545455,16.3636364 10,16.3636364 C6.54545455,16.3636364 3.63636364,13.4545455 3.63636364,10 C3.63636364,6.54545455 6.54545455,3.63636364 10,3.63636364 Z" opacity="0.6"></path>
                              <path class="color-background" d="M30,23.6363636 L10,23.6363636 C4.54545455,23.6363636 0,28.1818182 0,33.6363636 C0,39.0909091 4.54545455,43.6363636 10,43.6363636 L30,43.6363636 C35.4545455,43.6363636 40,39.0909091 40,33.6363636 C40,28.1818182 35.4545455,23.6363636 30,23.6363636 Z M30,40 C26.5454545,40 23.6363636,37.0909091 23.6363636,33.6363636 C23.6363636,30.1818182 26.5454545,27.2727273 30,27.2727273 C33.4545455,27.2727273 36.3636364,30.1818182 36.3636364,33.6363636 C36.3636364,37.0909091 33.4545455,40 30,40 Z"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">2FA</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#accounts">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 42 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>time-alarm</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-2319.000000, -440.000000)" fill="#923DFA" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(603.000000, 149.000000)">
                              <path class="color-background" d="M18.8086957,4.70034783 C15.3814926,0.343541521 9.0713063,-0.410050841 4.7145,3.01715217 C0.357693695,6.44435519 -0.395898667,12.7545415 3.03130435,17.1113478 C5.53738466,10.3360568 11.6337901,5.54042955 18.8086957,4.70034783 L18.8086957,4.70034783 Z" opacity="0.6"></path>
                              <path class="color-background" d="M38.9686957,17.1113478 C42.3958987,12.7545415 41.6423063,6.44435519 37.2855,3.01715217 C32.9286937,-0.410050841 26.6185074,0.343541521 23.1913043,4.70034783 C30.3662099,5.54042955 36.4626153,10.3360568 38.9686957,17.1113478 Z" opacity="0.6"></path>
                              <path class="color-background" d="M34.3815652,34.7668696 C40.2057958,27.7073059 39.5440671,17.3375603 32.869743,11.0755718 C26.1954189,4.81358341 15.8045811,4.81358341 9.13025701,11.0755718 C2.45593289,17.3375603 1.79420418,27.7073059 7.61843478,34.7668696 L3.9753913,40.0506522 C3.58549114,40.5871271 3.51710058,41.2928217 3.79673036,41.8941824 C4.07636014,42.4955431 4.66004722,42.8980248 5.32153275,42.9456105 C5.98301828,42.9931963 6.61830436,42.6784048 6.98113043,42.1232609 L10.2744783,37.3434783 C16.5555112,42.3298213 25.4444888,42.3298213 31.7255217,37.3434783 L35.0188696,42.1196087 C35.6014207,42.9211577 36.7169135,43.1118605 37.53266,42.5493622 C38.3484064,41.9868639 38.5667083,40.8764423 38.0246087,40.047 L34.3815652,34.7668696 Z M30.1304348,25.5652174 L21,25.5652174 C20.49574,25.5652174 20.0869565,25.1564339 20.0869565,24.6521739 L20.0869565,15.5217391 C20.0869565,15.0174791 20.49574,14.6086957 21,14.6086957 C21.50426,14.6086957 21.9130435,15.0174791 21.9130435,15.5217391 L21.9130435,23.7391304 L30.1304348,23.7391304 C30.6346948,23.7391304 31.0434783,24.1479139 31.0434783,24.6521739 C31.0434783,25.1564339 30.6346948,25.5652174 30.1304348,25.5652174 Z"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Accounts</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#notifications">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 44 43" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>megaphone</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-2168.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(452.000000, 300.000000)">
                              <path class="color-background" d="M35.7958333,0.273166667 C35.2558424,-0.0603712374 34.5817509,-0.0908856664 34.0138333,0.1925 L19.734,7.33333333 L9.16666667,7.33333333 C4.10405646,7.33333333 0,11.4373898 0,16.5 C0,21.5626102 4.10405646,25.6666667 9.16666667,25.6666667 L19.734,25.6666667 L34.0138333,32.8166667 C34.5837412,33.1014624 35.2606401,33.0699651 35.8016385,32.7334768 C36.3426368,32.3969885 36.6701539,31.8037627 36.6666942,31.1666667 L36.6666942,1.83333333 C36.6666942,1.19744715 36.3370375,0.607006911 35.7958333,0.273166667 Z"></path>
                              <path class="color-background" d="M38.5,11 L38.5,22 C41.5375661,22 44,19.5375661 44,16.5 C44,13.4624339 41.5375661,11 38.5,11 Z" opacity="0.601050967"></path>
                              <path class="color-background" d="M18.5936667,29.3333333 L10.6571667,29.3333333 L14.9361667,39.864 C15.7423448,41.6604248 17.8234451,42.4993948 19.6501416,41.764381 C21.4768381,41.0293672 22.3968823,38.982817 21.7341667,37.1286667 L18.5936667,29.3333333 Z" opacity="0.601050967"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Notifications</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#sessions">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>settings</title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-2020.000000, -442.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(304.000000, 151.000000)">
                              <polygon class="color-background" opacity="0.596981957" points="18.0883333 15.7316667 11.1783333 8.82166667 13.3333333 6.66666667 6.66666667 0 0 6.66666667 6.66666667 13.3333333 8.82166667 11.1783333 15.315 17.6716667"></polygon>
                              <path class="color-background" d="M31.5666667,23.2333333 C31.0516667,23.2933333 30.53,23.3333333 30,23.3333333 C29.4916667,23.3333333 28.9866667,23.3033333 28.48,23.245 L22.4116667,30.7433333 L29.9416667,38.2733333 C32.2433333,40.575 35.9733333,40.575 38.275,38.2733333 L38.275,38.2733333 C40.5766667,35.9716667 40.5766667,32.2416667 38.275,29.94 L31.5666667,23.2333333 Z" opacity="0.596981957"></path>
                              <path class="color-background" d="M33.785,11.285 L28.715,6.215 L34.0616667,0.868333333 C32.82,0.315 31.4483333,0 30,0 C24.4766667,0 20,4.47666667 20,10 C20,10.99 20.1483333,11.9433333 20.4166667,12.8466667 L2.435,27.3966667 C0.95,28.7083333 0.0633333333,30.595 0.00333333333,32.5733333 C-0.0583333333,34.5533333 0.71,36.4916667 2.11,37.89 C3.47,39.2516667 5.27833333,40 7.20166667,40 C9.26666667,40 11.2366667,39.1133333 12.6033333,37.565 L27.1533333,19.5833333 C28.0566667,19.8516667 29.01,20 30,20 C35.5233333,20 40,15.5233333 40,10 C40,8.55166667 39.685,7.18 39.1316667,5.93666667 L33.785,11.285 Z"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Sessions</span>
                </a>
              </li>
              <li class="nav-item pt-2">
                <a class="nav-link text-body" data-scroll="" href="#delete">
                  <div class="icon me-2">
                    <svg class="text-dark mb-1" width="16px" height="16px" viewBox="0 0 45 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                      <title>shop </title>
                      <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                        <g transform="translate(-1716.000000, -439.000000)" fill="#FFFFFF" fill-rule="nonzero">
                          <g transform="translate(1716.000000, 291.000000)">
                            <g transform="translate(0.000000, 148.000000)">
                              <path class="color-background" d="M46.7199583,10.7414583 L40.8449583,0.949791667 C40.4909749,0.360605034 39.8540131,0 39.1666667,0 L7.83333333,0 C7.1459869,0 6.50902508,0.360605034 6.15504167,0.949791667 L0.280041667,10.7414583 C0.0969176761,11.0460037 -1.23209662e-05,11.3946378 -1.23209662e-05,11.75 C-0.00758042603,16.0663731 3.48367543,19.5725301 7.80004167,19.5833333 L7.81570833,19.5833333 C9.75003686,19.5882688 11.6168794,18.8726691 13.0522917,17.5760417 C16.0171492,20.2556967 20.5292675,20.2556967 23.494125,17.5760417 C26.4604562,20.2616016 30.9794188,20.2616016 33.94575,17.5760417 C36.2421905,19.6477597 39.5441143,20.1708521 42.3684437,18.9103691 C45.1927731,17.649886 47.0084685,14.8428276 47.0000295,11.75 C47.0000295,11.3946378 46.9030823,11.0460037 46.7199583,10.7414583 Z" opacity="0.598981585"></path>
                              <path class="color-foreground" d="M39.198,22.4912623 C37.3776246,22.4928106 35.5817531,22.0149171 33.951625,21.0951667 L33.92225,21.1107282 C31.1430221,22.6838032 27.9255001,22.9318916 24.9844167,21.7998837 C24.4750389,21.605469 23.9777983,21.3722567 23.4960833,21.1018359 L23.4745417,21.1129513 C20.6961809,22.6871153 17.4786145,22.9344611 14.5386667,21.7998837 C14.029926,21.6054643 13.533337,21.3722507 13.0522917,21.1018359 C11.4250962,22.0190609 9.63246555,22.4947009 7.81570833,22.4912623 C7.16510551,22.4842162 6.51607673,22.4173045 5.875,22.2911849 L5.875,44.7220845 C5.875,45.9498589 6.7517757,46.9451667 7.83333333,46.9451667 L19.5833333,46.9451667 L19.5833333,33.6066734 L27.4166667,33.6066734 L27.4166667,46.9451667 L39.1666667,46.9451667 C40.2482243,46.9451667 41.125,45.9498589 41.125,44.7220845 L41.125,22.2822926 C40.4887822,22.4116582 39.8442868,22.4815492 39.198,22.4912623 Z"></path>
                            </g>
                          </g>
                        </g>
                      </g>
                    </svg>
                  </div>
                  <span class="text-sm">Delete Account</span>
                </a>
              </li>
            </ul>
          </div>
        </div>
        <div class="col-lg-9 mt-lg-0 mt-4">
          <!-- Card Profile -->
          <div class="card card-body" id="profile">
            <div class="row justify-content-center align-items-center">
              <div class="col-sm-auto col-4">
                <div class="avatar avatar-xl position-relative">
                  <img src="{% static "assets/img/bruce-mars.jpg" %}" alt="bruce" class="w-100 border-radius-lg shadow-sm">
                </div>
              </div>
              <div class="col-sm-auto col-8 my-auto">
                <div class="h-100">
                  <h5 class="mb-1 font-weight-bolder">
                    Alec Thompson
                  </h5>
                  <p class="mb-0 font-weight-bold text-sm">
                    CEO / Co-Founder
                  </p>
                </div>
              </div>
              <div class="col-sm-auto ms-sm-auto mt-sm-0 mt-3 d-flex">
                <label class="form-check-label mb-0">
                  <small id="profileVisibility">
                    Switch to invisible
                  </small>
                </label>
                <div class="form-check form-switch ms-2">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault23" checked onchange="visible()">
                </div>
              </div>
            </div>
          </div>
          <!-- Card Basic Info -->
          <div class="card mt-4" id="basic-info">
            <div class="card-header">
              <h5>Basic Info</h5>
            </div>
            <div class="card-body pt-0">
              <div class="row">
                <div class="col-6">
                  <label class="form-label">First Name</label>
                  <div class="input-group">
                    <input id="firstName" name="firstName" class="form-control" type="text" placeholder="Alec" required="required">
                  </div>
                </div>
                <div class="col-6">
                  <label class="form-label">Last Name</label>
                  <div class="input-group">
                    <input id="lastName" name="lastName" class="form-control" type="text" placeholder="Thompson" required="required">
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-sm-4 col-6">
                  <label class="form-label mt-4">I'm</label>
                  <select class="form-control" name="choices-gender" id="choices-gender">
                    <option value="Male">Male</option>
                    <option value="Female">Female</option>
                  </select>
                </div>
                <div class="col-sm-8">
                  <div class="row">
                    <div class="col-sm-5 col-5">
                      <label class="form-label mt-4">Birth Date</label>
                      <select class="form-control" name="choices-month" id="choices-month"></select>
                    </div>
                    <div class="col-sm-4 col-3">
                      <label class="form-label mt-4">&nbsp;</label>
                      <select class="form-control" name="choices-day" id="choices-day"></select>
                    </div>
                    <div class="col-sm-3 col-4">
                      <label class="form-label mt-4">&nbsp;</label>
                      <select class="form-control" name="choices-year" id="choices-year"></select>
                    </div>
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-6">
                  <label class="form-label mt-4">Email</label>
                  <div class="input-group">
                    <input id="email" name="email" class="form-control" type="email" placeholder="example@email.com">
                  </div>
                </div>
                <div class="col-6">
                  <label class="form-label mt-4">Confirmation Email</label>
                  <div class="input-group">
                    <input id="confirmation" name="confirmation" class="form-control" type="email" placeholder="example@email.com">
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-6">
                  <label class="form-label mt-4">Your location</label>
                  <div class="input-group">
                    <input id="location" name="location" class="form-control" type="text" placeholder="Sydney, A">
                  </div>
                </div>
                <div class="col-6">
                  <label class="form-label mt-4">Phone Number</label>
                  <div class="input-group">
                    <input id="phone" name="phone" class="form-control" type="number" placeholder="+40 735 631 620">
                  </div>
                </div>
              </div>
              <div class="row">
                <div class="col-md-6 align-self-center">
                  <label class="form-label mt-4">Language</label>
                  <select class="form-control" name="choices-language" id="choices-language">
                    <option value="English">English</option>
                    <option value="French">French</option>
                    <option value="Spanish">Spanish</option>
                  </select>
                </div>
                <div class="col-md-6">
                  <label class="form-label mt-4">Skills</label>
                  <input class="form-control" id="choices-skills" type="text" value="vuejs, angular, react" placeholder="Enter something" />
                </div>
              </div>
            </div>
          </div>
          <!-- Card Change Password -->
          <div class="card mt-4" id="password">
            <div class="card-header">
              <h5>Change Password</h5>
            </div>
            <div class="card-body pt-0">
              <label class="form-label">Current password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="Current password">
              </div>
              <label class="form-label">New password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="New password">
              </div>
              <label class="form-label">Confirm new password</label>
              <div class="form-group">
                <input class="form-control" type="password" placeholder="Confirm password">
              </div>
              <h5 class="mt-5">Password requirements</h5>
              <p class="text-muted mb-2">
                Please follow this guide for a strong password:
              </p>
              <ul class="text-muted ps-4 mb-0 float-start">
                <li>
                  <span class="text-sm">One special characters</span>
                </li>
                <li>
                  <span class="text-sm">Min 6 characters</span>
                </li>
                <li>
                  <span class="text-sm">One number (2 are recommended)</span>
                </li>
                <li>
                  <span class="text-sm">Change it often</span>
                </li>
              </ul>
              <button class="btn bg-gradient-dark btn-sm float-end mt-6 mb-0">Update password</button>
            </div>
          </div>
          <!-- Card Change Password -->
          <div class="card mt-4" id="2fa">
            <div class="card-header d-flex">
              <h5 class="mb-0">Two-factor authentication</h5>
              <span class="badge badge-success ms-auto">Enabled</span>
            </div>
            <div class="card-body">
              <div class="d-flex">
                <p class="my-auto">Security keys</p>
                <p class="text-secondary text-sm ms-auto my-auto me-3">No Security Keys</p>
                <button class="btn btn-sm btn-outline-dark mb-0" type="button">Add</button>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex">
                <p class="my-auto">SMS number</p>
                <p class="text-secondary text-sm ms-auto my-auto me-3">+4012374423</p>
                <button class="btn btn-sm btn-outline-dark mb-0" type="button">Edit</button>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex">
                <p class="my-auto">Authenticator app</p>
                <p class="text-secondary text-sm ms-auto my-auto me-3">Not Configured</p>
                <button class="btn btn-sm btn-outline-dark mb-0" type="button">Set up</button>
              </div>
            </div>
          </div>
          <!-- Card Accounts -->
          <div class="card mt-4" id="accounts">
            <div class="card-header">
              <h5>Accounts</h5>
              <p class="text-sm">Here you can setup and manage your integration settings.</p>
            </div>
            <div class="card-body pt-0">
              <div class="d-flex">
                <img class="width-48-px" src="{% static "assets/img/small-logos/logo-slack.svg" %}" alt="logo_slack">
                <div class="my-auto ms-3">
                  <div class="h-100">
                    <h5 class="mb-0">Slack</h5>
                    <a class="text-sm text-body" href="javascript:;">Show less <i class="fas fa-chevron-up text-xs ms-1" aria-hidden="true"></i></a>
                  </div>
                </div>
                <p class="text-sm text-secondary ms-auto me-3 my-auto">Enabled</p>
                <div class="form-check form-switch my-auto">
                  <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault1">
                </div>
              </div>
              <div class="ps-5 pt-3 ms-3">
                <p class="mb-0 text-sm">You haven't added your Slack yet or you aren't authorized. Please add our Slack Bot to your account by clicking on <a href="javascript">here</a>. When you've added the bot, send your verification code that you have received.</p>
                <div class="d-sm-flex bg-gray-100 border-radius-lg p-2 my-4">
                  <p class="text-sm font-weight-bold my-auto ps-sm-2">Verification Code</p>
                  <input class="form-control form-control-sm ms-sm-auto mt-sm-0 mt-2 w-sm-15 w-40" type="text" value="1172913" data-bs-toggle="tooltip" data-bs-placement="top" title="Copy!">
                </div>
                <div class="d-sm-flex bg-gray-100 border-radius-lg p-2 my-4">
                  <p class="text-sm font-weight-bold my-auto ps-sm-2">Connected account</p>
                  <h6 class="text-sm ms-auto me-3 my-auto">hello@creative-tim.com</h6>
                  <button class="btn btn-sm bg-gradient-danger my-sm-auto mt-2 mb-0" type="button" name="button">Delete</button>
                </div>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex">
                <img class="width-48-px" src="{% static "assets/img/small-logos/logo-spotify.svg" %}" alt="logo_spotify">
                <div class="my-auto ms-3">
                  <div class="h-100">
                    <h5 class="mb-0">Spotify</h5>
                    <p class="mb-0 text-sm">Music</p>
                  </div>
                </div>
                <p class="text-sm text-secondary ms-auto me-3 my-auto">Enabled</p>
                <div class="form-check form-switch my-auto">
                  <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault2">
                </div>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex">
                <img class="width-48-px" src="{% static "assets/img/small-logos/logo-atlassian.svg" %}" alt="logo_atlassian">
                <div class="my-auto ms-3">
                  <div class="h-100">
                    <h5 class="mb-0">Atlassian</h5>
                    <p class="mb-0 text-sm">Payment vendor</p>
                  </div>
                </div>
                <p class="text-sm text-secondary ms-auto me-3 my-auto">Enabled</p>
                <div class="form-check form-switch my-auto">
                  <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault3">
                </div>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex">
                <img class="width-48-px" src="{% static "assets/img/small-logos/logo-asana.svg" %}" alt="logo_asana">
                <div class="my-auto ms-3">
                  <div class="h-100">
                    <h5 class="mb-0">Asana</h5>
                    <p class="mb-0 text-sm">Organize your team</p>
                  </div>
                </div>
                <div class="form-check form-switch ms-auto my-auto">
                  <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault4">
                </div>
              </div>
            </div>
          </div>
          <!-- Card Notifications -->
          <div class="card mt-4" id="notifications">
            <div class="card-header">
              <h5>Notifications</h5>
              <p class="text-sm">Choose how you receive notifications. These notification settings apply to the things you’re watching.</p>
            </div>
            <div class="card-body pt-0">
              <div class="table-responsive">
                <table class="table mb-0">
                  <thead>
                    <tr>
                      <th class="ps-1" colspan="4">
                        <p class="mb-0">Activity</p>
                      </th>
                      <th class="text-center">
                        <p class="mb-0">Email</p>
                      </th>
                      <th class="text-center">
                        <p class="mb-0">Push</p>
                      </th>
                      <th class="text-center">
                        <p class="mb-0">SMS</p>
                      </th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="ps-1" colspan="4">
                        <div class="my-auto">
                          <span class="text-dark d-block text-sm">Mentions</span>
                          <span class="text-xs font-weight-normal">Notify when another user mentions you in a comment</span>
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault11">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault12">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault13">
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="ps-1" colspan="4">
                        <div class="my-auto">
                          <span class="text-dark d-block text-sm">Comments</span>
                          <span class="text-xs font-weight-normal">Notify when another user comments your item.</span>
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault14">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault15">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault16">
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="ps-1" colspan="4">
                        <div class="my-auto">
                          <span class="text-dark d-block text-sm">Follows</span>
                          <span class="text-xs font-weight-normal">Notify when another user follows you.</span>
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault17">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault18">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault19">
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="ps-1" colspan="4">
                        <div class="my-auto">
                          <p class="text-sm mb-0">Log in from a new device</p>
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault20">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault21">
                        </div>
                      </td>
                      <td>
                        <div class="form-check form-switch mb-0 d-flex align-items-center justify-content-center">
                          <input class="form-check-input" checked type="checkbox" id="flexSwitchCheckDefault22">
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <!-- Card Sessions -->
          <div class="card mt-4" id="sessions">
            <div class="card-header pb-3">
              <h5>Sessions</h5>
              <p class="text-sm">This is a list of devices that have logged into your account. Remove those that you do not recognize.</p>
            </div>
            <div class="card-body pt-0">
              <div class="d-flex align-items-center">
                <div class="text-center w-5">
                  <i class="fas fa-desktop text-lg opacity-6"></i>
                </div>
                <div class="my-auto ms-3">
                  <div class="h-100">
                    <p class="text-sm mb-1">
                      Bucharest 68.133.163.201
                    </p>
                    <p class="mb-0 text-xs">
                      Your current session
                    </p>
                  </div>
                </div>
                <span class="badge badge-success badge-sm my-auto ms-auto me-3">Active</span>
                <p class="text-secondary text-sm my-auto me-3">EU</p>
                <a href="javascript:;" class="text-primary text-sm icon-move-right my-auto">See more
                  <i class="fas fa-arrow-right text-xs ms-1" aria-hidden="true"></i>
                </a>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex align-items-center">
                <div class="text-center w-5">
                  <i class="fas fa-desktop text-lg opacity-6"></i>
                </div>
                <p class="my-auto ms-3">Chrome on macOS</p>
                <p class="text-secondary text-sm ms-auto my-auto me-3">US</p>
                <a href="javascript:;" class="text-primary text-sm icon-move-right my-auto">See more
                  <i class="fas fa-arrow-right text-xs ms-1" aria-hidden="true"></i>
                </a>
              </div>
              <hr class="horizontal dark">
              <div class="d-flex align-items-center">
                <div class="text-center w-5">
                  <i class="fas fa-mobile text-lg opacity-6"></i>
                </div>
                <p class="my-auto ms-3">Safari on iPhone</p>
                <p class="text-secondary text-sm ms-auto my-auto me-3">US</p>
                <a href="javascript:;" class="text-primary text-sm icon-move-right my-auto">See more
                  <i class="fas fa-arrow-right text-xs ms-1" aria-hidden="true"></i>
                </a>
              </div>
            </div>
          </div>
          <!-- Card Delete Account -->
          <div class="card mt-4" id="delete">
            <div class="card-header">
              <h5>Delete Account</h5>
              <p class="text-sm mb-0">Once you delete your account, there is no going back. Please be certain.</p>
            </div>
            <div class="card-body d-sm-flex pt-0">
              <div class="d-flex align-items-center mb-sm-0 mb-4">
                <div>
                  <div class="form-check form-switch mb-0">
                    <input class="form-check-input" type="checkbox" id="flexSwitchCheckDefault0">
                  </div>
                </div>
                <div class="ms-2">
                  <span class="text-dark font-weight-bold d-block text-sm">Confirm</span>
                  <span class="text-xs d-block">I want to delete my account.</span>
                </div>
              </div>
              <button class="btn btn-outline-secondary mb-0 ms-auto" type="button" name="button">Deactivate</button>
              <button class="btn bg-gradient-danger mb-0 ms-2" type="button" name="button">Delete Account</button>
            </div>
          </div>
        </div>
      </div>
      <footer class="footer pt-3  ">
        <div class="container-fluid">
          <div class="row align-items-center justify-content-lg-between">
            <div class="col-lg-6 mb-lg-0 mb-4">
              <div class="copyright text-center text-sm text-muted text-lg-start">
                &copy; Neuralami
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>
{% endblock content %}

{% block extra_js %}

  <script src="{% static "assets/js/plugins/choices.min.js" %}"></script>

  <script>
    if (document.getElementById('choices-gender')) {
      var gender = document.getElementById('choices-gender');
      const example = new Choices(gender);
    }

    if (document.getElementById('choices-language')) {
      var language = document.getElementById('choices-language');
      const example = new Choices(language);
    }

    if (document.getElementById('choices-skills')) {
      var skills = document.getElementById('choices-skills');
      const example = new Choices(skills, {
        delimiter: ',',
        editItems: true,
        maxItemCount: 5,
        removeItemButton: true,
        addItems: true
      });
    }

    if (document.getElementById('choices-year')) {
      var year = document.getElementById('choices-year');
      setTimeout(function() {
        const example = new Choices(year);
      }, 1);

      for (y = 1900; y <= 2020; y++) {
        var optn = document.createElement("OPTION");
        optn.text = y;
        optn.value = y;

        if (y == 2020) {
          optn.selected = true;
        }

        year.options.add(optn);
      }
    }

    if (document.getElementById('choices-day')) {
      var day = document.getElementById('choices-day');
      setTimeout(function() {
        const example = new Choices(day);
      }, 1);


      for (y = 1; y <= 31; y++) {
        var optn = document.createElement("OPTION");
        optn.text = y;
        optn.value = y;

        if (y == 1) {
          optn.selected = true;
        }

        day.options.add(optn);
      }

    }

    if (document.getElementById('choices-month')) {
      var month = document.getElementById('choices-month');
      setTimeout(function() {
        const example = new Choices(month);
      }, 1);

      var d = new Date();
      var monthArray = new Array();
      monthArray[0] = "January";
      monthArray[1] = "February";
      monthArray[2] = "March";
      monthArray[3] = "April";
      monthArray[4] = "May";
      monthArray[5] = "June";
      monthArray[6] = "July";
      monthArray[7] = "August";
      monthArray[8] = "September";
      monthArray[9] = "October";
      monthArray[10] = "November";
      monthArray[11] = "December";
      for (m = 0; m <= 11; m++) {
        var optn = document.createElement("OPTION");
        optn.text = monthArray[m];
        // server side month start from one
        optn.value = (m + 1);
        // if june selected
        if (m == 1) {
          optn.selected = true;
        }
        month.options.add(optn);
      }
    }

    function visible() {
      var elem = document.getElementById('profileVisibility');
      if (elem) {
        if (elem.innerHTML == "Switch to visible") {
          elem.innerHTML = "Switch to invisible"
        } else {
          elem.innerHTML = "Switch to visible"
        }
      }
    }

    var openFile = function(event) {
      var input = event.target;

      // Instantiate FileReader
      var reader = new FileReader();
      reader.onload = function() {
        imageFile = reader.result;

        document.getElementById("imageChange").innerHTML = '<img width="200" src="' + imageFile + '" class="rounded-circle w-100 shadow" />';
      };
      reader.readAsDataURL(input.files[0]);
    };
  </script>

{% endblock extra_js %}

================
File: templates/pages/apps/summarize.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block extra_styles %}
<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    #task-status .spinner {
        animation: spin 2s linear infinite;
        display: none;
    }
</style>
{% endblock %}

{% block content %}
{% load replace_value %}
<div id='modelSelectedContext' data-model-selected-value="{{ model_selected }}">
    <div class="container-fluid py-4">
        <div class="row">
            <!-- Main Summarize Area -->
            <div class="col-md-9 order-1 order-md-2">
                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Summarize Something</h5>
                        <form id="summarize-form" data-model-selected-value="{{ model_selected_value }}" method="post" action="{% url 'seo_manager:summarize_view' %}" enctype="multipart/form-data">
                            {% csrf_token %}
                            <div class="mb-3">
                                <label for="text" class="form-label">This will summarize any content you put in here. Copy paste any text, or enter the url of a web page, or enter the share link of a YouTube video:</label>
                                <textarea class="form-control" id="query-text" name="text" rows="5" required></textarea>
                            </div>
                            <div class="mb-3">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="crawl-website" name="crawl-website">
                                    <label class="form-check-label" for="crawl-website">
                                        Crawl entire website (for URLs only)
                                    </label>
                                </div>
                                <div id="max-pages-container" class="mt-2" style="display: none;">
                                    <label for="max-pages" class="form-label">Maximum pages to crawl (1-100):</label>
                                    <input type="number" class="form-control" id="max-pages" name="max-pages" min="1" max="100" value="10" style="width: 150px;">
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary">Summarize</button>
                            <button type="submit" class="btn btn-danger" style="float:right; padding-left:30px;" id="cancel-btn" title="Cancel this task">
                                Cancel 
                            </button>
                        </form>
                    </div>
                </div>

                <div class="card p-3">
                    <div id="task-status" class="mt-3" style="display: none;">
                        <div class="d-flex align-items-center">
                            <div class="spinner me-3">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                            <p class="mb-0">Getting source... <span id="perc-complete"></span> <span id="task-timer">0</span> seconds</p>
                        </div>
                        <div class="progress mt-2">
                            <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                    </div>
                    
                    <div class="card-body p-3">
                        <div class="d-flex justify-content-between align-items-center">
                            <h5 class="card-title">Summary</h5>
                            <button class="btn btn-icon-only shadow-none data-bs-toggle="tooltip" data-bs-placement="top" title data-bs-original-title="Copy to Clipboard" btn-link" id="copy-btn" title="Copy to clipboard" style="display: none;">
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>                
                        <div id="task-result" class="card-body border rounded-3 mt-3" style="display: none;"></div>
                    </div>
                </div>
            </div>

            <!-- Previous Summarizations Sidebar -->
            <div class="col-md-3 order-2 order-md-1">
                {% if request.user.is_superuser %}
                <div class="card mb-4">
                    <div class="card-body">
                        <label>Models:</label>
                        <select id="model-selected" name="models_selected" class="form-select" size="21" style="width: 100%;">
                            {% for model in models %}
                                <option value="{{ model }}" {% if model == model_selected %}selected="selected"{% endif %}>{{ model }}</option>
                            {% endfor %}
                        </select>
                    </div>
                </div>
                {% endif %}

                <div class="card mb-4">
                    <div class="card-body">
                        <h6 class="card-title">Previous Summarizations</h6>
                        <ul id="summarization-list" style="list-style: none; padding: 0;">
                            {% for summarization in summarizations %}
                            <a href="#" style="display: block; padding-left: 0;margin-left: 0;" class="text-xs mb-2" data-query="{{ summarization.query }}" data-response="{{ summarization.html_result }}">
                                {{ summarization.response|clean_title |truncatewords:20 }}
                            </a>
                            <hr class="horizontal dark">
                            {% empty %}
                            <li>No previous summarizations</li>
                            {% endfor %}
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
      const summarizationList = document.getElementById('summarization-list');
      summarizationList.addEventListener('click', function(event) {
        if (event.target.tagName === 'A') {
          const query = event.target.getAttribute('data-query');
          const response = event.target.getAttribute('data-response')
          var queryText=document.getElementById('query-text');
          var taskResult=document.getElementById('task-result');
          var copyBtn = document.getElementById('copy-btn');
          queryText.value = query;  
          taskResult.innerHTML = response;
          taskResult.style.display = 'block';
          copyBtn.style.display = 'inline-block';
        }
      });
    });
</script>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        var form = document.getElementById('summarize-form');
        var taskStatus = document.getElementById('task-status');
        var taskResult = document.getElementById('task-result');
        var csrfToken = '{{ csrf_token }}'; // Get the CSRF token from Django
        var taskTimer = document.getElementById('task-timer');
        var percComplete = document.getElementById('perc-complete');
        var taskTimerInterval;
        var taskStartTime;
        var copyBtn = document.getElementById('copy-btn');

        // Add this at the beginning of your DOMContentLoaded handler
        const crawlWebsiteCheckbox = document.getElementById('crawl-website');
        const maxPagesContainer = document.getElementById('max-pages-container');

        crawlWebsiteCheckbox.addEventListener('change', function() {
            maxPagesContainer.style.display = this.checked ? 'block' : 'none';
        });

        form.addEventListener('submit', function(event) {
            event.preventDefault();
            taskStatus.style.display = 'block';
            taskResult.style.display = 'none';
            taskResult.innerHTML = ''; // Clear the task result
            taskTimer.textContent = 0; // Reset the task timer
            clearInterval(taskTimerInterval); // Clear any existing interval
            copyBtn.style.display = 'none'; // Hide the copy button

            var modelSelectedElement = document.getElementById('model-selected');
            var modelSelected = modelSelectedElement ? modelSelectedElement.value : '';
            var modelSelectedFromContext = document.getElementById('modelSelectedContext');
            var modelSelectedValue = modelSelectedFromContext.dataset.modelSelectedValue;

            if (!modelSelected) {
                modelSelected = modelSelectedValue;
            }
            var formData = new FormData(form);
            
            // Add crawl website and max pages data if checkbox is checked
            if (crawlWebsiteCheckbox.checked) {
                formData.append('crawl_website', true);
                formData.append('max_pages', document.getElementById('max-pages').value);
            }

            formData.append('model_selected_value', modelSelected);            
            formData.append('query_text_value', document.getElementById('query-text').value);

            var xhr = new XMLHttpRequest();
            xhr.open('POST', '{% url "seo_manager:summarize_view" %}');
            xhr.onload = function() {
                if (xhr.status === 200) {
                    var response = JSON.parse(xhr.responseText);
                    console.log(response)
                    if (response.task_id) {
                        taskStartTime = new Date().getTime();
                        taskTimerInterval = setInterval(updateTaskTimer, 5000);
                        checkTaskStatus(response.task_id);
                    } else {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = 'Error: ' + response.error;
                        taskResult.style.display = 'block';
                    }
                }
            };
            xhr.send(formData);
        });

        function updateTaskTimer() {
            var currentTime = new Date().getTime();
            var elapsedTime = Math.floor((currentTime - taskStartTime) / 1000);
            taskTimer.textContent = elapsedTime;
        }

        // Store the current task ID
        let currentTaskId = null;
        
        function handleCancelClick(event) {
            event.preventDefault();
            if (currentTaskId) {
                clearInterval(taskTimerInterval);
                checkTaskStatus(currentTaskId, 'cancel');
            }
        }
        
        function checkTaskStatus(taskId, action = null) {
            currentTaskId = taskId; // Store the task ID
            var xhr = new XMLHttpRequest();
            
            var taskStatusUrl = '{% url "seo_manager:task_status" task_id="TASK_ID" %}'.replace('TASK_ID', encodeURIComponent(taskId));
            if (action === 'cancel') {
                taskStatusUrl += '?action=cancel';
            }
            xhr.open('GET', taskStatusUrl);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    var response = JSON.parse(xhr.responseText);
                    console.log(response); // Log the response for debugging
        
                    if (response.status === 'SUCCESS') {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = response.result;
                        taskResult.style.display = 'block';
                        copyBtn.style.display = 'inline-block'; // Show the copy button
                        clearInterval(taskTimerInterval); // Stop the timer interval
                            // Reset progress bar
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.width = '0%';
                        progressBar.setAttribute('aria-valuenow', 0);
                        percComplete.textContent = '0'; // Reset percentage text
                    } else if (response.status === 'FAILURE') {
                        taskStatus.style.display = 'none';
                        taskResult.innerHTML = 'Error: ' + response.result;
                        taskResult.style.display = 'block';
                        clearInterval(taskTimerInterval); // Stop the timer interval
                    } else if (response.status === 'processing') {
                        var progress = (response.current / response.total) * 100;
                        // Update progress percentage element
                        percComplete.textContent = response.status + '... ' + Math.round(progress) + '%';
                        // Update progress bar width
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.width = progress + '%';
                        progressBar.setAttribute('aria-valuenow', progress);
                        setTimeout(function () {
                            checkTaskStatus(taskId);
                        }, 5000);
                    } else if (response.satus ==='summarizing') {
                        percComplete.textContent = response.status + '... ';
                        var progressBar = document.getElementById('progress-bar');
                        progressBar.style.display = 'block';
                    } else {
                        percComplete.textContent = response.status + '... '
                        setTimeout(function() {
                            checkTaskStatus(taskId);
                        }, 5000);
                    }
                } else {
                    // Handle other response status codes
                    console.error('Error checking task status:', xhr.status, xhr.statusText);
                }
            };
            xhr.send();
        }
        
        // Add an event listener to the cancel button
        document.getElementById('cancel-btn').addEventListener('click', handleCancelClick);
        
        // Copy to clipboard functionality
        copyBtn.addEventListener('click', function() {
            var resultText = taskResult.textContent.trim();
            if (resultText) {
                navigator.clipboard.writeText(resultText)
                    .then(() => {
                        alert('Summary copied to clipboard!');
                    })
                    .catch((err) => {
                        console.error('Failed to copy summary: ', err);
                    });
            }
        });
    });
</script>
{% endblock extra_js %}

================
File: templates/pages/apps/tasks.html
================
{% extends 'layouts/base.html' %}
{% load formats file_extension info_value %}

{% block title %} Tables {% endblock title %}

{% block extrastyle %}
<!-- Specific CSS goes HERE -->
<style>
  .badge.bg-success:not(.badge-opaque) {
    background: #14A44D !important; }
  
  .badge.bg-warning:not(.badge-opaque) {
    background: #E4A11B !important; }
  
  .badge.bg-danger:not(.badge-opaque) {
    background: #DC4C64 !important; }

  .badge.bg-secondary:not(.badge-opaque) {
    background: #9FA6B2 !important; }

</style>
{% endblock extrastyle %}

<!-- MAIN Content -->
{% block content %}

    <div class="container-fluid py-4">

      <!-- Info component -->
      <div class="row">
        <div class="col-12">
          <div class="card mb-4">
            <div class="card-header pb-0">
              <h6>
                Async Tasks Manager
              </h6>
            </div>
            <div class="card-body px-0 pt-0 pb-2 px-4 mt-3">
              
              {% if scripts %}
                <p>
                  Superusers are able to create/cancel tasks.
                  <br />
                  Ordinary users can only view execution logs and running tasks (no other interactions allowed).
                </p>
              {% else %}
                <p class="text-danger">
                  No scripts detected - Please update the configuration (CELERY_SCRIPTS_DIR, CELERY_LOGS_DIR)
                </p>
              {% endif %}
            
            </div>
          </div>
        </div>
      </div>
      
      <!-- Task Manager Component -->
      <div class="row">
        <div class="col-12">
          <div class="card mb-4">
            <div class="card-header pb-0">
              <h6>Tasks List</h6>
            </div>
            <div class="card-body px-0 pt-0 pb-2">
              <div class="table-responsive p-0">
                <table class="table align-items-center mb-0">
                  <thead>
                    <tr>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder opacity-7">Name</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder opacity-7 ps-2">Script</th>
                      <th class="text-center text-uppercase text-dark text-xxs font-weight-bolder opacity-7">STATE</th>
                      <th class="text-center text-uppercase text-dark text-xxs font-weight-bolder opacity-7">
                        Script
                      </th>
                      <th class="text-center text-uppercase text-dark text-xxs font-weight-bolder opacity-7">
                        ARGS
                      </th>                   
                      {% if request.user.is_authenticated %}
                      <th class="text-center text-dark opacity-7">Action</th>
                      {% endif %}
                    </tr>
                  </thead>
                  <tbody>

                    <!-- Running Task -->
                    {% for task in  tasks %}    

                    {% if task.status == "STARTED" %}
                    <form action="{% url 'cancel-task' task.id %}" method="post">
                    {% else %}
                    <form action="{% url 'run-task' task.name %}" method="post">                      
                    {% endif %}  

                    
                      {% csrf_token %}
                      <tr>
                        <td>
                          <div class="d-flex px-2 py-1">
                            <div class="mx-3">
                              <i class="fa fa-file-code-o fa-2x"></i>
                            </div>
                            <div class="d-flex flex-column justify-content-center">
                              <h6 class="mb-0 text-sm">
                                {{task.name}}
                              </h6>
                              <p class="text-xs text-dark mb-0">
                                Celery Task
                              </p>
                            </div>
                          </div>
                        </td>
                        <td>
                          <p class="text-xs font-weight-bold mb-0">
                            {{ task.script }}
                          </p>
                          <div class="text-xs text-dark mb-0" style="width:200px;height:50px;overflow-x: scroll;">
                            Latest status: {{ task.status }}
                          </div>                          
                        </td>
                        <td class="align-middle text-center text-sm">

                          {% if task.status == "STARTED" %}
                            <span class="badge bg-warning">RUNNING</span>
                          {% elif task.status == "FAILURE" %}
                            <span class="badge bg-danger">FINISHED</span>
                          {% elif task.status == "REVOKED" %}
                          <span class="badge bg-secondary">CANCELLED</span>
                          {% else %}
                            <span class="badge bg-success">FINISHED</span>                          
                          {% endif %}
                          
                        </td>
                        <td class="align-middle text-center">
                          <span class="text-dark text-xs font-weight-bold">
                            
                            {% if task.name == 'execute_script' %}

                              <select class="form-control" name="script" 
                              {% if task.status == "STARTED" or not scripts %}
                                disabled
                              {% endif %}
                              >
                                {% for item in scripts %}
                                  <option value="{{item}}" {% if item == task.input %}selected{% endif %}>{{ item }}</option>
                                {% endfor %}
                              </select>
                            
                            {% else %}
                              NA
                            {% endif %}
                            
                          </span>
                        </td>
                        <td class="align-middle text-center">
                          <span class="text-dark text-xs font-weight-bold">
                            <input type="text" id="args" name="args">
                          </span>
                        </td>

                        {% if request.user.is_authenticated %}
                        <td class="align-middle text-center">

                          {% if task.status == "STARTED" %}

                            <button href="javascript:;" class="text-danger font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit user">
                              Cancel Task
                            </button>

                          {% elif task.status == "FAILURE" or task.status == "REVOKED" %}
                              
                              <button href="javascript:;" 
                                      class="text-dark font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit user">
                                Execute
                              </button>

                          {% else %}                               
                            
                              <button href="javascript:;" 
                                      class="text-dark font-weight-bold text-xs" data-toggle="tooltip" data-original-title="Edit user">
                                Execute
                              </button>

                          {% endif %}

                        </td>
                        {% endif %}
                      </tr>

                    </form>
                  {% endfor %}

                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Task Logs -->
      <div class="row">
        <div class="col-12">
          <div class="card mb-4">
            <div class="card-header pb-0">
              <h6>
                LOGS
              </h6>
            </div>
            <div class="card-body px-0 pt-0 pb-2">
              <div class="table-responsive p-0">
                <table class="table align-items-center justify-content-center mb-0">
                  <thead>
                    <tr>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder opacity-7">Task</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder opacity-7 ps-2">Input</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder text-center opacity-7 ps-2">Status</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder text-center opacity-7 ps-2">Start TS</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder text-center opacity-7 ps-2">End TS</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder text-center opacity-7 ps-2">Output</th>
                      <th class="text-uppercase text-dark text-xxs font-weight-bolder text-center opacity-7 ps-2">Logs</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for result in task_results %}
                      <tr>

                        <td>
                          <div class="d-flex px-2">
                            <div class="my-auto">
                              <h6 class="mb-0 text-sm">
                                {{result.id}} - {{result.task_name}}
                              </h6>
                              <p class="text-xs text-dark mb-0">
                                {{result.task_id}}
                              </p>
                            </div>
                          </div>
                        </td>

                        <td class="align-middle">
                          <p class="text-sm mb-0">{{result|get_result_field:"input"}}</p>
                        </td>

                        <td class="align-middle">
                          <p class="text-sm 
                            {% if result|get_result_field:"status" == 'SUCCESS' %} text-success
                            {% elif result|get_result_field:"status" == 'FAILURE' %} text-danger
                            {% else %} text-warning {% endif %}
                            text-center mb-0"
                          >
                          {% if result|get_result_field:"status" %}
                            {{result|get_result_field:"status"}}
                          {% else %}
                            RUNNING
                          {% endif %}
                          </p>
                        </td>
                        
                        <td class="align-middle">
                          <p class="text-sm text-center mb-0">{{result.date_created|date_format}}</p>
                        </td>
                        
                        <td class="align-middle">
                          <p class="text-sm text-center mb-0">{{result.date_done|date_format}}</p>
                        </td>      
                        
                        <td class="">
                          <p class="text-sm text-center mb-0">{{result|get_result_field:"output"}}</p>
                        </td>   
                        <td class="">
                          <p class="text-sm text-center mb-0">
                            <a data-bs-toggle="modal" data-bs-target="#view-log-{{result.id}}" href="#">View LOG</a> 
                          </p>
                        </td>                                               

                      </tr>

                      <div class="modal fade" id="view-log-{{result.id}}" data-bs-backdrop="static" data-bs-keyboard="false"
                        tabindex="-1" aria-labelledby="staticBackdropLabel" aria-hidden="true">
                        <div class="modal-dialog modal-dialog-centered modal-lg">
                          <div class="modal-content">
                            <div class="modal-header">
                              <h1 class="modal-title fs-5" id="staticBackdropLabel">
                                {% if result|get_result_field:"log_file" %}
                                  {{result|get_result_field:"log_file"|log_file_path|cut:"/"}}
                                {% endif %}
                              </h1>
                              <span>
                                {% if result|get_result_field:"log_file" %}
                                  <a href="{% url 'download_log_file' result|get_result_field:"log_file"|encoded_file_path %}">
                                    <i title="Download" class="fas fa-download text-success fs-4"></i>
                                </a>
                                {% endif %}
                              </span>
                              <div class="" id="modal-close-btn-{{result.id}}" data-bs-dismiss="modal" aria-label="Close">
                                <i class="fas fa-times fs-5"></i>
                              </div>
                            </div>
                            <div class="modal-body">
                              {% if result|get_result_field:"log_file" %}
                                <pre class="bg-dark text-light p-3">{{result|get_result_field:"log_file"|log_file_path|log_to_text}}</pre>
                              {% endif %}
                            </div>
                          </div>
                        </div>
                      </div>


                    {% endfor %}

                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="modal fade" 
         id="log-modal" tabindex="-1" role="dialog" aria-labelledby="modal-default" aria-hidden="true">
      <div class="modal-dialog modal- modal-dialog-centered modal-" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h6 class="modal-title mx-auto" id="modal-title-default">
              Task LOG
            </h6>
          </div>
          <div class="modal-body">
            <p id="log-content">
            </p>
          </div>
          <div class="modal-footer text-center">
            <button type="button" class="btn btn-link mx-auto" data-bs-dismiss="modal">Dismiss</button>
          </div>
        </div>
      </div>
    </div>  

{% endblock content %}
<!-- MAIN Content END -->

<!-- Specific JS goes HERE --> 
{% block javascripts %}

<script>

var logsModal      = new bootstrap.Modal(document.getElementById("log-modal"), {});
var logFileContent = document.getElementById("log-content");

function viewLog( aId ) {
  //console.log(' > LOG ' + aId );

  fetch('{% url 'task-log' %}?task_id=' + aId)
      .then((response) => response.json())
      .then((data) => { 
        console.log( data );
        logFileContent.textContent = JSON.stringify( data ); 
        logsModal.show();
      })
      .catch((err)     => { console.log(err.toString()) }); 
}

</script>

{% endblock javascripts %}

================
File: templates/pages/apps/user-profile.html
================
{% extends 'layouts/base.html' %}
{% load static %}

{% block content %}
{% csrf_token %}

<div class="container-fluid py-4">

<div class="row">
  <!-- [ sample-page ] start -->
  <div class="col-lg-4">
    <div class="card user-card user-card-1">
      <div class="card-body pb-0">
        <div class="float-end">
          <span class="badge badge-success">Pro</span>
        </div>
        <div class="media d-flex user-about-block align-items-center mt-0 mb-3">
          <form method="post" action="{% url "upload_avatar" %}" class="position-relative d-inline-block" enctype="multipart/form-data">
            {% csrf_token %}

            <input type="file" onchange="this.form.submit()" name="avatar" class="d-none" id="avatar">
            <label for="avatar">
              {% if request.user.profile.avatar %}
                <img class="rounded" width="60px" src="{{ request.user.profile.avatar.url }}" alt="User image">
              {% else %}
                <img class="rounded" width="60px" src="{% static 'assets/img/team-2.jpg' %}" alt="User image">
              {% endif %}
             
            </label>
          </form>
          <div class="media-body ms-3">
            <h6 class="mb-1">
              {% if request.user.profile.full_name %}
                {{request.user.profile.full_name}}
              {% else %}
                {{ request.user.username }}
              {% endif %}
            </h6>
            <p class="mb-0 text-muted">UI/UX Designer</p>
          </div>
        </div>
      </div>
      <ul class="list-group list-group-flush">
        <li class="list-group-item">
          <span class="f-w-500"><i class="feather icon-mail m-r-10"></i>Email</span>
          <a href="mailto:demo@sample" class="float-end text-body">{{ request.user.email }}</a>
        </li>
        <li class="list-group-item">
          <span class="f-w-500"><i class="feather icon-phone-call m-r-10"></i>Phone</span>
          <a href="#" class="float-end text-body">{{ request.user.profile.phone|default_if_none:"" }}</a>
        </li>
      </ul>
      <div class="nav flex-column nav-pills list-group list-group-flush list-pills mt-3" id="user-set-tab" role="tablist"
        aria-orientation="vertical">
        <a class="nav-link list-group-item list-group-item-action active border-0" id="user-set-profile-tab"
          data-bs-toggle="pill" href="#user-set-profile" role="tab" aria-controls="user-set-profile"
          aria-selected="true">
          <span class="f-w-500"><i class="feather icon-user m-r-10 h5 "></i>Profile
            Overview</span>
          <span class="float-end"><i class="feather icon-chevron-right"></i></span>
        </a>
        <a class="nav-link list-group-item list-group-item-action border-0" id="user-set-information-tab" data-bs-toggle="pill"
          href="#user-set-information" role="tab" aria-controls="user-set-information" aria-selected="false">
          <span class="f-w-500"><i class="feather icon-file-text m-r-10 h5 "></i>Edit Profile</span>
          <span class="float-end"><i class="feather icon-chevron-right"></i></span>
        </a>
        <a class="nav-link list-group-item list-group-item-action border-0" id="user-set-passwort-tab" data-bs-toggle="pill"
          href="#user-set-passwort" role="tab" aria-controls="user-set-passwort" aria-selected="false">
          <span class="f-w-500"><i class="feather icon-shield m-r-10 h5 "></i>Change
            Password</span>
          <span class="float-end"><i class="feather icon-chevron-right"></i></span>
        </a>
        <a class="nav-link list-group-item list-group-item-action border-0" id="user-set-api-tab" data-bs-toggle="pill"
          href="#user-set-api" role="tab" aria-controls="user-set-api" aria-selected="false">
          <span class="f-w-500"><i class="feather icon-key m-r-10 h5 "></i>API Token</span>
          <span class="float-end"><i class="feather icon-chevron-right"></i></span>
        </a>
        <a class="nav-link list-group-item list-group-item-action border-0" id="user-set-slack-tab" data-bs-toggle="pill"
          href="#user-set-slack" role="tab" aria-controls="user-set-slack" aria-selected="false">
          <span class="f-w-500"><i class="feather icon-message-circle m-r-10 h5 "></i>Slack
            Integration</span>
          <span class="float-end"><i class="feather icon-chevron-right"></i></span>
        </a>
      </div>
    </div>
  </div>
  <div class="col-lg-8">
    <div class="tab-content bg-transparent p-0 shadow-none" id="user-set-tabContent">
      <div class="tab-pane fade show active" id="user-set-profile" role="tabpanel"
        aria-labelledby="user-set-profile-tab">
        {% if messages %}
          {% for message in messages %}          
            <div class="alert {{ message.tags }} alert-dismissible" role="alert">
              <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close">
              </button>
              <p class="mb-0">{{ message }}</p>
            </div>
          {% endfor %}
        {% endif %}
        <div class="card">
          <div class="card-header">
            <h5><i class="feather icon-user text-c-blue wid-20"></i><span class="p-l-5">About me</span>
            </h5>
          </div>
          <div class="card-body">
            <p>
              {{ request.user.profile.bio.html|safe }}
            </p>
            <h5 class="mt-5 mb-3">Personal Details</h5>
            <table class="table table-borderless">
              <tbody>
                <tr>
                  <td class="">Full Name</td>
                  <td class="">:</td>
                  <td class="">{{ request.user.profile.full_name|default_if_none:"" }}</td>
                </tr>
                <tr>
                  <td class="">Address</td>
                  <td class="">:</td>
                  <td class="">{{ request.user.profile.address|default_if_none:"" }}{% if request.user.profile.city %}, {{request.user.profile.city}}{% endif %}{% if request.user.profile.country %}, {{request.user.profile.country}}{% endif %} </td>
                </tr>
                <tr>
                  <td class="">Zip Code</td>
                  <td class="">:</td>
                  <td class="">{{ request.user.profile.zip_code|default_if_none:"" }}</td>
                </tr>
                <tr>
                  <td class="">Phone</td>
                  <td class="">:</td>
                  <td class="">{{ request.user.profile.phone|default_if_none:"" }}</td>
                </tr>
                <tr>
                  <td class="">Email</td>
                  <td class="">:</td>
                  <td class="">{{ request.user.email|default_if_none:"" }}</td>
                </tr>
              </tbody>
            </table>
            <!-- Education -->
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="user-set-information" role="tabpanel" aria-labelledby="user-set-information-tab">
        <form method="post" action="{% url 'profile' %}" class="card">
          {% csrf_token %}

          <div class="card-header">
            <h5><i class="feather icon-user text-c-blue wid-20"></i><span class="p-l-5">Edit Profile</span></h5>
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-sm-12">
                <div class="form-group mb-3">
                  <label class="form-label">Full Name <span class="text-danger">*</span></label>
                  <input type="text" name="full_name" class="form-control" value="{{ request.user.profile.full_name|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Contact Phone</label>
                  <input type="text" name="phone" class="form-control" value="{{ request.user.profile.phone|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Email <span class="text-black-50">(Read Only)</span></label>
                  <input type="text" readonly class="form-control" name="email" value="{{ request.user.email }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Address</label>
                  <input type="text" name="address" class="form-control" value="{{ request.user.profile.address|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">City <span class="text-danger">*</span></label>
                  <input type="text" class="form-control" name="city" value="{{ request.user.profile.city|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Zip Code <span class="text-danger">*</span></label>
                  <input type="text" class="form-control" name="zip_code" value="{{ request.user.profile.zip_code|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Country <span class="text-danger">*</span></label>
                  <input type="text" class="form-control" name="country" value="{{ request.user.profile.country|default_if_none:"" }}">
                </div>
              </div>
              <div class="col-sm-12">
                <div class="form-group">
                  <label for="bio" class="form-label">Bio</label>
                  {{ form.media }}
                  {{ form.bio }}
                </div>
              </div>
            </div>
          </div>

          <div class="card-footer text-end">
            <button type="submit" class="btn btn-primary">Update Profile</button>
          </div>
        </form>
      </div>
      <div class="tab-pane fade" id="user-set-passwort" role="tabpanel" aria-labelledby="user-set-passwort-tab">
        <form method="post" action="{% url 'change_password' %}" class="card">
          {% csrf_token %}

          <div class="card-header">
            <h5><i data-feather="lock" class="icon-svg-primary wid-20"></i><span class="p-l-5">Change
                Password</span></h5>
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Current Password <span class="text-danger">*</span></label>
                  <input type="password" name="current_password" class="form-control mb-2" placeholder="Enter Your currunt password">
                </div>
              </div>
            </div>
            <div class="row">
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">New Password <span class="text-danger">*</span></label>
                  <input type="password" name="new_password" class="form-control" placeholder="Enter New password">
                </div>
              </div>
              <div class="col-sm-6">
                <div class="form-group mb-3">
                  <label class="form-label">Confirm Password <span class="text-danger">*</span></label>
                  <input type="password" name="confirm_new_password" class="form-control" placeholder="Enter your password again">
                </div>
              </div>
            </div>
          </div>
          <div class="card-footer text-end">
            <button type="submit" class="btn btn-danger">Change Password</button>
            <button type="button" class="btn btn-outline-danger ms-2">Clear</button>
          </div>
        </form>
      </div>
      <div class="tab-pane fade" id="user-set-api" role="tabpanel" aria-labelledby="user-set-api-tab">
        <div class="card">
          <div class="card-header">
            <h5><i class="feather icon-key text-c-blue wid-20"></i><span class="p-l-5">API Token Management</span></h5>
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-sm-12">
                <p class="mb-4">Your API token is used to authenticate requests to the API. Keep it secure and do not share it with others.</p>
                <div class="form-group mb-4">
                  <label class="form-label">Current API Token</label>
                  <div class="input-group">
                    <input type="text" class="form-control" id="api-token" value="{{ request.user.profile.get_token.key }}" readonly>
                    <button class="btn btn-outline-secondary" type="button" onclick="copyToken()">
                      <i class="feather icon-copy"></i>
                    </button>
                  </div>
                </div>
                <button type="button" class="btn btn-danger" onclick="regenerateToken()">
                  <i class="feather icon-refresh-cw me-2"></i>Regenerate Token
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="user-set-slack" role="tabpanel" aria-labelledby="user-set-slack-tab">
        <div class="card">
          <div class="card-header">
            <h5><i class="feather icon-message-circle text-c-blue wid-20"></i><span class="p-l-5">Slack Integration</span></h5>
          </div>
          <div class="card-body">
            <div class="row">
              <div class="col-sm-12">
                <p class="mb-4">Connect your Slack workspace to enable AI assistant features directly in your Slack channels.</p>
                <a href="{% url 'agents:slack_oauth_start' %}" class="btn btn-primary">
                  <i class="fab fa-slack me-2"></i>Connect to Slack
                </a>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- [ sample-page ] end -->
</div>
<!-- [ Main Content ] end -->
</div>
{% endblock content %}

{% block extra_js %}

<script src="{% static 'assets/js/plugins/choices.min.js' %}"></script>
<script src="{% static 'assets/js/plugins/sweetalert.min.js' %}"></script>
<script>

  var textRemove = new Choices(
    document.getElementById('skill-mlt-select'), {
    delimiter: ',',
    editItems: true,
    maxItemCount: 5,
    removeItemButton: true,
  }
  );

  function copyToken() {
    var tokenInput = document.getElementById('api-token');
    tokenInput.select();
    document.execCommand('copy');
    Swal.fire({
      title: 'Copied!',
      text: 'API token copied to clipboard',
      icon: 'success',
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 3000
    });
  }

  function regenerateToken() {
    Swal.fire({
      title: 'Are you sure?',
      text: "This will invalidate your current API token. Any applications using it will need to be updated.",
      icon: 'warning',
      showCancelButton: true,
      confirmButtonColor: '#3085d6',
      cancelButtonColor: '#d33',
      confirmButtonText: 'Yes, regenerate it!'
    }).then((result) => {
      if (result.isConfirmed) {
        const csrfToken = document.querySelector('input[name="csrfmiddlewaretoken"]').value;
        
        fetch('{% url "regenerate_token" %}', {
          method: 'POST',
          headers: {
            'X-CSRFToken': csrfToken,
            'Content-Type': 'application/json'
          },
          credentials: 'same-origin'
        })
        .then(response => {
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          return response.json();
        })
        .then(data => {
          document.getElementById('api-token').value = data.token;
          Swal.fire({
            title: 'Success!',
            text: data.message,
            icon: 'success',
            toast: true,
            position: 'top-end',
            showConfirmButton: false,
            timer: 3000
          });
        })
        .catch(error => {
          console.error('Error:', error);
          Swal.fire({
            title: 'Error!',
            text: 'Failed to regenerate token. Please try again.',
            icon: 'error'
          });
        });
      }
    });
  }
</script>

{% endblock extra_js %}

================
File: templates/pages/dashboards/default.html
================
{% extends "layouts/base.html" %}
{% load static %}

{% block content %}

    <div class="container-fluid py-4">
      <div class="row">
        <h2 class="mb-0">General Dashboard</h2>
        <p class="mb-4 ms-1">This is a simple dashboard with some statistics and charts.</p>
        <div class="col-lg-7">
          <div class="row">
            <div class="col-lg-6 col-sm-6">
              <div class="card  mb-4">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">Today's Money</p>
                        <h5 class="font-weight-bolder mb-0">
                          $53,000
                          <span class="text-success text-sm font-weight-bolder">+55%</span>
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-primary shadow text-center border-radius-md">
                        <i class="ni ni-money-coins text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card ">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">Today's Users</p>
                        <h5 class="font-weight-bolder mb-0">
                          2,300
                          <span class="text-success text-sm font-weight-bolder">+3%</span>
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-primary shadow text-center border-radius-md">
                        <i class="ni ni-world text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-lg-6 col-sm-6 mt-sm-0 mt-4">
              <div class="card  mb-4">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">New Clients</p>
                        <h5 class="font-weight-bolder mb-0">
                          +3,462
                          <span class="text-danger text-sm font-weight-bolder">-2%</span>
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-primary shadow text-center border-radius-md">
                        <i class="ni ni-paper-diploma text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="card ">
                <div class="card-body p-3">
                  <div class="row">
                    <div class="col-8">
                      <div class="numbers">
                        <p class="text-sm mb-0 text-capitalize font-weight-bold">Sales</p>
                        <h5 class="font-weight-bolder mb-0">
                          $103,430
                          <span class="text-success text-sm font-weight-bolder">+5%</span>
                        </h5>
                      </div>
                    </div>
                    <div class="col-4 text-end">
                      <div class="icon icon-shape bg-primary shadow text-center border-radius-md">
                        <i class="ni ni-cart text-lg opacity-10" aria-hidden="true"></i>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="mt-4">
            <div class="card ">
              <div class="card-header pb-0 p-3">
                <div class="d-flex justify-content-between">
                  <h6 class="mb-2">Sales by Country</h6>
                </div>
              </div>
              <div class="table-responsive">
                <table class="table align-items-center mb-0">
                  <thead>
                    <tr>
                      <th class="text-left text-sm p-0 pb-2 ps-3">Country</th>
                      <th class="text-left text-sm p-0 pb-2 ps-1">Sales</th>
                      <th class="text-left text-sm p-0 pb-2 ps-1">Value</th>
                      <th class="text-left text-sm p-0 pb-2 ps-1">Bounce</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td class="w-30">
                        <div class="d-flex px-2 py-1 align-items-center">
                          <div>
                            <img src="{% static "assets/img/icons/flags/US.png" %}" alt="Country flag">
                          </div>
                          <div class="ms-2">
                            <h6 class="text-sm mb-0">United States</h6>
                          </div>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">2500</h6>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">$230,900</h6>
                        </div>
                      </td>
                      <td class="align-middle text-sm">
                        <div class="col text-left">
                          <h6 class="text-sm mb-0">29.9%</h6>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="w-30">
                        <div class="d-flex px-2 py-1 align-items-center">
                          <div>
                            <img src="{% static "assets/img/icons/flags/DE.png" %}" alt="Country flag">
                          </div>
                          <div class="ms-2">
                            <h6 class="text-sm mb-0">Germany</h6>
                          </div>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">3.900</h6>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">$440,000</h6>
                        </div>
                      </td>
                      <td class="align-middle text-sm">
                        <div class="col text-left">
                          <h6 class="text-sm mb-0">40.22%</h6>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="w-30">
                        <div class="d-flex px-2 py-1 align-items-center">
                          <div>
                            <img src="{% static "assets/img/icons/flags/GB.png" %}" alt="Country flag">
                          </div>
                          <div class="ms-2">
                            <h6 class="text-sm mb-0">Great Britain</h6>
                          </div>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">1.400</h6>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">$190,700</h6>
                        </div>
                      </td>
                      <td class="align-middle text-sm">
                        <div class="col text-left">
                          <h6 class="text-sm mb-0">23.44%</h6>
                        </div>
                      </td>
                    </tr>
                    <tr>
                      <td class="w-30">
                        <div class="d-flex px-2 py-1 align-items-center">
                          <div>
                            <img src="{% static "assets/img/icons/flags/BR.png" %}" alt="Country flag">
                          </div>
                          <div class="ms-2">
                            <h6 class="text-sm mb-0">Brasil</h6>
                          </div>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">562</h6>
                        </div>
                      </td>
                      <td>
                        <div class="text-left">
                          <h6 class="text-sm mb-0">$143,960</h6>
                        </div>
                      </td>
                      <td class="align-middle text-sm">
                        <div class="col text-left">
                          <h6 class="text-sm mb-0">32.14%</h6>
                        </div>
                      </td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-5 col-sm-6 mt-sm-0 mt-4">
          <div class="card">
            <div class="card-body p-3 position-relative overflow-hidden min-height-500">
              <div class="row">
                <div class="col-10">
                  <div class="numbers">
                    <h3 class="text-dark font-weight-bold mb-0">Global Sales</h3>
                    <p class="mb-0 mb-4">Check the global stats of the company</p>
                    <h5 class="font-weight-bolder mb-0">
                      $103,430
                    </h5>
                    <p class="mb-2">Generated sales</p>
                    <h5 class="font-weight-bolder mb-0">
                      24,500
                    </h5>
                    <p class="mb-0">Reached Users</p>
                  </div>
                </div>
                <div class="col-2 text-end">
                  <div class="icon icon-shape bg-primary shadow text-center border-radius-md">
                    <i class="ni ni-square-pin text-lg opacity-10" aria-hidden="true"></i>
                  </div>
                </div>
              </div>
              <div id="globe" class="position-absolute end-0 bottom-n2 mt-sm-3">
                <canvas width="600" height="600" class="w-lg-100 h-lg-100 w-75 h-75 me-lg-0 me-n8 mt-lg-5"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="row mt-4">
        <div class="col-lg-5 mb-lg-0 mb-4">
          <div class="card z-index-2">
            <div class="card-body p-2">
              <div class="bg-dark border-radius-md py-3 pe-1 mb-3">
                <div class="chart">
                  <canvas id="chart-bars" class="chart-canvas" height="170"></canvas>
                </div>
              </div>
              <h6 class="ms-2 mt-4 mb-0"> Active Users </h6>
              <p class="text-sm ms-2"> (<span class="font-weight-bolder">+23%</span>) than last week </p>
              <div class="container border-radius-lg">
                <div class="row">
                  <div class="col-3 py-3 ps-0">
                    <div class="d-flex mb-2">
                      <div class="icon icon-shape icon-xxs shadow border-radius-sm bg-primary text-center me-2 d-flex align-items-center justify-content-center">
                        <svg width="10px" height="10px" viewBox="0 0 40 44" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>document</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-1870.000000, -591.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(154.000000, 300.000000)">
                                  <path class="color-background" d="M40,40 L36.3636364,40 L36.3636364,3.63636364 L5.45454545,3.63636364 L5.45454545,0 L38.1818182,0 C39.1854545,0 40,0.814545455 40,1.81818182 L40,40 Z" opacity="0.603585379"></path>
                                  <path class="color-background" d="M30.9090909,7.27272727 L1.81818182,7.27272727 C0.814545455,7.27272727 0,8.08727273 0,9.09090909 L0,41.8181818 C0,42.8218182 0.814545455,43.6363636 1.81818182,43.6363636 L30.9090909,43.6363636 C31.9127273,43.6363636 32.7272727,42.8218182 32.7272727,41.8181818 L32.7272727,9.09090909 C32.7272727,8.08727273 31.9127273,7.27272727 30.9090909,7.27272727 Z M18.1818182,34.5454545 L7.27272727,34.5454545 L7.27272727,30.9090909 L18.1818182,30.9090909 L18.1818182,34.5454545 Z M25.4545455,27.2727273 L7.27272727,27.2727273 L7.27272727,23.6363636 L25.4545455,23.6363636 L25.4545455,27.2727273 Z M25.4545455,20 L7.27272727,20 L7.27272727,16.3636364 L25.4545455,16.3636364 L25.4545455,20 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <p class="text-xs mt-1 mb-0 font-weight-bold">Users</p>
                    </div>
                    <h4 class="font-weight-bolder">36K</h4>
                    <div class="progress w-75">
                      <div class="progress-bar bg-dark w-60" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                  </div>
                  <div class="col-3 py-3 ps-0">
                    <div class="d-flex mb-2">
                      <div class="icon icon-shape icon-xxs shadow border-radius-sm bg-gradient-info text-center me-2 d-flex align-items-center justify-content-center">
                        <svg width="10px" height="10px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>spaceship</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-1720.000000, -592.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(4.000000, 301.000000)">
                                  <path class="color-background" d="M39.3,0.706666667 C38.9660984,0.370464027 38.5048767,0.192278529 38.0316667,0.216666667 C14.6516667,1.43666667 6.015,22.2633333 5.93166667,22.4733333 C5.68236407,23.0926189 5.82664679,23.8009159 6.29833333,24.2733333 L15.7266667,33.7016667 C16.2013871,34.1756798 16.9140329,34.3188658 17.535,34.065 C17.7433333,33.98 38.4583333,25.2466667 39.7816667,1.97666667 C39.8087196,1.50414529 39.6335979,1.04240574 39.3,0.706666667 Z M25.69,19.0233333 C24.7367525,19.9768687 23.3029475,20.2622391 22.0572426,19.7463614 C20.8115377,19.2304837 19.9992882,18.0149658 19.9992882,16.6666667 C19.9992882,15.3183676 20.8115377,14.1028496 22.0572426,13.5869719 C23.3029475,13.0710943 24.7367525,13.3564646 25.69,14.31 C26.9912731,15.6116662 26.9912731,17.7216672 25.69,19.0233333 L25.69,19.0233333 Z"></path>
                                  <path class="color-background" d="M1.855,31.4066667 C3.05106558,30.2024182 4.79973884,29.7296005 6.43969145,30.1670277 C8.07964407,30.6044549 9.36054508,31.8853559 9.7979723,33.5253085 C10.2353995,35.1652612 9.76258177,36.9139344 8.55833333,38.11 C6.70666667,39.9616667 0,40 0,40 C0,40 0,33.2566667 1.855,31.4066667 Z"></path>
                                  <path class="color-background" d="M17.2616667,3.90166667 C12.4943643,3.07192755 7.62174065,4.61673894 4.20333333,8.04166667 C3.31200265,8.94126033 2.53706177,9.94913142 1.89666667,11.0416667 C1.5109569,11.6966059 1.61721591,12.5295394 2.155,13.0666667 L5.47,16.3833333 C8.55036617,11.4946947 12.5559074,7.25476565 17.2616667,3.90166667 L17.2616667,3.90166667 Z" opacity="0.598539807"></path>
                                  <path class="color-background" d="M36.0983333,22.7383333 C36.9280725,27.5056357 35.3832611,32.3782594 31.9583333,35.7966667 C31.0587397,36.6879974 30.0508686,37.4629382 28.9583333,38.1033333 C28.3033941,38.4890431 27.4704606,38.3827841 26.9333333,37.845 L23.6166667,34.53 C28.5053053,31.4496338 32.7452344,27.4440926 36.0983333,22.7383333 L36.0983333,22.7383333 Z" opacity="0.598539807"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <p class="text-xs mt-1 mb-0 font-weight-bold">Clicks</p>
                    </div>
                    <h4 class="font-weight-bolder">2m</h4>
                    <div class="progress w-75">
                      <div class="progress-bar bg-dark w-90" role="progressbar" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                  </div>
                  <div class="col-3 py-3 ps-0">
                    <div class="d-flex mb-2">
                      <div class="icon icon-shape icon-xxs shadow border-radius-sm bg-gradient-warning text-center me-2 d-flex align-items-center justify-content-center">
                        <svg width="10px" height="10px" viewBox="0 0 43 36" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>credit-card</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-2169.000000, -745.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(453.000000, 454.000000)">
                                  <path class="color-background" d="M43,10.7482083 L43,3.58333333 C43,1.60354167 41.3964583,0 39.4166667,0 L3.58333333,0 C1.60354167,0 0,1.60354167 0,3.58333333 L0,10.7482083 L43,10.7482083 Z" opacity="0.593633743"></path>
                                  <path class="color-background" d="M0,16.125 L0,32.25 C0,34.2297917 1.60354167,35.8333333 3.58333333,35.8333333 L39.4166667,35.8333333 C41.3964583,35.8333333 43,34.2297917 43,32.25 L43,16.125 L0,16.125 Z M19.7083333,26.875 L7.16666667,26.875 L7.16666667,23.2916667 L19.7083333,23.2916667 L19.7083333,26.875 Z M35.8333333,26.875 L28.6666667,26.875 L28.6666667,23.2916667 L35.8333333,23.2916667 L35.8333333,26.875 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <p class="text-xs mt-1 mb-0 font-weight-bold">Sales</p>
                    </div>
                    <h4 class="font-weight-bolder">435$</h4>
                    <div class="progress w-75">
                      <div class="progress-bar bg-dark w-30" role="progressbar" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                  </div>
                  <div class="col-3 py-3 ps-0">
                    <div class="d-flex mb-2">
                      <div class="icon icon-shape icon-xxs shadow border-radius-sm bg-gradient-danger text-center me-2 d-flex align-items-center justify-content-center">
                        <svg width="10px" height="10px" viewBox="0 0 40 40" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
                          <title>settings</title>
                          <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
                            <g transform="translate(-2020.000000, -442.000000)" fill="#FFFFFF" fill-rule="nonzero">
                              <g transform="translate(1716.000000, 291.000000)">
                                <g transform="translate(304.000000, 151.000000)">
                                  <polygon class="color-background" opacity="0.596981957" points="18.0883333 15.7316667 11.1783333 8.82166667 13.3333333 6.66666667 6.66666667 0 0 6.66666667 6.66666667 13.3333333 8.82166667 11.1783333 15.315 17.6716667"></polygon>
                                  <path class="color-background" d="M31.5666667,23.2333333 C31.0516667,23.2933333 30.53,23.3333333 30,23.3333333 C29.4916667,23.3333333 28.9866667,23.3033333 28.48,23.245 L22.4116667,30.7433333 L29.9416667,38.2733333 C32.2433333,40.575 35.9733333,40.575 38.275,38.2733333 L38.275,38.2733333 C40.5766667,35.9716667 40.5766667,32.2416667 38.275,29.94 L31.5666667,23.2333333 Z" opacity="0.596981957"></path>
                                  <path class="color-background" d="M33.785,11.285 L28.715,6.215 L34.0616667,0.868333333 C32.82,0.315 31.4483333,0 30,0 C24.4766667,0 20,4.47666667 20,10 C20,10.99 20.1483333,11.9433333 20.4166667,12.8466667 L2.435,27.3966667 C0.95,28.7083333 0.0633333333,30.595 0.00333333333,32.5733333 C-0.0583333333,34.5533333 0.71,36.4916667 2.11,37.89 C3.47,39.2516667 5.27833333,40 7.20166667,40 C9.26666667,40 11.2366667,39.1133333 12.6033333,37.565 L27.1533333,19.5833333 C28.0566667,19.8516667 29.01,20 30,20 C35.5233333,20 40,15.5233333 40,10 C40,8.55166667 39.685,7.18 39.1316667,5.93666667 L33.785,11.285 Z"></path>
                                </g>
                              </g>
                            </g>
                          </g>
                        </svg>
                      </div>
                      <p class="text-xs mt-1 mb-0 font-weight-bold">Items</p>
                    </div>
                    <h4 class="font-weight-bolder">43</h4>
                    <div class="progress w-75">
                      <div class="progress-bar bg-dark w-50" role="progressbar" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="col-lg-7">
          <div class="card z-index-2">
            <div class="card-header pb-0">
              <h6>Sales overview</h6>
              <p class="text-sm">
                <i class="fa fa-arrow-up text-success"></i>
                <span class="font-weight-bold">4% more</span> in 2021
              </p>
            </div>
            <div class="card-body p-3">
              <div class="chart">
                <canvas id="chart-line" class="chart-canvas" height="300"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
{% endblock content %}

{% block extra_js %}

  <!-- Kanban scripts -->
  <script src="{% static "assets/js/plugins/dragula/dragula.min.js" %}"></script>
  <script src="{% static "assets/js/plugins/jkanban/jkanban.js" %}"></script>
  <script src="{% static "assets/js/plugins/chartjs.min.js" %}"></script>
  <script src="{% static "assets/js/plugins/threejs.js" %}"></script>
  <script src="{% static "assets/js/plugins/orbit-controls.js" %}"></script>
  <script>
    var ctx = document.getElementById("chart-bars").getContext("2d");

    new Chart(ctx, {
      type: "bar",
      data: {
        labels: ["Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        datasets: [{
          label: "Sales",
          tension: 0.4,
          borderWidth: 0,
          borderRadius: 4,
          borderSkipped: false,
          backgroundColor: "#fff",
          data: [450, 200, 100, 220, 500, 100, 400, 230, 500],
          maxBarThickness: 6
        }, ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          }
        },
        interaction: {
          intersect: false,
          mode: 'index',
        },
        scales: {
          y: {
            grid: {
              drawBorder: false,
              display: false,
              drawOnChartArea: false,
              drawTicks: false,
            },
            ticks: {
              suggestedMin: 0,
              suggestedMax: 500,
              beginAtZero: true,
              padding: 15,
              font: {
                size: 14,
                family: "Inter",
                style: 'normal',
                lineHeight: 2
              },
              color: "#fff"
            },
          },
          x: {
            grid: {
              drawBorder: false,
              display: false,
              drawOnChartArea: false,
              drawTicks: false
            },
            ticks: {
              display: false
            },
          },
        },
      },
    });


    var ctx2 = document.getElementById("chart-line").getContext("2d");

    var gradientStroke1 = ctx2.createLinearGradient(0, 230, 0, 50);

    gradientStroke1.addColorStop(1, 'rgba(203,108,12,0.2)');
    gradientStroke1.addColorStop(0.2, 'rgba(203,108,12,0)');
    gradientStroke1.addColorStop(0, 'rgba(203,108,12,0)'); //orange colors

    var gradientStroke2 = ctx2.createLinearGradient(0, 230, 0, 50);

    gradientStroke2.addColorStop(1, 'rgba(2,2,2,0.2)');
    gradientStroke2.addColorStop(0.2, 'rgba(2,2,2,0)');
    gradientStroke2.addColorStop(0, 'rgba(2,2,2,0)'); //orange colors

    new Chart(ctx2, {
      type: "line",
      data: {
        labels: ["Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        datasets: [{
            label: "Mobile apps",
            tension: 0.4,
            borderWidth: 0,
            pointRadius: 0,
            borderColor: "#f97316",
            borderWidth: 3,
            backgroundColor: gradientStroke1,
            fill: true,
            data: [50, 40, 300, 220, 500, 250, 400, 230, 500],
            maxBarThickness: 6

          },
          {
            label: "Websites",
            tension: 0.4,
            borderWidth: 0,
            pointRadius: 0,
            borderColor: "#3A416F",
            borderWidth: 3,
            backgroundColor: gradientStroke2,
            fill: true,
            data: [30, 90, 40, 140, 290, 290, 340, 230, 400],
            maxBarThickness: 6
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          }
        },
        interaction: {
          intersect: false,
          mode: 'index',
        },
        scales: {
          y: {
            grid: {
              drawBorder: false,
              display: true,
              drawOnChartArea: true,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              padding: 10,
              color: '#b2b9bf',
              font: {
                size: 11,
                family: "Inter",
                style: 'normal',
                lineHeight: 2
              },
            }
          },
          x: {
            grid: {
              drawBorder: false,
              display: false,
              drawOnChartArea: false,
              drawTicks: false,
              borderDash: [5, 5]
            },
            ticks: {
              display: true,
              color: '#b2b9bf',
              padding: 20,
              font: {
                size: 11,
                family: "Inter",
                style: 'normal',
                lineHeight: 2
              },
            }
          },
        },
      },
    });


    (function() {
      const container = document.getElementById("globe");
      const canvas = container.getElementsByTagName("canvas")[0];

      const globeRadius = 100;
      const globeWidth = 4098 / 2;
      const globeHeight = 1968 / 2;

      function convertFlatCoordsToSphereCoords(x, y) {
        let latitude = ((x - globeWidth) / globeWidth) * -180;
        let longitude = ((y - globeHeight) / globeHeight) * -90;
        latitude = (latitude * Math.PI) / 180;
        longitude = (longitude * Math.PI) / 180;
        const radius = Math.cos(longitude) * globeRadius;

        return {
          x: Math.cos(latitude) * radius,
          y: Math.sin(longitude) * globeRadius,
          z: Math.sin(latitude) * radius
        };
      }

      function makeMagic(points) {
        const {
          width,
          height
        } = container.getBoundingClientRect();

        // 1. Setup scene
        const scene = new THREE.Scene();
        // 2. Setup camera
        const camera = new THREE.PerspectiveCamera(45, width / height);
        // 3. Setup renderer
        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: true
        });
        renderer.setSize(width, height);
        // 4. Add points to canvas
        // - Single geometry to contain all points.
        const mergedGeometry = new THREE.Geometry();
        // - Material that the dots will be made of.
        const pointGeometry = new THREE.SphereGeometry(0.5, 1, 1);
        const pointMaterial = new THREE.MeshBasicMaterial({
          color: "#a1a1aa",
        });

        for (let point of points) {
          const {
            x,
            y,
            z
          } = convertFlatCoordsToSphereCoords(
            point.x,
            point.y,
            width,
            height
          );

          if (x && y && z) {
            pointGeometry.translate(x, y, z);
            mergedGeometry.merge(pointGeometry);
            pointGeometry.translate(-x, -y, -z);
          }
        }

        const globeShape = new THREE.Mesh(mergedGeometry, pointMaterial);
        scene.add(globeShape);

        container.classList.add("peekaboo");

        // Setup orbital controls
        camera.orbitControls = new THREE.OrbitControls(camera, canvas);
        camera.orbitControls.enableKeys = false;
        camera.orbitControls.enablePan = false;
        camera.orbitControls.enableZoom = false;
        camera.orbitControls.enableDamping = false;
        camera.orbitControls.enableRotate = true;
        camera.orbitControls.autoRotate = true;
        camera.position.z = -265;

        function animate() {
          // orbitControls.autoRotate is enabled so orbitControls.update
          // must be called inside animation loop.
          camera.orbitControls.update();
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();
      }

      function hasWebGL() {
        const gl =
          canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        if (gl && gl instanceof WebGLRenderingContext) {
          return true;
        } else {
          return false;
        }
      }

      function init() {
        if (hasWebGL()) {
          window
          window.fetch("https://raw.githubusercontent.com/creativetimofficial/public-assets/master/soft-ui-dashboard-pro/assets/js/points.json")
            .then(response => response.json())
            .then(data => {
              makeMagic(data.points);
            });
        }
      }
      init();
    })();
  </script>

{% endblock extra_js %}
